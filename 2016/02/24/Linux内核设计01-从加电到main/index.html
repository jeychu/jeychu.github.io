

<!DOCTYPE html>
<html lang xmlns:v-bind="http://www.w3.org/1999/xhtml">

<head><meta name="generator" content="Hexo 3.8.0">
    <title>Linux内核设计01-从加电到main - javfa&#39;s blog</title>
<meta charset="utf-8">
<meta name="X-UA-Compatible" content="IE=edge">
<meta name="author" content="Javfa">
<meta name="description" content="

从开机加电到执行main函数之前的过程
第一步，启动BIOS，准备实模式下的中断向量表和中断服务程序
BIOS...">
<meta name="keywords" content>

    <meta charset="utf-8">
    <meta name="X-UA-Compatible" content="IE=edge">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <meta content="telephone=no" name="format-detection">
    <meta name="renderer" content="webkit">
    <meta name="theme-color" content="#ffffff">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.1.3/dist/css/bootstrap.min.css" integrity="sha256-eSi1q2PG6J7g7ib17yAaWMcrr5GrtohYChqibrV7PBE=" crossorigin="anonymous">
<link rel="stylesheet" href="/css/journal.css?74300961">
<script src="/js/loadCSS.js"></script>
<script>
    loadCSS("https://fonts.googleapis.com/css?family=Lora|Montserrat|Fira+Mono|Material+Icons");
    (function (d) {
        var config = {
                kitId: 'dwg1tuc',
                scriptTimeout: 3000,
                async: true
            },
            h = d.documentElement, t = setTimeout(function () {
                h.className = h.className.replace(/\bwf-loading\b/g, "") + " wf-inactive";
            }, config.scriptTimeout), tk = d.createElement("script"), f = false,
            s = d.getElementsByTagName("script")[0], a;
        h.className += " wf-loading";
        tk.src = 'https://use.typekit.net/' + config.kitId + '.js';
        tk.async = true;
        tk.onload = tk.onreadystatechange = function () {
            a = this.readyState;
            if (f || a && a != "complete" && a != "loaded") return;
            f = true;
            clearTimeout(t);
            try {
                Typekit.load(config)
            } catch (e) {
            }
        };
        s.parentNode.insertBefore(tk, s)
    })(document);
</script>
<noscript>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora|Montserrat|Anonymous+Pro:400|Material+Icons">
</noscript>
</head>
<body>
<div id="top"></div>
<div id="app">
<div class="single-column-drawer-container" ref="drawer" v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }">
    <div class="drawer-content">
        <div class="drawer-menu">
            <a class="a-block drawer-menu-item false" href="http://yoursite.com">
                首页
            </a>
            <a class="a-block drawer-menu-item false" href="/archives">
                归档
            </a>

            
            

            
        </div>
    </div>
</div>
<transition name="fade">
    <div v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if="isDrawerOpen" v-on:click="toggleDrawer"></div>
</transition>
<nav ref="navBar" class="navbar sticky-top navbar-light single-column-nav-container">
    <div ref="navBackground" class="nav-background"></div>
    <div class="container container-narrow nav-content">
        <button id="nav_dropdown_btn" class="nav-dropdown-toggle" type="button" v-on:click="toggleDrawer">
            <i class="material-icons">
                menu
            </i>
        </button>
        <a ref="navTitle" class="navbar-brand" href="/">
            javfa&#39;s blog
        </a>
    </div>
</nav>
<div class="single-column-header-container" ref="pageHead" v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }">
    <a href="/">
        <div class="single-column-header-title">javfa&#39;s blog</div>
        <div class="single-column-header-subtitle"></div>
    </a>
</div>
<div ref="sideContainer" class="side-container">
    <a class="a-block nav-head false" href="/">
        <div class="nav-title">
            {博客@家發}
        </div>
        <div class="nav-subtitle">
            隻言片語<br>於此匯聚
        </div>
    </a>

    <div class="nav-link-list">
        <a class="a-block no-tint nav-link-item false" href="/archives">
            归档
        </a>

        
        

        
    </div>

    
    <div class="nav-footer">
        Proudly published with Hexo<br>
        
        Theme <a href="https://github.com/SumiMakito/hexo-theme-journal/" target="_blank" rel="noreferrer noopener">Journal.</a> by <a href="https://mak1t0.cc/" target="_blank" rel="noreferrer noopener">Makito</a><br>
        
        &copy; 2019 <a href="http://yoursite.com">javfa&#39;s blog</a>
    </div>
</div>
<div ref="extraContainer" class="extra-container">
    <div class="pagination">
        <a id="globalBackToTop" class="pagination-action animated-visibility" href="#top" :class="{ invisible: scrollY == 0 }">
            <i class="material-icons pagination-action-icon">
                keyboard_arrow_up
            </i>
        </a>

        
    </div>
</div>

<div ref="streamContainer" class="stream-container">
    <div class="post-list-container post-list-container-shadow">
        <div class="post">
            <div class="post-head-wrapper-text-only" style="background-image: url('')">
                <div class="post-title">
                    Linux内核设计01-从加电到main
                    <div class="post-meta">
                        <time datetime="2016-02-24T00:49:09.000Z" itemprop="datePublished">
                            2016-02-24 08:49
                        </time>&nbsp;
                        
    
                        
                        
                        <i class="material-icons" style>label</i>
                        
                        <a href="/tags/Linux/">Linux</a>
                        
                        
                    </div>
                </div>
            </div>
    
            <div class="post-body-wrapper">
                <div class="post-body">
                    <!-- toc -->
<ul>
<li><a href="#从开机加电到执行main函数之前的过程">从开机加电到执行main函数之前的过程</a><ul>
<li><a href="#第一步启动bios准备实模式下的中断向量表和中断服务程序">第一步，启动BIOS，准备<em>实模式</em>下的中断向量表和中断服务程序</a><ul>
<li><a href="#bios启动原理">BIOS启动原理</a></li>
<li><a href="#bios在内存中加载中断向量表和中断服务程序">BIOS在内存中加载中断向量表和中断服务程序</a></li>
</ul>
</li>
<li><a href="#第二步利用第一步中准备的中断服务程序来实现从启动盘加载操作系统程序到内存">第二步，利用第一步中准备的中断服务程序来实现：从启动盘加载操作系统程序到内存</a></li>
<li><a href="#第三步为执行32位的main函数做过渡工作">第三步，为执行32位的main函数做过渡工作</a><ul>
<li><a href="#关中断并将system移动到内存地址起始位置0x00000">关中断，并将system移动到内存地址起始位置0x00000</a></li>
<li><a href="#设置中断描述符表和全局描述符表">设置中断描述符表和全局描述符表</a></li>
<li><a href="#打开a20实现32位寻址">打开A20，实现32位寻址</a></li>
<li><a href="#为在保护模式下执行heads做准备">为在保护模式下执行head.s做准备</a></li>
<li><a href="#heads开始执行">head.s开始执行</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#文件操作">文件操作</a><ul>
<li><a href="#打开文件">打开文件</a></li>
<li><a href="#读文件">读文件</a></li>
<li><a href="#新建文件">新建文件</a></li>
<li><a href="#写文件">写文件</a></li>
<li><a href="#修改文件">修改文件</a></li>
<li><a href="#关闭文件">关闭文件</a></li>
<li><a href="#删除文件">删除文件</a></li>
</ul>
</li>
<li><a href="#用户进程与内存管理">用户进程与内存管理</a><ul>
<li><a href="#用户进程的创建">用户进程的创建</a></li>
<li><a href="#为用户进程str1的加载做准备">为用户进程str1的加载做准备</a></li>
<li><a href="#对缺页中断的处理">对缺页中断的处理</a></li>
<li><a href="#str1用户进程的退出">str1用户进程的退出</a></li>
<li><a href="#多个用户进程同时运行">多个用户进程同时运行</a></li>
<li><a href="#进程的调度与切换">进程的调度与切换</a></li>
<li><a href="#内核的分页">内核的分页</a></li>
<li><a href="#页写保护">页写保护</a></li>
</ul>
</li>
<li><a href="#多个进程同时操作一个文件">多个进程同时操作一个文件</a><ul>
<li><a href="#三个进程操作同一个文件">三个进程操作同一个文件</a></li>
<li><a href="#缓冲区与外设的数据同步">缓冲区与外设的数据同步</a></li>
</ul>
</li>
<li><a href="#ipc问题">IPC问题</a><ul>
<li><a href="#管道机制">管道机制</a></li>
<li><a href="#信号机制">信号机制</a><ul>
<li><a href="#processing进程开始执行">processing进程开始执行</a></li>
<li><a href="#processig进程进入可中断等待状态">processig进程进入可中断等待状态</a></li>
<li><a href="#sendsig进程开始执行并向processig进程发信号">sendsig进程开始执行并向processig进程发信号</a></li>
<li><a href="#系统检测当前进程接收到信号并准备处理">系统检测当前进程接收到信号并准备处理</a></li>
<li><a href="#系统检测信号处理函数指针是否正常">系统检测信号处理函数指针是否正常</a></li>
<li><a href="#调整processig进程的内核栈结构使之先执行信号处理函数">调整processig进程的内核栈结构，使之先执行信号处理函数</a></li>
<li><a href="#信号对进程执行状态的影响">信号对进程执行状态的影响</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h1><span id="从开机加电到执行main函数之前的过程">从开机加电到执行main函数之前的过程</span></h1><p>从开机到main函数的执行分三步完成，其目的是实现从启动盘加载操作系统程序，完成执行main函数所需要的准备工作。</p>
<h2><span id="第一步启动bios准备实模式下的中断向量表和中断服务程序">第一步，启动BIOS，准备<em>实模式</em>下的中断向量表和中断服务程序</span></h2><p>加电的一瞬间，计算机的RAM中，空空如也，什么程序也没有。而CPU的逻辑电路被设计为只能运行内存中的程序。如果要运行软盘中的操作系统，必须将软盘中操作系统程序加载到RAM中。<br>在RAM中什么程序都没有的时候，要由BIOS来完成加载软盘中操作系统到RAM中的任务。</p>
<h3><span id="bios启动原理">BIOS启动原理</span></h3><p>此时RAM中无程序，所以通过软件方法不可能执行BIOS，只能靠<strong>硬件方法</strong>完成。<br>从硬件角度看，Intel 80x86系列的cpu可以分别在16位实模式和32位保护模式下运行。</p>
<p>所有80x86系列CPU的硬件都设计为加电即进入16位实模式状态运行。且在加电瞬间强行将CS置为0xFFFF，IP置为0x0000，如此CS：IP就指向0xFFFF0这个地址位置。</p>
<blockquote>
<p>实模式（Real mode）的特性是一个20位的存储器地址空间，可以直接通过软件的方式访问BIOS以及周边硬件。</p>
<blockquote>
<p>$$<br>2^{20} =1048576​<br>$$</p>
<p>即1M的存储器可被寻</p>
</blockquote>
</blockquote>
<p>0xFFFF0指向了BIOS的地址范围。<br>这是一个纯硬件完成的动作。</p>
<p>BIOS程序的入口地址就是0xFFFF0.</p>
<h3><span id="bios在内存中加载中断向量表和中断服务程序">BIOS在内存中加载中断向量表和中断服务程序</span></h3><p>BIOS程序被固化在计算机主板之上的一块很小的ROM芯片里。不同的主板所用的BIOS也有所不同，就启动部分，各种类型的BIOS的基本原理大致相似。</p>
<p>在此，我们选用8KB的BIOS来说明此问题，此时BIOS所占地址段为0xFE000-0xFFFFF。</p>
<p>而此时，在实模式下内存寻址空间为：0x00000-0xFFFFF</p>
<p>CS：IP指向0xFFFF0，意味着BIOS开始启动了。<br>随着BIOS程序的执行，屏幕上显示显卡的信息、内存的信息……<br>在这期间，BIOS在内存中建立了中断向量表和中断服务程序：<br><strong>BIOS在内存最开始的位置（0x00000）用1K的内存空间构建中断向量表，并在紧挨它的位置用256字节的内存空间构建BIOS数据区，在大约56K以后的位置加载了8KB左右的与中断向量表相应的若干中断服务程序</strong>。<br>中断向量表中有256个中断向量，每个中断向量占4个字节，其中两个字节是CS值，两个为IP值，每个中断向量都指向一个具体的中断服务程序。</p>
<blockquote>
<p><em>中断</em>，可以理解为函数调用。</p>
</blockquote>
<h2><span id="第二步利用第一步中准备的中断服务程序来实现从启动盘加载操作系统程序到内存">第二步，利用第一步中准备的中断服务程序来实现：从启动盘加载操作系统程序到内存</span></h2><p>从现在开始就要执行真正的boot操作了，即把软盘中的操作系统加载至内存。</p>
<p>分三批逐次加载操作系统的内核代码：</p>
<ul>
<li><p>第一批由BIOS中断int 0x19h把第一扇区bootsect的内容加载到内存。</p>
<p>CPU接收到int 19h中断，立即在中断向量表中找到int 19h中断向量-&gt;这个中断向量把CPU指向0x0E6F2，这个位置就是int 19h相对应的中断服务程序的入口地址。</p>
<p>这个中断服务程序的作用就是把软盘的第一个扇区中的程序（512B）加载到内存中的指定位置（0x07C00）。</p>
<p><strong>这个中断服务程序的功能是BIOS事先设计好的，代码是固定的，与Linux操作系统无关</strong>。</p>
<p>这个扇区里的内容就是Linux 0.11操作系统的引导程序，也就是bootsect，其作用就是陆续把软盘中的操作系统程序载入内存。</p>
<p>bootsect的载入，标志着操作系统中的代码即将发挥作用了。</p>
</li>
<li><p>加载第二部分代码-setup</p>
<p>现在BIOS已经把bootsect（如上所示）载入内存了，它的作用就是把第二批和第三批程序陆续加载到内存中。为了把第二批和第三批程序加载到内存中的适当位置，bootsect首先做的工作就是规划内存。</p>
<ol>
<li>bootsect对内存的规划</li>
</ol>
<p>在实模式下，寻址的最大范围是1MB，为了规划内存，bootsect首先设计了如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SETUPLEN, 4     # nr of setup-sectors</span><br><span class="line"></span><br><span class="line">BOOTSEG, 0x07c0 # original address of boot-sector</span><br><span class="line"></span><br><span class="line">INITSEG, 0x9000 # we move boot here - out of the way</span><br><span class="line"></span><br><span class="line">SETUPSEG, 0x9020    # setup starts here</span><br><span class="line"></span><br><span class="line">SYSSEG, 0x1000      # system loaded at 0x10000 (65536).</span><br><span class="line"></span><br><span class="line">ENDSEG, SYSSEG + SYSSIZE    # where to stop loading</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>  这些源代码的作用就是对后续操作所涉及的内存位置进行设置，包括将要加载的setup程序的扇区数和被加载到的位置、启动扇区被BIOS加载的位置和将要移动到的新位置、内核被加载的位置、内核末尾位置和根文件系统设备号。</p>
<p>  要时刻牢记这样一个概念：<strong>操作系统的设计者要全面</strong>、<strong>整体地考虑内存的规划</strong>。</p>
<ol start="2">
<li><p>复制bootsect</p>
<p>接下来，bootsect启动程序将它自身从内存0x07C00处复制至内存0x90000处</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">start:					;// 以下10行作用是将自身(bootsect)从目前段位置07c0h(31k)</span><br><span class="line">						;// 移动到9000h(576k)处，共256字(512字节)，然后跳转到</span><br><span class="line">						;// 移动后代码的 go 标号处，也即本程序的下一语句处。 </span><br><span class="line">	mov	ax,BYTE PTR BOOTSEG		;// 将ds段寄存器置为7C0h</span><br><span class="line">	mov	ds,ax</span><br><span class="line">	mov	ax,BYTE PTR INITSEG		;// 将es段寄存器置为9000h</span><br><span class="line">	mov	es,ax</span><br><span class="line">	mov	cx,256			;// 移动计数值 ＝ 256字 = 512 字节</span><br><span class="line">	sub	si,si			;// 源地址   ds:si = 07C0h:0000h</span><br><span class="line">	sub	di,di			;// 目的地址 es:di = 9000h:0000h</span><br><span class="line">	rep movsw			;// 重复执行，直到cx = 0;移动1个字</span><br></pre></td></tr></table></figure>
<p>在这次复制过程中，ds和si联合使用，构成了源地址；es和di联合使用，构成了目的地址，而<code>mov cx,256</code>循环控制量，提供了需要复制的字数（一个字位两个字节）。</p>
<p>bootsect复制到新位置后，将ds、es、ss都置成移动后代码所在段处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">;	jmp INITSEG:[go] 	;// 间接跳转。这里INITSEG指出跳转到的段地址。</span><br><span class="line">    db 0eah				;// 间接跳转指令码</span><br><span class="line">	dw go</span><br><span class="line">	dw INITSEG</span><br><span class="line">go:	mov	ax,cs			;// 将ds、es和ss都置成移动后代码所在的段处（9000h）。</span><br><span class="line">	mov	ds,ax			;// 由于程序中有堆栈操作（push，pop，call），因此必须设置堆栈。</span><br><span class="line">	mov	es,ax</span><br><span class="line">;// put stack at 9ff00.  将堆栈指针sp指向9ff00h（即9000h:0ff00h）处</span><br><span class="line">	mov	ss,ax</span><br><span class="line">	mov	sp,0FF00h		;/* 由于代码段移动过了，所以要重新设置堆栈段的位置。</span><br><span class="line">						;   sp只要指向远大于512偏移（即地址90200h）处</span><br><span class="line">						;   都可以。因为从90200h地址开始处还要放置setup程序，</span><br><span class="line">						;   而此时setup程序大约为4个扇区，因此sp要指向大</span><br><span class="line">						;   于（200h + 200h*4 + 堆栈大小）处。 */</span><br></pre></td></tr></table></figure>
</li>
<li><p>将setup程序加载到内存中</p>
<p>加载setup程序，要借助BIOS提供的int 0x 13h中断向量所指向的中断服务程序（也就是磁盘服务程序）来完成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">load_setup:</span><br><span class="line">	;// 以下10行的用途是利用BIOS中断INT 13h将setup模块从磁盘第2个扇区</span><br><span class="line">	;// 开始读到90200h开始处，共读4个扇区。如果读出错，则复位驱动器，并</span><br><span class="line">	;// 重试，没有退路。</span><br><span class="line">	;// INT 13h 的使用方法如下：</span><br><span class="line">	;// ah = 02h - 读磁盘扇区到内存；al = 需要读出的扇区数量；</span><br><span class="line">	;// ch = 磁道（柱面）号的低8位；  cl = 开始扇区（0－5位），磁道号高2位（6－7）；</span><br><span class="line">	;// dh = 磁头号；				  dl = 驱动器号（如果是硬盘则要置为7）；</span><br><span class="line">	;// es:bx -&gt;指向数据缓冲区；  如果出错则CF标志置位。 </span><br><span class="line">	mov	dx,0000h				;// drive 0, head 0</span><br><span class="line">	mov	cx,0002h				;// sector 2, track 0</span><br><span class="line">	mov	bx,0200h				;// address = 512, in INITSEG</span><br><span class="line">	mov	ax,0200h+SETUPLEN		;// service 2, nr of sectors</span><br><span class="line">	int	13h					;// read it</span><br><span class="line">	jnc	ok_load_setup			;// ok - continue</span><br><span class="line">	mov	dx,0000h</span><br><span class="line">	mov	ax,0000h				;// reset the diskette</span><br><span class="line">	int	13h</span><br><span class="line">	jmp	load_setup</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><p>加载第三部分代码-system模块</p>
<p>仍然使用BIOS提供的int 0x 13h中断。</p>
<p>bootsect借着BIOS中断int 0x 13h，将240个扇区的system模块加载进内存。</p>
<p>加载工作主要是由bootsect调用read_it子程序完成的。</p>
<p>到此为止，第三批程序已经加载完毕，整个操作系统的代码已全部载入内存。bootsect的主体工作已经做完了，还有一点小事，就是要再次确定以下根设备号。</p>
<p>经过一系列检测，得知软盘为根设备，所以就把根设备号保存在root_dev中，作为机器系统数据之一。</p>
<p>现在，bootsect程序的任务都已经完成。</p>
<p>下面通过执行<code>jmpi 0, SETUPSEG</code>这行语句跳转至0x90200处，也就是第二批程序setup程序加载的位置。</p>
<p>CS：IP指向setup程序的第一条指令，意味着由setup程序接着bootsect程序继续执行。</p>
<p>setup程序现在开始执行。它做的第一件事情就是利用BIOS提供的中断服务程序从设备上提取内核运行所需的机器系统数据。</p>
<p>这些机器系统数据被加载到内存的0x90000-0x901FC位置，这些数据将在以后main函数执行时发挥重要作用。</p>
</li>
</ul>
<h2><span id="第三步为执行32位的main函数做过渡工作">第三步，为执行32位的main函数做过渡工作</span></h2><p>接下来，操作系统要使计算机在32位保护模式下工作。</p>
<p>这期间要做大量的重建工作，并且持续工作到操作系统的main函数的执行过程中。</p>
<p>在本节中，操作系统执行的操作包括打开32位的寻址空间、打开保护模式、建立保护模式下的中断响应机制等与保护模式配套的相关工作、建立内存的分页机制，以及做好调用main函数的准备。</p>
<p>setup继续执行……</p>
<h3><span id="关中断并将system移动到内存地址起始位置0x00000">关中断，并将system移动到内存地址起始位置0x00000</span></h3><p>即将CPU的标志寄存器（EFLAGS）中的中断允许标志置0。意味着，在接下来的执行过程中，无论是否发生中断，系统都不再响应此中断，直到main函数中适应保护模式的中断服务体系被重建完毕才会打开。那时响应中断的服务程序不再是BIOS提供的中断服务程序，取而代之的是由系统自身提供的中断服务程序。</p>
<blockquote>
<p>EFLAGS：标志寄存器，存在于CPU中，32位，包含一组状态标志、控制标志和系统标志。第9位IF为中断允许标志。</p>
</blockquote>
<blockquote>
<p>关中断（cli）和开中断（sti）操作在操作系统代码中频繁出现，总是在一个完整的操作过程的两头出现，目的是为了避免中断在此期间介入。</p>
</blockquote>
<p>下面，setup做了一个影响深远的动作：将位于0x10000的内核程序拷贝至内存地址起始位置0x00000处。</p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">;// 从这里开始我们要保护模式方面的工作了。</span><br><span class="line"></span><br><span class="line">	cli			;// 此时不允许中断。 ;//</span><br><span class="line"></span><br><span class="line">;// 首先我们将system 模块移到正确的位置。</span><br><span class="line">;// bootsect 引导程序是将system 模块读入到从10000（64k）开始的位置。由于当时假设</span><br><span class="line">;// system 模块最大长度不会超过80000（512k），也即其末端不会超过内存地址90000，</span><br><span class="line">;// 所以bootsect 会将自己移动到90000 开始的地方，并把setup 加载到它的后面。</span><br><span class="line">;// 下面这段程序的用途是再把整个system 模块移动到00000 位置，即把从10000 到8ffff</span><br><span class="line">;// 的内存数据块(512k)，整块地向内存低端移动了10000（64k）的位置。</span><br><span class="line"></span><br><span class="line">	mov	ax,0000h</span><br><span class="line">	cld			;// &apos;direction&apos;=0, movs moves forward</span><br><span class="line">do_move:</span><br><span class="line">	mov	es,ax		;// es:di -&gt; 目的地址(初始为0000:0)</span><br><span class="line">	add	ax,1000h</span><br><span class="line">	cmp	ax,9000h	;// 已经把从8000 段开始的64k 代码移动完？</span><br><span class="line">	jz	end_move</span><br><span class="line">	mov	ds,ax		;// ds:si -&gt; 源地址(初始为1000:0)</span><br><span class="line">	sub	di,di</span><br><span class="line">	sub	si,si</span><br><span class="line">	mov cx,8000h	;// 移动8000 字（64k 字节）。</span><br><span class="line">	rep movsw</span><br><span class="line">	jmp	do_move</span><br></pre></td></tr></table></figure>
<h3><span id="设置中断描述符表和全局描述符表">设置中断描述符表和全局描述符表</span></h3><p>setup继续为保护模式做准备，此时要通过setup自身提供的数据信息对中断描述符表寄存器IDTR和全局描述符表寄存器GDTR进行初始化设置。</p>
<blockquote>
<p>GDT(Global Descriptor Table)：它是系统中唯一存放段寄存器内容（段描述符）的数组，配合程序进行保护模式下的段寻址。它在操作系统的进程切换中具有重要意义，可理解为所有进程的总目录表，其中存放着每一个任务局部描述符表（LDT）地址和任务状态段（TSS）地址，用于完成进程中各段的寻址、现场保护和现场恢复。</p>
<p>GDTR：GDT可以存放在内存的任何位置，当程序通过段寄存器引用一个段描述符时，需要取得GDT的入口，GDTR所标识的即为此入口。在操作系统对GDT的初始化完成后，可以用LGDT（Load GDT）指令将GDT基地址加载至GDTR。</p>
<p>IDT(Interrupt Descriptor Table)：保存保护模式下所有中断服务程序的入口地址，类似于实模式下的中断向量表。</p>
<p>IDTR：IDT基地址寄存器，保存IDT的起始地址。</p>
</blockquote>
<blockquote>
<p>32位的中断机制和16位的中断机制在原理上有比较大的差别，最明显的是16位的中断机制用的是中断向量表，中断向量表的起始位置在0x00000处，这个位置是固定的。</p>
<p>32位的中断机制用的是中断描述符表IDT，位置是不固定的，可以由操作系统的设计者根据设计要求灵活安排，由IDTR寄存器来锁定其位置。</p>
</blockquote>
<blockquote>
<p>GDT表是保护模式下管理段描述符的数据结构，对操作系统自身的运行和管理，以及进程调度有重大意义。</p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">;// 全局描述符表开始处。描述符表由多个8 字节长的描述符项组成。</span><br><span class="line">;// 这里给出了3 个描述符项。第1 项无用，但须存在。第2 项是系统代码段</span><br><span class="line">;// 描述符，第3 项是系统数据段描述符。每个描述符的具体</span><br><span class="line">;// 含义参见列表后说明。</span><br><span class="line">gdt:</span><br><span class="line">	dw	0,0,0,0		;// 第1 个描述符，不用。</span><br><span class="line">;// 这里在gdt 表中的偏移量为08，当加载代码段寄存器(段选择符)时，使用的是这个偏移值。</span><br><span class="line">	dw	07FFh		;// 8Mb - limit=2047 (2048*4096=8Mb)</span><br><span class="line">	dw	0000h		;// base address=0</span><br><span class="line">	dw	9A00h		;// code read/exec</span><br><span class="line">	dw	00C0h		;// granularity=4096, 386</span><br><span class="line">;// 这里在gdt 表中的偏移量是16，当加载数据段寄存器(如ds 等)时，使用的是这个偏移值。</span><br><span class="line">	dw	07FFh		;// 8Mb - limit=2047 (2048*4096=8Mb)</span><br><span class="line">	dw	0000h		;// base address=0</span><br><span class="line">	dw	9200h		;// data read/write</span><br><span class="line">	dw	00C0h		;// granularity=4096, 386</span><br><span class="line"></span><br><span class="line">idt_48:</span><br><span class="line">	dw	0			;// idt limit=0</span><br><span class="line">	dw	0,0			;// idt base=0L</span><br><span class="line"></span><br><span class="line">gdt_48:</span><br><span class="line">	dw	800h		;// 全局表长度为2k 字节，因为每8 字节组成一个段描述符项</span><br><span class="line">						;// 所以表中共可有256 项。</span><br><span class="line">	dw	512+gdt,9h	;// 4 个字节构成的内存线性地址：0009&lt;&lt;16 + 0200+gdt</span><br><span class="line">						;// 也即90200 + gdt(即在本程序段中的偏移地址，205 行)。</span><br></pre></td></tr></table></figure>
<p>此时内核尚未真正运行起来，还没有进程，所以现在创建的GDT表的第一项为空，第二项为内核代码段描述符，第三项为内核数据段描述符，其余项皆为空。</p>
<p>IDT表虽然已经设置，实为一张空表，原因是目前中断已关，无须调用中断服务程序。</p>
<p>创建这两个表的过程可理解为是分两步进行的：</p>
<ul>
<li>在设计内核代码时，已经将两个表写好，并且把需要的数据也写好；</li>
<li>将专用寄存器（IDTR和GDTR）指向表</li>
</ul>
<blockquote>
<p>在内存中做出数据的方法有两种：</p>
<ul>
<li>划分一块内存区域并初始化数据，“看住”这块内存区域，使之能被找到；</li>
<li>有代码做出数据，如用push代码压栈，做出数据。</li>
</ul>
</blockquote>
<p>此处采用的是第一种方法。</p>
<h3><span id="打开a20实现32位寻址">打开A20，实现32位寻址</span></h3><p>打开A20，意味着CPU可以进行32位寻址，最大寻址空间为4GB</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">call empty_8042		;// 等待输入缓冲器空。</span><br><span class="line">					;// 只有当输入缓冲器为空时才可以对其进行写命令。</span><br><span class="line">mov	al,0D1h			;// D1 命令码-表示要写数据到8042 的P2 端口。P2 端</span><br><span class="line">out	64h,al			;// 口的位1 用于A20 线的选通。数据要写到60 口。</span><br><span class="line"></span><br><span class="line">call empty_8042		;// 等待输入缓冲器空，看命令是否被接受。</span><br><span class="line">mov	al,0DFh			;// A20 on 选通A20 地址线的参数。</span><br><span class="line">out	60h,al</span><br><span class="line">call empty_8042		;// 输入缓冲器为空，则表示A20 线已经选通。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">;// 下面这个子程序检查键盘命令队列是否为空。这里不使用超时方法- 如果这里死机，</span><br><span class="line">;// 则说明PC 机有问题，我们就没有办法再处理下去了。</span><br><span class="line">;// 只有当输入缓冲器为空时（状态寄存器位2 = 0）才可以对其进行写命令。</span><br><span class="line">empty_8042:</span><br><span class="line">	dw 00ebh,00ebh	;// jmp $+2, jmp $+2 $ 表示当前指令的地址</span><br><span class="line">						;// 这是两个跳转指令的机器码(跳转到下一句)，相当于延时空操作。</span><br><span class="line">	in	al,64h			;// 读AT 键盘控制器状态寄存器。</span><br><span class="line">	test al,2			;// 测试位2，输入缓冲器满？</span><br><span class="line">	jnz	empty_8042		;// yes - loop</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<blockquote>
<p>实模式下CPU的寻址范围为0到0xFFFFF，共1MB寻址空间，需要0-19号共20根地址线。进入保护模式后，将使用32位寻址模式，即采用32根地址线进行寻址，第21根到第32根地址线的选通，将意味着寻址模式的切换。</p>
</blockquote>
<blockquote>
<p>实模式下，当程序寻址超过0xFFFFF时，CPU将回滚至内存起始处寻址。（在只有20根地址线的条件下，0xFFFFF+1=0x00000，最高位溢出）。</p>
<p>例如，系统的段寄存器的最大允许地址为0xFFFF，指令指针的最大允许段内偏移也为0xFFFF，两者确定的最大绝对地址为0x10FFEF，这将意味着程序中可产生的实模式下的寻址范围比1MB多出将近64KB。</p>
<p>若将A20地址线启用就相对于关闭了CPU在实模式下寻址的“回滚”机制。可以利用这个特点来验证A20是否确实已经打开。</p>
</blockquote>
<h3><span id="为在保护模式下执行heads做准备">为在保护模式下执行head.s做准备</span></h3><p>为了建立保护模式下的中断机制，setup将对可编程中断控制器8259A进行重新编程。</p>
<blockquote>
<p>8259A中断控制器：8259A是专门为了对8085A和8086/8088进行中断控制而设计的芯片，它是可以用程序控制的中断控制器。单个的8259A能管理8级向量优先级中断。在不增加其他电路的情况下，最多可以级联成64级的向量优先级中断系统。</p>
</blockquote>
<blockquote>
<p>在保护模式下，int 0x00-int 0x1F被Intel保留作为内部（不可屏蔽）中断和异常中断。</p>
</blockquote>
<p><strong>setup通过下面的代码将CPU的工作方式设为保护模式</strong>【此后正式进入了保护模式】：</p>
<p>将CR0寄存器的第0位（PE）置1，即设定处理器的工作方式为保护模式。</p>
<blockquote>
<p>CR0寄存器：0号32位控制寄存器，存放系统控制标志。第0位为PE（Protected Mode Enable）标志，置1时CPU工作在保护模式下，置0时为实模式。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">;// 这里设置进入32 位保护模式运行。首先加载机器状态字(lmsw - Load Machine Status Word)，</span><br><span class="line">;// 也称控制寄存器CR0，其比特位0 置1 将导致CPU 工作在保护模式。</span><br><span class="line"></span><br><span class="line">	mov	ax,0001h	;// 保护模式比特位(PE)。</span><br><span class="line">	lmsw ax			;// 就这样加载机器状态字</span><br></pre></td></tr></table></figure>
<p>CPU工作方式转变为保护模式，一个重要的特征就是要根据GDT表来决定后续将执行哪里的程序。</p>
<p><code>jmpi 0, 8</code></p>
<p>这一句中的0是段内偏移，8是保护模式下的段选择符，用于选择描述符表和描述符表项以及所要求的特权级。</p>
<p>8要看成00001000：最后的00表示内核特权级，第3位的0表示GDT表，第4、5两位的01表示所选的表的1项来确定代码段的基址和段限长信息。</p>
<p>而GDT表的1项内容为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dw	07FFh		;// 8Mb - limit=2047 (2048*4096=8Mb)</span><br><span class="line">dw	0000h		;// base address=0</span><br><span class="line">dw	9A00h		;// code read/exec</span><br><span class="line">dw	00C0h		;// granularity=4096, 386</span><br></pre></td></tr></table></figure>
<p>所以，代码就会从段基址0x00000000、偏移为0处开始执行，也就是head的开始位置，这意味着将执行head程序。</p>
<h3><span id="heads开始执行">head.s开始执行</span></h3><p><strong>从bootsect到main执行的整体技术策略</strong>：</p>
<p>在执行main之前，先要执行三个汇编代码生成的程序，即bootsect、setup和head。之后，才执行由main开始的用C语言编写的操作系统内核程序。</p>
<p>先将head.s汇编成目标代码，将用C语言编写的内核程序编译成目标代码，然后链接成system模块。也就是说，system模块中，既有内核程序，也有head程序，二者是紧挨着的。head在前，内核在后，head在内存中占有25KB+184B的空间。</p>
<p>head用它自身的代码在它自身所在的空间创建了内核分页机制，即在0x000000的位置创建了也目录表、页表、缓冲区、GDT、IDT，并将head已经执行过的代码所占内存空间覆盖，这意味这head自己将自己废弃，main即将开始执行。</p>
<p>_pg_dir：用于标识内核分页机制完成后的内核起始位置，也就是物理内存的起始位置0x000000。head将在此建立页目录表，为分页机制做准备。这是内核能够掌控用户进程的基础之一。</p>
<p>现在head正式开始执行。一切都是为适应保护模式做准备。其本质就是让CS的用法从实模式转变到保护模式。</p>
<p>在实模式下时，CS本身就是代码段基址。而在保护模式下时，CS本身并不是代码段基址，而是代码段选择符。</p>
<p><code>jmpi 0, 8</code>这句代码使CS和GDT表的第2项关联，并且使代码的基址指向了0x000000。</p>
<p>这之后要将DS、ES、FS和GS等其他寄存器从实模式转变到保护模式。执行代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">_startup_32:			;// 以下5行设置各个数据段寄存器。指向gdt数据段描述符项</span><br><span class="line">	mov eax,10h</span><br><span class="line">;// 再次注意!!! 这里已经处于32 位运行模式，因此这里的$0x10 并不是把地址0x10 装入各</span><br><span class="line">;// 个段寄存器，它现在其实是全局段描述符表中的偏移值，或者更正确地说是一个描述符表</span><br><span class="line">;// 项的选择符。有关选择符的说明请参见setup.s 中的说明。这里$0x10 的含义是请求特权</span><br><span class="line">;// 级0(位0-1=0)、选择全局描述符表(位2=0)、选择表中第2 项(位3-15=2)。它正好指向表中</span><br><span class="line">;// 的数据段描述符项。（描述符的具体数值参见前面setup.s ）。下面代码的含义是：</span><br><span class="line">;// 置ds,es,fs,gs 中的选择符为setup.s 中构造的数据段（全局段描述符表的第2 项）=0x10，</span><br><span class="line">;// 并将堆栈放置在数据段中的_stack_start 数组内，然后使用新的中断描述符表和全局段</span><br><span class="line">;// 描述表.新的全局段描述表中初始内容与setup.s 中的完全一样。</span><br><span class="line">	mov ds,ax</span><br><span class="line">	mov es,ax</span><br><span class="line">	mov fs,ax</span><br><span class="line">	mov gs,ax</span><br><span class="line">	lss esp,_stack_start	;// 表示_stack_start -&gt; ss:esp，设置系统堆栈。</span><br><span class="line">							;// stack_start 定义在kernel/sched.c，69 行。</span><br><span class="line">	call setup_idt		;// 调用设置中断描述符表子程序。</span><br><span class="line">	call setup_gdt		;// 调用设置全局描述符表子程序。</span><br><span class="line">	mov eax,10h			;// reload all the segment registers</span><br><span class="line">	mov ds,ax			;// after changing gdt. CS was already</span><br><span class="line">	mov es,ax			;// reloaded in &apos;setup_gdt&apos;</span><br><span class="line">	mov fs,ax			;// 因为修改了gdt，所以需要重新装载所有的段寄存器。</span><br><span class="line">	mov gs,ax			;// CS 代码段寄存器已经在setup_gdt 中重新加载过了。</span><br><span class="line">	lss esp,_stack_start</span><br></pre></td></tr></table></figure>
<p>执行完毕后，DS、ES、FS和GS中的值都变成0x10。</p>
<p>0x10应看成二进制的00010000：最后两位的00表示内核特权级，第3位的0表示选择GDT表，第4、5两位的10是GDT表的2项，也就是第3项。</p>
<p>此时，4个寄存器用的是同一个全局描述符，它们的段基址、段限长和特权级都是相同的。</p>
<p>SS现在也要转变为栈段选择符，栈顶指针也成为32位的esp，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lss _stack_start, %esp</span><br></pre></td></tr></table></figure>
<blockquote>
<p>取段寄存器指令（Load Segment Instruction）:该组指令的功能是把内存单元的一个“低字”传送给指令中指定的16位寄存器，把随后的一个“高字”传送给相应的段寄存器（DS、ES、FS、GS和SS）。其指令格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; LDS/LES/LFS/LGS/LSS Reg, Mem</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>如果Reg是16位寄存器，那么Mem必须是32位指针；如果Reg是32位寄存器，那么Mem必须是48位指针，其低32位给指令中指定的寄存器，高16位给指令中的段寄存器。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kernel/sched.c</span><br><span class="line"><span class="keyword">long</span> user_stack[PAGE_SIZE &gt;&gt; <span class="number">2</span>];	<span class="comment">// 定义系统堆栈指针，4K。指针指在最后一项。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 该结构用于设置堆栈ss:esp（数据段选择符，指针），见head.s，第23 行。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">long</span> *a;</span><br><span class="line">  <span class="keyword">short</span> b;</span><br><span class="line">&#125;</span><br><span class="line">stack_start = &#123;&amp;user_stack[PAGE_SIZE &gt;&gt; <span class="number">2</span>], <span class="number">0x10</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>0x10将SS的值设置为与前面4个段选择符的值相同。这样，SS与前面讲解过的4个段选择符相同，段基址都指向0x000000，段限长都是8MB，特权级都是内核特权级，后面的压栈动作就要在这里进行。</p>
<p>head接下来对中断描述符表进行设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">;/*</span><br><span class="line">; * 下面这段是设置中断描述符表子程序setup_idt</span><br><span class="line">; *</span><br><span class="line">; * 将中断描述符表idt 设置成具有256 个项，并都指向ignore_int 中断门。然后加载</span><br><span class="line">; * 中断描述符表寄存器(用lidt 指令)。真正实用的中断门以后再安装。当我们在其它</span><br><span class="line">; * 地方认为一切都正常时再开启中断。该子程序将会被页表覆盖掉。</span><br><span class="line">; */</span><br><span class="line">setup_idt:</span><br><span class="line">	lea edx,ignore_int		;// 将ignore_int 的有效地址（偏移值）值 edx 寄存器</span><br><span class="line">	mov eax,00080000h		;// 将选择符0x0008 置入eax 的高16 位中。</span><br><span class="line">	mov ax,dx				;/* selector = 0x0008 = cs */</span><br><span class="line">							;// 偏移值的低16 位置入eax 的低16 位中。此时eax 含</span><br><span class="line">							;// 有门描述符低4 字节的值。</span><br><span class="line">	mov dx,8E00h		;/* interrupt gate - dpl=0, present */</span><br><span class="line">							;// 此时edx 含有门描述符高4 字节的值。</span><br><span class="line">	lea edi,_idt</span><br><span class="line">	mov ecx,256</span><br><span class="line">rp_sidt:</span><br><span class="line">	mov [edi],eax		;// 将哑中断门描述符存入表中。</span><br><span class="line">	mov [edi+4],edx</span><br><span class="line">	add edi,8			;// edi 指向表中下一项。</span><br><span class="line">	dec ecx</span><br><span class="line">	jne rp_sidt</span><br><span class="line">	lidt fword ptr idt_descr		;// 加载中断描述符表寄存器值。</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>现在，setup要废除已有的GDT，并在内核中的新位置重新创建全局描述符表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">;/*</span><br><span class="line">; * 下面这段是设置全局描述符表项setup_gdt</span><br><span class="line">; *</span><br><span class="line">; * 这个子程序设置一个新的全局描述符表gdt，并加载。此时仅创建了两个表项，与前</span><br><span class="line">; * 面的一样。该子程序只有两行，“非常的”复杂，所以当然需要这么长的注释了:)。</span><br><span class="line">; */</span><br><span class="line">setup_gdt:</span><br><span class="line">	lgdt fword ptr gdt_descr		;// 加载全局描述符表寄存器(内容已设置好，见232-238 行)。</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>入栈：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">;// 下面这几个入栈操作(pushl)用于为调用/init/main.c 程序和返回作准备。</span><br><span class="line">;// 前面3 个入栈指令不知道作什么用的，也许是Linus 用于在调试时能看清机器码用的.。</span><br><span class="line">;// 139 行的入栈操作是模拟调用main.c 程序时首先将返回地址入栈的操作，所以如果</span><br><span class="line">;// main.c 程序真的退出时，就会返回到这里的标号L6 处继续执行下去，也即死循环。</span><br><span class="line">;// 140 行将main.c 的地址压入堆栈，这样，在设置分页处理（setup_paging）结束后</span><br><span class="line">;// 执行&apos;ret&apos;返回指令时就会将main.c 程序的地址弹出堆栈，并去执行main.c 程序去了。</span><br><span class="line">after_page_tables:</span><br><span class="line">	push 0			;// These are the parameters to main :-)</span><br><span class="line">	push 0			;// 这些是调用main 程序的参数（指init/main.c）。</span><br><span class="line">	push 0</span><br><span class="line">	push L6			;// return address for main, if it decides to.</span><br><span class="line">	push _main_rename		;// &apos;_main&apos;是编译程序对main 的内部表示方法。</span><br><span class="line">	jmp setup_paging</span><br><span class="line">L6:</span><br><span class="line">	jmp L6			;// main should never return here, but</span><br><span class="line">				;// just in case, we know what happens.</span><br></pre></td></tr></table></figure>
<p>之后，跳转至setup_paging去执行，开始创建分页机制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">;/*</span><br><span class="line">; * Setup_paging</span><br><span class="line">; *</span><br><span class="line">; * 这个子程序通过设置控制寄存器cr0 的标志（PG 位31）来启动对内存的分页处理</span><br><span class="line">; * 功能，并设置各个页表项的内容，以恒等映射前16 MB 的物理内存。分页器假定</span><br><span class="line">; * 不会产生非法的地址映射（也即在只有4Mb 的机器上设置出大于4Mb 的内存地址）。</span><br><span class="line">; *</span><br><span class="line">; * 注意！尽管所有的物理地址都应该由这个子程序进行恒等映射，但只有内核页面管</span><br><span class="line">; * 理函数能直接使用&gt;1Mb 的地址。所有“一般”函数仅使用低于1Mb 的地址空间，或</span><br><span class="line">; * 者是使用局部数据空间，地址空间将被映射到其它一些地方去-- mm(内存管理程序)</span><br><span class="line">; * 会管理这些事的。</span><br><span class="line">; *</span><br><span class="line">; * 对于那些有多于16Mb 内存的家伙- 太幸运了，我还没有，为什么你会有:-)。代码就</span><br><span class="line">; * 在这里，对它进行修改吧。（实际上，这并不太困难的。通常只需修改一些常数等。</span><br><span class="line">; * 我把它设置为16Mb，因为我的机器再怎么扩充甚至不能超过这个界限（当然，我的机 </span><br><span class="line">; * 器很便宜的:-)）。我已经通过设置某类标志来给出需要改动的地方（搜索“16Mb”），</span><br><span class="line">; * 但我不能保证作这些改动就行了 :-( )</span><br><span class="line">; */</span><br><span class="line">align 2		;// 按4 字节方式对齐内存地址边界。</span><br><span class="line">setup_paging:	;// 首先对5 页内存（1 页目录+ 4 页页表）清零</span><br><span class="line">	mov ecx,1024*5		;/* 5 pages - pg_dir+4 page tables */</span><br><span class="line">	xor eax,eax</span><br><span class="line">	xor edi,edi			;/* pg_dir is at 0x000 */</span><br><span class="line">							;// 页目录从0x000 地址开始。</span><br><span class="line">	pushf		;// VC内汇编使用cld和std后，需要自己恢复DF的值</span><br><span class="line">	cld</span><br><span class="line">	rep stosd</span><br><span class="line">;// 下面4 句设置页目录中的项，我们共有4 个页表所以只需设置4 项。</span><br><span class="line">;// 页目录项的结构与页表中项的结构一样，4 个字节为1 项。参见上面的说明。</span><br><span class="line">;// &quot;$pg0+7&quot;表示：0x00001007，是页目录表中的第1 项。</span><br><span class="line">;// 则第1 个页表所在的地址= 0x00001007 &amp; 0xfffff000 = 0x1000；第1 个页表</span><br><span class="line">;// 的属性标志= 0x00001007 &amp; 0x00000fff = 0x07，表示该页存在、用户可读写。</span><br><span class="line">	mov eax,_pg_dir</span><br><span class="line">	mov [eax],pg0+7		;/* set present bit/user r/w */</span><br><span class="line">	mov [eax+4],pg1+7		;/*  --------- &quot; &quot; --------- */</span><br><span class="line">	mov [eax+8],pg2+7		;/*  --------- &quot; &quot; --------- */</span><br><span class="line">	mov [eax+12],pg3+7		;/*  --------- &quot; &quot; --------- */</span><br><span class="line">;// 下面6 行填写4 个页表中所有项的内容，共有：4(页表)*1024(项/页表)=4096 项(0 - 0xfff)，</span><br><span class="line">;// 也即能映射物理内存4096*4Kb = 16Mb。</span><br><span class="line">;// 每项的内容是：当前项所映射的物理内存地址+ 该页的标志（这里均为7）。</span><br><span class="line">;// 使用的方法是从最后一个页表的最后一项开始按倒退顺序填写。一个页表的最后一项</span><br><span class="line">;// 在页表中的位置是1023*4 = 4092。因此最后一页的最后一项的位置就是$pg3+4092。</span><br><span class="line">	mov edi,pg3+4092		;// edi -&gt; 最后一页的最后一项。</span><br><span class="line">	mov eax,00fff007h		;/*  16Mb - 4096 + 7 (r/w user,p) */</span><br><span class="line">							;// 最后1 项对应物理内存页面的地址是0xfff000，</span><br><span class="line">							;// 加上属性标志7，即为0xfff007.</span><br><span class="line">	std					;// 方向位置位，edi 值递减(4 字节)。</span><br><span class="line">L3:	stosd				;/* fill pages backwards - more efficient :-) */</span><br><span class="line">	sub eax,00001000h	;// 每填写好一项，物理地址值减0x1000。</span><br><span class="line">	jge L3				;// 如果小于0 则说明全添写好了。</span><br><span class="line">	popf</span><br><span class="line">;// 设置页目录基址寄存器cr3 的值，指向页目录表。</span><br><span class="line">	xor eax,eax		;/* 页目录表(pg_dir)在0x0000 处。 */</span><br><span class="line">	mov cr3,eax		;/* cr3 - page directory start */</span><br><span class="line">;// 设置启动使用分页处理（cr0 的PG 标志，位31）</span><br><span class="line">	mov eax,cr0</span><br><span class="line">	or  eax,80000000h	;// 添上PG 标志。</span><br><span class="line">	mov cr0,eax			;/* set paging (PG) bit */</span><br><span class="line">	ret						;/* this also flushes prefetch-queue */</span><br></pre></td></tr></table></figure>
<p>在执行完setup_paging的ret之后，将先前入栈的、在栈顶的_main函数的地址弹出给CS：EIP，即等价于CPU开始执行main函数程序。</p>
<p>## </p>
<p>## </p>
<h1><span id="文件操作">文件操作</span></h1><h2><span id="打开文件">打开文件</span></h2><h2><span id="读文件">读文件</span></h2><h2><span id="新建文件">新建文件</span></h2><h2><span id="写文件">写文件</span></h2><h2><span id="修改文件">修改文件</span></h2><h2><span id="关闭文件">关闭文件</span></h2><h2><span id="删除文件">删除文件</span></h2><h1><span id="用户进程与内存管理">用户进程与内存管理</span></h1><h2><span id="用户进程的创建">用户进程的创建</span></h2><h2><span id="为用户进程str1的加载做准备">为用户进程str1的加载做准备</span></h2><h2><span id="对缺页中断的处理">对缺页中断的处理</span></h2><h2><span id="str1用户进程的退出">str1用户进程的退出</span></h2><h2><span id="多个用户进程同时运行">多个用户进程同时运行</span></h2><h2><span id="进程的调度与切换">进程的调度与切换</span></h2><h2><span id="内核的分页">内核的分页</span></h2><h2><span id="页写保护">页写保护</span></h2><h1><span id="多个进程同时操作一个文件">多个进程同时操作一个文件</span></h1><h2><span id="三个进程操作同一个文件">三个进程操作同一个文件</span></h2><h2><span id="缓冲区与外设的数据同步">缓冲区与外设的数据同步</span></h2><h1><span id="ipc问题">IPC问题</span></h1><h2><span id="管道机制">管道机制</span></h2><h2><span id="信号机制">信号机制</span></h2><p>信号机制是Linux 0.11为进程提供的一套“局部的类中断机制”，即在进程执行过程中，如果系统发现该进程接收到了信号，就暂时打断该进程的执行，转而去执行该进程的信号处理程序，处理完毕后，再从该进程“被打断”处继续执行。</p>
<h3><span id="processing进程开始执行">processing进程开始执行</span></h3><h3><span id="processig进程进入可中断等待状态">processig进程进入可中断等待状态</span></h3><h3><span id="sendsig进程开始执行并向processig进程发信号">sendsig进程开始执行并向processig进程发信号</span></h3><h3><span id="系统检测当前进程接收到信号并准备处理">系统检测当前进程接收到信号并准备处理</span></h3><h3><span id="系统检测信号处理函数指针是否正常">系统检测信号处理函数指针是否正常</span></h3><h3><span id="调整processig进程的内核栈结构使之先执行信号处理函数">调整processig进程的内核栈结构，使之先执行信号处理函数</span></h3><h3><span id="信号对进程执行状态的影响">信号对进程执行状态的影响</span></h3>
                </div>
            </div>
    
            <nav class="post-pagination">
    
    <a class="newer-posts" href="/2016/02/26/Linux内核设计02-从main到怠速/">
        上一篇<br>Linux内核设计02-从main到怠速
    </a>
    
    <span class="page-number"></span>
    
</nav>

    
            


        </div>
    </div>
    <div class="single-column-footer">
    Proudly published with Hexo<br>
    
    Theme <a href="https://github.com/SumiMakito/hexo-theme-journal/" target="_blank" rel="noreferrer noopener">Journal.</a> by <a href="https://mak1t0.cc/" target="_blank" rel="noreferrer noopener">Makito</a><br>
    
    &copy; 2018 <a href="http://yoursite.com">javfa&#39;s blog</a>
</div>
</div>

</div>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.14.4/dist/umd/popper.min.js" integrity="sha256-EGs9T1xMHdvM1geM8jPpoo8EZ1V1VRsmcJz8OByENLA=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.1.3/dist/js/bootstrap.min.js" integrity="sha256-VsEqElsCHSGmnmHXGQzvoWjWwoznFSZc6hs7ARLRacQ=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.min.js" integrity="sha256-FtWfRI+thWlNz2sB3SJbwKx5PgMyKIVgwHCTwa3biXc=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/smooth-scroll@14.2.1/dist/smooth-scroll.polyfills.min.js" integrity="sha256-CI4Gq5E0io1Pv0xM3qPM+NUIOhbIBvC3GiN1Y4KhXpw=" crossorigin="anonymous"></script>
<script src="/js/journal.js?70371921"></script>



</body>
</html>
