

<!DOCTYPE html>
<html lang xmlns:v-bind="http://www.w3.org/1999/xhtml">

<head><meta name="generator" content="Hexo 3.8.0">
    <title>Linux内核设计 - javfa&#39;s blog</title>
<meta charset="utf-8">
<meta name="X-UA-Compatible" content="IE=edge">
<meta name="author" content="Javfa">
<meta name="description" content="本文详细剖析了Linux 0.11的源代码，以此来阐述Linux内核的设计思想和实现细节。
从开机加电到执行mai...">
<meta name="keywords" content>

<link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml">

    <meta charset="utf-8">
    <meta name="X-UA-Compatible" content="IE=edge">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <meta content="telephone=no" name="format-detection">
    <meta name="renderer" content="webkit">
    <meta name="theme-color" content="#ffffff">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.1.3/dist/css/bootstrap.min.css" integrity="sha256-eSi1q2PG6J7g7ib17yAaWMcrr5GrtohYChqibrV7PBE=" crossorigin="anonymous">
<link rel="stylesheet" href="/css/journal.css?38009929">
<script src="/js/loadCSS.js"></script>
<script>
    loadCSS("https://fonts.googleapis.com/css?family=Lora|Montserrat|Fira+Mono|Material+Icons");
    (function (d) {
        var config = {
                kitId: 'dwg1tuc',
                scriptTimeout: 3000,
                async: true
            },
            h = d.documentElement, t = setTimeout(function () {
                h.className = h.className.replace(/\bwf-loading\b/g, "") + " wf-inactive";
            }, config.scriptTimeout), tk = d.createElement("script"), f = false,
            s = d.getElementsByTagName("script")[0], a;
        h.className += " wf-loading";
        tk.src = 'https://use.typekit.net/' + config.kitId + '.js';
        tk.async = true;
        tk.onload = tk.onreadystatechange = function () {
            a = this.readyState;
            if (f || a && a != "complete" && a != "loaded") return;
            f = true;
            clearTimeout(t);
            try {
                Typekit.load(config)
            } catch (e) {
            }
        };
        s.parentNode.insertBefore(tk, s)
    })(document);
</script>
<noscript>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora|Montserrat|Anonymous+Pro:400|Material+Icons">
</noscript>
</head>
<body>
<div id="top"></div>
<div id="app">
<div class="single-column-drawer-container" ref="drawer" v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }">
    <div class="drawer-content">
        <div class="drawer-menu">
            <a class="a-block drawer-menu-item false" href="http://yoursite.com">
                Home
            </a>
            <a class="a-block drawer-menu-item false" href="/archives">
                Archive
            </a>

            
            

            
            <a class="a-block drawer-menu-item" href="/atom.xml">
                RSS
            </a>
            
        </div>
    </div>
</div>
<transition name="fade">
    <div v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if="isDrawerOpen" v-on:click="toggleDrawer"></div>
</transition>
<nav ref="navBar" class="navbar sticky-top navbar-light single-column-nav-container">
    <div ref="navBackground" class="nav-background"></div>
    <div class="container container-narrow nav-content">
        <button id="nav_dropdown_btn" class="nav-dropdown-toggle" type="button" v-on:click="toggleDrawer">
            <i class="material-icons">
                menu
            </i>
        </button>
        <a ref="navTitle" class="navbar-brand" href="/">
            javfa&#39;s blog
        </a>
    </div>
</nav>
<div class="single-column-header-container" ref="pageHead" v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }">
    <a href="/">
        <div class="single-column-header-title">javfa&#39;s blog</div>
        <div class="single-column-header-subtitle"></div>
    </a>
</div>
<div ref="sideContainer" class="side-container">
    <a class="a-block nav-head false" href="/">
        <div class="nav-title">
            Journal.
        </div>
        <div class="nav-subtitle">
            隻言片語<br>於此匯聚
        </div>
    </a>

    <div class="nav-link-list">
        <a class="a-block no-tint nav-link-item false" href="/archives">
            Archive
        </a>

        
        

        
        <a class="a-block no-tint nav-link-item" href="/atom.xml">
            RSS
        </a>
        
    </div>

    
    <div class="nav-footer">
        Proudly published with Hexo<br>
        
        Theme <a href="https://github.com/SumiMakito/hexo-theme-journal/" target="_blank" rel="noreferrer noopener">Journal.</a> by <a href="https://mak1t0.cc/" target="_blank" rel="noreferrer noopener">Makito</a><br>
        
        &copy; 2019 <a href="http://yoursite.com">javfa&#39;s blog</a>
    </div>
</div>
<div ref="extraContainer" class="extra-container">
    <div class="pagination">
        <a id="globalBackToTop" class="pagination-action animated-visibility" href="#top" :class="{ invisible: scrollY == 0 }">
            <i class="material-icons pagination-action-icon">
                keyboard_arrow_up
            </i>
        </a>

        
    </div>
</div>

<div ref="streamContainer" class="stream-container">
    <div class="post-list-container post-list-container-shadow">
        <div class="post">
            <div class="post-head-wrapper-text-only" style="background-image: url('')">
                <div class="post-title">
                    Linux内核设计
                    <div class="post-meta">
                        <time datetime="2016-02-24T00:49:09.000Z" itemprop="datePublished">
                            2016-02-24 08:49
                        </time>&nbsp;
                        
    
                        
                        
                        <i class="material-icons" style>label</i>
                        
                        <a href="/tags/Linux/">Linux</a>
                        
                        
                    </div>
                </div>
            </div>
    
            <div class="post-body-wrapper">
                <div class="post-body">
                    <p>本文详细剖析了Linux 0.11的源代码，以此来阐述Linux内核的设计思想和实现细节。<br><a id="more"></a></p>
<h1 id="从开机加电到执行main函数之前的过程"><a href="#从开机加电到执行main函数之前的过程" class="headerlink" title="从开机加电到执行main函数之前的过程"></a>从开机加电到执行main函数之前的过程</h1><p>从开机到main函数的执行分三步完成，其目的是实现从启动盘加载操作系统程序，完成执行main函数所需要的准备工作。</p>
<h2 id="第一步，启动BIOS，准备实模式下的中断向量表和中断服务程序"><a href="#第一步，启动BIOS，准备实模式下的中断向量表和中断服务程序" class="headerlink" title="第一步，启动BIOS，准备实模式下的中断向量表和中断服务程序"></a>第一步，启动BIOS，准备<em>实模式</em>下的中断向量表和中断服务程序</h2><p>加电的一瞬间，计算机的RAM中，空空如也，什么程序也没有。而CPU的逻辑电路被设计为只能运行内存中的程序。如果要运行软盘中的操作系统，必须将软盘中操作系统程序加载到RAM中。<br>在RAM中什么程序都没有的时候，要由BIOS来完成加载软盘中操作系统到RAM中的任务。</p>
<h3 id="BIOS启动原理"><a href="#BIOS启动原理" class="headerlink" title="BIOS启动原理"></a>BIOS启动原理</h3><p>此时RAM中无程序，所以通过软件方法不可能执行BIOS，只能靠<strong>硬件方法</strong>完成。<br>从硬件角度看，Intel 80x86系列的cpu可以分别在16位实模式和32位保护模式下运行。</p>
<p>所有80x86系列CPU的硬件都设计为加电即进入16位实模式状态运行。且在加电瞬间强行将CS置为0xFFFF，IP置为0x0000，如此CS：IP就指向0xFFFF0这个地址位置。</p>
<blockquote>
<p>实模式（Real mode）的特性是一个20位的存储器地址空间，可以直接通过软件的方式访问BIOS以及周边硬件。</p>
<blockquote>
<p>$$<br>2^{20} =1048576​<br>$$</p>
<p>即1M的存储器可被寻</p>
</blockquote>
</blockquote>
<p>0xFFFF0指向了BIOS的地址范围。<br>这是一个纯硬件完成的动作。</p>
<p>BIOS程序的入口地址就是0xFFFF0.</p>
<h3 id="BIOS在内存中加载中断向量表和中断服务程序"><a href="#BIOS在内存中加载中断向量表和中断服务程序" class="headerlink" title="BIOS在内存中加载中断向量表和中断服务程序"></a>BIOS在内存中加载中断向量表和中断服务程序</h3><p>BIOS程序被固化在计算机主板之上的一块很小的ROM芯片里。不同的主板所用的BIOS也有所不同，就启动部分，各种类型的BIOS的基本原理大致相似。</p>
<p>在此，我们选用8KB的BIOS来说明此问题，此时BIOS所占地址段为0xFE000-0xFFFFF。</p>
<p>而此时，在实模式下内存寻址空间为：0x00000-0xFFFFF</p>
<p>CS：IP指向0xFFFF0，意味着BIOS开始启动了。<br>随着BIOS程序的执行，屏幕上显示显卡的信息、内存的信息……<br>在这期间，BIOS在内存中建立了中断向量表和中断服务程序：<br><strong>BIOS在内存最开始的位置（0x00000）用1K的内存空间构建中断向量表，并在紧挨它的位置用256字节的内存空间构建BIOS数据区，在大约56K以后的位置加载了8KB左右的与中断向量表相应的若干中断服务程序</strong>。<br>中断向量表中有256个中断向量，每个中断向量占4个字节，其中两个字节是CS值，两个为IP值，每个中断向量都指向一个具体的中断服务程序。</p>
<blockquote>
<p><em>中断</em>，可以理解为函数调用。</p>
</blockquote>
<h2 id="第二步，利用第一步中准备的中断服务程序来实现：从启动盘加载操作系统程序到内存"><a href="#第二步，利用第一步中准备的中断服务程序来实现：从启动盘加载操作系统程序到内存" class="headerlink" title="第二步，利用第一步中准备的中断服务程序来实现：从启动盘加载操作系统程序到内存"></a>第二步，利用第一步中准备的中断服务程序来实现：从启动盘加载操作系统程序到内存</h2><p>从现在开始就要执行真正的boot操作了，即把软盘中的操作系统加载至内存。</p>
<p>分三批逐次加载操作系统的内核代码：</p>
<ul>
<li><p>第一批由BIOS中断int 0x19h把第一扇区bootsect的内容加载到内存。</p>
<p>CPU接收到int 19h中断，立即在中断向量表中找到int 19h中断向量-&gt;这个中断向量把CPU指向0x0E6F2，这个位置就是int 19h相对应的中断服务程序的入口地址。</p>
<p>这个中断服务程序的作用就是把软盘的第一个扇区中的程序（512B）加载到内存中的指定位置（0x07C00）。</p>
<p><strong>这个中断服务程序的功能是BIOS事先设计好的，代码是固定的，与Linux操作系统无关</strong>。</p>
<p>这个扇区里的内容就是Linux 0.11操作系统的引导程序，也就是bootsect，其作用就是陆续把软盘中的操作系统程序载入内存。</p>
<p>bootsect的载入，标志着操作系统中的代码即将发挥作用了。</p>
</li>
<li><p>加载第二部分代码-setup</p>
<p>现在BIOS已经把bootsect（如上所示）载入内存了，它的作用就是把第二批和第三批程序陆续加载到内存中。为了把第二批和第三批程序加载到内存中的适当位置，bootsect首先做的工作就是规划内存。</p>
<ol>
<li>bootsect对内存的规划</li>
</ol>
<p>在实模式下，寻址的最大范围是1MB，为了规划内存，bootsect首先设计了如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SETUPLEN, 4     # nr of setup-sectors</span><br><span class="line"></span><br><span class="line">BOOTSEG, 0x07c0 # original address of boot-sector</span><br><span class="line"></span><br><span class="line">INITSEG, 0x9000 # we move boot here - out of the way</span><br><span class="line"></span><br><span class="line">SETUPSEG, 0x9020    # setup starts here</span><br><span class="line"></span><br><span class="line">SYSSEG, 0x1000      # system loaded at 0x10000 (65536).</span><br><span class="line"></span><br><span class="line">ENDSEG, SYSSEG + SYSSIZE    # where to stop loading</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>  这些源代码的作用就是对后续操作所涉及的内存位置进行设置，包括将要加载的setup程序的扇区数和被加载到的位置、启动扇区被BIOS加载的位置和将要移动到的新位置、内核被加载的位置、内核末尾位置和根文件系统设备号。</p>
<p>  要时刻牢记这样一个概念：<strong>操作系统的设计者要全面</strong>、<strong>整体地考虑内存的规划</strong>。</p>
<ol start="2">
<li><p>复制bootsect</p>
<p>接下来，bootsect启动程序将它自身从内存0x07C00处复制至内存0x90000处</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">start:					;// 以下10行作用是将自身(bootsect)从目前段位置07c0h(31k)</span><br><span class="line">						;// 移动到9000h(576k)处，共256字(512字节)，然后跳转到</span><br><span class="line">						;// 移动后代码的 go 标号处，也即本程序的下一语句处。 </span><br><span class="line">	mov	ax,BYTE PTR BOOTSEG		;// 将ds段寄存器置为7C0h</span><br><span class="line">	mov	ds,ax</span><br><span class="line">	mov	ax,BYTE PTR INITSEG		;// 将es段寄存器置为9000h</span><br><span class="line">	mov	es,ax</span><br><span class="line">	mov	cx,256			;// 移动计数值 ＝ 256字 = 512 字节</span><br><span class="line">	sub	si,si			;// 源地址   ds:si = 07C0h:0000h</span><br><span class="line">	sub	di,di			;// 目的地址 es:di = 9000h:0000h</span><br><span class="line">	rep movsw			;// 重复执行，直到cx = 0;移动1个字</span><br></pre></td></tr></table></figure>
<p>在这次复制过程中，ds和si联合使用，构成了源地址；es和di联合使用，构成了目的地址，而<code>mov cx,256</code>循环控制量，提供了需要复制的字数（一个字位两个字节）。</p>
<p>bootsect复制到新位置后，将ds、es、ss都置成移动后代码所在段处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">;	jmp INITSEG:[go] 	;// 间接跳转。这里INITSEG指出跳转到的段地址。</span><br><span class="line">    db 0eah				;// 间接跳转指令码</span><br><span class="line">	dw go</span><br><span class="line">	dw INITSEG</span><br><span class="line">go:	mov	ax,cs			;// 将ds、es和ss都置成移动后代码所在的段处（9000h）。</span><br><span class="line">	mov	ds,ax			;// 由于程序中有堆栈操作（push，pop，call），因此必须设置堆栈。</span><br><span class="line">	mov	es,ax</span><br><span class="line">;// put stack at 9ff00.  将堆栈指针sp指向9ff00h（即9000h:0ff00h）处</span><br><span class="line">	mov	ss,ax</span><br><span class="line">	mov	sp,0FF00h		;/* 由于代码段移动过了，所以要重新设置堆栈段的位置。</span><br><span class="line">						;   sp只要指向远大于512偏移（即地址90200h）处</span><br><span class="line">						;   都可以。因为从90200h地址开始处还要放置setup程序，</span><br><span class="line">						;   而此时setup程序大约为4个扇区，因此sp要指向大</span><br><span class="line">						;   于（200h + 200h*4 + 堆栈大小）处。 */</span><br></pre></td></tr></table></figure>
</li>
<li><p>将setup程序加载到内存中</p>
<p>加载setup程序，要借助BIOS提供的int 0x 13h中断向量所指向的中断服务程序（也就是磁盘服务程序）来完成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">load_setup:</span><br><span class="line">	;// 以下10行的用途是利用BIOS中断INT 13h将setup模块从磁盘第2个扇区</span><br><span class="line">	;// 开始读到90200h开始处，共读4个扇区。如果读出错，则复位驱动器，并</span><br><span class="line">	;// 重试，没有退路。</span><br><span class="line">	;// INT 13h 的使用方法如下：</span><br><span class="line">	;// ah = 02h - 读磁盘扇区到内存；al = 需要读出的扇区数量；</span><br><span class="line">	;// ch = 磁道（柱面）号的低8位；  cl = 开始扇区（0－5位），磁道号高2位（6－7）；</span><br><span class="line">	;// dh = 磁头号；				  dl = 驱动器号（如果是硬盘则要置为7）；</span><br><span class="line">	;// es:bx -&gt;指向数据缓冲区；  如果出错则CF标志置位。 </span><br><span class="line">	mov	dx,0000h				;// drive 0, head 0</span><br><span class="line">	mov	cx,0002h				;// sector 2, track 0</span><br><span class="line">	mov	bx,0200h				;// address = 512, in INITSEG</span><br><span class="line">	mov	ax,0200h+SETUPLEN		;// service 2, nr of sectors</span><br><span class="line">	int	13h					;// read it</span><br><span class="line">	jnc	ok_load_setup			;// ok - continue</span><br><span class="line">	mov	dx,0000h</span><br><span class="line">	mov	ax,0000h				;// reset the diskette</span><br><span class="line">	int	13h</span><br><span class="line">	jmp	load_setup</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><p>加载第三部分代码-system模块</p>
<p>仍然使用BIOS提供的int 0x 13h中断。</p>
<p>bootsect借着BIOS中断int 0x 13h，将240个扇区的system模块加载进内存。</p>
<p>加载工作主要是由bootsect调用read_it子程序完成的。</p>
<p>到此为止，第三批程序已经加载完毕，整个操作系统的代码已全部载入内存。bootsect的主体工作已经做完了，还有一点小事，就是要再次确定以下根设备号。</p>
<p>经过一系列检测，得知软盘为根设备，所以就把根设备号保存在root_dev中，作为机器系统数据之一。</p>
<p>现在，bootsect程序的任务都已经完成。</p>
<p>下面通过执行<code>jmpi 0, SETUPSEG</code>这行语句跳转至0x90200处，也就是第二批程序setup程序加载的位置。</p>
<p>CS：IP指向setup程序的第一条指令，意味着由setup程序接着bootsect程序继续执行。</p>
<p>setup程序现在开始执行。它做的第一件事情就是利用BIOS提供的中断服务程序从设备上提取内核运行所需的机器系统数据。</p>
<p>这些机器系统数据被加载到内存的0x90000-0x901FC位置，这些数据将在以后main函数执行时发挥重要作用。</p>
</li>
</ul>
<h2 id="第三步，为执行32位的main函数做过渡工作"><a href="#第三步，为执行32位的main函数做过渡工作" class="headerlink" title="第三步，为执行32位的main函数做过渡工作"></a>第三步，为执行32位的main函数做过渡工作</h2><p>接下来，操作系统要使计算机在32位保护模式下工作。</p>
<p>这期间要做大量的重建工作，并且持续工作到操作系统的main函数的执行过程中。</p>
<p>在本节中，操作系统执行的操作包括打开32位的寻址空间、打开保护模式、建立保护模式下的中断响应机制等与保护模式配套的相关工作、建立内存的分页机制，以及做好调用main函数的准备。</p>
<p>setup继续执行……</p>
<h3 id="关中断，并将system移动到内存地址起始位置0x00000"><a href="#关中断，并将system移动到内存地址起始位置0x00000" class="headerlink" title="关中断，并将system移动到内存地址起始位置0x00000"></a>关中断，并将system移动到内存地址起始位置0x00000</h3><p>即将CPU的标志寄存器（EFLAGS）中的中断允许标志置0。意味着，在接下来的执行过程中，无论是否发生中断，系统都不再响应此中断，直到main函数中适应保护模式的中断服务体系被重建完毕才会打开。那时响应中断的服务程序不再是BIOS提供的中断服务程序，取而代之的是由系统自身提供的中断服务程序。</p>
<blockquote>
<p>EFLAGS：标志寄存器，存在于CPU中，32位，包含一组状态标志、控制标志和系统标志。第9位IF为中断允许标志。</p>
</blockquote>
<blockquote>
<p>关中断（cli）和开中断（sti）操作在操作系统代码中频繁出现，总是在一个完整的操作过程的两头出现，目的是为了避免中断在此期间介入。</p>
</blockquote>
<p>下面，setup做了一个影响深远的动作：将位于0x10000的内核程序拷贝至内存地址起始位置0x00000处。</p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">;// 从这里开始我们要保护模式方面的工作了。</span><br><span class="line"></span><br><span class="line">	cli			;// 此时不允许中断。 ;//</span><br><span class="line"></span><br><span class="line">;// 首先我们将system 模块移到正确的位置。</span><br><span class="line">;// bootsect 引导程序是将system 模块读入到从10000（64k）开始的位置。由于当时假设</span><br><span class="line">;// system 模块最大长度不会超过80000（512k），也即其末端不会超过内存地址90000，</span><br><span class="line">;// 所以bootsect 会将自己移动到90000 开始的地方，并把setup 加载到它的后面。</span><br><span class="line">;// 下面这段程序的用途是再把整个system 模块移动到00000 位置，即把从10000 到8ffff</span><br><span class="line">;// 的内存数据块(512k)，整块地向内存低端移动了10000（64k）的位置。</span><br><span class="line"></span><br><span class="line">	mov	ax,0000h</span><br><span class="line">	cld			;// &apos;direction&apos;=0, movs moves forward</span><br><span class="line">do_move:</span><br><span class="line">	mov	es,ax		;// es:di -&gt; 目的地址(初始为0000:0)</span><br><span class="line">	add	ax,1000h</span><br><span class="line">	cmp	ax,9000h	;// 已经把从8000 段开始的64k 代码移动完？</span><br><span class="line">	jz	end_move</span><br><span class="line">	mov	ds,ax		;// ds:si -&gt; 源地址(初始为1000:0)</span><br><span class="line">	sub	di,di</span><br><span class="line">	sub	si,si</span><br><span class="line">	mov cx,8000h	;// 移动8000 字（64k 字节）。</span><br><span class="line">	rep movsw</span><br><span class="line">	jmp	do_move</span><br></pre></td></tr></table></figure>
<h3 id="设置中断描述符表和全局描述符表"><a href="#设置中断描述符表和全局描述符表" class="headerlink" title="设置中断描述符表和全局描述符表"></a>设置中断描述符表和全局描述符表</h3><p>setup继续为保护模式做准备，此时要通过setup自身提供的数据信息对中断描述符表寄存器IDTR和全局描述符表寄存器GDTR进行初始化设置。</p>
<blockquote>
<p>GDT(Global Descriptor Table)：它是系统中唯一存放段寄存器内容（段描述符）的数组，配合程序进行保护模式下的段寻址。它在操作系统的进程切换中具有重要意义，可理解为所有进程的总目录表，其中存放着每一个任务局部描述符表（LDT）地址和任务状态段（TSS）地址，用于完成进程中各段的寻址、现场保护和现场恢复。</p>
<p>GDTR：GDT可以存放在内存的任何位置，当程序通过段寄存器引用一个段描述符时，需要取得GDT的入口，GDTR所标识的即为此入口。在操作系统对GDT的初始化完成后，可以用LGDT（Load GDT）指令将GDT基地址加载至GDTR。</p>
<p>IDT(Interrupt Descriptor Table)：保存保护模式下所有中断服务程序的入口地址，类似于实模式下的中断向量表。</p>
<p>IDTR：IDT基地址寄存器，保存IDT的起始地址。</p>
</blockquote>
<blockquote>
<p>32位的中断机制和16位的中断机制在原理上有比较大的差别，最明显的是16位的中断机制用的是中断向量表，中断向量表的起始位置在0x00000处，这个位置是固定的。</p>
<p>32位的中断机制用的是中断描述符表IDT，位置是不固定的，可以由操作系统的设计者根据设计要求灵活安排，由IDTR寄存器来锁定其位置。</p>
</blockquote>
<blockquote>
<p>GDT表是保护模式下管理段描述符的数据结构，对操作系统自身的运行和管理，以及进程调度有重大意义。</p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">;// 全局描述符表开始处。描述符表由多个8 字节长的描述符项组成。</span><br><span class="line">;// 这里给出了3 个描述符项。第1 项无用，但须存在。第2 项是系统代码段</span><br><span class="line">;// 描述符，第3 项是系统数据段描述符。每个描述符的具体</span><br><span class="line">;// 含义参见列表后说明。</span><br><span class="line">gdt:</span><br><span class="line">	dw	0,0,0,0		;// 第1 个描述符，不用。</span><br><span class="line">;// 这里在gdt 表中的偏移量为08，当加载代码段寄存器(段选择符)时，使用的是这个偏移值。</span><br><span class="line">	dw	07FFh		;// 8Mb - limit=2047 (2048*4096=8Mb)</span><br><span class="line">	dw	0000h		;// base address=0</span><br><span class="line">	dw	9A00h		;// code read/exec</span><br><span class="line">	dw	00C0h		;// granularity=4096, 386</span><br><span class="line">;// 这里在gdt 表中的偏移量是16，当加载数据段寄存器(如ds 等)时，使用的是这个偏移值。</span><br><span class="line">	dw	07FFh		;// 8Mb - limit=2047 (2048*4096=8Mb)</span><br><span class="line">	dw	0000h		;// base address=0</span><br><span class="line">	dw	9200h		;// data read/write</span><br><span class="line">	dw	00C0h		;// granularity=4096, 386</span><br><span class="line"></span><br><span class="line">idt_48:</span><br><span class="line">	dw	0			;// idt limit=0</span><br><span class="line">	dw	0,0			;// idt base=0L</span><br><span class="line"></span><br><span class="line">gdt_48:</span><br><span class="line">	dw	800h		;// 全局表长度为2k 字节，因为每8 字节组成一个段描述符项</span><br><span class="line">						;// 所以表中共可有256 项。</span><br><span class="line">	dw	512+gdt,9h	;// 4 个字节构成的内存线性地址：0009&lt;&lt;16 + 0200+gdt</span><br><span class="line">						;// 也即90200 + gdt(即在本程序段中的偏移地址，205 行)。</span><br></pre></td></tr></table></figure>
<p>此时内核尚未真正运行起来，还没有进程，所以现在创建的GDT表的第一项为空，第二项为内核代码段描述符，第三项为内核数据段描述符，其余项皆为空。</p>
<p>IDT表虽然已经设置，实为一张空表，原因是目前中断已关，无须调用中断服务程序。</p>
<p>创建这两个表的过程可理解为是分两步进行的：</p>
<ul>
<li>在设计内核代码时，已经将两个表写好，并且把需要的数据也写好；</li>
<li>将专用寄存器（IDTR和GDTR）指向表</li>
</ul>
<blockquote>
<p>在内存中做出数据的方法有两种：</p>
<ul>
<li>划分一块内存区域并初始化数据，“看住”这块内存区域，使之能被找到；</li>
<li>有代码做出数据，如用push代码压栈，做出数据。</li>
</ul>
</blockquote>
<p>此处采用的是第一种方法。</p>
<h3 id="打开A20，实现32位寻址"><a href="#打开A20，实现32位寻址" class="headerlink" title="打开A20，实现32位寻址"></a>打开A20，实现32位寻址</h3><p>打开A20，意味着CPU可以进行32位寻址，最大寻址空间为4GB</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">call empty_8042		;// 等待输入缓冲器空。</span><br><span class="line">					;// 只有当输入缓冲器为空时才可以对其进行写命令。</span><br><span class="line">mov	al,0D1h			;// D1 命令码-表示要写数据到8042 的P2 端口。P2 端</span><br><span class="line">out	64h,al			;// 口的位1 用于A20 线的选通。数据要写到60 口。</span><br><span class="line"></span><br><span class="line">call empty_8042		;// 等待输入缓冲器空，看命令是否被接受。</span><br><span class="line">mov	al,0DFh			;// A20 on 选通A20 地址线的参数。</span><br><span class="line">out	60h,al</span><br><span class="line">call empty_8042		;// 输入缓冲器为空，则表示A20 线已经选通。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">;// 下面这个子程序检查键盘命令队列是否为空。这里不使用超时方法- 如果这里死机，</span><br><span class="line">;// 则说明PC 机有问题，我们就没有办法再处理下去了。</span><br><span class="line">;// 只有当输入缓冲器为空时（状态寄存器位2 = 0）才可以对其进行写命令。</span><br><span class="line">empty_8042:</span><br><span class="line">	dw 00ebh,00ebh	;// jmp $+2, jmp $+2 $ 表示当前指令的地址</span><br><span class="line">						;// 这是两个跳转指令的机器码(跳转到下一句)，相当于延时空操作。</span><br><span class="line">	in	al,64h			;// 读AT 键盘控制器状态寄存器。</span><br><span class="line">	test al,2			;// 测试位2，输入缓冲器满？</span><br><span class="line">	jnz	empty_8042		;// yes - loop</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<blockquote>
<p>实模式下CPU的寻址范围为0到0xFFFFF，共1MB寻址空间，需要0-19号共20根地址线。进入保护模式后，将使用32位寻址模式，即采用32根地址线进行寻址，第21根到第32根地址线的选通，将意味着寻址模式的切换。</p>
</blockquote>
<blockquote>
<p>实模式下，当程序寻址超过0xFFFFF时，CPU将回滚至内存起始处寻址。（在只有20根地址线的条件下，0xFFFFF+1=0x00000，最高位溢出）。</p>
<p>例如，系统的段寄存器的最大允许地址为0xFFFF，指令指针的最大允许段内偏移也为0xFFFF，两者确定的最大绝对地址为0x10FFEF，这将意味着程序中可产生的实模式下的寻址范围比1MB多出将近64KB。</p>
<p>若将A20地址线启用就相对于关闭了CPU在实模式下寻址的“回滚”机制。可以利用这个特点来验证A20是否确实已经打开。</p>
</blockquote>
<h3 id="为在保护模式下执行head-s做准备"><a href="#为在保护模式下执行head-s做准备" class="headerlink" title="为在保护模式下执行head.s做准备"></a>为在保护模式下执行head.s做准备</h3><p>为了建立保护模式下的中断机制，setup将对可编程中断控制器8259A进行重新编程。</p>
<blockquote>
<p>8259A中断控制器：8259A是专门为了对8085A和8086/8088进行中断控制而设计的芯片，它是可以用程序控制的中断控制器。单个的8259A能管理8级向量优先级中断。在不增加其他电路的情况下，最多可以级联成64级的向量优先级中断系统。</p>
</blockquote>
<blockquote>
<p>在保护模式下，int 0x00-int 0x1F被Intel保留作为内部（不可屏蔽）中断和异常中断。</p>
</blockquote>
<p><strong>setup通过下面的代码将CPU的工作方式设为保护模式</strong>【此后正式进入了保护模式】：</p>
<p>将CR0寄存器的第0位（PE）置1，即设定处理器的工作方式为保护模式。</p>
<blockquote>
<p>CR0寄存器：0号32位控制寄存器，存放系统控制标志。第0位为PE（Protected Mode Enable）标志，置1时CPU工作在保护模式下，置0时为实模式。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">;// 这里设置进入32 位保护模式运行。首先加载机器状态字(lmsw - Load Machine Status Word)，</span><br><span class="line">;// 也称控制寄存器CR0，其比特位0 置1 将导致CPU 工作在保护模式。</span><br><span class="line"></span><br><span class="line">	mov	ax,0001h	;// 保护模式比特位(PE)。</span><br><span class="line">	lmsw ax			;// 就这样加载机器状态字</span><br></pre></td></tr></table></figure>
<p>CPU工作方式转变为保护模式，一个重要的特征就是要根据GDT表来决定后续将执行哪里的程序。</p>
<p><code>jmpi 0, 8</code></p>
<p>这一句中的0是段内偏移，8是保护模式下的段选择符，用于选择描述符表和描述符表项以及所要求的特权级。</p>
<p>8要看成00001000：最后的00表示内核特权级，第3位的0表示GDT表，第4、5两位的01表示所选的表的1项来确定代码段的基址和段限长信息。</p>
<p>而GDT表的1项内容为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dw	07FFh		;// 8Mb - limit=2047 (2048*4096=8Mb)</span><br><span class="line">dw	0000h		;// base address=0</span><br><span class="line">dw	9A00h		;// code read/exec</span><br><span class="line">dw	00C0h		;// granularity=4096, 386</span><br></pre></td></tr></table></figure>
<p>所以，代码就会从段基址0x00000000、偏移为0处开始执行，也就是head的开始位置，这意味着将执行head程序。</p>
<h3 id="head-s开始执行"><a href="#head-s开始执行" class="headerlink" title="head.s开始执行"></a>head.s开始执行</h3><p><strong>从bootsect到main执行的整体技术策略</strong>：</p>
<p>在执行main之前，先要执行三个汇编代码生成的程序，即bootsect、setup和head。之后，才执行由main开始的用C语言编写的操作系统内核程序。</p>
<p>先将head.s汇编成目标代码，将用C语言编写的内核程序编译成目标代码，然后链接成system模块。也就是说，system模块中，既有内核程序，也有head程序，二者是紧挨着的。head在前，内核在后，head在内存中占有25KB+184B的空间。</p>
<p>head用它自身的代码在它自身所在的空间创建了内核分页机制，即在0x000000的位置创建了也目录表、页表、缓冲区、GDT、IDT，并将head已经执行过的代码所占内存空间覆盖，这意味这head自己将自己废弃，main即将开始执行。</p>
<p>_pg_dir：用于标识内核分页机制完成后的内核起始位置，也就是物理内存的起始位置0x000000。head将在此建立页目录表，为分页机制做准备。这是内核能够掌控用户进程的基础之一。</p>
<p>现在head正式开始执行。一切都是为适应保护模式做准备。其本质就是让CS的用法从实模式转变到保护模式。</p>
<p>在实模式下时，CS本身就是代码段基址。而在保护模式下时，CS本身并不是代码段基址，而是代码段选择符。</p>
<p><code>jmpi 0, 8</code>这句代码使CS和GDT表的第2项关联，并且使代码的基址指向了0x000000。</p>
<p>这之后要将DS、ES、FS和GS等其他寄存器从实模式转变到保护模式。执行代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">_startup_32:			;// 以下5行设置各个数据段寄存器。指向gdt数据段描述符项</span><br><span class="line">	mov eax,10h</span><br><span class="line">;// 再次注意!!! 这里已经处于32 位运行模式，因此这里的$0x10 并不是把地址0x10 装入各</span><br><span class="line">;// 个段寄存器，它现在其实是全局段描述符表中的偏移值，或者更正确地说是一个描述符表</span><br><span class="line">;// 项的选择符。有关选择符的说明请参见setup.s 中的说明。这里$0x10 的含义是请求特权</span><br><span class="line">;// 级0(位0-1=0)、选择全局描述符表(位2=0)、选择表中第2 项(位3-15=2)。它正好指向表中</span><br><span class="line">;// 的数据段描述符项。（描述符的具体数值参见前面setup.s ）。下面代码的含义是：</span><br><span class="line">;// 置ds,es,fs,gs 中的选择符为setup.s 中构造的数据段（全局段描述符表的第2 项）=0x10，</span><br><span class="line">;// 并将堆栈放置在数据段中的_stack_start 数组内，然后使用新的中断描述符表和全局段</span><br><span class="line">;// 描述表.新的全局段描述表中初始内容与setup.s 中的完全一样。</span><br><span class="line">	mov ds,ax</span><br><span class="line">	mov es,ax</span><br><span class="line">	mov fs,ax</span><br><span class="line">	mov gs,ax</span><br></pre></td></tr></table></figure>
<p>执行完毕后，DS、ES、FS和GS中的值都变成0x10。</p>
<p>0x10应看成二进制的00010000：最后两位的00表示内核特权级，第3位的0表示选择GDT表，第4、5两位的10是GDT表的2项，也就是第3项。</p>
<p>此时，4个寄存器用的是同一个全局描述符，它们的段基址、段限长和特权级都是相同的。</p>
<p>SS现在也要转变为栈段选择符，栈顶指针也成为32位的esp，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lss _stack_start, %esp</span><br></pre></td></tr></table></figure>
<blockquote>
<p>取段寄存器指令（Load Segment Instruction）:该组指令的功能是把内存单元的一个“低字”传送给指令中指定的16位寄存器，把随后的一个“高字”传送给相应的段寄存器（DS、ES、FS、GS和SS）。其指令格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; LDS/LES/LFS/LGS/LSS Reg, Mem</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>如果Reg是16位寄存器，那么Mem必须是32位指针；如果Reg是32位寄存器，那么Mem必须是48位指针，其低32位给指令中指定的寄存器，高16位给指令中的段寄存器。</p>
</blockquote>
<h1 id="从main到怠速"><a href="#从main到怠速" class="headerlink" title="从main到怠速"></a>从main到怠速</h1><h2 id="开中断之前的准备工作"><a href="#开中断之前的准备工作" class="headerlink" title="开中断之前的准备工作"></a>开中断之前的准备工作</h2><h3 id="复制根设备号和硬盘参数表"><a href="#复制根设备号和硬盘参数表" class="headerlink" title="复制根设备号和硬盘参数表"></a>复制根设备号和硬盘参数表</h3><h3 id="物理内存规划格局"><a href="#物理内存规划格局" class="headerlink" title="物理内存规划格局"></a>物理内存规划格局</h3><h3 id="虚拟盘设置与初始化"><a href="#虚拟盘设置与初始化" class="headerlink" title="虚拟盘设置与初始化"></a>虚拟盘设置与初始化</h3><h3 id="内存管理结构mem-map初始化"><a href="#内存管理结构mem-map初始化" class="headerlink" title="内存管理结构mem_map初始化"></a>内存管理结构mem_map初始化</h3><h3 id="异常处理类中断服务程序挂接"><a href="#异常处理类中断服务程序挂接" class="headerlink" title="异常处理类中断服务程序挂接"></a>异常处理类中断服务程序挂接</h3><h3 id="初始化块设备请求项结构"><a href="#初始化块设备请求项结构" class="headerlink" title="初始化块设备请求项结构"></a>初始化块设备请求项结构</h3><h3 id="与建立人机交互界面相关的外设的中断服务程序挂接"><a href="#与建立人机交互界面相关的外设的中断服务程序挂接" class="headerlink" title="与建立人机交互界面相关的外设的中断服务程序挂接"></a>与建立人机交互界面相关的外设的中断服务程序挂接</h3><h3 id="开机启动时间设置"><a href="#开机启动时间设置" class="headerlink" title="开机启动时间设置"></a>开机启动时间设置</h3><h3 id="系统开始激活进程0"><a href="#系统开始激活进程0" class="headerlink" title="系统开始激活进程0"></a>系统开始激活进程0</h3><h3 id="进程相关事务初始化设置"><a href="#进程相关事务初始化设置" class="headerlink" title="进程相关事务初始化设置"></a>进程相关事务初始化设置</h3><h3 id="时钟中断设置"><a href="#时钟中断设置" class="headerlink" title="时钟中断设置"></a>时钟中断设置</h3><h3 id="系统调用服务程序挂接"><a href="#系统调用服务程序挂接" class="headerlink" title="系统调用服务程序挂接"></a>系统调用服务程序挂接</h3><h3 id="初始化缓冲区管理结构"><a href="#初始化缓冲区管理结构" class="headerlink" title="初始化缓冲区管理结构"></a>初始化缓冲区管理结构</h3><h3 id="初始化硬盘"><a href="#初始化硬盘" class="headerlink" title="初始化硬盘"></a>初始化硬盘</h3><h3 id="初始化软盘"><a href="#初始化软盘" class="headerlink" title="初始化软盘"></a>初始化软盘</h3><h3 id="开中断"><a href="#开中断" class="headerlink" title="开中断"></a>开中断</h3><h2 id="进程创建的最基本动作"><a href="#进程创建的最基本动作" class="headerlink" title="进程创建的最基本动作"></a>进程创建的最基本动作</h2><h3 id="操作系统为进程0创建进程1做准备"><a href="#操作系统为进程0创建进程1做准备" class="headerlink" title="操作系统为进程0创建进程1做准备"></a>操作系统为进程0创建进程1做准备</h3><h3 id="在进程槽中为进程1申请一个空闲位置并获取进程号"><a href="#在进程槽中为进程1申请一个空闲位置并获取进程号" class="headerlink" title="在进程槽中为进程1申请一个空闲位置并获取进程号"></a>在进程槽中为进程1申请一个空闲位置并获取进程号</h3><h3 id="复制进程信息之前，先将以下数据压栈"><a href="#复制进程信息之前，先将以下数据压栈" class="headerlink" title="复制进程信息之前，先将以下数据压栈"></a>复制进程信息之前，先将以下数据压栈</h3><h3 id="初步设置进程1管理结构"><a href="#初步设置进程1管理结构" class="headerlink" title="初步设置进程1管理结构"></a>初步设置进程1管理结构</h3><h3 id="进程0创建进程1的过程中发生时钟中断"><a href="#进程0创建进程1的过程中发生时钟中断" class="headerlink" title="进程0创建进程1的过程中发生时钟中断"></a>进程0创建进程1的过程中发生时钟中断</h3><h3 id="从时钟中断返回"><a href="#从时钟中断返回" class="headerlink" title="从时钟中断返回"></a>从时钟中断返回</h3><h3 id="调整进程1管理结构"><a href="#调整进程1管理结构" class="headerlink" title="调整进程1管理结构"></a>调整进程1管理结构</h3><h3 id="设置进程1的线性地址空间及物理页面"><a href="#设置进程1的线性地址空间及物理页面" class="headerlink" title="设置进程1的线性地址空间及物理页面"></a>设置进程1的线性地址空间及物理页面</h3><h3 id="继续调整进程1管理结构"><a href="#继续调整进程1管理结构" class="headerlink" title="继续调整进程1管理结构"></a>继续调整进程1管理结构</h3><h2 id="加载根文件系统"><a href="#加载根文件系统" class="headerlink" title="加载根文件系统"></a>加载根文件系统</h2><h3 id="进程1如何开始执行"><a href="#进程1如何开始执行" class="headerlink" title="进程1如何开始执行"></a>进程1如何开始执行</h3><h3 id="进程1开始执行"><a href="#进程1开始执行" class="headerlink" title="进程1开始执行"></a>进程1开始执行</h3><h3 id="进程1开始以数据块的形式操作硬盘"><a href="#进程1开始以数据块的形式操作硬盘" class="headerlink" title="进程1开始以数据块的形式操作硬盘"></a>进程1开始以数据块的形式操作硬盘</h3><h3 id="将找到的缓冲块与请求项挂接"><a href="#将找到的缓冲块与请求项挂接" class="headerlink" title="将找到的缓冲块与请求项挂接"></a>将找到的缓冲块与请求项挂接</h3><h3 id="将请求项与硬盘处理函数挂接"><a href="#将请求项与硬盘处理函数挂接" class="headerlink" title="将请求项与硬盘处理函数挂接"></a>将请求项与硬盘处理函数挂接</h3><h3 id="进行硬盘读盘前的准备工作"><a href="#进行硬盘读盘前的准备工作" class="headerlink" title="进行硬盘读盘前的准备工作"></a>进行硬盘读盘前的准备工作</h3><h3 id="给硬盘下达读盘指令"><a href="#给硬盘下达读盘指令" class="headerlink" title="给硬盘下达读盘指令"></a>给硬盘下达读盘指令</h3><h3 id="进程1由于等待读盘操作挂起"><a href="#进程1由于等待读盘操作挂起" class="headerlink" title="进程1由于等待读盘操作挂起"></a>进程1由于等待读盘操作挂起</h3><h3 id="系统切换到进程0执行"><a href="#系统切换到进程0执行" class="headerlink" title="系统切换到进程0执行"></a>系统切换到进程0执行</h3><h3 id="进程0的执行过程"><a href="#进程0的执行过程" class="headerlink" title="进程0的执行过程"></a>进程0的执行过程</h3><h3 id="进程0执行过程中发生硬盘中断"><a href="#进程0执行过程中发生硬盘中断" class="headerlink" title="进程0执行过程中发生硬盘中断"></a>进程0执行过程中发生硬盘中断</h3><h3 id="硬盘中断服务程序响应后，进程0继续执行"><a href="#硬盘中断服务程序响应后，进程0继续执行" class="headerlink" title="硬盘中断服务程序响应后，进程0继续执行"></a>硬盘中断服务程序响应后，进程0继续执行</h3><h3 id="再次响应硬盘中断并唤醒进程1"><a href="#再次响应硬盘中断并唤醒进程1" class="headerlink" title="再次响应硬盘中断并唤醒进程1"></a>再次响应硬盘中断并唤醒进程1</h3><h3 id="读盘操作完成后，进程1继续执行"><a href="#读盘操作完成后，进程1继续执行" class="headerlink" title="读盘操作完成后，进程1继续执行"></a>读盘操作完成后，进程1继续执行</h3><h3 id="进程1继续设置硬盘管理结构"><a href="#进程1继续设置硬盘管理结构" class="headerlink" title="进程1继续设置硬盘管理结构"></a>进程1继续设置硬盘管理结构</h3><h3 id="进程1获取软盘超级块，为加载根文件系统做准备"><a href="#进程1获取软盘超级块，为加载根文件系统做准备" class="headerlink" title="进程1获取软盘超级块，为加载根文件系统做准备"></a>进程1获取软盘超级块，为加载根文件系统做准备</h3><h3 id="进程1备份超级块数据"><a href="#进程1备份超级块数据" class="headerlink" title="进程1备份超级块数据"></a>进程1备份超级块数据</h3><h3 id="进程1将根文件系统从软盘拷贝到虚拟盘"><a href="#进程1将根文件系统从软盘拷贝到虚拟盘" class="headerlink" title="进程1将根文件系统从软盘拷贝到虚拟盘"></a>进程1将根文件系统从软盘拷贝到虚拟盘</h3><h3 id="进程1开始加载根文件系统"><a href="#进程1开始加载根文件系统" class="headerlink" title="进程1开始加载根文件系统"></a>进程1开始加载根文件系统</h3><h3 id="进程1准备加载根文件系统超级块"><a href="#进程1准备加载根文件系统超级块" class="headerlink" title="进程1准备加载根文件系统超级块"></a>进程1准备加载根文件系统超级块</h3><h3 id="进程1加载根文件系统超级块"><a href="#进程1加载根文件系统超级块" class="headerlink" title="进程1加载根文件系统超级块"></a>进程1加载根文件系统超级块</h3><h3 id="进程1继续加载根文件系统"><a href="#进程1继续加载根文件系统" class="headerlink" title="进程1继续加载根文件系统"></a>进程1继续加载根文件系统</h3><h3 id="进程1准备读取根目录i节点"><a href="#进程1准备读取根目录i节点" class="headerlink" title="进程1准备读取根目录i节点"></a>进程1准备读取根目录i节点</h3><h3 id="进程1加载根目录i节点"><a href="#进程1加载根目录i节点" class="headerlink" title="进程1加载根目录i节点"></a>进程1加载根目录i节点</h3><h3 id="进程1结束加载根文件系统的过程"><a href="#进程1结束加载根文件系统的过程" class="headerlink" title="进程1结束加载根文件系统的过程"></a>进程1结束加载根文件系统的过程</h3><h2 id="打开终端设备文件及复制文件句柄"><a href="#打开终端设备文件及复制文件句柄" class="headerlink" title="打开终端设备文件及复制文件句柄"></a>打开终端设备文件及复制文件句柄</h2><h3 id="进程1与内核文件表挂接，为打开文件做准备"><a href="#进程1与内核文件表挂接，为打开文件做准备" class="headerlink" title="进程1与内核文件表挂接，为打开文件做准备"></a>进程1与内核文件表挂接，为打开文件做准备</h3><h3 id="确定打开操作的起点"><a href="#确定打开操作的起点" class="headerlink" title="确定打开操作的起点"></a>确定打开操作的起点</h3><h3 id="获得枝梢i节点-dev目录文件的i节点"><a href="#获得枝梢i节点-dev目录文件的i节点" class="headerlink" title="获得枝梢i节点-dev目录文件的i节点"></a>获得枝梢i节点-dev目录文件的i节点</h3><h3 id="确定dev目录文件i节点为枝梢i节点"><a href="#确定dev目录文件i节点为枝梢i节点" class="headerlink" title="确定dev目录文件i节点为枝梢i节点"></a>确定dev目录文件i节点为枝梢i节点</h3><h3 id="继续返回枝梢i节点"><a href="#继续返回枝梢i节点" class="headerlink" title="继续返回枝梢i节点"></a>继续返回枝梢i节点</h3><h3 id="查找tty0文件的i节点"><a href="#查找tty0文件的i节点" class="headerlink" title="查找tty0文件的i节点"></a>查找tty0文件的i节点</h3><h3 id="将tty0设备文件的i节点返回给sys-open系统调用"><a href="#将tty0设备文件的i节点返回给sys-open系统调用" class="headerlink" title="将tty0设备文件的i节点返回给sys_open系统调用"></a>将tty0设备文件的i节点返回给sys_open系统调用</h3><h3 id="分析tty0文件i节点"><a href="#分析tty0文件i节点" class="headerlink" title="分析tty0文件i节点"></a>分析tty0文件i节点</h3><h3 id="设置文件管理结构并返回给用户进程"><a href="#设置文件管理结构并返回给用户进程" class="headerlink" title="设置文件管理结构并返回给用户进程"></a>设置文件管理结构并返回给用户进程</h3><h3 id="进程1复制tty0文件句柄"><a href="#进程1复制tty0文件句柄" class="headerlink" title="进程1复制tty0文件句柄"></a>进程1复制tty0文件句柄</h3><h3 id="进程1继续复制tty0文件句柄"><a href="#进程1继续复制tty0文件句柄" class="headerlink" title="进程1继续复制tty0文件句柄"></a>进程1继续复制tty0文件句柄</h3><h2 id="创建进程2"><a href="#创建进程2" class="headerlink" title="创建进程2"></a>创建进程2</h2><p>进程1准备创建进程2</p>
<p>复制进程2管理结构并继续调整</p>
<p>设置进程2的页目录项并复制进程2的页表</p>
<p>调整进程2管理结构中与文件有关的内容</p>
<p>进程1执行过程中发生时钟中断</p>
<p>进程1从时钟中断返回，准备切换到进程2</p>
<h2 id="进程1等待进程2退出"><a href="#进程1等待进程2退出" class="headerlink" title="进程1等待进程2退出"></a>进程1等待进程2退出</h2><h2 id="shell程序的加载"><a href="#shell程序的加载" class="headerlink" title="shell程序的加载"></a>shell程序的加载</h2><h2 id="系统实现怠速"><a href="#系统实现怠速" class="headerlink" title="系统实现怠速"></a>系统实现怠速</h2><h1 id="安装文件系统"><a href="#安装文件系统" class="headerlink" title="安装文件系统"></a>安装文件系统</h1><h2 id="获取硬盘设备号"><a href="#获取硬盘设备号" class="headerlink" title="获取硬盘设备号"></a>获取硬盘设备号</h2><h2 id="获取虚拟盘上的挂接点"><a href="#获取虚拟盘上的挂接点" class="headerlink" title="获取虚拟盘上的挂接点"></a>获取虚拟盘上的挂接点</h2><h2 id="得到hd1设备文件的超级块"><a href="#得到hd1设备文件的超级块" class="headerlink" title="得到hd1设备文件的超级块"></a>得到hd1设备文件的超级块</h2><h2 id="将hd1设备文件与mnt目录文件的i节点挂接"><a href="#将hd1设备文件与mnt目录文件的i节点挂接" class="headerlink" title="将hd1设备文件与mnt目录文件的i节点挂接"></a>将hd1设备文件与mnt目录文件的i节点挂接</h2><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><h2 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h2><h2 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h2><h2 id="新建文件"><a href="#新建文件" class="headerlink" title="新建文件"></a>新建文件</h2><h2 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h2><h2 id="修改文件"><a href="#修改文件" class="headerlink" title="修改文件"></a>修改文件</h2><h2 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h2><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><h1 id="用户进程与内存管理"><a href="#用户进程与内存管理" class="headerlink" title="用户进程与内存管理"></a>用户进程与内存管理</h1><h2 id="用户进程的创建"><a href="#用户进程的创建" class="headerlink" title="用户进程的创建"></a>用户进程的创建</h2><h2 id="为用户进程str1的加载做准备"><a href="#为用户进程str1的加载做准备" class="headerlink" title="为用户进程str1的加载做准备"></a>为用户进程str1的加载做准备</h2><h2 id="对缺页中断的处理"><a href="#对缺页中断的处理" class="headerlink" title="对缺页中断的处理"></a>对缺页中断的处理</h2><h2 id="str1用户进程的退出"><a href="#str1用户进程的退出" class="headerlink" title="str1用户进程的退出"></a>str1用户进程的退出</h2><h2 id="多个用户进程同时运行"><a href="#多个用户进程同时运行" class="headerlink" title="多个用户进程同时运行"></a>多个用户进程同时运行</h2><h2 id="进程的调度与切换"><a href="#进程的调度与切换" class="headerlink" title="进程的调度与切换"></a>进程的调度与切换</h2><h2 id="内核的分页"><a href="#内核的分页" class="headerlink" title="内核的分页"></a>内核的分页</h2><h2 id="页写保护"><a href="#页写保护" class="headerlink" title="页写保护"></a>页写保护</h2><h1 id="多个进程同时操作一个文件"><a href="#多个进程同时操作一个文件" class="headerlink" title="多个进程同时操作一个文件"></a>多个进程同时操作一个文件</h1><h2 id="三个进程操作同一个文件"><a href="#三个进程操作同一个文件" class="headerlink" title="三个进程操作同一个文件"></a>三个进程操作同一个文件</h2><h2 id="缓冲区与外设的数据同步"><a href="#缓冲区与外设的数据同步" class="headerlink" title="缓冲区与外设的数据同步"></a>缓冲区与外设的数据同步</h2><h1 id="IPC问题"><a href="#IPC问题" class="headerlink" title="IPC问题"></a>IPC问题</h1><h2 id="管道机制"><a href="#管道机制" class="headerlink" title="管道机制"></a>管道机制</h2><h2 id="信号机制"><a href="#信号机制" class="headerlink" title="信号机制"></a>信号机制</h2>
                </div>
            </div>
    
            <nav class="post-pagination">
    
    <a class="newer-posts" href="/2017/02/21/运维体系管理/">
        Previous post<br>运维体系管理
    </a>
    
    <span class="page-number"></span>
    
</nav>

    
            


        </div>
    </div>
    <div class="single-column-footer">
    Proudly published with Hexo<br>
    
    Theme <a href="https://github.com/SumiMakito/hexo-theme-journal/" target="_blank" rel="noreferrer noopener">Journal.</a> by <a href="https://mak1t0.cc/" target="_blank" rel="noreferrer noopener">Makito</a><br>
    
    &copy; 2018 <a href="http://yoursite.com">javfa&#39;s blog</a>
</div>
</div>

</div>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.14.4/dist/umd/popper.min.js" integrity="sha256-EGs9T1xMHdvM1geM8jPpoo8EZ1V1VRsmcJz8OByENLA=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.1.3/dist/js/bootstrap.min.js" integrity="sha256-VsEqElsCHSGmnmHXGQzvoWjWwoznFSZc6hs7ARLRacQ=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.min.js" integrity="sha256-FtWfRI+thWlNz2sB3SJbwKx5PgMyKIVgwHCTwa3biXc=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/smooth-scroll@14.2.1/dist/smooth-scroll.polyfills.min.js" integrity="sha256-CI4Gq5E0io1Pv0xM3qPM+NUIOhbIBvC3GiN1Y4KhXpw=" crossorigin="anonymous"></script>
<script src="/js/journal.js?1632869"></script>



</body>
</html>
