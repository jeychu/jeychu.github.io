

<!DOCTYPE html>
<html lang xmlns:v-bind="http://www.w3.org/1999/xhtml">

<head><meta name="generator" content="Hexo 3.8.0">
    <title>Web性能优化指南 - javfa&#39;s blog</title>
<meta charset="utf-8">
<meta name="X-UA-Compatible" content="IE=edge">
<meta name="author" content="Javfa">
<meta name="description" content="网络技术概览延迟与带宽速度是关键
WPO（Web Performance Optimization）产业从无到有，...">
<meta name="keywords" content>

    <meta charset="utf-8">
    <meta name="X-UA-Compatible" content="IE=edge">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <meta content="telephone=no" name="format-detection">
    <meta name="renderer" content="webkit">
    <meta name="theme-color" content="#ffffff">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.1.3/dist/css/bootstrap.min.css" integrity="sha256-eSi1q2PG6J7g7ib17yAaWMcrr5GrtohYChqibrV7PBE=" crossorigin="anonymous">
<link rel="stylesheet" href="/css/journal.css?80712861">
<script src="/js/loadCSS.js"></script>
<script>
    loadCSS("https://fonts.googleapis.com/css?family=Lora|Montserrat|Fira+Mono|Material+Icons");
    (function (d) {
        var config = {
                kitId: 'dwg1tuc',
                scriptTimeout: 3000,
                async: true
            },
            h = d.documentElement, t = setTimeout(function () {
                h.className = h.className.replace(/\bwf-loading\b/g, "") + " wf-inactive";
            }, config.scriptTimeout), tk = d.createElement("script"), f = false,
            s = d.getElementsByTagName("script")[0], a;
        h.className += " wf-loading";
        tk.src = 'https://use.typekit.net/' + config.kitId + '.js';
        tk.async = true;
        tk.onload = tk.onreadystatechange = function () {
            a = this.readyState;
            if (f || a && a != "complete" && a != "loaded") return;
            f = true;
            clearTimeout(t);
            try {
                Typekit.load(config)
            } catch (e) {
            }
        };
        s.parentNode.insertBefore(tk, s)
    })(document);
</script>
<noscript>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora|Montserrat|Anonymous+Pro:400|Material+Icons">
</noscript>
</head>
<body>
<div id="top"></div>
<div id="app">
<div class="single-column-drawer-container" ref="drawer" v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }">
    <div class="drawer-content">
        <div class="drawer-menu">
            <a class="a-block drawer-menu-item false" href="http://yoursite.com">
                Home
            </a>
            <a class="a-block drawer-menu-item false" href="/archives">
                Archive
            </a>

            
            

            
        </div>
    </div>
</div>
<transition name="fade">
    <div v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if="isDrawerOpen" v-on:click="toggleDrawer"></div>
</transition>
<nav ref="navBar" class="navbar sticky-top navbar-light single-column-nav-container">
    <div ref="navBackground" class="nav-background"></div>
    <div class="container container-narrow nav-content">
        <button id="nav_dropdown_btn" class="nav-dropdown-toggle" type="button" v-on:click="toggleDrawer">
            <i class="material-icons">
                menu
            </i>
        </button>
        <a ref="navTitle" class="navbar-brand" href="/">
            javfa&#39;s blog
        </a>
    </div>
</nav>
<div class="single-column-header-container" ref="pageHead" v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }">
    <a href="/">
        <div class="single-column-header-title">javfa&#39;s blog</div>
        <div class="single-column-header-subtitle"></div>
    </a>
</div>
<div ref="sideContainer" class="side-container">
    <a class="a-block nav-head false" href="/">
        <div class="nav-title">
            {博客@家發}
        </div>
        <div class="nav-subtitle">
            隻言片語<br>於此匯聚
        </div>
    </a>

    <div class="nav-link-list">
        <a class="a-block no-tint nav-link-item false" href="/archives">
            Archive
        </a>

        
        

        
    </div>

    
    <div class="nav-footer">
        Proudly published with Hexo<br>
        
        Theme <a href="https://github.com/SumiMakito/hexo-theme-journal/" target="_blank" rel="noreferrer noopener">Journal.</a> by <a href="https://mak1t0.cc/" target="_blank" rel="noreferrer noopener">Makito</a><br>
        
        &copy; 2019 <a href="http://yoursite.com">javfa&#39;s blog</a>
    </div>
</div>
<div ref="extraContainer" class="extra-container">
    <div class="pagination">
        <a id="globalBackToTop" class="pagination-action animated-visibility" href="#top" :class="{ invisible: scrollY == 0 }">
            <i class="material-icons pagination-action-icon">
                keyboard_arrow_up
            </i>
        </a>

        
    </div>
</div>

<div ref="streamContainer" class="stream-container">
    <div class="post-list-container post-list-container-shadow">
        <div class="post">
            <div class="post-head-wrapper-text-only" style="background-image: url('')">
                <div class="post-title">
                    Web性能优化指南
                    <div class="post-meta">
                        <time datetime="2019-02-21T02:54:57.000Z" itemprop="datePublished">
                            2019-02-21 10:54
                        </time>&nbsp;
                        
    
                        
                        
                        <i class="material-icons" style>label</i>
                        
                        <a href="/tags/Web/">Web</a>
                        
                        
                    </div>
                </div>
            </div>
    
            <div class="post-body-wrapper">
                <div class="post-body">
                    <h1><span id="网络技术概览">网络技术概览</span></h1><h2><span id="延迟与带宽">延迟与带宽</span></h2><p>速度是关键</p>
<p>WPO（Web Performance Optimization）产业从无到有，快速增长，充分说明用户越来越重视速度方面的用户体验。</p>
<p>业绩证实：</p>
<ul>
<li>网站越快，用户的黏性越高</li>
<li>网站越快，用户忠诚度更高</li>
<li>网站越快，用户转化率越高</li>
</ul>
<p>延迟和带宽：</p>
<ul>
<li><p>延迟：分组从信息源发送到目的地所需的时间</p>
</li>
<li><p>带宽：逻辑或物理通信路径最大的吞吐量</p>
</li>
</ul>
<p>延迟的构成：</p>
<ul>
<li>传播延迟<br>消息从发送端到接收端需要的时间，是信号传播距离和速度的函数</li>
<li>传输延迟<br>把消息中的所有比特转移到链路中需要的时间，是消息长度和链路速率的函数</li>
<li>处理延迟<br>处理分组首部、检查位错误及确定分组目标所需的时间</li>
<li>排队延迟<br>到来的分组排队等待处理的时间</li>
</ul>
<blockquote>
<p>在软件交互中，哪怕100-200ms左右的延迟，大多数人都会感觉到‘拖拉’；如果超过了300ms的门槛，就会说“反应迟钝”。</p>
</blockquote>
<h2><span id="tcp">TCP</span></h2><p>TCP/IP，是由Vint Cerf和Bob Khan在他们1974年的论文<a href="https://www.cs.princeton.edu/courses/archive/fall06/cos561/papers/cerf74.pdf" target="_blank" rel="noopener">“A Protocol for Packet Network Intercommunication”</a>中首次提出。</p>
<blockquote>
<p>TCP/IP V4：</p>
<p><a href="https://www.rfc-editor.org/rfc/rfc791.txt" target="_blank" rel="noopener">RFC 791- Internet Protocol</a>;</p>
<p><a href="https://www.rfc-editor.org/rfc/rfc793.txt" target="_blank" rel="noopener">RFC 793 - Transmission Control Protocol</a>.</p>
</blockquote>
<p>TCP负责在不可靠的传输信道上提供可靠的传输抽象层，向应用层隐藏了大多数网络通信的复杂细节，比如丢包重发、按序发送、拥塞控制及避免、数据完整等等。</p>
<p>TCP专门为精确传送做了优化，但并未过多顾及时间。</p>
<p>现实中，几乎所有的HTTP流量都是通过TCP传送的。</p>
<p>因此，理解TCP的核心机制是优化web体验所必需的基础。</p>
<h3><span id="三次握手">三次握手</span></h3><p><img src="/2019/02/21/Web性能基础/1552725463782.png" alt="1552725463782"></p>
<p>所有的TCP连接一开始都要经过三次握手。</p>
<p>在两端交换数据之前，就起始序列号达成一致。序列号由两端随机生成。</p>
<p>三次握手后，两端就可以通信了。客户端可以在发送ACK之后，立即发送数据，而服务器必须等接收到ACK之后才能发送数据。</p>
<p>三次握手，需要一个往返的时间。如上图，三次握手花了56ms。</p>
<p>三次握手带来的延迟使得每创建一个新TCP连接都要付出很大代价。</p>
<p>重用连接，可以极大提高TCP应用的性能。</p>
<p><a href="https://www.rfc-editor.org/rfc/rfc7413.txt" target="_blank" rel="noopener">TCP Fast Open</a>：致力于减少新建TCP连接带来的性能损失。通过TFO cookie机制，将DATA放到SYN包和SYN-ACK包之中，从而在新建TCP连接时节省一个RTT<sup>Round Trip Time</sup>的时间。</p>
<p>经过流量分析和网络模拟，谷歌研究人员发现TFO平均可以降低HTTP事务网络延迟15%、整个页面加载时间10%以上。</p>
<h3><span id="拥塞预防及控制">拥塞预防及控制</span></h3><h4><span id="流量控制">流量控制</span></h4><p>是一种预防发送端向接收端过多发送数据的机制。</p>
<p>若不做预防，接收端可能因为忙碌、负载过重或缓冲区而无法处理。</p>
<p>该机制为：TCP连接的每一方都要通告自己的接收窗口<sup>rwnd，即接收数据缓冲区</sup>的大小。</p>
<p><img src="/2019/02/21/Web性能基础/1552726988500.png" alt="1552726988500"></p>
<p>第一次建立连接时，两端都会使用自身系统的默认设置来发送rwnd。</p>
<p>如果其中一端跟不上数据传输，那它可以向发送端通告一个较小的窗口。假如窗口为零，则表示应用层必须先清空缓冲区，才能再接收剩余数据。</p>
<p>这个过程贯穿于每个TCP连接的整个生命周期：每个ACK分组都会携带相应的最新rwnd值，以便两端动态调整数据流速，适应两端的容量和处理能力。</p>
<p>窗口缩放：</p>
<p>最初的TCP规范设定了窗口的最大值为2<sup>16</sup>即65535字节。RFC 1323提供了TCP窗口缩放的选项，可以把窗口大小由65535字节提高到1G字节。在Linux中可以通过如下命令检查和启用窗口缩放选项：</p>
<p><code>sysctl net.ipv4.tcp_window_scaling</code></p>
<p><code>sysctl -w net.ipv4.tcp_window_scaling=1</code></p>
<h4><span id="慢启动">慢启动</span></h4><p>发送端和接收端在连接建立之初，谁也不知道可用带宽是多少，因此需要一个机制，估算出双方的可用带宽，并根据网络中不断变化的条件动态改变传输速度。</p>
<p><img src="/2019/02/21/Web性能基础/1552727986717.png" alt="1552727986717"></p>
<p>如上所示，拥塞窗口的初始值为4个TCP报文段。</p>
<blockquote>
<p>TCP报文段的大小即MSS<sup>Max Segment Size</sup>的计算：</p>
<p>MSS=MTU-sizeof(TCP heder)-sizeof(IP header)</p>
<p>对于以太网：MTU=1500bytes 故：MSS=1500-20-20=1460bytes</p>
<p>对于Internet：MTU=576bytes 故：MSS=576-20-20=536bytes</p>
</blockquote>
<blockquote>
<p>MSS的协商确定：</p>
<p>MSS值只会出现在SYN报文中，即SYN=1时，才会有MSS字段值。当客户端想要以TCP方式从服务器端下载数据时，</p>
<p>（1）首先客户端会发送一个SYN请求报文，这个SYN报文的“选项”字段中会有MSS值（MSS = MUT - IP首部长度 - TCP首部长度）。该MSS值是为了告知对方最大的发送数据大小。</p>
<p>（2）当服务器端收到SYN报文后，会向请求端返回SYN+ACK（同步确认报文）报文，其中的“选项”字段也会有MSS值。</p>
<p>（3）通信双方选择SYN和SYN+ACK报文中最小的MSS最为此次TCP连接的MSS，从而达到通信双方协商MSS的效果。</p>
<p>因此，在第二次握手后就可以确定TCP中最大传输报文（MSS）大小。</p>
</blockquote>
<p>此后，每一次数据往返，cwnd就增大一倍（即每接收到一个ACK，cwnd就加1）这样，cwnd就迅速地向有效带宽靠拢。</p>
<p>包括HTTP在内的很多应用层协议都运行于TCP之上，无论带宽多大，每个TCP连接都必须经过慢启动阶段。我们不可能一上来就完全利用连接的最大带宽。</p>
<p>从一个较小的拥塞窗口开始，每次往返都令其翻倍。</p>
<p><img src="/2019/02/21/Web性能基础/1552728644844.png" alt="1552728644844"></p>
<p>假设：</p>
<ul>
<li>客户端和服务器的接收窗口为65535字节（64KB）</li>
<li>初始拥塞窗口：4段</li>
<li>往返时间为56ms。</li>
</ul>
<p>要达到64KB的吞吐量，需要把拥塞窗口大小增加到45个段，而这需要224ms：</p>
<p><img src="/2019/02/21/Web性能基础/1552731475351.png" alt="1552731475351"></p>
<p><img src="/2019/02/21/Web性能基础/1552731607667.png" alt="1552731607667"></p>
<p>三次握手和慢启动对简单HTTP传输的影响示例：</p>
<p>假设：</p>
<ul>
<li>往返时间：56ms</li>
<li>客户端到服务器的带宽：5Mbit/s</li>
<li>客户端和服务器接收窗口：65535字节</li>
<li>初始拥塞窗口：4段（4×1460字节=5.7KB）</li>
<li>服务器生成响应的处理时间：40ms</li>
<li>没有分组丢失、每个分组都要确认、GET请求只占1段。</li>
</ul>
<p><img src="/2019/02/21/Web性能基础/1552732025454.png" alt="1552732025454"></p>
<p>时间分析：</p>
<ul>
<li>0ms：客户端发送SYN开始TCP握手</li>
<li>28ms：服务器响应SYN-ACK并指定rwnd大小</li>
<li>56ms：客户端确认ACK，并指定rwnd大小，并立即发送GET请求</li>
<li>84ms：服务器收到GET</li>
<li>124ms：服务器生成20KB的响应，并发送4个TCP段，然后等待ACK</li>
<li>152ms：客户端收到4个段，并发送4个ACK</li>
<li>180ms：服务器针对每个ACK递增cwnd，然后发送8个TCP段</li>
<li>208ms：客户端收到8个段，并发送8个ACK</li>
<li>236ms：服务器针对每个ACK递增cwnd，然后发送剩余的TCP段</li>
<li>264ms：客户端收到剩余的TCP段，并发送ACK</li>
</ul>
<p>通过新TCP连接，在往返时间为56ms的两端之间传输一个20KB的文件需要264ms。</p>
<p>现在重用同一个TCP连接，再发一次相同的请求</p>
<p><img src="/2019/02/21/Web性能基础/1552732840016.png" alt="1552732840016"></p>
<p>时间分析：</p>
<ul>
<li>0ms：客户端发送GET</li>
<li>28ms：服务器收到GET</li>
<li>68ms：服务器生成20KB的响应，此时cwnd已经大于发送文件所需的15段了，因此一次性发送所有数据段</li>
<li>96ms：客户端收到所有15个段，分别发送ACK</li>
</ul>
<p>同一个连接、同样的请求，但没有三次握手和慢启动，只花了96ms，性能提升幅度达275%。</p>
<p>以上两种情况下，服务器和客户端之间的5Mbit/s的带宽并没有影响，因为拥塞窗口还远没有达到带宽限定水平。</p>
<p>增大TCP的初始拥塞窗口，如把服务器的初始cwnd增大到RFC6928新规定的10段（IW10），是提升用户体验以及所有TCP应用性能的最简单方式。</p>
<p>Linux 2.6.29以上版本内核的新默认值就是IW10。</p>
<h4><span id="拥塞预防">拥塞预防</span></h4><p>慢启动以保守的窗口初始化连接，随后每次往返都会成倍提高传输的数据量，直到超过接收端的流量控制窗口，即系统配置的拥塞阈值（ssthresh）窗口，或者有分组丢失为止，此时拥塞预防算法介入。</p>
<p>拥塞预防算法把丢包作为网络拥塞的标志，即路径中某个连接或路由器拥堵了，以至于必须采取删包措施，调整窗口大小，以避免造成更多的包丢失，从而保证网络畅通。</p>
<p>重置拥塞窗口后，拥塞预防机制按照自己的算法来增大窗口以尽量避免继续丢包。某个时刻，可能又会有丢包，于是这个过程再从头开始。此时的TCP连接吞吐量跟踪曲线成锯齿状，这是拥塞控制和预防算法在处理丢包问题的体现。</p>
<p>丢包恢复算法：</p>
<ul>
<li>AIMD<sup>Multiplicative Decrease and Additive Increase，倍减加增</sup>：发生丢包时，先将拥塞窗口减半，然后每次往返再缓慢地给仓库增加一个固定的值。太过保守。</li>
<li>PRR<sup>Proportional Rate Reduction，比例减速</sup>：<a href="https://www.rfc-editor.org/pdfrfc/rfc6937.txt.pdf" target="_blank" rel="noopener">RFC6937</a>规定的一个新算法，其目标就是改进丢包后的恢复速度。是Linux 3.2+内核默认的拥塞预防算法。</li>
</ul>
<h4><span id="带宽延迟积">带宽延迟积</span></h4><p>BDP<sup>Bandwidth-delay product</sup>：任意时刻处于在途未确认状态的最大数据量。</p>
<p>窗口和带宽：</p>
<p>假设cwnd和rwnd的最小值为16KB，往返时间为100ms：</p>
<p><img src="/2019/02/21/Web性能基础/1552741208611.png" alt="1552741208611"></p>
<p>不管发送端和接收端的实际带宽多大，这个TCP连接的数据传输速率不会超过1.31Mbit/s。</p>
<p>假设往返时间不变，发送端的可用带宽为10Mbit/s，接收端为100Mbit/s。两端之间没有网络拥塞，我们的目标是充分利用客户端的10Mbit/s带宽：</p>
<p><img src="/2019/02/21/Web性能基础/1552741381486.png" alt="1552741381486"></p>
<p>窗口至少需要122.1KB才能充分利用10Mbit/s带宽。</p>
<h4><span id="队首阻塞">队首阻塞</span></h4><h3><span id="针对tcp的优化建议">针对TCP的优化建议</span></h3><h4><span id="性能检查清单">性能检查清单</span></h4><ul>
<li>把服务器内核升级到最新版本</li>
<li>确保cwnd大小为10</li>
<li>禁用空闲后的慢启动</li>
<li>确保启动窗口缩放</li>
<li>减少传输冗余数据</li>
<li>压缩要传输的数据</li>
<li>把服务器放到离用户近的地方以减少往返时间</li>
<li>尽最大可能重用已经建立的TCP连接</li>
</ul>
<h2><span id="udp">UDP</span></h2><p>User Datagram Protocol 用户数据报协议</p>
<p>也被称为：Null Protocol 无协议</p>
<blockquote>
<p>数据报</p>
<p>一个完整、独立的数据实体，携带着从源节点到目的节点的足够信息，对这些节点间之前的数据交换和传输网络没有任何依赖。</p>
</blockquote>
<h3><span id="无协议服务">无协议服务</span></h3><p>IPV4首部（20字节）：</p>
<p><img src="/2019/02/21/Web性能基础/1552784951978.png" alt="1552784951978"></p>
<p>UDP首部（8字节）：</p>
<p><img src="/2019/02/21/Web性能基础/1552784980075.png" alt="1552784980075"></p>
<p>其中源端口和校验和字段都是可选的，应用程序可以忽略UDP校验和，因此UDP仅仅是在IP层上加了应用程序的源端口和目标端口，也可以只是加上目标端口。</p>
<p>这就是为什么UDP被称为无协议了：</p>
<ul>
<li>不保证消息交付：不确认、不重传、无超时</li>
<li>不保证交付顺序：不设置包序号、不重排、不会发生队首阻塞</li>
<li>不跟踪连接状态：不必建立连接或重启状态机</li>
<li>不需要拥塞控制：不内置客户端或网络反馈机制</li>
</ul>
<p>UDP是一个简单、无状态的协议，适合作为其他上层应用协议的辅助。</p>
<p>这个协议的所有决定都需要由上层应用程序作出。</p>
<h3><span id="udp和网络地址转换器">UDP和网络地址转换器</span></h3><p>IPv4地址只有32位，因而最多提供42.9亿个IP地址。</p>
<p>1994年，作为解决IPv4地址即将耗尽的一个临时性方案，NAT规范<sup><a href="https://www.rfc-editor.org/pdfrfc/rfc1631.txt.pdf" target="_blank" rel="noopener">RFC 1631</a></sup>出台了。</p>
<p><img src="/2019/02/21/Web性能基础/1552788332037.png" alt="1552788332037"></p>
<p>此IP重用方案就是：在网络边缘加入NAT设备，每个NAT设备负责维护一个表，表中包含本地IP和端口到外网（全球唯一）IP和端口的映射。</p>
<p>NAT设备不仅解决了地址耗尽的问题，而且迅速成为代理和路由器、安全装置、防火墙等。它也不再只是个临时方案，已经成了因特网基础设施的一个组成部分。</p>
<h4><span id="连接状态超时">连接状态超时</span></h4><h4><span id="nat穿透">NAT穿透</span></h4><p>不可预测的连接状态处理是NAT带来的一个严重问题</p>
<p>STUN、TURN与ICE</p>
<h2><span id="tls">TLS</span></h2><p>SSL<sup>Secure Sockets Layer</sup>协议最初是网景公司为了保障网上交易安全而开发的，该协议通过加密来保护客户个人资料，通过认证和完整性检查来确保交易安全。</p>
<p>在会话层实现，不会影响应用层协议，但能够保证这些协议的网络通信安全。</p>
<p><img src="/2019/02/21/Web性能基础/1552794544909.png" alt="1552794544909"></p>
<p><a href="https://www.rfc-editor.org/pdfrfc/rfc2246.txt.pdf" target="_blank" rel="noopener">RFC 2246</a>，TLS1.0，是SSL 3.0的升级版。</p>
<p>TLS协议的目标是为在它之上运行的应用提供三个基本服务：</p>
<ul>
<li>加密</li>
<li>身份验证</li>
<li>数据完整性</li>
</ul>
<h3><span id="tls握手">TLS握手：</span></h3><h4><span id="应用层协议协商">应用层协议协商</span></h4><h4><span id="服务器名称指示">服务器名称指示</span></h4><h3><span id="tls会话恢复">TLS会话恢复</span></h3><h4><span id="会话标识符">会话标识符</span></h4><h4><span id="会话记录单">会话记录单</span></h4><h3><span id="信任链和证书颁发机构">信任链和证书颁发机构</span></h3><h4><span id="证书撤销">证书撤销</span></h4><h4><span id="tls记录协议">TLS记录协议</span></h4><p><img src="/2019/02/21/Web性能基础/1552800184385.png" alt="1552800184385"></p>
<h3><span id="针对tls的优化建议">针对TLS的优化建议</span></h3><h1><span id="无线网络性能">无线网络性能</span></h1><h2><span id="wifi">WIFI</span></h2><h2><span id="移动网络">移动网络</span></h2><h1><span id="http">HTTP</span></h1><h2><span id="http-1x">HTTP 1.x</span></h2><h2><span id="http-20">HTTP 2.0</span></h2><h2><span id="优化应用的交付">优化应用的交付</span></h2><h1><span id="浏览器api与协议">浏览器API与协议</span></h1><h2><span id="xmlhttprequest">XMLHttpRequest</span></h2><h2><span id="服务器发送事件">服务器发送事件</span></h2><h2><span id="websocket">websocket</span></h2><p>WebSocket可以实现客户端与服务器间同时双向、基于消息的文本或二进制数据传输。<br>WebSocket使得浏览器具备了实时、双向通信的能力，是由HTML5开始提供的一种浏览器与服务器进行全双工通讯的网络技术，属于应用层协议。基于TCP传输协议，并复用HTTP的握手通道。</p>
<ul>
<li>优点：<ul>
<li>支持双向通信，实时性更强</li>
<li>更好的支持二进制</li>
<li>较少的控制开销。连接创建后，ws客户端、服务的进行数据交换时，协议控制的数据包头部较小。</li>
<li>支持扩展。可以扩展协议，实现自定义的自协议（如自定义压缩算法等）</li>
</ul>
</li>
</ul>
<h3><span id="1-入门例子">1. 入门例子：</span></h3><ul>
<li>1.1 <strong>服务端</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="built_in">require</span>(<span class="string">'express'</span>)();</span><br><span class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">'http'</span>).Server(app);</span><br><span class="line"><span class="keyword">var</span> WebSocket = <span class="built_in">require</span>(<span class="string">'ws'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wss = <span class="keyword">new</span> WebSocket.Server(&#123; <span class="attr">port</span>: <span class="number">8080</span> &#125;);</span><br><span class="line"></span><br><span class="line">wss.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> <span class="title">connection</span>(<span class="params">ws</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'server: receive connection.'</span>);</span><br><span class="line">    </span><br><span class="line">    ws.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> <span class="title">incoming</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'server: received %s'</span>, message);</span><br><span class="line">        ws.send(<span class="string">'server: reply'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    ws.on(<span class="string">'pong'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'server: received pong from client'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    ws.send(<span class="string">'world'</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// setInterval(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//     ws.ping('', false, true);</span></span><br><span class="line">    <span class="comment">// &#125;, 2000);</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.sendfile(__dirname + <span class="string">'/index.html'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>1.2 <strong>客户端</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:8080'</span>);</span><br><span class="line">  ws.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'ws onopen'</span>);</span><br><span class="line">    ws.send(<span class="string">'from client: hello'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  ws.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'ws onmessage'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'from server: '</span> + e.data);</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>1.3 <strong>运行结果</strong></li>
</ul>
<p><em>服务端输出</em>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server: receive connection.</span><br><span class="line">server: received hello</span><br></pre></td></tr></table></figure></p>
<p><em>客户端输出</em>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">client: ws connection is open</span><br><span class="line">client: received world</span><br></pre></td></tr></table></figure></p>
<h3><span id="2-如何建立连接">2. 如何建立连接</span></h3><p>WebSocket复用了HTTP的握手通道。具体是指，客户端通过HTTP请求与WebSocket服务器协商升级协议。</p>
<ul>
<li><p>2.1. 客户端：申请协议升级</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: localhost:8080</span><br><span class="line">Origin: http://127.0.0.1:3000</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Sec-WebSocket-Key: w4v7O6xFTi36lq3RNcgctw==</span><br></pre></td></tr></table></figure>
</li>
<li><p>2.2. 服务端：响应协议升级</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Connection:Upgrade</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Sec-WebSocket-Accept: Oy4NRAQ13jhfONC7bP8dTKb4PTU=</span><br></pre></td></tr></table></figure>
</li>
<li><p>2.3. Sec-WebSocket-Accept的计算</p>
</li>
</ul>
<p>伪代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;toBase64( sha1( Sec-WebSocket-Key +258EAFA5-E914-47DA-95CA-C5AB0DC85B11 )  )</span><br></pre></td></tr></table></figure></p>
<h3><span id="3-数据帧格式">3. 数据帧格式</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-------+-+-------------+-------------------------------+</span><br><span class="line">|F|R|R|R| opcode|M| Payload len |    Extended payload length    |</span><br><span class="line">|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |</span><br><span class="line">|N|V|V|V|       |S|             |   (if payload len==126/127)   |</span><br><span class="line">| |1|2|3|       |K|             |                               |</span><br><span class="line">+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</span><br><span class="line">|     Extended payload length continued, if payload len == 127  |</span><br><span class="line">+ - - - - - - - - - - - - - - - +-------------------------------+</span><br><span class="line">|                               |Masking-key, if MASK set to 1  |</span><br><span class="line">+-------------------------------+-------------------------------+</span><br><span class="line">| Masking-key (continued)       |          Payload Data         |</span><br><span class="line">+-------------------------------- - - - - - - - - - - - - - - - +</span><br><span class="line">:                     Payload Data continued ...                :</span><br><span class="line">+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</span><br><span class="line">|                     Payload Data continued ...                |</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure>
<h3><span id="4-数据传递">4. 数据传递</span></h3><p>使用场景及性能</p>
<h2><span id="webrtc">WebRTC</span></h2>
                </div>
            </div>
    
            <nav class="post-pagination">
    
    <a class="newer-posts" href="/2019/02/21/Nginx的配置/">
        Previous post<br>Nginx的配置
    </a>
    
    <span class="page-number"></span>
    
    <a class="older-posts" href="/2019/02/20/Linux性能优化之CPU篇/">
        Next post<br>Linux性能优化之CPU篇
    </a>
    
</nav>

    
            


        </div>
    </div>
    <div class="single-column-footer">
    Proudly published with Hexo<br>
    
    Theme <a href="https://github.com/SumiMakito/hexo-theme-journal/" target="_blank" rel="noreferrer noopener">Journal.</a> by <a href="https://mak1t0.cc/" target="_blank" rel="noreferrer noopener">Makito</a><br>
    
    &copy; 2018 <a href="http://yoursite.com">javfa&#39;s blog</a>
</div>
</div>

</div>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.14.4/dist/umd/popper.min.js" integrity="sha256-EGs9T1xMHdvM1geM8jPpoo8EZ1V1VRsmcJz8OByENLA=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.1.3/dist/js/bootstrap.min.js" integrity="sha256-VsEqElsCHSGmnmHXGQzvoWjWwoznFSZc6hs7ARLRacQ=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.min.js" integrity="sha256-FtWfRI+thWlNz2sB3SJbwKx5PgMyKIVgwHCTwa3biXc=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/smooth-scroll@14.2.1/dist/smooth-scroll.polyfills.min.js" integrity="sha256-CI4Gq5E0io1Pv0xM3qPM+NUIOhbIBvC3GiN1Y4KhXpw=" crossorigin="anonymous"></script>
<script src="/js/journal.js?2406308"></script>



</body>
</html>
