<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>javfa&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-08T05:46:39.133Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Javfa</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux性能优化之性能优化的一般方法</title>
    <link href="http://yoursite.com/2019/04/08/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E4%B8%80%E8%88%AC%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2019/04/08/Linux性能优化之性能优化的一般方法/</id>
    <published>2019-04-08T02:19:16.000Z</published>
    <updated>2019-04-08T05:46:39.133Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="系统资源瓶颈">系统资源瓶颈</span></h1><p>系统资源的瓶颈，可以通过USE法，即使用率、饱和度以及错误数这三类指标来衡量。</p><p>系统的资源，可以分为：</p><ul><li>硬件资源：CPU、内存、磁盘和文件系统以及网络等</li><li>软件资源：文件描述符数、连接跟踪数、套接字缓冲区大小等</li></ul><p>CPU性能分析</p><p><img src="/2019/04/08/Linux性能优化之性能优化的一般方法/1554702173337.png" alt="1554702173337"></p><p>内存性能分析</p><p><img src="/2019/04/08/Linux性能优化之性能优化的一般方法/1554702242465.png" alt="1554702242465"></p><p>磁盘和文件系统IO性能分析</p><p><img src="/2019/04/08/Linux性能优化之性能优化的一般方法/1554702267979.png" alt="1554702267979"></p><p>网络性能分析</p><p><img src="/2019/04/08/Linux性能优化之性能优化的一般方法/1554702288719.png" alt="1554702288719"></p><p>应用程序瓶颈</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;系统资源瓶颈&quot;&gt;系统资源瓶颈&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;系统资源的瓶颈，可以通过USE法，即使用率、饱和度以及错误数这三类指标来衡量。&lt;/p&gt;
&lt;p&gt;系统的资源，可以分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;硬件资源：CPU、内存、磁盘和文件系统以及网络等&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux性能优化之性能工具速查</title>
    <link href="http://yoursite.com/2019/04/08/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E6%80%A7%E8%83%BD%E5%B7%A5%E5%85%B7%E9%80%9F%E6%9F%A5/"/>
    <id>http://yoursite.com/2019/04/08/Linux性能优化之性能工具速查/</id>
    <published>2019-04-08T01:54:26.000Z</published>
    <updated>2019-04-08T02:20:16.485Z</updated>
    
    <content type="html"><![CDATA[<p>在进行性能分析和优化时，借助合适的工具，可以让整个过程事半功倍。</p><p>以下是Brendan Gregg整理的性能工具图谱：</p><p><img src="/2019/04/08/Linux性能优化之性能工具速查/1554688884569.png" alt="1554688884569"></p><p>可使用man、info查看相应工具的使用方法。</p><p>根据性能指标的不同，可将性能工具划分为不同类型：</p><h2><span id="cpu性能工具">CPU性能工具</span></h2><p><img src="/2019/04/08/Linux性能优化之性能工具速查/1554688975359.png" alt="1554688975359"></p><p><img src="/2019/04/08/Linux性能优化之性能工具速查/1554689047030.png" alt="1554689047030"></p><h2><span id="内存性能工具">内存性能工具</span></h2><p><img src="/2019/04/08/Linux性能优化之性能工具速查/1554689080568.png" alt="1554689080568"></p><p><img src="/2019/04/08/Linux性能优化之性能工具速查/1554689104188.png" alt="1554689104188"></p><h2><span id="磁盘io性能工具">磁盘IO性能工具</span></h2><p><img src="/2019/04/08/Linux性能优化之性能工具速查/1554689137466.png" alt="1554689137466"></p><p><img src="/2019/04/08/Linux性能优化之性能工具速查/1554689157154.png" alt="1554689157154"></p><h2><span id="网络性能工具">网络性能工具</span></h2><p><img src="/2019/04/08/Linux性能优化之性能工具速查/1554689183346.png" alt="1554689183346"></p><p><img src="/2019/04/08/Linux性能优化之性能工具速查/1554689203413.png" alt="1554689203413"></p><h2><span id="基准测试工具">基准测试工具</span></h2><p><img src="/2019/04/08/Linux性能优化之性能工具速查/1554689235658.png" alt="1554689235658"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在进行性能分析和优化时，借助合适的工具，可以让整个过程事半功倍。&lt;/p&gt;
&lt;p&gt;以下是Brendan Gregg整理的性能工具图谱：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/04/08/Linux性能优化之性能工具速查/1554688884569.png&quot; alt=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>会计</title>
    <link href="http://yoursite.com/2019/04/04/%E4%BC%9A%E8%AE%A1/"/>
    <id>http://yoursite.com/2019/04/04/会计/</id>
    <published>2019-04-04T15:01:31.000Z</published>
    <updated>2019-04-08T07:02:09.930Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>题记</strong></p><p>逢考必胜的在下，在过去的几年中，好似忘记精进考业这回事儿了，现在醒悟过来，发现为时不晚，赶紧立个小目标，要在4年内把CPA拿下。</p></blockquote><p>计划如下：</p><table><thead><tr><th>时间</th><th>科目</th></tr></thead><tbody><tr><td>2019年</td><td>会计+审计+税法</td></tr><tr><td>2020年</td><td>财管+经济法+战略</td></tr><tr><td>2021年</td><td>综合</td></tr></tbody></table><p> 本篇是学习会计的相关笔记的糅合。</p><!-- toc --><ul><li><a href="#总论">总论</a><ul><li><a href="#会计概述">会计概述</a></li><li><a href="#财务报告目标-会计基本假设和会计基础">财务报告目标、会计基本假设和会计基础</a></li><li><a href="#会计信息质量要求">会计信息质量要求</a></li><li><a href="#会计要素及其确认与计量">会计要素及其确认与计量</a></li><li><a href="#财务报告">财务报告</a></li></ul></li><li><a href="#会计政策-会计估计及其变更和差错更正">会计政策、会计估计及其变更和差错更正</a><ul><li><a href="#会计政策及其变更的概述">会计政策及其变更的概述</a></li><li><a href="#会计估计及其变更的概述">会计估计及其变更的概述</a></li><li><a href="#会计政策与会计估计及其变更的划分">会计政策与会计估计及其变更的划分</a></li><li><a href="#会计政策与会计估计变更的会计处理">会计政策与会计估计变更的会计处理</a></li><li><a href="#前期差错及其更正">前期差错及其更正</a></li></ul></li><li><a href="#存货">存货</a><ul><li><a href="#存货的确认和初始计量">存货的确认和初始计量</a></li><li><a href="#发出存货的计量">发出存货的计量</a></li><li><a href="#期末存货的计量">期末存货的计量</a></li><li><a href="#存货的清查盘点">存货的清查盘点</a></li></ul></li><li><a href="#固定资产">固定资产</a><ul><li><a href="#固定资产的确认和初始计量">固定资产的确认和初始计量</a></li><li><a href="#固定资产的后续计量">固定资产的后续计量</a></li><li><a href="#固定资产的处置">固定资产的处置</a></li></ul></li><li><a href="#无形资产">无形资产</a><ul><li><a href="#无形资产的确认和初始计量">无形资产的确认和初始计量</a></li><li><a href="#内部研究开发支出的确认和计量">内部研究开发支出的确认和计量</a></li><li><a href="#无形资产的后续计量">无形资产的后续计量</a></li><li><a href="#无形资产的处置">无形资产的处置</a></li></ul></li><li><a href="#投资性房产">投资性房产</a></li><li><a href="#长期股权投资与合营安排">长期股权投资与合营安排</a></li><li><a href="#资产减值">资产减值</a></li><li><a href="#负债">负债</a></li><li><a href="#职工薪酬">职工薪酬</a></li><li><a href="#借款费用">借款费用</a></li><li><a href="#股份支付">股份支付</a></li><li><a href="#或有事项">或有事项</a></li><li><a href="#金融工具">金融工具</a></li><li><a href="#所有者权益">所有者权益</a></li><li><a href="#收入-费用和利润">收入、费用和利润</a></li><li><a href="#政府补助">政府补助</a></li><li><a href="#非货币性资产交换">非货币性资产交换</a></li><li><a href="#债务重组">债务重组</a></li><li><a href="#所得税">所得税</a></li><li><a href="#外币折算">外币折算</a></li><li><a href="#租赁">租赁</a></li><li><a href="#财务报告-1">财务报告</a></li><li><a href="#资产负债表日后事项">资产负债表日后事项</a></li><li><a href="#持有待售的非流动资产-处置组和终止经营">持有待售的非流动资产、处置组和终止经营</a></li><li><a href="#企业合并">企业合并</a></li><li><a href="#合并财务报表">合并财务报表</a></li><li><a href="#每股收益">每股收益</a></li><li><a href="#公允价值计量">公允价值计量</a></li><li><a href="#政府及民间非营利组织会计">政府及民间非营利组织会计</a></li></ul><!-- tocstop --><h1><span id="总论">总论</span></h1><h2><span id="会计概述">会计概述</span></h2><p>会计是以货币为主要计量单位，反映和监督一个单位经济活动的一种经济管理工作。</p><p>反映企业的财务状况、经营成果和现金流量</p><p>对经营活动和财务收支进行监督。</p><h2><span id="财务报告目标-会计基本假设和会计基础">财务报告目标、会计基本假设和会计基础</span></h2><p>财务报告目标：</p><ul><li><p>受托责任观</p><p>公司制企业：公司财产所有权与经营权分离。</p><p>财务报表应当能恰当有效地反映受托经营者管理责任的履行情况，向委托人揭示过去的经营活动和财务成果。</p></li><li><p>决策有用观</p><p>资本市场</p><p>股权交换和流通</p><p>股权进一步分散，财务报告要为投资者提供有助于决策的信息</p></li></ul><h2><span id="会计信息质量要求">会计信息质量要求</span></h2><h2><span id="会计要素及其确认与计量">会计要素及其确认与计量</span></h2><h2><span id="财务报告">财务报告</span></h2><h1><span id="会计政策-会计估计及其变更和差错更正">会计政策、会计估计及其变更和差错更正</span></h1><h2><span id="会计政策及其变更的概述">会计政策及其变更的概述</span></h2><h2><span id="会计估计及其变更的概述">会计估计及其变更的概述</span></h2><h2><span id="会计政策与会计估计及其变更的划分">会计政策与会计估计及其变更的划分</span></h2><h2><span id="会计政策与会计估计变更的会计处理">会计政策与会计估计变更的会计处理</span></h2><h2><span id="前期差错及其更正">前期差错及其更正</span></h2><h1><span id="存货">存货</span></h1><h2><span id="存货的确认和初始计量">存货的确认和初始计量</span></h2><h2><span id="发出存货的计量">发出存货的计量</span></h2><h2><span id="期末存货的计量">期末存货的计量</span></h2><h2><span id="存货的清查盘点">存货的清查盘点</span></h2><h1><span id="固定资产">固定资产</span></h1><h2><span id="固定资产的确认和初始计量">固定资产的确认和初始计量</span></h2><h2><span id="固定资产的后续计量">固定资产的后续计量</span></h2><h2><span id="固定资产的处置">固定资产的处置</span></h2><h1><span id="无形资产">无形资产</span></h1><h2><span id="无形资产的确认和初始计量">无形资产的确认和初始计量</span></h2><h2><span id="内部研究开发支出的确认和计量">内部研究开发支出的确认和计量</span></h2><h2><span id="无形资产的后续计量">无形资产的后续计量</span></h2><h2><span id="无形资产的处置">无形资产的处置</span></h2><h1><span id="投资性房产">投资性房产</span></h1><h1><span id="长期股权投资与合营安排">长期股权投资与合营安排</span></h1><h1><span id="资产减值">资产减值</span></h1><h1><span id="负债">负债</span></h1><h1><span id="职工薪酬">职工薪酬</span></h1><h1><span id="借款费用">借款费用</span></h1><h1><span id="股份支付">股份支付</span></h1><h1><span id="或有事项">或有事项</span></h1><h1><span id="金融工具">金融工具</span></h1><h1><span id="所有者权益">所有者权益</span></h1><h1><span id="收入-费用和利润">收入、费用和利润</span></h1><h1><span id="政府补助">政府补助</span></h1><h1><span id="非货币性资产交换">非货币性资产交换</span></h1><h1><span id="债务重组">债务重组</span></h1><h1><span id="所得税">所得税</span></h1><h1><span id="外币折算">外币折算</span></h1><h1><span id="租赁">租赁</span></h1><h1><span id="财务报告">财务报告</span></h1><h1><span id="资产负债表日后事项">资产负债表日后事项</span></h1><h1><span id="持有待售的非流动资产-处置组和终止经营">持有待售的非流动资产、处置组和终止经营</span></h1><h1><span id="企业合并">企业合并</span></h1><h1><span id="合并财务报表">合并财务报表</span></h1><h1><span id="每股收益">每股收益</span></h1><h1><span id="公允价值计量">公允价值计量</span></h1><h1><span id="政府及民间非营利组织会计">政府及民间非营利组织会计</span></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;题记&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;逢考必胜的在下，在过去的几年中，好似忘记精进考业这回事儿了，现在醒悟过来，发现为时不晚，赶紧立个小目标，要在4年内把CPA拿下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;计划如下：&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="CPA" scheme="http://yoursite.com/tags/CPA/"/>
    
  </entry>
  
  <entry>
    <title>iptables</title>
    <link href="http://yoursite.com/2019/03/28/iptables/"/>
    <id>http://yoursite.com/2019/03/28/iptables/</id>
    <published>2019-03-28T01:51:58.000Z</published>
    <updated>2019-03-28T02:14:28.248Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.frozentux.net/iptables-tutorial/cn/iptables-tutorial-cn-1.1.19.html#RCFLUSH-IPTABLESTXT" target="_blank" rel="noopener">iptables指南</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.frozentux.net/iptables-tutorial/cn/iptables-tutorial-cn-1.1.19.html#RCFLUSH-IPTABLESTXT&quot; target=&quot;_blank&quot; rel=&quot;noopen
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MySQL的优化和高可用</title>
    <link href="http://yoursite.com/2019/03/26/MySQL%E7%9A%84%E4%BC%98%E5%8C%96%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/03/26/MySQL的优化和高可用/</id>
    <published>2019-03-26T03:56:11.000Z</published>
    <updated>2019-03-27T04:46:37.655Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="优化">优化</span></h1><h2><span id="服务器物理硬件的优化">服务器物理硬件的优化</span></h2><ul><li>磁盘寻道能力（磁盘IO）：机械硬盘，可以选择SAS 15000转做RAID10；在资金允许的情况下，可以选择固态硬盘来代替机械硬盘。</li><li>选择运算能力强悍的CPU如：Intel XEON 5504</li><li>内存不小于4G，现在一般的高端服务器的内存都超过了32G</li></ul><h2><span id="配置文件的优化">配置文件的优化</span></h2><p>MySQL自身的优化主要是对其配置文件my.cnf中各项参数进行优化调整。</p><p>[mysqld]段落</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># 避免外部锁定，减少出错几率，增强稳定性</span><br><span class="line">skip-external-locking</span><br><span class="line"># 禁止MySQL对外部链接进行DNS解析，可以消除MySQL进行DNS解析的时间</span><br><span class="line">skip-name-resolve</span><br><span class="line"># back_log 是</span><br><span class="line">back_log=384</span><br><span class="line">key_buffer_size=384M</span><br><span class="line">max_allowed_packet=4M</span><br><span class="line">thread_stack=256K</span><br><span class="line">table_cache=614K</span><br><span class="line">sort_buffer_size=6M</span><br><span class="line">read_buffer_size=4M</span><br><span class="line">join_buffer_size=8M</span><br><span class="line">thread_cache_size=64</span><br><span class="line">query_cache_size=64M</span><br><span class="line">tmp_table_size=256M</span><br><span class="line">max_connections=768</span><br><span class="line">max_connect_errors=1000</span><br><span class="line">wait_timeout=10</span><br><span class="line">thread_concurrency=8</span><br><span class="line">skip-networking</span><br><span class="line">table_cache=1024</span><br><span class="line">innodb_additional_mem_pool_szie=4M</span><br><span class="line">innodb_flush_log_at_trx_commit=1</span><br><span class="line">innodb_log_buffer_size=2M</span><br><span class="line">innodb_thread_concurrency=8</span><br><span class="line">tmp_table_size=64M</span><br><span class="line">read_rnd_buffer_size=16M</span><br></pre></td></tr></table></figure><h2><span id="上线后根据status进行优化">上线后，根据status进行优化</span></h2><p>show global status;</p><h3><span id="慢查询">慢查询</span></h3><p>show variables like “%slow%”;</p><p>show global status like “%slow”;</p><p>mysqldumpslow -s -c -t 20 host-slow.log</p><p>启用慢查询可能会对系统性能有一点影响，如果是主从结构，可以考虑打开其中一台从服务器的慢查询日志。</p><h3><span id="连接数">连接数</span></h3><p>“MySQL:ERROR 1040:Too many connections”，原因有可能是：</p><ul><li><p>访问量确实很高，服务器扛不住，此时需考虑增加从服务器分散读压力；</p></li><li><p>配置文件中max_connections的值过小</p><p>show variables like “max_connections”;</p><p>show global status like “Max_used_connections”;</p></li></ul><h3><span id="临时表">临时表</span></h3><p> show global status like ‘created_tmp%’；</p><h3><span id="open-table的情况">Open Table的情况</span></h3><h3><span id="进程使用情况">进程使用情况</span></h3><h3><span id="查询缓存">查询缓存</span></h3><h3><span id="排序使用情况">排序使用情况</span></h3><h3><span id="文件打开数">文件打开数</span></h3><h3><span id="innodb_buffer_size的合理设置">Innodb_buffer_size的合理设置</span></h3><h2><span id="利用tuning-primer脚本进行数据库调优">利用tuning-primer脚本进行数据库调优</span></h2><h2><span id="架构设计调优">架构设计调优</span></h2><p>除非之前的设置存在严重不合理的情况，否则通过参数调整是不可能在性能优化上产生质的飞跃的。</p><p>在MySQL数据库层的前面引入NoSQL数据缓存</p><ul><li>把部分业务直接分到redis集群</li><li>redis缓存海量小数据文件</li><li>引入RabbitMQ消息中间件，以异步任务的方式来处理业务</li></ul><h1><span id="高可用架构">高可用架构</span></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;优化&quot;&gt;优化&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span id=&quot;服务器物理硬件的优化&quot;&gt;服务器物理硬件的优化&lt;/span&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;磁盘寻道能力（磁盘IO）：机械硬盘，可以选择SAS 15000转做RAID10；在资金允许的情况下，可
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Nginx负载调度算法</title>
    <link href="http://yoursite.com/2019/03/21/%E8%B4%9F%E8%BD%BD%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/03/21/负载调度算法/</id>
    <published>2019-03-21T07:01:19.000Z</published>
    <updated>2019-03-27T03:59:38.888Z</updated>
    
    <content type="html"><![CDATA[<p>RR</p><p>weighted RR</p><p>ip_hash</p><p>url_hash</p><p>fair</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;RR&lt;/p&gt;
&lt;p&gt;weighted RR&lt;/p&gt;
&lt;p&gt;ip_hash&lt;/p&gt;
&lt;p&gt;url_hash&lt;/p&gt;
&lt;p&gt;fair&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Java概要</title>
    <link href="http://yoursite.com/2019/03/20/Java%E6%A6%82%E8%A6%81/"/>
    <id>http://yoursite.com/2019/03/20/Java概要/</id>
    <published>2019-03-20T04:17:46.000Z</published>
    <updated>2019-03-21T11:11:12.215Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="类与对象">类与对象</span></h1><h2><span id="java变量的作用域">Java变量的作用域</span></h2><ul><li><p>类级变量</p><p>全局级变量或者静态变量，加static修饰符</p><p>类级变量在类定义后就会一直存在，占用内存空间，可以通过类名来访问，不需要实例化</p></li><li><p>对象实例级变量</p><p>成员变量，实例化后才会分配内存空间，才能访问</p></li><li><p>方法级变量</p><p>方法内部定义的变量，就是局部变量</p></li><li><p>块级变量</p><p>是定义在一个块内的变量，出了这个块变量就消失了。块是指由大括号包围的代码。</p></li></ul><h2><span id="this">this</span></h2><p>用来表示当前对象本身。通过this可以调用本对象的所有方法和属性。</p><p>this只有在实例化后才有意义。</p><p>可以用来区分同名变量、作为构造方法、作为参数传递</p><h2><span id="重载">重载</span></h2><p>重载就是在一个类中，有相同的函数名称，但形参不同的函数。</p><p>说明：</p><ul><li>参数列表不同包括：个数不同、类型不同和顺序不同。</li><li>仅仅参数变量名称不同是不可以的。</li><li>跟成员方法一样，构造方法也可以重载。</li><li>声明为final的方法不能被重载。</li><li>声明为static的方法不能被重载，但是能够被再次声明。</li></ul><h2><span id="包装类-拆箱和装箱">包装类、拆箱和装箱</span></h2><p>Java为每种基本数据类型分别设计了对应的类，称之为包装类（Wrapper Classes）。</p><table><thead><tr><th>基本数据类型</th><th>对应的包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><p>基本类型和对应的包装类可以相互装换： </p><ul><li>由基本类型向对应的包装类转换称为装箱，例如把 int 包装成 Integer 类的对象；</li><li>包装类向对应的基本类型转换称为拆箱，例如把 Integer 类的对象重新简化为 int。</li></ul><h1><span id="继承与多态">继承与多态</span></h1><h2><span id="继承">继承</span></h2><p>一个类从另一个类获取方法和属性的过程。</p><p>如果B继承于类A，那么B就拥有A的方法和属性。</p><p>继承使用extends关键字。</p><p>单继承性：Java中，一个类只能有一个父类。</p><p>接口允许多继承。</p><h2><span id="super">super</span></h2><p>和this类似，this表示当前类的实例，super表示父类。</p><p>该关键字的功能：</p><ul><li>调用父类中声明为private的变量</li><li>点取已经覆盖了的方法</li><li>作为方法名表示父类构造方法</li></ul><h2><span id="方法的覆盖和重载">方法的覆盖和重载</span></h2><p>被覆盖的方法在子类中只能通过super调用</p><p>覆盖不会删除父类中的方法，而是对子类的实例隐藏</p><p>方法覆盖的原则：</p><ul><li>覆盖方法的返回类型、方法名称、参数列表必须与原方法的相同。</li><li>覆盖方法不能比原方法访问性差（即访问权限不允许缩小）。</li><li>覆盖方法不能比原方法抛出更多的异常。</li><li>被覆盖的方法不能是final类型，因为final修饰的方法是无法覆盖的。</li><li>被覆盖的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。</li><li>被覆盖的方法不能为static。如果父类中的方法为静态的，而子类中的方法不是静态的，但是两个方法除了这一点外其他都满足覆盖条件，那么会发生编译错误；反之亦然。即使父类和子类中的方法都是静态的，并且满足覆盖条件，但是仍然不会发生覆盖，因为静态方法是在编译的时候把静态方法和类的引用类型进行匹配。</li></ul><p>覆盖和重载的不同：</p><ul><li>方法覆盖要求参数列表必须一致，而方法重载要求参数列表必须不一致。</li><li>方法覆盖要求返回类型必须一致，方法重载对此没有要求。</li><li>方法覆盖只能用于子类覆盖父类的方法，方法重载用于同一个类中的所有方法（包括从父类中继承而来的方法）。</li><li>方法覆盖对方法的访问权限和抛出的异常有特殊的要求，而方法重载在这方面没有任何限制。</li><li>父类的一个方法只能被子类覆盖一次，而一个方法可以在所有的类中可以被重载多次。</li></ul><h2><span id="多态与动态绑定">多态与动态绑定</span></h2><p>父类变量可以引用父类的实例，也可以引用子类的实例。</p><p>多态存在的三个必要条件：</p><ul><li>要有继承</li><li>要有重写覆盖</li><li>父类变量引用子类对象</li></ul><p>当使用多态方式调用方法时：</p><ul><li>首先检查父类中是否有该方法，如果没有，则编译错误；若有，则检查子类是否覆盖了该方法；</li><li>如果子类覆盖了该方法，就调用子类的方法，否则调用父类方法</li></ul><h2><span id="instanceof">instanceof</span></h2><p>判断一个变量实际引用的对象的类型</p><h2><span id="多态对象的类型转换">多态对象的类型转换</span></h2><p>子类向父类转换称为“向上转型”，父类向子类转换称为“向下转型”。</p><p>父类类型的变量引用子类对象，程序在运行时通过动态绑定来实现子类方法的调用。这个过程就是向上转型。</p><p>不能直接将父类对象强制转换成子类类型，只能将向上转型后的子类对象再次转换成子类类型。</p><h1><span id="接口">接口</span></h1><p>接口中，所有的方法都必须时抽象的，不能有方法体，是更加抽象的抽象类。</p><p>用interface来声明一个接口。</p><p>为什么要使用接口呢？</p><p>保证可插入性：</p><p>一个继承链中的任何一个类都可以实现一个接口，这个接口会影响到此类的所有子类，但不会影响到此类的任何父类。</p><p>一个类只能继承一个父类，但可以实现多个接口。</p><p>接口必须通过类来implements它的抽象方法，然后再实例化。</p><h1><span id="泛型">泛型</span></h1><p>宽泛的类型。不明确指定类型，而是将类型作为参数传递到类、方法中。</p><p>传值参数由小括号包围，类型参数由尖括号包围。</p><p>可以通过extends限制泛型的类型。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;类与对象&quot;&gt;类与对象&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span id=&quot;java变量的作用域&quot;&gt;Java变量的作用域&lt;/span&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;类级变量&lt;/p&gt;
&lt;p&gt;全局级变量或者静态变量，加static修饰符&lt;/p&gt;
&lt;p&gt;类级
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Nginx下Lua实现机制</title>
    <link href="http://yoursite.com/2019/03/18/Nginx%E4%B8%8BLua%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/03/18/Nginx下Lua实现机制/</id>
    <published>2019-03-18T13:52:32.000Z</published>
    <updated>2019-03-22T05:29:15.134Z</updated>
    
    <content type="html"><![CDATA[<p>Nginx中的大部分功能是通过模块提供的。一个模块的失效不会影响其他部分，是Nginx扩展性和可靠性的一个保证。</p><p>Nginx使用比较多的场合时反向代理，使用Nginx在前端做登陆校验、JS合并、数据库访问、访问鉴权等。</p><p>Lua是高效、紧凑、嵌入式的快速脚本语言，内建协程，非常便于业务开发。</p><p>ngx_lua模块，将Lua解释器集成进Nginx中，使开发者可以使用Lua脚本语言实现业务。</p><h1><span id="ngx_lua原理">ngx_lua原理</span></h1><p>ngx_lua将Lua集成进Nginx。Lua内建<a href="https://jeychu.github.io/2016/03/20/关于协程/" target="_blank" rel="noopener">协程</a>，使用协程可以很好地将异步回调转换成顺序调用的形式，和Nginx的全异步模式匹配起来：协程调用异步API，然后协程挂起，在异步回调事件到来时，在将协程唤醒，继续执行。</p><p>这样既可以实现全异步的Nginx机制，不会影响Nginx的高并发处理性能，又使开发者以同步的方式编写异步程序。</p><p>Ngx_lua在Nginx的管理/工作进程<sup>master-worker</sup>机制基础上加入了Lua解释器。ngx_lua在每一个Nginx工作进程上执行一个Lua解释器实例，这个工作进程上处理的所有请求共享这个实例。</p><p>每个请求的上下文都被Lua的协程分割，保证每个请求是独立的。</p><p>采用一个请求一个协程的处理模式，对于每个用户请求，都会创建一个协程用于执行用户代码以处理请求，请求处理完毕，协程会被销毁。</p><p>每个协程都有一个独立的全局变量空间，保存从全局共享的数据。用户在自己的代码里操作了全局空间的变量不会影响其他的请求处理协程，因为数据被隔离了。数据用完就会被释放，用户代码是运行在一个沙箱里，沙箱的生存周期与请求的生命周期相同。</p><p>协程是轻量级线程，占用极少内存，通常每个请求ngx_lua只会占用2KB左右内存。</p><p>一个简单的ngx_lua请求处理流程：</p><p><img src="/2019/03/18/Nginx下Lua实现机制/1553134371819.png" alt="1553134371819"></p><p>Nginx HTTP请求流程及11个阶段：</p><p><img src="/2019/03/18/Nginx下Lua实现机制/1553135971971.png" alt="1553135971971"></p><p>ngx_lua的11个阶段在Nginx的4个主要阶段分布情况：</p><p><img src="/2019/03/18/Nginx下Lua实现机制/1553135166993.png" alt="1553135166993"></p><p>Lua可使用的主要阶段：</p><p><img src="/2019/03/18/Nginx下Lua实现机制/1553135339907.png" alt="1553135339907"></p><h1><span id="阶段解析">阶段解析</span></h1><p>init_by_lua</p><p>在每次Nginx重新加载配置时执行</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Nginx中的大部分功能是通过模块提供的。一个模块的失效不会影响其他部分，是Nginx扩展性和可靠性的一个保证。&lt;/p&gt;
&lt;p&gt;Nginx使用比较多的场合时反向代理，使用Nginx在前端做登陆校验、JS合并、数据库访问、访问鉴权等。&lt;/p&gt;
&lt;p&gt;Lua是高效、紧凑、嵌入式
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Pro MySQL</title>
    <link href="http://yoursite.com/2019/03/18/MySQL%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/03/18/MySQL优化/</id>
    <published>2019-03-18T12:08:03.000Z</published>
    <updated>2019-03-24T07:15:58.327Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#基础架构">基础架构</a><ul><li><a href="#连接器">连接器</a></li><li><a href="#查询缓存">查询缓存</a></li><li><a href="#分析器">分析器</a></li><li><a href="#优化器">优化器</a></li><li><a href="#执行器">执行器</a></li></ul></li><li><a href="#日志系统">日志系统</a><ul><li><a href="#redo-log">redo log</a></li><li><a href="#binlog">binlog</a></li></ul></li><li><a href="#索引">索引</a><ul><li><a href="#索引的实现">索引的实现</a><ul><li><a href="#哈希表">哈希表</a></li><li><a href="#有序数组">有序数组</a></li><li><a href="#搜索树">搜索树</a></li></ul></li><li><a href="#innodb的索引模型">InnoDB的索引模型</a></li><li><a href="#索引的维护">索引的维护</a></li></ul></li><li><a href="#事务隔离">事务隔离</a><ul><li><a href="#隔离级别">隔离级别</a></li><li><a href="#隔离的实现">隔离的实现</a></li><li><a href="#事务的启动方式">事务的启动方式</a></li></ul></li><li><a href="#锁">锁</a></li></ul><!-- tocstop --><h1><span id="基础架构">基础架构</span></h1><p><img src="/2019/03/18/MySQL优化/1553066900441.png" alt="1553066900441"></p><p>Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等</p><p>而存储引擎负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。</p><h2><span id="连接器">连接器</span></h2><p>负责建立连接、获取权限、维持和管理连接。</p><p>连接空闲最长时间由参数wait_timeout控制，默认值是8小时。</p><p>连接断开后，再次发送请求，就会有错误提醒：Lost connection to MySQL server during query。此时要重连。</p><p>使用长连接，占用内存大，容易被系统强行杀掉，导致异常重启。</p><p>解决方法：</p><ul><li>定期断开长连接</li><li>执行一个比较大的操作后，通过执行mysql_reset_connection来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态</li></ul><h2><span id="查询缓存">查询缓存</span></h2><p>8.0已经没有这个功能了</p><p>query_cache_type设置为DEMAND，则默认不启用查询缓存。</p><p>可以特定语句使用缓存：</p><p>select SQL_CACHE * from T where ID=10;</p><h2><span id="分析器">分析器</span></h2><h2><span id="优化器">优化器</span></h2><h2><span id="执行器">执行器</span></h2><h1><span id="日志系统">日志系统</span></h1><p>MySQL可以恢复到半个月内任意一秒的状态。</p><h2><span id="redo-log">redo log</span></h2><p>WAL<sup>Write-Ahead Logging</sup>，先写日志，再写磁盘。</p><p>用于保证crash-safe能力</p><h2><span id="binlog">binlog</span></h2><h1><span id="索引">索引</span></h1><p>是为了提高数据查询的效率</p><h2><span id="索引的实现">索引的实现</span></h2><h3><span id="哈希表">哈希表</span></h3><p>是一种以key-value存储数据的结构。</p><p>哈希函数将一个值<sup>key</sup>换算成一个确定的位置<sup>value</sup>，然后把值放到这个位置。</p><p>不可避免地，会出现多个key经过哈希函数的换算，得到同一个value的情况。处理办法是，在此value项拉出一个链表，重复的key依次往后追加。查找时通过哈希换算+顺序遍历，找到索引项。</p><p>链表只是追加，并不是有序的，所以做区间查询会很慢。</p><p>因此，哈希表适用于只有等值查询的场景。比如Memcached及其他一些NoSQL引擎。</p><h3><span id="有序数组">有序数组</span></h3><p>在等值查询和范围查询场景中的性能都很优秀。</p><p>用二分法查找，时间复杂度是O(logN)。</p><p>只看查询效率，有序数组就是最好的数据结构了。</p><p>但是，更新数据的成本太高。</p><p>所以，有序数组只适用于静态存储引擎。</p><h3><span id="搜索树">搜索树</span></h3><p>二叉搜索树：每个节点的左子小于父，父小于右子。</p><p>查找的时间复杂度是O(logN)。</p><p>为了维持O(logN)的查询复杂度，需平衡二叉树，更新的时间复杂度也是O(logN)。</p><p>还可以有多叉树。</p><p>二叉树的搜索效率最高，但实际上大多数数据库存储却并不使用二叉树。原因是，索引不只存在内存中，还要写到磁盘上。</p><p>100万个节点的平衡二叉树，树高20。一次查询可能需要访问20个数据块。机械硬盘随机读一个数据块需要10ms左右的寻址时间。因此，单独访问一行就可能需要200ms的时间。</p><p>为了尽量少的读磁盘，使用N叉树。</p><p>InnoDB的一个整数字段索引，N差不多是1200。这棵树高是4的时候，就可以存1200<sup>3</sup>个值，约17亿。树根的数据块总是在内存中，因此一个10亿行的表上一个整数字段的索引，查找一个值最多只需要访问3次磁盘。</p><h2><span id="innodb的索引模型">InnoDB的索引模型</span></h2><p>每一个索引在InnoDB里面对应一颗B+树。</p><blockquote><p>B-树：</p><p>多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；</p><p>所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；</p><p>B+树：</p><p>在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；</p><p>B+树总是到叶子结点才命中；</p><p>B*树：</p><p>在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率</p><p>从1/2提高到2/3；</p></blockquote><p>索引类型可分为主键索引和非主键索引：</p><ul><li><p>主键索引的叶子节点存放的是行数据。</p><p>也被称为聚行索引<sup>clustered index</sup>。</p><p>基于主键索引的查询，只需搜索主键索引B+树。</p></li><li><p>非主键索引的叶子节点内容是主键的值。</p><p>也被称为二级索引<sup>secondary index</sup>。</p><p>基于普通索引<sup>非主键索引</sup>的查询，则需要先搜索普通索引B+树，得到相应的主键索引值，再到主键索引B+树中搜索一次。这个过程称为回表。</p></li></ul><p>基于非主键索引的查询需要多扫描一颗索引树。因此，我们在应用中应该尽量使用主键查询。</p><h2><span id="索引的维护">索引的维护</span></h2><p>B+树为了维护索引有序性，在插入新值的时候需要做必要的维护。</p><p>覆盖索引</p><p>最左前缀</p><p>索引下推</p><h1><span id="事务隔离">事务隔离</span></h1><p>事务，就是要保证一组数据库操作，要么全部成功，要么全部失败。</p><p>MyISAM不支持事务，因而被InnoDB取代。</p><p>隔离的越严实，效率就会越低。</p><h2><span id="隔离级别">隔离级别</span></h2><p>SQL标准的事务隔离级别包括：</p><ul><li>读未提交<sup>read uncommitted</sup>，一个事务还没提交时，它做的变更就能被别的事务看到；</li><li>读提交<sup>read committed</sup>，一个事务提交之后，它做的变更才会被其他事务看到；</li><li>可重复读<sup>repeated read</sup>，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。未提交变更对其他事务也是不可见的。</li><li>串行化<sup>serializable</sup>，对于同一个记录，写会加写锁，读会加读锁。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li></ul><p>形象一点，可以这样理解：</p><p><img src="/2019/03/18/MySQL优化/1553321751566.png" alt="1553321751566"></p><h2><span id="隔离的实现">隔离的实现</span></h2><p>同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制<sup>MVCC</sup>。</p><p>在MySQL中，每条记录在更新的时候都会同时记录一条回滚记录。</p><p>在查询这条记录的时候，不同时刻启动的事务会有不同的read-view。</p><p>当没有事务再需要用到这些回滚日志之时，也就是当系统里没有比这个回滚日志更早的read-view的时候，回滚日志会被删除。</p><p>长事务，意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以在这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。</p><p>长事务还占用锁资源，可能会拖跨库。</p><p>因此，应该尽量避免长事务。</p><h2><span id="事务的启动方式">事务的启动方式</span></h2><ul><li>显式启动事务语句，begin或start transaction。配套的提交语句是commit，回滚语句是rollback</li><li>set autocommit=0，这个命令会将这个线程的自动提交关闭。这会容易导致意外长事务的出现。</li></ul><p>建议总是使用set autocommit=1，然后显式启动事务。</p><p>在autocommit=1的情况下，用begin显式启动的事务，如果执行commit则提交事务。如果执行commit work and chain，则是提交事务并自动启动下一个事务，这样也省去了再次执行begin语句的开销。</p><p>以下语句可查询持续时间超过60s的长事务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))&gt;60</span><br></pre></td></tr></table></figure><h1><span id="锁">锁</span></h1><p>是为了处理并发。</p><p>多用户共享的资源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则。</p><p>锁就是用来实现这些访问规则的数据结构。</p><p>根据锁的范围，大致可分成</p><ul><li><p>全局锁：对整个数据库实例加锁。</p><p>全局加读锁的命令：<code>flush tables with read lock</code>。之后，整库处于只读状态，其他线程的以下语句会被阻塞：数据更新语句、数据定义语句和更新类事务的提交语句。</p><p>典型使用场景是，做全库逻辑备份。</p><p>全库只读，很危险：</p><ul><li>若在主库备份，则在备份期间都不能执行更新，业务停摆；</li><li>若在从库备份，则在备份期间不能执行主库同步过来的binlog，会导致主从延迟。</li></ul><p>但是，不加锁的话，备份系统备份得到的库不是一个逻辑时间点，这个视图是逻辑不一致的。</p><p>如何不加锁的情况下，得到一致性视图呢？</p><p>可以在可重复读隔离级别下开启一个事务，得到一致性视图。</p><p>mysqldump使用参数-single-transaction的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。由于 MVCC的支持，这个过程中的数据是可以正常更新的。</p><p>一致性读的前提是引擎要支持这个隔离级别。</p><p>single-transaction方法只适用于所有表使用事务引擎的库。</p></li><li><p>表级锁</p><ul><li><p>一类是主动加锁，语法是<code>lock tables … read/write</code></p><p>可以使用unlock tables主动释放锁，亦可以在客户端断开的时候自动释放。</p><p>lock tables除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。</p></li><li><p>另一类表级锁是系统默认加的MDL<sup>metadata lock</sup>。MDL不需要显式使用，在访问一个表的时候会被自动加上。</p><p>MDL的作用是，保证读写的正确性。</p><p>当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。</p><ul><li>读锁之间不互斥，因此可以多线程同时对一张表增删改查</li><li>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</li></ul></li></ul><p>一个事务在提交之前，它是不会释放MDL锁的。所以在事务提交之前，若有另一个session需要MDL写锁，就会阻塞，并且会导致随后其他所有session的所有操作。</p><p>给一个表加字段，或者修改字段，或者加索引，需要扫描全表的数据。在对大表操作的时候，要特别小心，以免对线上服务造成影响。对于小表，操作不慎也会出问题。</p><p>如何安全地给小表加字段？</p><p>首先，我们要解决长事务，事务不提交，就会一直占着MDL锁。在MySQL的information_schema库的innodb_trx表中，可以查到当前执行中的事务。如果要做DDL变更的表刚好有长事务在执行，要考虑先暂停DDL，或者kill掉这个长事务。</p><p>如果要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频繁。此时kill可能未必管用，因为新的请求马上就来了。理想的机制是，在alter table语句里设定等待时间，如果在这个指定的等待时间里能够拿到MDL写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后再重试命令重复这个过程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tb1_name NOWAIT add column...</span><br><span class="line">ALTER TABLE tb1_name WAIT N add column...</span><br></pre></td></tr></table></figure></li><li><p>行锁</p><p><strong>两阶段锁</strong></p><p>在InnoDB中，行锁是在需要的时候加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放，这个就是两阶段锁协议。</p><p>因此，如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。</p><p><strong>死锁和死锁检测</strong></p><p>在并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。</p><p><img src="/2019/03/18/MySQL优化/1553348202957.png" alt="1553348202957"></p><p>如上，事务A在等待事务B释放id=2的行锁，而B在等待A释放id=1的行锁，AB互相等待对方的资源释放，就进入死锁状态。</p><p>出现死锁之后，有两种策略：</p><ul><li>直接进入等待，直到超时。超时时间可以通过参数<code>innodb_lock_wait_timeout</code>来设置。</li><li>发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，然后其他事务得以继续执行。将参数<code>innodb_deadlock_detect</code>设置为on，表示开启这个逻辑。</li></ul><p>死锁检测是有额外负担的。</p><p>每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断释放出现了循环等待，也就是死锁。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#基础架构&quot;&gt;基础架构&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#连接器&quot;&gt;连接器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#查询缓存&quot;&gt;查询缓存&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#分析器&quot;&gt;分析器&lt;
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>译-拥塞避免和拥塞控制</title>
    <link href="http://yoursite.com/2019/03/17/Reading-Congestion-Avoidance-and-Control/"/>
    <id>http://yoursite.com/2019/03/17/Reading-Congestion-Avoidance-and-Control/</id>
    <published>2019-03-17T08:37:27.000Z</published>
    <updated>2019-04-08T05:23:34.759Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址：<a href="https://ee.lbl.gov/papers/congavoid.pdf" target="_blank" rel="noopener">Congestion Avoidance and Control</a></p><h1><span id="拥塞避免和拥塞控制">拥塞避免和拥塞控制</span></h1><p>Van Jacobson</p><p>Michael J.Kearels</p><p>1988年11月</p><h2><span id="引子">引子</span></h2><p>在过去的几年中，计算机网络经历了爆炸性的增长，这种增长带来了严重的拥堵问题。例如，现在常见的情况是，由于本地缓冲区溢出，Internet网关会丢弃10%的传入数据包。我们对其中一些问题的调查表明，造成这些问题的原因很大程度上在于传输协议的实现方式(而不是在于协议本身)：在网络拥塞问题上，以“直白”方式实现基于窗口的传输协议可能会导致完全错误的行为。我们给出了“错误”行为的例子，并描述了一些可以用来使正确的事情发生的简单算法。这些算法是根植于这样的一个想法——即通过强制传输连接遵循“包守恒”原则来实现网络的稳定。我们展示了这些算法是如何从这一原理中派生出来的，以及它们对拥挤网络上的流量有什么影响。</p><p>86年10月，互联网第一次出现了一系列的“拥堵现象”。在此期间，从LBL到加州大学伯克利分校的数据吞吐量(两个站点相距400码、两个IMP跳数)，从32Kbps下降到40bps。我们被这一突然的千倍带宽下降吸引住了，并开始调查为什么事情会变得如此糟糕。特别是，我们想知道是不是4.3BSD(Berkeley UNIX)TCP出现了问题，又是不是可以使它在糟糕的网络条件下更好地工作。这两个问题的答案都是肯定的。</p><p>从那时开始，我们将以下7种新算法纳入4BSD TCP之中：</p><ol><li>round-trip-time variance estimation</li><li>exponential retransmit timer backoff</li><li>slow-start</li><li>more aggressive reveive ack policy</li><li>dynamic window sizing on congestion</li><li>Karn’s clamped retransmit backoff</li><li>fast retransmit</li></ol><p>我们的测量结果和beta测试人员的报告表明，最终产品能很好的解决互联网拥塞的问题。<br>本文简要介绍了1-5项及其背后的理论基础。6是最近由贝尔通信研究的菲尔·卡恩(PhilKarn)在[16]中描述的算法。7在即将出版的“征求意见”(ARPANET“征求意见”)中作了说明。<br>算法1-5来源于这样一个观察：TCP连接上的流(或ISO TP-4或Xerox NS SPP连接)应遵循“包守恒”原则。而且，如果遵守这一原则，拥堵崩溃将成为一个例外。因此，拥塞控制就是查找违反守恒的地方并修复它们。<br>我们所说的“包守恒”是指对于“处于平衡状态”的连接，即这个连接以全窗口数据传输状态稳定运行，它的包流处于“守恒”状态：在旧数据包离开之前，不会将新数据包放入网络。流物理学预测，具有这种性质的系统在面对拥塞情况时应该是健壮的。但对互联网的观察表明，这样的系统也不是特别健壮。为什么会有差异呢？<br>引起包守恒失败的方式只有三种：</p><ul><li>连接没有达到平衡状态，或者</li><li>老包未出之前，新包注入，或者</li><li>由于线路资源限制导致无法达到平衡状态</li></ul><p>在如下章节，我们将对此依次说明。</p><h2><span id="达到平衡状态通过慢启动">达到平衡状态：通过慢启动</span></h2><p><img src="/2019/03/17/Reading-Congestion-Avoidance-and-Control/1552819582010.png" alt="1552819582010"></p><p>失败1发生在一个正在启动的连接，或是一个丢包后正在重新启动的连接。另一种看待守恒属性的方式是，发送方使用ack作为计时，将新的数据包传送到网络。由于接收器生成ack的速度不能比数据包通过网络的速度快，因此该协议是“自计时”(图1)。自计时系统自动调整带宽和延迟变化，并具有较宽的动态范围(考虑到TCP跨越800 Mbps Cray通道到1200 bps数据包无线电链路，这一点很重要)。但同样的东西，使一个自计时系统在运行时保持稳定，却使得启动变得困难-要有数据流，必须有ACK用来计时清出数据包，但是为了获取ACK，必须有数据流。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文地址：&lt;a href=&quot;https://ee.lbl.gov/papers/congavoid.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Congestion Avoidance and Control&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;&lt;span 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>为什么一定要用MQ中间件</title>
    <link href="http://yoursite.com/2019/03/15/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%80%E5%AE%9A%E8%A6%81%E7%94%A8MQ%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>http://yoursite.com/2019/03/15/为什么一定要用MQ中间件/</id>
    <published>2019-03-15T13:14:03.000Z</published>
    <updated>2019-03-18T11:52:24.977Z</updated>
    
    <content type="html"><![CDATA[<p>系统解耦</p><p>异步调用</p><p>流量削峰</p><p>待更。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;系统解耦&lt;/p&gt;
&lt;p&gt;异步调用&lt;/p&gt;
&lt;p&gt;流量削峰&lt;/p&gt;
&lt;p&gt;待更。。。&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux性能优化之网络篇</title>
    <link href="http://yoursite.com/2019/03/15/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E7%BD%91%E7%BB%9C%E7%AF%87/"/>
    <id>http://yoursite.com/2019/03/15/Linux性能优化之网络篇/</id>
    <published>2019-03-15T04:54:05.000Z</published>
    <updated>2019-03-15T11:55:17.513Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="网络模型">网络模型</span></h1><p>OSI网络模型，开放式系统互联通信参考模型<sup>Open System Interconnection Reference Model</sup>。</p><p>为了解决网络互联中异构设备的兼容性问题，并解耦复杂的网络包处理流程，OSI模型把网络互联的框架分为应用层、表示层、会话层、传输层、网络层、数据链路层和物理层等七层，每层负责不同的功能：</p><ul><li>应用层，负责为应用程序提供统一的接口；</li><li>表示层，负责把数据转换成兼容格式；</li><li>会话层，负责维护计算机之间的通信连接；</li><li>传输层，负责为数据加上传输包头，形成数据包；</li><li>网络层，负责数据的路由和转发；</li><li>数据链路层，负责MAC寻址、错误侦测和改错；</li><li>物理层，负责在物理网络中传输数据帧。</li></ul><p>Linux中，使用的是四层模型，即TCP/IP网络模型：</p><ul><li>应用层，负责向用户提供一组应用程序，如HTTP、FTP、DNS等</li><li>传输层，负责端到端的通信，如TCP、UDP等</li><li>网络层，负责网络包的封装、寻址和路由，如IP、ICMP等</li><li>网络接口层，负责网络包在物理网络中的传输，如MAC寻址、错误侦测以及通过网卡传输网络帧等</li></ul><h1><span id="linux网络栈">Linux网络栈</span></h1><p>有了TCP/IP模型后，在进行网络传输时，数据包就会按照协议栈，对上一层发来的数据进行逐层处理；然后封装上该层的协议头，再发送到下一层。</p><h1><span id="linux网络收发流程">Linux网络收发流程</span></h1><h1><span id="性能指标">性能指标</span></h1><ul><li>带宽，表示链路的最大传输速率，单位通常为b/s。</li><li>吞吐量，表示单位事件内成功传输的数据量，单位通常为b/s或则B/s。吞吐量受带宽限制，而吞吐量/带宽，就是该网络的使用率。</li><li>时延，表示从网络请求发出后，一直到收到远端响应，所需要的时间延迟。</li><li>PPS<sup>Packet Per Second</sup>，表示以网络包为单位的传输速率。通常用来评估网络的转发能力，比如硬件交换机，通常可以达到线性转发（即PPS可以达到或者接近理论最大值）。而基于Linux服务器的转发，则容易受网络包大小的影响。</li><li>此外，还有网络可用性、并发连接数<sup>TCP连接数量</sup>、丢包率、重传率等</li></ul><h1><span id="网络配置">网络配置</span></h1><p>ip a </p><p>ifconfig</p><h1><span id="套接字信息">套接字信息</span></h1><h1><span id="协议栈统计信息">协议栈统计信息</span></h1><h1><span id="网络吞吐和pps">网络吞吐和PPS</span></h1><h1><span id="连通性和时延">连通性和时延</span></h1><h1><span id="c10k">C10K</span></h1><p>C10K问题最早由Dan Kegel于1999年提出。那时的服务器是32位，配置很少的内存（2G）和千兆网卡</p><p>怎么在这样的系统支持并发1万的请求？</p><p>从资源上来说，对2GB内存和千兆网卡的服务器来说，同时处理10000个请求，只要每个请求处理占用不到200KB的内存和100Kbit的网络带宽即可。所以物理资源足够，接下来是软件的问题，特别是网络IO模型问题。</p><h2><span id="io模型优化">IO模型优化</span></h2><p>两种IO事件通知的方式：</p><ul><li>水平触发：只要文件描述符可以非阻塞地执行IO，就会触发通知。应用程序可以随时检查文件描述符的状态，然后再根据状态，进行IO操作。</li><li>边缘触发：只有在文件描述符的状态发生改变时（也就是IO请求到达时），才发送一次通知。这时候，应用程序要尽可能多地执行IO，直到无法继续读写，才可以停止。</li></ul><h1><span id="c1000k">C1000K</span></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;网络模型&quot;&gt;网络模型&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;OSI网络模型，开放式系统互联通信参考模型&lt;sup&gt;Open System Interconnection Reference Model&lt;/sup&gt;。&lt;/p&gt;
&lt;p&gt;为了解决网络互联中异构设备的兼容性
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>大型网站技术架构</title>
    <link href="http://yoursite.com/2019/03/14/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"/>
    <id>http://yoursite.com/2019/03/14/大型网站技术架构/</id>
    <published>2019-03-14T15:04:49.000Z</published>
    <updated>2019-04-04T14:50:00.622Z</updated>
    
    <content type="html"><![CDATA[<p>此篇为读书笔记。</p><p>待更。。。</p><h1><span id="概述大型网站架构演化">概述大型网站架构演化</span></h1><h2><span id="大型网站架构模式">大型网站架构模式</span></h2><h2><span id="大型网站核心架构要素">大型网站核心架构要素</span></h2><h1><span id="架构">架构</span></h1><h2><span id="高性能架构">高性能架构</span></h2><p>网站性能是客观的指标，可以具体体现到响应时间、吞吐量等技术指标，同时也是主观的感受。</p><h3><span id="网站性能测试">网站性能测试</span></h3><p>性能测试是性能优化的前提和基础，也是性能优化结果的检查和度量标准。不同视角下的网站性能有不同的标准，也有不同的优化手段。</p><h4><span id="不同视角下的网站性能">不同视角下的网站性能</span></h4><h2><span id="高可用架构">高可用架构</span></h2><h2><span id="伸缩性架构">伸缩性架构</span></h2><h2><span id="可扩展架构">可扩展架构</span></h2><h2><span id="安全架构">安全架构</span></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;此篇为读书笔记。&lt;/p&gt;
&lt;p&gt;待更。。。&lt;/p&gt;
&lt;h1&gt;&lt;span id=&quot;概述大型网站架构演化&quot;&gt;概述大型网站架构演化&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span id=&quot;大型网站架构模式&quot;&gt;大型网站架构模式&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span id=&quot;大型网站核
      
    
    </summary>
    
    
      <category term="web" scheme="http://yoursite.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>TCP状态详解</title>
    <link href="http://yoursite.com/2019/03/12/TCP%E7%8A%B6%E6%80%81%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/03/12/TCP状态详解/</id>
    <published>2019-03-12T13:42:31.000Z</published>
    <updated>2019-04-04T10:39:53.494Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/03/12/TCP状态详解/1553563117387.png" alt="1553563117387"></p><p>LISTEN：服务端打开一个socket进行监听，状态为LISTEN。此socket侦听来自远方TCP端口的连接请求。</p><p>SYN_SENT：客户端发送一个SYN请求建立一个连接。之后状态置为SYN_SENT</p><p>SYN_RECV：服务端应发出ACK确认客户端的SYN，状态置为SYN_RECV</p><p>ESTABLISHED：双方可以进行或已经在数据交互了</p><p>FIN_WAIT1：主动关闭端应用程序调用close，发出FIN请求主动关闭连接，之后进入FIN_WAIT1状态</p><p>CLOSE_WAIT：被动关闭端TCP接收FIN后，就发出ACK回应FIN，并进入CLOSE_WAIT</p><p>FIN_WAIT2：主动关闭端接收到ACK后，就进入FIN_WAIT2</p><p>LAST_ACK：被动关闭端发动一个FIN，等待对方的ACK，就进入LAST_ACK</p><p>TIME_WAIT：在主动关闭端接收到FIN后，发送ACK包，并进入TIME_WAIT状态</p><p>CLOSING：</p><p>CLOSED：被动关闭端在接受到ACK包后，就进入closed的状态。连接结束</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/2019/03/12/TCP状态详解/1553563117387.png&quot; alt=&quot;1553563117387&quot;&gt;&lt;/p&gt;
&lt;p&gt;LISTEN：服务端打开一个socket进行监听，状态为LISTEN。此socket侦听来自远方TCP端口的连接请求。&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux性能优化之磁盘篇</title>
    <link href="http://yoursite.com/2019/03/12/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E7%A3%81%E7%9B%98%E7%AF%87/"/>
    <id>http://yoursite.com/2019/03/12/Linux性能优化之磁盘篇/</id>
    <published>2019-03-12T08:19:51.000Z</published>
    <updated>2019-03-20T11:12:07.845Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="linux文件系统是怎么工作的">Linux文件系统是怎么工作的？</span></h1><p>和CPU、内存一样，磁盘和文件系统的管理，也是操作系统最核心的功能。</p><ul><li>磁盘为系统提供了最基本的持久化存储；</li><li>文件系统则在磁盘的基础上，提供了一个用来管理文件的树状结构。</li></ul><h2><span id="索引节点和目录项">索引节点和目录项</span></h2><p>文件系统，本身是对存储设备上的文件进行组织管理的机制。组织方式的不同，就会形成不同的文件系统。</p><blockquote><p>在Linux中，一切皆文件：普通文件和目录、块设备、套接字、管道等都要通过统一的文件系统来管理。</p></blockquote><p>为了方便管理，Linux文件系统为每个文件都分配两个数据结构：</p><ul><li>索引节点<sup>index node</sup>：简称为inode，用来记录文件的元数据，比如inode编号、文件大小、访问权限、修改日期、数据的位置等。索引节点和文件一一对应，它跟文件内容一样，都会被持久化存储到磁盘中。所以，索引节点同样占用磁盘空间。</li><li>目录项<sup>dentry</sup>：用来记录文件的名字、索引节点指针以及与其他目录项的关联关系。多个关联的目录项，就构成了文件系统的目录结构。不过，不同于索引节点，目录项是由内核维护的一个<strong>内存数据结构</strong>，所以通常也被叫做目录项缓存。</li></ul><p>索引节点是每个文件的唯一标志，而目录项维护的是文件系统的树状结构。</p><p>目录项和索引节点的关系是多对一，即一个文件可以有多个别名。如硬链接。通过硬链接为文件创建别名，就会对应不同的目录项。这些目录项本质上链接到同一个文件，所以，它们的索引节点相同。</p><p>索引节点和目录项记录了文件的元数据和文件之间的目录关系，那文件数据到底又是怎么存储的呢？</p><p>磁盘读写的最小单位是扇区，而一个扇区只有512B的大小，如果每次都读写这么小的单位，效率是很低的。所以，文件系统把连续的扇区组成逻辑块，然后每次都以逻辑块为最小单位，来管理数据。</p><p>常见的逻辑块大小为4KB，也就是由连续的8个扇区组成。</p><p>目录项、索引节点以及文件数据的关系如下图所示：</p><p><img src="/2019/03/12/Linux性能优化之磁盘篇/1552381349393.png" alt="1552381349393"></p><p>需要注意的是：</p><ul><li>目录项本身就是一个内存缓存，而索引节点则是存储在磁盘中的数据。为了协调磁盘和CPU的性能差异，文件内容会被缓存到Cache中，这些索引节点自然也会缓存到内存中，加速文件的访问。</li><li>磁盘在执行文件系统格式化时，会被分成三个存储区域，超级块、索引节点区和数据块区。其中：<ul><li>超级块，存储整个文件系统的状态；</li><li>索引节点区，用来存储索引节点；</li><li>数据块区，则用来存储文件数据。</li></ul></li></ul><h2><span id="虚拟文件系统">虚拟文件系统</span></h2><p>目录项、索引节点、逻辑块以及超级块，构成了Linux文件系统的四大基本要素。</p><p>为了支持各种不同的文件系统，Linux内核在用户进程和文件系统之间，又引入了一个抽象层，也就是虚拟文件系统VFS<sup>Virtual File System</sup>。</p><p>Linux文件系统架构图：</p><p><img src="/2019/03/12/Linux性能优化之磁盘篇/1552382275869.png" alt="1552382275869"></p><p>在VFS之下，Linux支持各种各样的文件系统，如Ext4、XFS、NFS、ZFS。。。</p><p>按照存储位置的不同，这些文件系统可以分为三类：</p><ul><li>基于磁盘的文件系统，也就是把数据直接存储在计算机本地挂载的磁盘中。如：Ext4、XFS、OverlayFS等；</li><li>基于内存的文件系统，也就是虚拟文件系统。这类文件系统，不需要任何磁盘分配存储空间，但会占用内存。如/proc、/sys<sup>主要用于向用户空间导出层次化的内核对象</sup>；</li><li>网络文件系统，也就是用来访问其他计算机数据的文件系统，比如NFS、SMB、iSCSI等。</li></ul><p>这些文件系统，要先挂载到VFS目录树中的某个子目录<sup>称为挂载点</sup>，然后才能访问其中的文件。</p><h2><span id="文件系统io">文件系统IO</span></h2><p>文件读写方式的各种差异，导致IO的分类多种多样。常见的有：</p><ul><li><p>缓冲与非缓冲IO<sup>是否利用标准库缓存</sup>：</p><ul><li>缓冲IO，指利用标准库缓存来加速文件的访问，标准库内部再通过系统调度访问文件；</li><li>非缓冲IO，指直接通过系统调用来访问文件，不再经过标准库缓存。</li></ul><p>无论缓存IO还是非缓冲IO，最终还是要经过系统调用来访问文件。系统调用后，还会通过页缓存，来减少磁盘的IO操作。</p></li><li><p>直接与非直接IO<sup>是否利用操作系统的页缓存</sup>：</p><ul><li>直接IO，指跳过操作系统的页缓存，直接跟文件系统交互来访问文件；</li><li>非直接IO，文件读写时，先要经过系统的页缓存，然后再由内核或额外的系统调用，真正写入磁盘。</li></ul><p>在系统调用中，指定O_DIRECT标志，可以实现直接IO。如果没有设置过，默认是非直接IO。</p><p>直接IO和非直接IO，本质上还是和文件系统交互。如果是在数据库等场景中，还会有跳过文件系统读写磁盘的情况，也就是裸IO。</p></li><li><p>阻塞与非阻塞IO<sup>根据应用程序是否阻塞自身运行</sup>：</p><ul><li>阻塞IO，指应用程序之下IO操作后，如果没有获得响应，就会阻塞当前线程，自然就不能执行其他任务；</li><li>非阻塞IO，是指应用程序执行IO操作后，不会阻塞当前的线程，可以继续执行其他的任务，随后再通过轮询或者事件通知的形式，获取调用的结果。</li></ul><p>如：在访问管道或网络套接字时，设置O_NONBLOCK标志，就表示用非阻塞方式访问；如果不做任何设置，默认的是阻塞访问。</p></li><li><p>同步和异步IO<sup>根据是否等待响应结果</sup>：</p><ul><li>同步IO，指应用程序执行IO操作后，要一直等到整个IO完成后，才能获得IO响应；</li><li>异步IO，指应用程序执行IO操作后，不用等待完成和完成后的响应，而是继续执行就可以。等到这次IO完成后，响应会用事件通知的方式，告诉应用程序。</li></ul><p>如：在操作文件时，如果设置了O_SYNC或O_DSYNC标志，就代表同步IO。</p><p>在访问管道或网络套接字时，设置了O_ASYNC，就代表异步IO。</p></li></ul><h2><span id="如何查看文件系统的性能情况呢">如何查看文件系统的性能情况呢？</span></h2><h3><span id="容量">容量</span></h3><p>df</p><p><img src="/2019/03/12/Linux性能优化之磁盘篇/1552385605875.png" alt="1552385605875"></p><p>索引节点的容量<sup>inode的个数</sup>，是在格式化磁盘时设定好的，一般由格式化工具自动生成。当你发现索引节点空间不足，但磁盘空间充足时，很可能就是过多小文件导致的。</p><h3><span id="缓存">缓存</span></h3><p>/proc/meminfo</p><p><img src="/2019/03/12/Linux性能优化之磁盘篇/1552386039282.png" alt="1552386039282"></p><p>/proc/slabinfo</p><p><img src="/2019/03/12/Linux性能优化之磁盘篇/1552385847934.png" alt="1552385847934"></p><p>slabtop</p><p><img src="/2019/03/12/Linux性能优化之磁盘篇/1552385975568.png" alt="1552385975568"></p><h1><span id="linux磁盘io是怎么工作的">Linux磁盘IO是怎么工作的？</span></h1><h2><span id="磁盘">磁盘</span></h2><p>磁盘是可以持久化存储的设备，根据存储介质的不同，常见磁盘可以分为：</p><ul><li><p>机械磁盘，也称为硬盘驱动器<sup>Hard Disk Driver</sup>，通常缩写为HDD。机械磁盘主要由盘片和读写磁头组成，数据就存储在盘片的环状磁道中。在读写数据前，需要移动读写磁头，定位到数据所在的磁道，然后才能访问数据。</p><p>如果是连续IO，不需要磁道寻址，可以获得较好性能。对于随机IO，需要不停地移动磁头来定位数据位置，读写性能会比较差。</p><p>最小读写单位是扇区，一般为512字节。</p></li><li><p>固态磁盘<sup>Solid State Disk</sup>，通常缩写为SSD。由固态电子元器件组成。固态磁盘不需要磁道寻址，所以，不管是连续IO，还是随机IO的性能，都比机械磁盘要好很多。</p><p>最小读写单位是页，一般为4KB、8KB等。</p></li></ul><p>无论机械磁盘还是固态磁盘，相同磁盘的随机IO都要比连续IO慢得多，是因为：</p><ul><li>对机械磁盘来说，由于随机IO需要更多的磁头寻道和盘片旋转，它的性能自然要比连续IO慢；</li><li>对固态磁盘来说，虽然它的随机性能比机械硬盘好很多，但同样存在”先擦除再写入”的限制。随机读写会导致大量的垃圾回收，所以它的随机IO的性能比连续IO，还是差了很多。</li><li>连续IO还可以通过预读的方式，来减少IO请求的次数，这也是其性能优异的一个原因。</li></ul><p>按照接口来分类，可以分为：IDE<sup>Integrated Drive Electronics</sup>、SCSI<sup>Small Computer System Interface</sup>、SAS<sup>Serial Attached SCSI</sup>、SATA<sup>Serial ATA</sup>、FC<sup>Fibre Channel</sup>等。</p><p>不同的接口，往往分配不同的设备名称。比如，IDE设备以hd为前缀，SCSI和SATA以sd为前缀。多块同类型的磁盘，按照a、b、c等的字母顺序来编号。</p><p>在Linux中，磁盘是作为一个块设备来管理的，以块为单位读写数据，支持随机读写。</p><p>每个块设备都会被赋予两个设备号，分别是主、次设备号。主设备号用在驱动程序中，用来区分设备类型；次设备号则是用来给多个同类设备编号。</p><h2><span id="通用块层">通用块层</span></h2><p>与VFS类似，为了减少不同块设备的差异带来的影响，Linux通过一个统一的通用块层，来管理各种不同的块设备。</p><p>通用块层，是处在文件系统和磁盘驱动中间的一个块设备抽象层。它主要有两个功能：</p><ul><li>与VFS类似：向上，为文件系统和应用程序，提供访问块设备的标准接口；向下，把各种异构的磁盘设备抽象为统一的块设备，并提供统一框架来管理这些设备的驱动程序；</li><li>给文件系统和应用程序发来的IO请求排队，并通过重新排序、请求合并等方式，提高磁盘读写的效率。</li></ul><p>对IO请求排序的过程，就是IO调度。Linux内核支持四种IO调度算法：</p><ul><li>NONE：不做处理，常用于虚拟机中</li><li>NOOP：最简单的IO调度算法。是一个先入先出的队列，只做一些最基本的请求合并，常用于SSD</li><li>CFQ：是现在很多发行版的默认IO调度器，它为每一个进程维护了一个IO调度队列，并按照时间片来均匀分布每个进程的IO请求。</li><li>DeadLine：分别为读、写创建了不同的IO队列，可以提高机械磁盘的吞吐量，并确保达到最终期限（deadline）的请求被优先处理。多用于IO压力比较重的场景，比如事件库等。</li></ul><h2><span id="io栈">IO栈</span></h2><p>Linux存储系统的IO栈，由上到下分为三个层次，分别是文件系统层、通用块层和设备层。这三个IO层的关系如下图所示：</p><p><img src="/2019/03/12/Linux性能优化之磁盘篇/1552547651555.png" alt="1552547651555"></p><p>通过这张IO全景图，我们可以清楚的理解存储系统IO的工作原理：</p><ul><li>文件系统层，包括虚拟文件系统和其他各种文件系统的具体实现。为上层的应用程序提供标准的文件访问接口；对下通过通用块层，来存储和管理磁盘数据；</li><li>通用块层，包括块设备IO队列和IO调度。对文件系统的IO请求进行排队，通过重新排序和请求合并，然后发送给下一级的设备层；</li><li>设备层，包括存储设备和相应的驱动程序，负责最终物理设备的IO操作。</li></ul><h2><span id="磁盘性能指标">磁盘性能指标</span></h2><ul><li>使用率</li><li>饱和度</li><li>IOPS</li><li>吞吐量</li><li>响应时间</li></ul><h2><span id="磁盘io观测">磁盘IO观测</span></h2><p>每块磁盘的使用情况</p><p>iostat</p><p><img src="/2019/03/12/Linux性能优化之磁盘篇/1552623565915.png" alt="1552623565915"></p><p>进程IO观测</p><p>pidstat -d 1</p><h1><span id="调优策略及实践">调优策略及实践</span></h1><p>文件系统性能研究方法：</p><table><thead><tr><th>方法</th><th style="text-align:center">类型</th></tr></thead><tbody><tr><td>磁盘分析</td><td style="text-align:center">观察分析</td></tr><tr><td>延时分析</td><td style="text-align:center">观察分析</td></tr><tr><td>负载特征归纳</td><td style="text-align:center">观察分析、容量规划</td></tr><tr><td>性能监控</td><td style="text-align:center">观察分析、容量规划</td></tr><tr><td>事件跟踪</td><td style="text-align:center">观察分析</td></tr><tr><td>静态性能调优</td><td style="text-align:center">观察分析、容量规划</td></tr><tr><td>缓存调优</td><td style="text-align:center">观察分析、调优</td></tr><tr><td>负载分离</td><td style="text-align:center">调优</td></tr><tr><td>内存文件系统</td><td style="text-align:center">调优</td></tr><tr><td>微型基准测试</td><td style="text-align:center">实验分析</td></tr></tbody></table><p>这些方法可以单独使用，也可以组合使用。</p><p>推荐按顺序使用以下策略：延时分析、性能监控、负载特征归纳、微型基准测试、静态性能调优和事件跟踪。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;linux文件系统是怎么工作的&quot;&gt;Linux文件系统是怎么工作的？&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;和CPU、内存一样，磁盘和文件系统的管理，也是操作系统最核心的功能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;磁盘为系统提供了最基本的持久化存储；&lt;/li&gt;
&lt;li&gt;文件
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>在CentOS7上安装eBPF-tools,bcc和ply</title>
    <link href="http://yoursite.com/2019/03/12/%E5%9C%A8CentOS7%E4%B8%8A%E5%AE%89%E8%A3%85eBPF-tools-bcc%E5%92%8Cply/"/>
    <id>http://yoursite.com/2019/03/12/在CentOS7上安装eBPF-tools-bcc和ply/</id>
    <published>2019-03-12T03:27:49.000Z</published>
    <updated>2019-03-12T04:20:02.760Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>升级内核：</p><p>CentOS7的内核版本是3.x，要安装使用eBPF，bcc和ply，内核版本至少是4.9，所以需要先升级CentOS7的内核。详见<a href="https://jeychu.github.io/2019/03/11/CentOS7%E5%8D%87%E7%BA%A7%E5%86%85%E6%A0%B8/" target="_blank" rel="noopener">CentOS7升级内核</a>。</p></li><li><p>升级、安装开发工具：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y epel-release</span><br><span class="line">sudo yum update -y</span><br><span class="line">sudo yum groupinstall -y &quot;Development tools&quot;</span><br><span class="line">sudo yum install -y elfutils-libelf-devel iperf cmake3</span><br></pre></td></tr></table></figure></li><li><p>安装LLVM，clang，ply和bcc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/build</span><br><span class="line">cd ~/build</span><br><span class="line">git clone https://github.com/iovisor/ply.git</span><br><span class="line">cd ply</span><br><span class="line">./autogen.sh</span><br><span class="line"> export CFLAGS=-I$&#123;HOME&#125;/build/usr/include</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line">cd ..</span><br><span class="line">curl -LO http://releases.llvm.org/3.9.1/cfe-3.9.1.src.tar.xz</span><br><span class="line">curl -LO http://releases.llvm.org/3.9.1/llvm-3.9.1.src.tar.xz</span><br><span class="line">tar -xf cfe-3.9.1.src.tar.xz</span><br><span class="line">tar -xf llvm-3.9.1.src.tar.xz</span><br><span class="line">mkdir clang-build</span><br><span class="line">mkdir llvm-build</span><br><span class="line"></span><br><span class="line">cd llvm-build</span><br><span class="line">cmake3 -G &quot;Unix Makefiles&quot; -DLLVM_TARGETS_TO_BUILD=&quot;BPF;X86&quot; \</span><br><span class="line">  -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=/usr ../llvm-3.9.1.src</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line">cd ../clang-build</span><br><span class="line">cmake3 -G &quot;Unix Makefiles&quot; -DLLVM_TARGETS_TO_BUILD=&quot;BPF;X86&quot; \</span><br><span class="line">  -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=/usr ../cfe-3.9.1.src</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line">cd ..</span><br><span class="line">git clone https://github.com/iovisor/bcc.git</span><br><span class="line">mkdir bcc-build</span><br><span class="line">cd bcc-build</span><br><span class="line">cmake3 -G &quot;Unix Makefiles&quot; -DCMAKE_INSTALL_PREFIX=/usr ../bcc</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure></li><li><p>安装完成：</p><p><img src="/2019/03/12/在CentOS7上安装eBPF-tools-bcc和ply/1552362190205.png" alt="1552362190205"></p></li></ol><p>参考文献：</p><p><a href="http://hydandata.org/installing-ebpf-tools-bcc-and-ply-on-centos-7" target="_blank" rel="noopener">Installing eBPF tools, bcc and ply on CentOS 7</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;升级内核：&lt;/p&gt;
&lt;p&gt;CentOS7的内核版本是3.x，要安装使用eBPF，bcc和ply，内核版本至少是4.9，所以需要先升级CentOS7的内核。详见&lt;a href=&quot;https://jeychu.github.io/2019/03/11/Cent
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7升级内核</title>
    <link href="http://yoursite.com/2019/03/11/CentOS7%E5%8D%87%E7%BA%A7%E5%86%85%E6%A0%B8/"/>
    <id>http://yoursite.com/2019/03/11/CentOS7升级内核/</id>
    <published>2019-03-11T07:56:06.000Z</published>
    <updated>2019-03-12T04:16:40.991Z</updated>
    
    <content type="html"><![CDATA[<ol><li>当前版本</li></ol><p><img src="/2019/03/11/CentOS7升级内核/1552291068649.png" alt="1552291068649"></p><ol start="2"><li>开始升级：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</span><br></pre></td></tr></table></figure><p><img src="/2019/03/11/CentOS7升级内核/1552291299843.png" alt="1552291299843"></p><p><img src="/2019/03/11/CentOS7升级内核/1552291341907.png" alt="1552291341907"></p><p><img src="/2019/03/11/CentOS7升级内核/1552291401131.png" alt="1552291401131"></p><ol start="3"><li>将升级后的内核作为默认内核，重启机器</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># grub2-set-default 0</span><br><span class="line"># reboot</span><br></pre></td></tr></table></figure><ol start="4"><li>升级后的版本</li></ol><p><img src="/2019/03/11/CentOS7升级内核/1552353122161.png" alt="1552353122161"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;当前版本&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;/2019/03/11/CentOS7升级内核/1552291068649.png&quot; alt=&quot;1552291068649&quot;&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;开始升级：&lt;/li&gt;
&lt;/ol
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux性能优化之内存篇</title>
    <link href="http://yoursite.com/2019/03/10/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%86%85%E5%AD%98%E7%AF%87/"/>
    <id>http://yoursite.com/2019/03/10/Linux性能优化之内存篇/</id>
    <published>2019-03-10T11:05:56.000Z</published>
    <updated>2019-03-20T05:34:05.925Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#linux内存是怎么工作的">Linux内存是怎么工作的？</a><ul><li><a href="#内存映射">内存映射</a></li><li><a href="#虚拟内存空间分布">虚拟内存空间分布</a></li><li><a href="#内存分配与回收">内存分配与回收</a></li><li><a href="#如何查看内存使用情况">如何查看内存使用情况</a></li></ul></li><li><a href="#buffer和cache">Buffer和Cache</a></li><li><a href="#swap">SWAP</a><ul><li><a href="#swap原理">SWAP原理</a></li></ul></li><li><a href="#如何利用系统缓存优化程序的运行效率">如何利用系统缓存优化程序的运行效率</a></li></ul><!-- tocstop --><h1><span id="linux内存是怎么工作的">Linux内存是怎么工作的？</span></h1><p>内存管理是操作系统最核心的功能之一。内存主要用来存储系统和应用程序的指令、数据、缓存等。</p><p>Linux是怎么管理内存的呢？</p><h2><span id="内存映射">内存映射</span></h2><p>物理内存，也称为主存，大多数计算机用的主存都是动态随机访问内存（DRAM）。</p><p>只有内核才可以直接访问物理内存。进程要访问内存时，该怎么办呢？</p><p>Linux内核给每个进程都提供了一个独立的虚拟地址空间，并且这个地址空间是连续的。</p><p>进程可以很方便地访问虚拟内存。</p><p>虚拟地址空间的内部又被分为内核空间和用户空间两部分，不同字长（单个CPU指令可以处理数的最大长度）的处理器，虚拟地址空间的范围也不同。对于常见的32位和64位系统，它们的虚拟地址空间，如下所示：</p><p><img src="/2019/03/10/Linux性能优化之内存篇/1552216929887.png" alt="1552216929887"></p><p>既然每个进程都有一个这么大的地址空间，那么所有进程的虚拟内存加起来，自然要比实际的物理内存大得多。所以，并不是所有的虚拟内存都会分配物理内存，只有哪些实际使用的虚拟内存才分配物理内存，并且分配后的物理内存，是通过内存映射来管理的。</p><p>内存映射，就是将虚拟内存地址映射到物理内存地址。为了完成内存映射，内核为每个进程都维护了一张页表，记录虚拟地址与物理地址的映射关系，如下图所示：</p><p><img src="/2019/03/10/Linux性能优化之内存篇/1552216874797.png" alt="1552216874797"></p><p>页表存储在CPU的内存管理单元MMU中。</p><p>当进程访问的虚拟地址在页表中查不到时，系统会产生一个缺页异常，进入内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。</p><p>TLB是MMU中页表的高速缓存。由于进程的虚拟地址空间是独立的，而TLB的访问速度又比MMU快得多，所以，通过减少进程的上下文切换，减少TLB的刷新次数，就可以提高TLB缓存的使用率，进而提高CPU的内存访问性能。</p><p>MMU规定了内存映射的最小单位为页，通常是4KB大小，以页为单位来管理内存。这样，每一次内存映射，都需要关联4KB或4KB整数倍的内存空间。</p><p>页的大小只有4KB，整个页表非常大。比如，32位系统就需要100多万个页表项<sup>4GB/4KB=1048576</sup>，才可以实现整个地址空间的映射。</p><p>为了解决页表项过多的问题，Linux提供了两种机制：</p><ul><li><p><strong>多级页表</strong>：把内存分成区块来管理，将原来的映射关系改成区块索引和区块内的偏移。由于虚拟内存空间通常只用了很少一部分，那么，多级页表就只保持这些使用中的区块，这样就可以大大减少页表的项数。</p><p>Linux用四级页表来管理内存页，如下图所示，虚拟内存被分为5个部分，前4个表项用于选择页，而最后一个索引表示页内偏移。</p><p><img src="/2019/03/10/Linux性能优化之内存篇/1552218344165.png" alt="1552218344165"></p></li><li><p><strong>大页</strong></p><p>指的是比普通页更大的内存块，常见的大小有2MB和1GB。通常用在使用大量内存的进程上，如Oracle、DPDK等</p></li></ul><p>通过以上机制，在页表的映射下，进程就可以通过虚拟地址来访问物理内存了。那么，具体到一个Linux进程中，这些内存又是怎么使用的呢？</p><h2><span id="虚拟内存空间分布">虚拟内存空间分布</span></h2><p>虚拟内存空间的分布情况，以32位系统为例，如下所示：</p><p><img src="/2019/03/10/Linux性能优化之内存篇/1552218920555.png" alt="1552218920555"></p><p>最上方的是内核空间。虽然，每个进程的地址空间都包含了内核空间，但这些内核空间，其实关联的都是相同的物理内存。</p><p>下方的用户空间内存被划分成了多个不同的段。</p><p>从低到高分别是五种不同的内存段：</p><ol><li>只读段，包括代码和常量等；</li><li>数据段，包括全局变量等；</li><li>堆，包括动态分配的内存，从低地址开始向上增长；</li><li>文件映射段，包括动态库、共享内存等，从高地址开始向下增长；</li><li>栈，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是8MB。</li></ol><p>内存是怎么分配的呢？</p><h2><span id="内存分配与回收">内存分配与回收</span></h2><p>malloc()是C标准库提供的内存分配函数，对应到系统调用上，有两种实现方式，即brk()和mmap()。</p><ul><li><p>对于小块内存（小于128K），C标准库使用brk()来分配内存。也就是通过移动堆顶的位置来分配内存。这些内存释放后并不会立刻归还系统，而是被缓存起来，重复使用。</p><p>缓存的方式，可以减少缺页异常的发生，提高内存访问效率。</p><p>但是由于内存没有归还系统，易造成内存碎片。</p></li><li><p>对于大块内存（大于128K），则直接使用内存映射mmap()来分配。也就是在文件映射段找一块空闲内存分配出去。</p><p>由于释放时，直接归还系统，所以每次mmap都会发生缺页异常。</p><p>大量的缺页异常，使内核的管理负担增大。所以malloc只对大块内存使用mmap。</p></li></ul><p><strong>当这两种调用发生后，其实并没有真正分配内存。这些内存，都只是在首次访问时才被分配，也就是通过缺页异常进入内核中，再由内核来分配内存。</strong></p><p>内核使用伙伴系统来管理内存分配。和MMU一样，伙伴系统也是以页为单位进行管理，并且通过相邻块的合并，减少内存碎片化。</p><p>对于比页更小的对象，比如不到1K的时候，内核通过slab分配器来管理这些小内存。</p><p>对于内存来说，如果只分配而不释放，就会造成内存泄漏，甚至会耗尽系统内存。所以，在应用程序用完内存后，还需要调用free()或unmap()，来释放这些不用的内存。</p><p>在发现内存紧张时，系统会通过以下方式回收内存：</p><ul><li><p>回收缓存，比如使用LRU（Least Recently Used）算法，回收最近使用最少的内存页面；</p></li><li><p>回收不常访问的内存，把不常用的内存通过交换分区直接写到磁盘中。Swap把一块磁盘空间当成内存来用。从内存到磁盘称为换出，从磁盘读取到内存称为换入。</p></li><li><p>杀死进程，通过OOM（Out Of Memory），直接杀死占用大量内存的进程。内核使用oom_score为每个进程的内存使用情况进行评分：</p><ul><li>一个进程消耗的内存越大，oom_score就越大；</li><li>一个进程运行占用的CPU越大，oom_score就越小。</li></ul><p>oom_score越大，越容易被OOM杀死。</p><p>可以通过调整/proc/中进程的oom_adj来调整进程的oom_score。</p><p>oom_adj的范围为[-17, 15]，数值越大，越容易被OOM杀死；-17表示禁止OOM。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo -16 &gt; /proc/$(pidof sshd)/oom_adj</span><br></pre></td></tr></table></figure><p>将sshd进程的oom_adj调小为-16，以使sshd不容易被OOM杀死。</p></li></ul><h2><span id="如何查看内存使用情况">如何查看内存使用情况</span></h2><p>free</p><p><img src="/2019/03/10/Linux性能优化之内存篇/1552275955243.png" alt="1552275955243"></p><p>available不仅包含未使用的内存，还包括了可回收的缓存，所以一般会比未使用内存更大。不过，并不是所有缓存都可以回收，因为有些缓存可能正在使用中。</p><p>top</p><p><img src="/2019/03/10/Linux性能优化之内存篇/1552276016601.png" alt="1552276016601"></p><p>下面部分显示了每个进程的内存使用情况：</p><ul><li>VIRT是进程虚拟内存的大小，只要是进程申请过的内存，即便还没有真正分配物理内存，也会计算在内；</li><li>RES是常驻内存的大小，也就是进程实际使用的物理内存大小，但不包括Swap和共享内存；</li><li>SHR是共享内存的大小，比如与其他进程共同使用的共享内存、加载的动态链接库以及程序的代码段等；需要注意的是，SHR并不一定是共享的，程序的代码段、非共享的动态链接库，也都计算在SHR里。</li><li>%MEM是进程使用物理内存占系统总内存的百分比。</li></ul><h1><span id="buffer和cache">Buffer和Cache</span></h1><p><strong>磁盘读写的缓冲为</strong>Buffer</p><p><strong>文件读写的缓存为</strong>Cache</p><p>注意磁盘读写和文件读写的不同：</p><blockquote><p>磁盘是块设备，可以划分分区，在分区之上再创建文件系统，挂载到某个目录，就可以在这个目录中读写文件。</p></blockquote><p>读写文件时，会经过文件系统，由文件系统和磁盘交互；</p><p>读写磁盘或分区时，会跳过文件系统，也就是裸IO。</p><p>二者所用缓存是不同的。</p><p>Buffer和Cache的设计目的，是为了系统的IO性能。它们利用内存，充当起慢速磁盘和快速CPU之间的桥梁，可以加速IO的访问速度。</p><p>Buffer和Cache分别缓存的是对磁盘和文件系统的读写数据。</p><ul><li>从写的角度来说，不仅可以优化磁盘和文件的写入，对应用程序也有好处，应用程序可以在数据真正落盘前，就返回去做其他工作；</li><li>从读的角度来说，不仅可以提高那些频繁访问数据的读取速度，也降低了频繁IO对磁盘的压力。</li></ul><h1><span id="swap">SWAP</span></h1><p>当内存泄漏时，或者运行了大内存的应用程序，导致系统的内存资源紧张时，系统会如何应对呢？</p><p>可能会导致两种结果：</p><ul><li><p>内存回收</p><p>系统释放掉可以回收的内存，比如缓存和缓冲区，就属于可回收内存。它们在内存管理中，通常被叫做文件页（File-backed Page)。</p><p>大部分文件页，都可以直接回收，以后又需要时，再从磁盘重新读取就可以了。而那些被应用程序修改过，并且暂时还没写入磁盘的数据（脏页），就得先写入磁盘，然后才能进行内存释放。</p><p>这些脏页，一般可以通过两种方式写入磁盘：</p><ul><li>可以在应用程序中，通过系统调用fsync，把脏页同步到磁盘中；</li><li>可以交给系统，由内核线程pdflush负责这些脏页的刷新。</li></ul><p>除了缓存和缓冲区，通过内存映射获取的文件映射页，也是一种常见的文件页。它也可以被释放掉，下次再访问的时候，从文件重新读取。</p><p>而应用程序动态分配的内存（匿名页<sup>Anonymous Page</sup>）是不能直接释放的。但是如果这些内存在分配后很少被访问，可以暂时把它们先存到磁盘里，以释放内存。这就是SWAP机制。</p></li><li><p>OOM杀死进程。</p></li></ul><h2><span id="swap原理">SWAP原理</span></h2><p>Swap就是把一块磁盘空间或者一个本地文件，当成内存来使用。它包括换出和换入两个过程：</p><ul><li><p>换出，就是把进程暂时不用的内存数据存储到磁盘中，并释放这些数据占用的内存；</p></li><li><p>换入，在进程再次访问这些内存的时候，把它们从磁盘读到内存中来</p></li></ul><h1><span id="如何利用系统缓存优化程序的运行效率">如何利用系统缓存优化程序的运行效率</span></h1><p>缓存命中率，指直接通过缓存获取数据的请求次数，占所有数据请求次数的百分比。</p><p>命中率越高，表示使用缓存带来的收益越高，应用程序的性能也就越好。</p><p>实际上，缓存是现在所有高并发系统必需的核心模块，主要作用就是把经常访问的数据（也就是热点数据），提前读入到内存中。以加快应用程序的响应速度。</p><p>缓存分析工具：cachestat和pcstat</p><p>cachestat在CentOS7上的安装详见：<a href="https://jeychu.github.io/2019/03/12/%E5%9C%A8CentOS7%E4%B8%8A%E5%AE%89%E8%A3%85eBPF-tools-bcc%E5%92%8Cply/" target="_blank" rel="noopener">在CentOS7上安装eBPF-tools,bcc和ply</a></p><p>pcstat的安装：</p><ol><li>安装go语言：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wget https://studygolang.com/dl/golang/go1.11.5.linux-amd64.tar.gz</span><br><span class="line">mkdir /opt/go</span><br><span class="line">tar -xvf go1.11.5.linux-amd64.tar.gz -C /opt/go</span><br><span class="line">mkdir /root/gopath</span><br><span class="line">vim /etc/profile</span><br><span class="line">export GOROOT=/opt/go/go</span><br><span class="line">   export PATH=$PATH:$GOROOT/bin</span><br><span class="line">   export GOPATH=/root/gopath</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><p>​         安装完成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@es gopath]# go version</span><br><span class="line">go version go1.11.5 linux/amd64</span><br></pre></td></tr></table></figure><ol start="2"><li>安装pcstat：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir /root/gopath/golang.org/</span><br><span class="line">cd /root/gopath/golang.org</span><br><span class="line">git clone https://github.com/golang/sys.git</span><br><span class="line">go get github.com/tobert/pcstat/pcstat</span><br><span class="line">export PATH=$PATH:/root/gopath/bin</span><br></pre></td></tr></table></figure><p>​           安装完成：</p><p><img src="/2019/03/10/Linux性能优化之内存篇/1552368584437.png" alt="1552368584437"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#linux内存是怎么工作的&quot;&gt;Linux内存是怎么工作的？&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#内存映射&quot;&gt;内存映射&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#虚拟内存空间分布&quot;&gt;虚拟内存空间分布&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>MySQL的监控</title>
    <link href="http://yoursite.com/2019/03/09/MySQL%E7%9A%84%E7%9B%91%E6%8E%A7/"/>
    <id>http://yoursite.com/2019/03/09/MySQL的监控/</id>
    <published>2019-03-08T18:05:10.000Z</published>
    <updated>2019-03-09T06:17:27.047Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL</p><p>监控哪些内容？</p><ul><li>数据库服务的可用性</li><li>数据库性能</li><li>主从同步的情况</li><li>服务器的资源</li><li></li></ul><p>怎么监控？</p><p>调优</p><p>先找出瓶颈所在，然后针对瓶颈做出优化</p><p>如何找瓶颈？</p><p>利用top ps vmstat iostat netstat /proc/</p><p>然后用perf strace ltrace systemtap 追踪进程 定位函数</p><p>zabbix添加自定义监控项</p><p>写脚本 -&gt; 在agentd.conf中添加UserParameter -&gt; 在server中用zabbix-get测试 -&gt;在web添加item和graph</p><p>故障排查思路：</p><p>网络 DNS解析是否正常 ping延时</p><p>主机</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;MySQL&lt;/p&gt;
&lt;p&gt;监控哪些内容？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据库服务的可用性&lt;/li&gt;
&lt;li&gt;数据库性能&lt;/li&gt;
&lt;li&gt;主从同步的情况&lt;/li&gt;
&lt;li&gt;服务器的资源&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;怎么监控？&lt;/p&gt;
&lt;p&gt;调优&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>The Kernel of Nginx之用好浏览器的缓存</title>
    <link href="http://yoursite.com/2019/03/06/The-Kernel-of-Nginx%E4%B9%8B%E7%94%A8%E5%A5%BD%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98/"/>
    <id>http://yoursite.com/2019/03/06/The-Kernel-of-Nginx之用好浏览器的缓存/</id>
    <published>2019-03-06T03:02:25.000Z</published>
    <updated>2019-03-08T12:57:26.489Z</updated>
    
    <content type="html"><![CDATA[<p>浏览器的缓存与nginx缓存</p><ul><li><p>浏览器缓存</p><ul><li>优点：<ul><li>使用有效缓存时，没有网络消耗，速度最快</li><li>即使有网络消耗，但对失效缓存使用304响应做到网络流量消耗最小化</li></ul></li><li>缺点：<ul><li>只提升一个用户的体验</li></ul></li></ul></li><li><p>Nginx缓存</p><ul><li>优点<ul><li>提升所有用户的体验</li><li>相比浏览器缓存，有效降低上游服务的负载</li><li>通过304响应减少Nginx与上游服务间的流量消耗</li></ul></li><li>缺点<ul><li>用户仍然保持网络消耗</li></ul></li></ul></li></ul><p>同时使用浏览器和Nginx缓存</p><p>浏览器缓存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 浏览器请求</span><br><span class="line">op1=&gt;operation: 有缓存</span><br><span class="line">op2=&gt;operation: 向浏览器请求带If-None_Match</span><br><span class="line">op3=&gt;operation: 向浏览器请求带If-Modified-Since</span><br><span class="line">op4=&gt;operation: 从缓存读取 200（from cache）</span><br><span class="line">op5=&gt;operation: 向web服务器请求</span><br><span class="line">op6=&gt;operation: 请求响应，缓存协商</span><br><span class="line">op7=&gt;operation: 从缓存读取</span><br><span class="line">con1=&gt;condition: 是否过期？</span><br><span class="line">con2=&gt;condition: Etag？</span><br><span class="line">con3=&gt;condition: Last-Modified？</span><br><span class="line">con4=&gt;condition: 200 or 304？</span><br><span class="line">end=&gt;end: 呈现</span><br><span class="line">st-&gt;op1-&gt;con1</span><br><span class="line">con1(no)-&gt;op4-&gt;end</span><br><span class="line">con1(yes)-&gt;con2</span><br><span class="line">con2(yes)-&gt;op2-&gt;con4</span><br><span class="line">con2(no)-&gt;con3</span><br><span class="line">con3(yes)-&gt;op3-&gt;con4</span><br><span class="line">con3(no)-&gt;op5-&gt;op6</span><br><span class="line">con4(yes)-&gt;op6</span><br><span class="line">con4(no)-&gt;op7-&gt;end</span><br><span class="line">op6-&gt;end</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax： etag on|off;</span><br><span class="line">Default: etag on;</span><br><span class="line">Context: http, server, location</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ngx_sprintf(etag-&gt;value.data, <span class="string">"\"%xT-%xO\""</span>,</span><br><span class="line">           r-&gt;headers_out.last_modified_time,</span><br><span class="line">           r-&gt;headers_out.contect_length_n)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;浏览器的缓存与nginx缓存&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;浏览器缓存&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：&lt;ul&gt;
&lt;li&gt;使用有效缓存时，没有网络消耗，速度最快&lt;/li&gt;
&lt;li&gt;即使有网络消耗，但对失效缓存使用304响应做到网络流量消耗最小化&lt;/li&gt;
&lt;/ul&gt;
&lt;/
      
    
    </summary>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
</feed>
