<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>javfa&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-02-28T15:02:21.320Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Javfa</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微服务设计</title>
    <link href="http://yoursite.com/2019/02/28/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2019/02/28/微服务设计/</id>
    <published>2019-02-28T14:53:03.000Z</published>
    <updated>2019-02-28T15:02:21.320Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="微服务">微服务</span></h1><h1><span id="演化式架构师">演化式架构师</span></h1><h1><span id="如何建模服务">如何建模服务</span></h1><h1><span id="集成">集成</span></h1><h1><span id="分解单块系统">分解单块系统</span></h1><h1><span id="部署">部署</span></h1><h1><span id="测试">测试</span></h1><h1><span id="监控">监控</span></h1><h1><span id="安全">安全</span></h1><h1><span id="康威定律和系统设计">康威定律和系统设计</span></h1><h1><span id="规模化微服务">规模化微服务</span></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;微服务&quot;&gt;微服务&lt;/span&gt;&lt;/h1&gt;&lt;h1&gt;&lt;span id=&quot;演化式架构师&quot;&gt;演化式架构师&lt;/span&gt;&lt;/h1&gt;&lt;h1&gt;&lt;span id=&quot;如何建模服务&quot;&gt;如何建模服务&lt;/span&gt;&lt;/h1&gt;&lt;h1&gt;&lt;span id=&quot;集成&quot;&gt;集成&lt;/span
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>红黑树</title>
    <link href="http://yoursite.com/2019/02/28/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>http://yoursite.com/2019/02/28/红黑树/</id>
    <published>2019-02-28T11:07:51.000Z</published>
    <updated>2019-02-28T11:07:51.982Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Web客户端追踪</title>
    <link href="http://yoursite.com/2019/02/28/Web%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%BD%E8%B8%AA/"/>
    <id>http://yoursite.com/2019/02/28/Web客户端追踪/</id>
    <published>2019-02-28T08:30:46.000Z</published>
    <updated>2019-02-28T08:30:46.775Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript In A Nutshell</title>
    <link href="http://yoursite.com/2019/02/26/JavaScript-In-A-Nutshell/"/>
    <id>http://yoursite.com/2019/02/26/JavaScript-In-A-Nutshell/</id>
    <published>2019-02-25T17:49:28.000Z</published>
    <updated>2019-02-28T15:03:24.386Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="基础">基础</span></h1><h2><span id="运行时页面构建过程">运行时页面构建过程</span></h2><h1><span id="理解函数">理解函数</span></h1><p>定义与参数</p><p>理解函数调用</p><p>闭包和作用域</p><p>生成器和promise</p><h1><span id="钻研对象">钻研对象</span></h1><p>面向对象与原型</p><p>控制对象的访问</p><p>处理集合</p><p>正则表达式</p><p>代码模式化</p><h1><span id="洞悉浏览器">洞悉浏览器</span></h1><p>DOM操作</p><p>事件</p><p>跨浏览器的开发技巧</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;基础&quot;&gt;基础&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span id=&quot;运行时页面构建过程&quot;&gt;运行时页面构建过程&lt;/span&gt;&lt;/h2&gt;&lt;h1&gt;&lt;span id=&quot;理解函数&quot;&gt;理解函数&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;定义与参数&lt;/p&gt;
&lt;p&gt;理解函数调用&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Nginx的配置</title>
    <link href="http://yoursite.com/2019/02/21/Nginx%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/02/21/Nginx的配置/</id>
    <published>2019-02-21T15:21:21.000Z</published>
    <updated>2019-02-24T12:50:13.731Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="运行中的nginx进程间的关系">运行中的Nginx进程间的关系</span></h1><p>在正式提供服务的产品环境中，部署Nginx时都是使用一个master进程来管理多个worker进程，一般情况下，worker进程的数量与服务器上的CPU核心数相等。每一个worker进程都时繁忙的，它们在真正地提供互联网服务，master进程则很“清闲”，只负责监控管理worker进程。worker之间通过共享内存、原子操作等一些进程间通信机制来实现负载均衡等功能。</p><p>Nginx是支持单进程（master进程）提供服务的，那么为什么产品环境下要按照master、worker方式配置同时启动多个进程呢？这样做的好处主要有一下两点：</p><ul><li>由于master进程不会对用户请求提供服务，只用于管理真正提供服务的worker进程，所以master进程可以是唯一的，它仅专注于自己的纯管理工作，为管理员提供命令行服务，包括诸如启动服务、停止服务、重新配置文件、平滑升级程序等。master进程需要拥有较大的权限，例如，通常会使用root用户启动master进程。worker进程的权限要小于或者等于master进程，这样master进程才可以完全地管理worker进程。当任意一个worker进程出现错误从而导致coredump时，master进程会立刻启动新的worker进程继续服务。</li><li>多个worker进程处理互联网请求不但可以提高服务的健壮性，最重要的是，这样可以充分利用现在常见的SMP多核架构，从而实现微观上真正的多核并发处理。为什么要把worker进程数量设置得跟CPU核心数量一致呢？对于Nginx，一个worker进程可以同时处理的请求数只受限于内存大小，而且在架构上，<strong>不同的worker进程之间处理并发请求时几乎没有同步锁的限制</strong>，worker进程通常不会进入睡眠状态，因此，当Nginx上的进程数与CPU核心数相等时（最好每一个worker进程都绑定特定的CPU核心【使用taskset命令来设置进程的CPU亲和性（affinity），将进程绑定到某个或某组CPU核心上】），进程间的切换的代价是最小的。</li></ul><h1><span id="nginx服务的基本配置">Nginx服务的基本配置</span></h1><h2><span id="用于调试进程和定位问题的配置项">用于调试进程和定位问题的配置项</span></h2><ol><li><p>是否以守护进程方式运行Nginx</p><p>语法：daemon on|off;</p><p>默认：daemon on;</p><p>关闭守护进程的模式，方便使用gdb跟踪调试Nginx，在研究Nginx架构时很有用。</p></li><li><p>是否以master/worker方式工作</p><p>语法：master_process on | off;</p><p>默认：master_process on;</p><p>如果用off关闭了master_process方式，就不会fork出worker子进程来处理请求，而是用master进程自身来处理请求。</p></li><li><p>error日志的位置</p><p>语法：error_log /path/file level;</p><p>默认：error_log logs/error.log error;</p><p>error日志是定位Nginx问题的最佳工具，我们可以根据自己的需求妥善设置error日志的路径和级别。<br>/path/file可以是：</p><ul><li>一个具体的文件，例如，默认情况下是logs/error.log文件，最好将它放到一个磁盘空间足够大的位置；</li><li>也可以是/dev/null，这也是关闭error日志的唯一方法；</li><li><p>也可以是stderr，将日志输出到标准错误文件中；</p><p>level是日志的输出级别，取值范围是debug、info、notice、warn、error、crit、alert、emerg，从左到右级别依次增大。当设定一个级别时，大于或者等于该级别的日志都会输出到/path/file文件中，小于该级别的日志则不会输出。</p><p>如果日志级别设定到debug，必须在configure时加入–with-debug配置项。</p></li></ul></li><li><p>是否处理几个特殊的调试点</p><p>语法：debug_points [stop|abort]</p><p>这个配置项也是用来帮助用户跟踪调试Nginx的。Nginx在一些关键的错误逻辑中设置了调试点。如果设置了debug_points为stop，那么Nginx的代码执行到这些调试点时就会发出SIGSTOP信号以用于调试。如果设置为abort，则会产生一个coredump文件，可以使用gdb来查看Nginx当时的各种信息。</p></li><li><p>仅对指定的客户端输出debug级别的日志</p><p>语法：debug_connection [IP|CIDR]</p><p>这个配置项实际上属于事件类配置，因此，它必须放在events {…}中才有效。</p><p>对来自于指定IP地址的请求才会输出debug级别的日志，其他请求仍然沿用error_log中配置的日志级别。</p></li><li><p>限制coredump核心转储文件的大小</p><p>语法：worker_rlimit_core size;</p><p>在Linux系统中，当进程发生错误或收到信号而终止时，系统会将进程执行时的内存内容写入一个文件，以作为调试只用，这就是所谓的核心转储（core dumps）.</p></li><li><p>指定coredump文件生成目录</p><p>语法：working_directory path;</p></li></ol><h2><span id="正常运行的配置项">正常运行的配置项</span></h2><ol><li><p>定义环境变量</p><p>语法：env VAR|VAR=VALUE;</p><p>这个配置项可以让用户直接设置操作系统上的环境变量。</p></li><li><p>嵌入其他配置文件</p><p>语法：include /path/file;</p></li><li><p>pid文件的路径</p><p>语法：pid /path/file;</p><p>默认：pid logs/nginx.pid;</p></li><li><p>Nginx worker进程运行的用户和用户组</p><p>语法：user username [groupname];</p><p>默认：user nobody nodoby;</p></li><li><p>指定Nginx worker进程可以打开的最大句柄描述符个数</p><p>语法：worker_rlimit_nofile limit;</p></li><li><p>限制信号队列</p><p>语法：worker_rlimit_sigpending limit;</p><p>设置每个用户发往Nginx的信号队列的大小。也就是说，当某个用户的信号队列满了，这个用户再发送的信号量就会被丢掉。</p></li></ol><h2><span id="优化性能的配置项">优化性能的配置项</span></h2><ol><li><p>Nginx worker进程个数</p><p>语法：worker_processes number;</p><p>默认：worker_processes 1;</p></li><li><p>绑定Nginx worker进程到指定的CPU内核</p><p>语法：worker_cpu_affinity cpumask [cpumask…]</p><p>例如，如果有4个CPU内核，可以进行如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">worker_processes 4;</span><br><span class="line">worker_cpu_affinity 1000 0100 0010 0001;</span><br></pre></td></tr></table></figure></li><li><p>SSL硬件加速</p><p>语法：ssl_engine device;</p><p>如果服务器上有ssl硬件加速设备，那么就可以进行配置以加快SSL协议的处理速度。</p></li><li><p>系统调用gettimeofday的执行频率</p><p>语法：timer_resolution t;</p><p>默认情况下，每次内核的事件调用（如epoll、select、poll、kqueue等）返回时，都会执行一次gettimeofday，实现用内核的时钟来更新Nginx中的缓存时钟。</p><p>在早期的内核中，gettimeofday的执行代价不小，因为中间有一次内核态到用户态的内存复制。需要降低gettimeofday的调用频率时，可以使用该配置项，表示至少每t秒才调用一次。</p><p>但在目前的大多数内核中，gettimeofday只是一次vsyscall，仅仅是对共享内存页中的数据做访问，并不是通常的系统调用，代价不大，一般不必使用这个配置。</p></li><li><p>Nginx worker进程优先级设置</p><p>语法：worker_priority nice;</p><p>默认：worker_pricrity 0;</p><p>当有多个进程处于可执行状态时，系统将按照所有进程的优先级来决定本次内核选择哪一个进程执行。</p><p>进程所分配的时间片大小也与进程优先级相关，优先级越高，进程分配到的时间片也就越大。</p><p>（在默认配置下，最小的时间片时5ms，最大的时间片则有800ms。）</p><p>这样，优先级高的进程会占有更多的系统资源。</p></li></ol><h2><span id="事件类配置项">事件类配置项</span></h2><ol><li><p>是否打开accept锁</p><p>语法：accept_mutex [on|off];</p><p>默认：accept_mutex on;</p><p>accept_mutex是Nginx的负载均衡锁。</p><p>这把锁可以让多个worker进程轮流地、序列化地与新的客户端建立TCP连接。</p><p>当某个worker进程建立的连接数量达到worker_connections配置的最大连接数的7/8时，会大大地减小该worker进程试图建立新TCP连接的机会，以此实现所有的worker进程之上处理的客户端请求数尽量接近。</p><p>如果关闭它，那么建立TCP连接的耗时会更短，但worker进程之间的负载会非常不均衡。不建议关闭它。</p></li><li><p>lock文件的路径</p><p>语法：lock_file path/file;</p><p>默认：lock_file logs/nginx.lock;</p><p>accept_mutex为off时，此配置完全不生效。</p><p>accept_mutex为on是，若由于编译程序、操作系统导致Nginx不支持原子锁，这时会用文件锁来实现accecpt锁，此时lock_file所指定的lock文件才会生效。</p><blockquote><p><strong>文件锁</strong>：在多任务操作系统中，如果一个进程尝试对正在被其他进程读取的文件进行写操作，可能会导致正在进行读操作的进程读取到一些被破坏或者不完整的数据；如果两个进程并发对同一个文件进行写操作，可能会导致该文件遭到破坏。因此，为了避免发生这种问题，必须要采用某种机制来<strong>解决多个进程并发访问同一个文件时所面临的同步问题</strong>，由此而产生了文件加锁方面的技术。</p><p>Linux支持的文件锁主要包括劝告锁（advisory lock）和强制锁（mandatory lock）这两种。此外，Linux中还引入了两种强制锁的变种形式：共享模式强制锁（share-mode mandatory lock）和租借锁（lease）。</p></blockquote></li><li><p>使用accept锁后到真正建立连接之间的延迟时间</p><p>语法：accept_mutex_delay Nms;</p><p>默认：accept_mutex_delay 500ms;</p><p>在使用accept锁后，同一时间只有一个worker进程能够取到accept锁。这个锁不是阻塞锁，如果取不到会立刻返回。如果有一个worker进程试图取锁而未得，它至少要等该配置项所定义的时间间隔后才能再次试图取锁。</p></li><li><p>批量建立新连接</p><p>语法：multi_accept [on|off];</p><p>默认：multi_accept off;</p><p>当事件模型通知有新连接时，尽可能地对本次调度中客户端发起的所有TCP请求都建立连接。</p></li><li><p>选择事件模型</p><p>语法：use [kqueue|rtsig|epoll|/dev/poll|select|poll|eventport];</p><p>默认：Nginx会自动使用最合适的事件模型。</p><p>在Linux系统中，epoll性能是最高的。</p></li><li><p>每个worker的最大连接数</p><p>语法：worker_connections number;</p><p>定义每个worker进程可以同时处理的最大连接数。</p></li></ol><h1><span id="使用http核心模块配置一个静态web服务器">使用HTTP核心模块配置一个静态Web服务器</span></h1>]]></content>
    
    <summary type="html">
    
      Nginx的配置详解
    
    </summary>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Web性能基础</title>
    <link href="http://yoursite.com/2019/02/21/Web%E6%80%A7%E8%83%BD%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/02/21/Web性能基础/</id>
    <published>2019-02-21T02:54:57.000Z</published>
    <updated>2019-02-24T12:48:20.377Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="网络技术概览">网络技术概览</span></h1><h2><span id="延迟与带宽">延迟与带宽</span></h2><p>速度是关键</p><p>WPO（Web Performance Optimization）产业从无到有，快速增长，充分说明用户越来越重视速度方面的用户体验。</p><p>业绩证实：</p><ul><li>网站越快，用户的黏性越高</li><li>网站越快，用户忠诚度更高</li><li>网站越快，用户转化率越高</li></ul><p>延迟和带宽：</p><ul><li><p>延迟：分组从信息源发送到目的地所需的时间</p></li><li><p>带宽：逻辑或物理通信路径最大的吞吐量</p></li></ul><p>延迟的构成：</p><ul><li>传播延迟<br>消息从发送端到接收端需要的时间，是信号传播距离和速度的函数</li><li>传输延迟<br>把消息中的所有比特转移到链路中需要的时间，是消息长度和链路速率的函数</li><li>处理延迟<br>处理分组首部、检查位错误及确定分组目标所需的时间</li><li>排队延迟<br>到来的分组排队等待处理的时间</li></ul><blockquote><p>在软件交互中，哪怕100-200ms左右的延迟，大多数人都会感觉到‘拖拉’；如果超过了300ms的门槛，就会说“反应迟钝”。</p></blockquote><blockquote><p>光速与分组在介质中传播速度之比，叫做该介质的折射率。我们大都假定光纤的折射率约为1.5，即光通过光纤的速度约为每秒200，000，000米。</p></blockquote><h2><span id="tcp">TCP</span></h2><h2><span id="udp">UDP</span></h2><h2><span id="tls">TLS</span></h2><h1><span id="无线网络性能">无线网络性能</span></h1><h2><span id="wifi">WIFI</span></h2><h2><span id="移动网络">移动网络</span></h2><h1><span id="http">HTTP</span></h1><h2><span id="http-1x">HTTP 1.x</span></h2><h2><span id="http-20">HTTP 2.0</span></h2><h2><span id="优化应用的交付">优化应用的交付</span></h2><h1><span id="浏览器api与协议">浏览器API与协议</span></h1><h2><span id="xmlhttprequest">XMLHttpRequest</span></h2><h2><span id="服务器发送事件">服务器发送事件</span></h2><h2><span id="websocket">websocket</span></h2><p>WebSocket可以实现客户端与服务器间同时双向、基于消息的文本或二进制数据传输。<br>WebSocket使得浏览器具备了实时、双向通信的能力，是由HTML5开始提供的一种浏览器与服务器进行全双工通讯的网络技术，属于应用层协议。基于TCP传输协议，并复用HTTP的握手通道。</p><ul><li>优点：<ul><li>支持双向通信，实时性更强</li><li>更好的支持二进制</li><li>较少的控制开销。连接创建后，ws客户端、服务的进行数据交换时，协议控制的数据包头部较小。</li><li>支持扩展。可以扩展协议，实现自定义的自协议（如自定义压缩算法等）</li></ul></li></ul><h3><span id="1-入门例子">1. 入门例子：</span></h3><ul><li>1.1 <strong>服务端</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="built_in">require</span>(<span class="string">'express'</span>)();</span><br><span class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">'http'</span>).Server(app);</span><br><span class="line"><span class="keyword">var</span> WebSocket = <span class="built_in">require</span>(<span class="string">'ws'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wss = <span class="keyword">new</span> WebSocket.Server(&#123; <span class="attr">port</span>: <span class="number">8080</span> &#125;);</span><br><span class="line"></span><br><span class="line">wss.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> <span class="title">connection</span>(<span class="params">ws</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'server: receive connection.'</span>);</span><br><span class="line">    </span><br><span class="line">    ws.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> <span class="title">incoming</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'server: received %s'</span>, message);</span><br><span class="line">        ws.send(<span class="string">'server: reply'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    ws.on(<span class="string">'pong'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'server: received pong from client'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    ws.send(<span class="string">'world'</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// setInterval(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//     ws.ping('', false, true);</span></span><br><span class="line">    <span class="comment">// &#125;, 2000);</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.sendfile(__dirname + <span class="string">'/index.html'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><ul><li>1.2 <strong>客户端</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:8080'</span>);</span><br><span class="line">  ws.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'ws onopen'</span>);</span><br><span class="line">    ws.send(<span class="string">'from client: hello'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  ws.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'ws onmessage'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'from server: '</span> + e.data);</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><ul><li>1.3 <strong>运行结果</strong></li></ul><p><em>服务端输出</em>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server: receive connection.</span><br><span class="line">server: received hello</span><br></pre></td></tr></table></figure></p><p><em>客户端输出</em>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">client: ws connection is open</span><br><span class="line">client: received world</span><br></pre></td></tr></table></figure></p><h3><span id="2-如何建立连接">2. 如何建立连接</span></h3><p>WebSocket复用了HTTP的握手通道。具体是指，客户端通过HTTP请求与WebSocket服务器协商升级协议。</p><ul><li><p>2.1. 客户端：申请协议升级</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: localhost:8080</span><br><span class="line">Origin: http://127.0.0.1:3000</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Sec-WebSocket-Key: w4v7O6xFTi36lq3RNcgctw==</span><br></pre></td></tr></table></figure></li><li><p>2.2. 服务端：响应协议升级</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Connection:Upgrade</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Sec-WebSocket-Accept: Oy4NRAQ13jhfONC7bP8dTKb4PTU=</span><br></pre></td></tr></table></figure></li><li><p>2.3. Sec-WebSocket-Accept的计算</p></li></ul><p>伪代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;toBase64( sha1( Sec-WebSocket-Key +258EAFA5-E914-47DA-95CA-C5AB0DC85B11 )  )</span><br></pre></td></tr></table></figure></p><h3><span id="3-数据帧格式">3. 数据帧格式</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-------+-+-------------+-------------------------------+</span><br><span class="line">|F|R|R|R| opcode|M| Payload len |    Extended payload length    |</span><br><span class="line">|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |</span><br><span class="line">|N|V|V|V|       |S|             |   (if payload len==126/127)   |</span><br><span class="line">| |1|2|3|       |K|             |                               |</span><br><span class="line">+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</span><br><span class="line">|     Extended payload length continued, if payload len == 127  |</span><br><span class="line">+ - - - - - - - - - - - - - - - +-------------------------------+</span><br><span class="line">|                               |Masking-key, if MASK set to 1  |</span><br><span class="line">+-------------------------------+-------------------------------+</span><br><span class="line">| Masking-key (continued)       |          Payload Data         |</span><br><span class="line">+-------------------------------- - - - - - - - - - - - - - - - +</span><br><span class="line">:                     Payload Data continued ...                :</span><br><span class="line">+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</span><br><span class="line">|                     Payload Data continued ...                |</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure><h3><span id="4-数据传递">4. 数据传递</span></h3><p>使用场景及性能</p><h2><span id="webrtc">WebRTC</span></h2>]]></content>
    
    <summary type="html">
    
      有关于Web性能的基础知识
    
    </summary>
    
    
      <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Discover the Secrets of Linux Kernel</title>
    <link href="http://yoursite.com/2019/02/20/Linux-Kernel/"/>
    <id>http://yoursite.com/2019/02/20/Linux-Kernel/</id>
    <published>2019-02-20T08:47:55.000Z</published>
    <updated>2019-02-28T14:46:09.366Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#如何学习内核">如何学习内核：</a><ul><li><a href="#将内核划分成两层减少内核阅读的难度">将内核划分成两层，减少内核阅读的难度</a><ul><li><a href="#内核基础层">内核基础层</a></li><li><a href="#内核应用层">内核应用层</a></li></ul></li><li><a href="#内核学习最终目的">内核学习最终目的：</a></li></ul></li><li><a href="#内核的基础层和应用层">内核的基础层和应用层</a><ul><li><a href="#内核基础层提供的服务">内核基础层提供的服务</a><ul><li><a href="#内核中使用内存">内核中使用内存</a></li><li><a href="#内核中的任务调度">内核中的任务调度</a></li><li><a href="#软中断和tasklet">软中断和tasklet</a></li><li><a href="#工作队列">工作队列</a></li><li><a href="#自旋锁">自旋锁</a></li><li><a href="#内核信号量">内核信号量</a></li><li><a href="#原子变量">原子变量</a></li></ul></li><li><a href="#内核基础层的数据结构">内核基础层的数据结构</a><ul><li><a href="#双向链表">双向链表</a></li><li><a href="#hash链表">hash链表</a></li><li><a href="#单向链表">单向链表</a></li><li><a href="#红黑树">红黑树</a></li><li><a href="#radix树">radix树</a></li></ul></li><li><a href="#内核应用层-1">内核应用层</a></li></ul></li><li><a href="#文件系统">文件系统</a></li><li><a href="#设备的概念和总体架构">设备的概念和总体架构</a></li><li><a href="#为设备服务的特殊文件系统sysfs">为设备服务的特殊文件系统sysfs</a></li><li><a href="#字符设备和input设备">字符设备和input设备</a></li></ul><!-- tocstop --><h1><span id="如何学习内核">如何学习内核：</span></h1><ul><li>以应用为目的来学习，边学边用，学以致用</li><li>以培养内核的阅读能力为主要目标</li><li>阅读和修改真实的代码，而非只是阅读书籍</li><li>需要不断的更新和学习，因为内核的策略和方法一直在不断的变化着</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">勿贪大求全，聚焦关键应用</span><br><span class="line">奠定基础，循序渐进</span><br><span class="line">兴趣是第一驱动力</span><br></pre></td></tr></table></figure><h2><span id="将内核划分成两层减少内核阅读的难度">将内核划分成两层，减少内核阅读的难度</span></h2><h3><span id="内核基础层">内核基础层</span></h3><blockquote><p>内核中提供基础服务的部分</p></blockquote><ul><li>代码总量很少，但难度高</li><li>提供基本稳定的API</li><li>数据结构 </li><li>内核同步机制</li><li>内存管理和任务调度</li><li>学习方法：<ul><li>以API接口学习为主要内容，不细究实现</li><li>日后应该加强基础层的研读</li></ul></li></ul><h3><span id="内核应用层">内核应用层</span></h3><blockquote><p>建立在基础层之上，提供应用服务的部分</p></blockquote><ul><li>占代码的90%以上，数量多，重复性强</li><li>接口经常变化</li><li>文件系统 </li><li>设备和驱动</li><li>网络</li><li>学习方法：<ul><li>文件系统是应用层的基础和灵魂</li><li>从文件系统入手，驻步扩展</li><li>以架构为核心，举一反三</li><li>设备和驱动不依赖具体设备，以通用架构为主</li></ul></li></ul><h2><span id="内核学习最终目的">内核学习最终目的：</span></h2><ul><li>独立思考，独立学习，不断分享成为在该领域有影响力的专家</li></ul><h1><span id="内核的基础层和应用层">内核的基础层和应用层</span></h1><h2><span id="内核基础层提供的服务">内核基础层提供的服务</span></h2><p>内核通常提供的服务是内存管理、进程管理、设备管理和文件系统。</p><h3><span id="内核中使用内存">内核中使用内存</span></h3><p>内核中提供了两个层次的内存分配接口：</p><ul><li><p>从伙伴系统分配：是最底层的内存管理机制，提供页式的内存管理。</p><p>伙伴系统分配内存调用的是alloc_pages，得到的是页面地址，如果要获得能使用的内存地址，还需要用page_address。</p><p>如果要直接获得内存地址，需要使用_get_free_pages。它封装了alloc_pages和page_address两个函数。</p></li><li><p>从slab系统分配：是伙伴系统之上的内存管理，提供基于对象的内存管理。</p><p>alloc_pages申请的内存是以页为单元的，最少是一个页。如果只是申请一小块内存，一个页就很浪费，而且内核中很多应用也希望一种对象化的内存管理，希望内存管理能自动地构造和析构对象，这就是slab内存管理。</p><p>使用kmem_cache_create创建slab对象来从slab申请内存。kmem_cache_create可以提供对象的名字和大小、构造函数和析构函数等，然后通过kmem_cache_alloc和kmem_cache_free来申请和释放内存。</p><p>内核中常用的kmalloc其实也是slab提供的对象管理，只不过内核已经构建了一些固定大小的对象，用户通过kmalloc申请的时候，就直接使用了这些对象。</p><p>一个内核中创建slab对象的例子如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bh_cachep = kmem_cache_create(<span class="string">"buffer_head"</span>,</span><br><span class="line">                              <span class="keyword">sizeof</span>(struct buffer_head), <span class="number">0</span>,</span><br><span class="line">                              (SLAB_RECLAIM_ACCOUNT|SLAB_PANIC|SLAB_MEM_SPREAD),</span><br><span class="line">                              init_buffer_head,</span><br><span class="line">                              <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>用以下代码申请一个slab对象：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">ret</span> = <span class="title">kmem_cache_alloc</span>(<span class="title">bh_cachep</span>, <span class="title">gfp_flags</span>);</span></span><br></pre></td></tr></table></figure><p>内核中另一个内存分配调用vmalloc的作用是把物理内存不连续的内存页面拼凑为逻辑地址连续的内存区间。</p></li></ul><h3><span id="内核中的任务调度">内核中的任务调度</span></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> wait_event(wq, condition)</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (condition)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    __wait_event(wq, condition);</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __wait_event(wq, condition)</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    DEFINE_WAIT(__wait);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        prepare_to_wait(&amp;wq, &amp;__wait, TASK_UNINTERRUPTIBLE);</span><br><span class="line">        <span class="keyword">if</span> (condition)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        schedule();</span><br><span class="line">    &#125;</span><br><span class="line">    finish_wait(&amp;wq, &amp;__wait);</span><br><span class="line">&#125;<span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>上文定义了一个wait结构，然后设置进程睡眠。如果其他进程唤醒这个进程后，判断条件是否满足，如果满足，删除wait对象，否则进程继续睡眠。</p><h3><span id="软中断和tasklet">软中断和tasklet</span></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_TASKLET_DISABLED(hil_mlcs_tasklet, hil_mlcs_process, <span class="number">0</span>);</span><br><span class="line">tasklet_schedule(&amp;hil_mlcs_tasklet);</span><br></pre></td></tr></table></figure><h3><span id="工作队列">工作队列</span></h3><p>和tasklet类似，都是一种延缓执行的机制。</p><p>不同之处是工作队列有自己的进程上下文，所以工作队列可以睡眠，也可以被调度，而tasklet不可睡眠。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INIT_WORK(&amp;ioc-&gt;sas_persist_task,</span><br><span class="line">         mptsas_persist_clear_table,</span><br><span class="line">         (<span class="keyword">void</span> *)ioc);</span><br><span class="line">schedule_work(&amp;ioc-&gt;sas_persist_task);</span><br></pre></td></tr></table></figure><h3><span id="自旋锁">自旋锁</span></h3><p>用来在多处理器的环境下保护数据。</p><p>如果内核发现数据未锁，就获取锁并运行；如果数据被锁，就一直旋转（其实是一直反复执行一条指令）。之所以说自旋锁用在多处理器环境，是因为在单处理器环境（非抢占式内核）下，自旋锁其实不起作用。在单处理器抢占式内核的情况下，自旋锁起到禁止抢占的作用。</p><p>因为被自旋锁锁着的进程一直旋转，而不是睡眠，所以自旋锁可以用在中断等禁止睡眠的场景。</p><p>自旋锁的使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spin_lock(shost-&gt;host_lock);</span><br><span class="line">shost-&gt;host_busy++;</span><br><span class="line">spin_unlock(shost-&gt;host_lock);</span><br></pre></td></tr></table></figure><h3><span id="内核信号量">内核信号量</span></h3><p>和自旋锁类似，作用是保护数据。</p><p>不同之处在于，进程获取内核信号量的时候，如果不能获取，则进程进入睡眠状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">down(&amp;dev-&gt;sem);</span><br><span class="line">up(&amp;dev-&gt;sem);</span><br></pre></td></tr></table></figure><h3><span id="原子变量">原子变量</span></h3><p>提供了一种原子的、不可中断的操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atomic_t mapped;</span><br></pre></td></tr></table></figure><p>内核提供了一系列的原子变量操作函数，如下所示</p><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td>atomic_add</td><td>加一个整数到原子变量</td></tr><tr><td>atomic_sub</td><td>从原子变量减一个整数</td></tr><tr><td>atomic_read</td><td>读原子变量的数值</td></tr><tr><td>atomic_set</td><td>设置原子变量的数值</td></tr></tbody></table><h2><span id="内核基础层的数据结构">内核基础层的数据结构</span></h2><p>container是Linux中很重要的一个概念，使用container能实现对象的封装。代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> container_of(ptr, type, member) (&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="title">typeof</span><span class="params">(((type *)<span class="number">0</span>)-&gt;member)</span> *__mptr </span>= (ptr);</span><br><span class="line">  (type *)((<span class="keyword">char</span> *)__mptr - offsetof(type, member));&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offsetof(type, member) (size_t)&amp;(((type*)0)-&gt;member)</span></span><br></pre></td></tr></table></figure><p>这个方法可以实现通过结构的一个成员找到整个结构的地址。内核中大量使用了这个方法。</p><h3><span id="双向链表">双向链表</span></h3><p>list是双向链表的一个抽象，定义在/include/linux目录下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_entry(ptr, type, member)</span></span><br><span class="line">container_of(ptr, type, member)</span><br></pre></td></tr></table></figure><table><thead><tr><th>内联函数和宏</th><th>作用</th></tr></thead><tbody><tr><td>LIST_HEAD</td><td>定义并初始化一个list链表</td></tr><tr><td>list_add_tail</td><td>加一个成员到链表尾</td></tr><tr><td>list_del</td><td>删除一个list成员</td></tr><tr><td>list_empty</td><td>检测链表是否为空</td></tr><tr><td>list_for_each</td><td>遍历链表</td></tr><tr><td>list_for_each_safe</td><td>遍历链表（可以删除遍历的成员）</td></tr><tr><td>list_for_each_entry</td><td>遍历链表（通过container方法返回结构指针）</td></tr></tbody></table><h3><span id="hash链表">hash链表</span></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">first</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="单向链表">单向链表</span></h3><h3><span id="红黑树">红黑树</span></h3><p>红黑树是一种自平衡的二叉树，代码位于/lib/rbtree.c文件。</p><h3><span id="radix树">radix树</span></h3><h2><span id="内核应用层">内核应用层</span></h2><h1><span id="文件系统">文件系统</span></h1><p>基本概念</p><p>文件系统的架构</p><p>从代码层深入分析文件系统</p><h1><span id="设备的概念和总体架构">设备的概念和总体架构</span></h1><p>设备的配置表</p><p>访问设备寄存器和设备内存</p><p>设备中断和DMA</p><p>总线对设备的扫描</p><p>设备驱动管理</p><h1><span id="为设备服务的特殊文件系统sysfs">为设备服务的特殊文件系统sysfs</span></h1><p>文件和目录的创建</p><p>sysfs文件的打开操作</p><p>sysfs文件的读写</p><p>kobject结构</p><h1><span id="字符设备和input设备">字符设备和input设备</span></h1><p>文件如何变成设备</p><p>input设备的注册</p><p>input设备架构</p><p>platform总线</p>]]></content>
    
    <summary type="html">
    
      以应用为目的来学习Linux内核，通过阅读和修改代码，培养内核的阅读能力
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Nginx-Lua-Directives</title>
    <link href="http://yoursite.com/2018/03/01/Nginx-Lua-Directives/"/>
    <id>http://yoursite.com/2018/03/01/Nginx-Lua-Directives/</id>
    <published>2018-03-01T04:44:13.000Z</published>
    <updated>2019-03-01T06:25:52.347Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#nginx-directives-for-lua">Nginx Directives For Lua</a><ul><li><a href="#lua_capture_error_log">lua_capture_error_log</a></li><li><a href="#lua_use_default_type">lua_use_default_type</a></li><li><a href="#lua_malloc_trim">lua_malloc_trim</a></li><li><a href="#lua_code_cache">lua_code_cache</a></li><li><a href="#lua_regex_cache_max_entries">lua_regex_cache_max_entries</a></li><li><a href="#lua_regex_match_limit">lua_regex_match_limit</a></li><li><a href="#lua_package_path">lua_package_path</a></li><li><a href="#lua_package_cpath">lua_package_cpath</a></li><li><a href="#init_by_lua">init_by_lua</a></li><li><a href="#init_by_lua_block">init_by_lua_block</a></li><li><a href="#init_by_lua_file">init_by_lua_file</a></li><li><a href="#init_worker_by_lua">init_worker_by_lua</a></li><li><a href="#init_worker_by_lua_block">init_worker_by_lua_block</a></li><li><a href="#init_worker_by_lua_file">init_worker_by_lua_file</a></li><li><a href="#set_by_lua">set_by_lua</a></li><li><a href="#set_by_lua_block">set_by_lua_block</a></li><li><a href="#set_by_lua_file">set_by_lua_file</a></li><li><a href="#content_by_lua">content_by_lua</a></li><li><a href="#content_by_lua_block">content_by_lua_block</a></li><li><a href="#content_by_lua_file">content_by_lua_file</a></li><li><a href="#rewrite_by_lua">rewrite_by_lua</a></li><li><a href="#rewrite_by_lua_block">rewrite_by_lua_block</a></li><li><a href="#rewrite_by_lua_file">rewrite_by_lua_file</a></li><li><a href="#access_by_lua">access_by_lua</a></li><li><a href="#access_by_lua_block">access_by_lua_block</a></li><li><a href="#access_by_lua_file">access_by_lua_file</a></li><li><a href="#header_filter_by_lua">header_filter_by_lua</a></li><li><a href="#header_filter_by_lua_block">header_filter_by_lua_block</a></li><li><a href="#header_filter_by_lua_file">header_filter_by_lua_file</a></li><li><a href="#body_filter_by_lua">body_filter_by_lua</a></li><li><a href="#body_filter_by_lua_block">body_filter_by_lua_block</a></li><li><a href="#body_filter_by_lua_file">body_filter_by_lua_file</a></li><li><a href="#log_by_lua">log_by_lua</a></li><li><a href="#log_by_lua_block">log_by_lua_block</a></li><li><a href="#log_by_lua_file">log_by_lua_file</a></li><li><a href="#balancer_by_lua_block">balancer_by_lua_block</a></li><li><a href="#balancer_by_lua_file">balancer_by_lua_file</a></li><li><a href="#lua_need_request_body">lua_need_request_body</a></li><li><a href="#ssl_certificate_by_lua_block">ssl_certificate_by_lua_block</a></li><li><a href="#ssl_certificate_by_lua_file">ssl_certificate_by_lua_file</a></li><li><a href="#ssl_session_fetch_by_lua_block">ssl_session_fetch_by_lua_block</a></li><li><a href="#ssl_session_fetch_by_lua_file">ssl_session_fetch_by_lua_file</a></li><li><a href="#ssl_session_store_by_lua_block">ssl_session_store_by_lua_block</a></li><li><a href="#ssl_session_store_by_lua_file">ssl_session_store_by_lua_file</a></li><li><a href="#lua_shared_dict">lua_shared_dict</a></li><li><a href="#lua_socket_connect_timeout">lua_socket_connect_timeout</a></li><li><a href="#lua_socket_send_timeout">lua_socket_send_timeout</a></li><li><a href="#lua_socket_send_lowat">lua_socket_send_lowat</a></li><li><a href="#lua_socket_read_timeout">lua_socket_read_timeout</a></li><li><a href="#lua_socket_buffer_size">lua_socket_buffer_size</a></li><li><a href="#lua_socket_pool_size">lua_socket_pool_size</a></li><li><a href="#lua_socket_keepalive_timeout">lua_socket_keepalive_timeout</a></li><li><a href="#lua_socket_log_errors">lua_socket_log_errors</a></li><li><a href="#lua_ssl_ciphers">lua_ssl_ciphers</a></li><li><a href="#lua_ssl_crl">lua_ssl_crl</a></li><li><a href="#lua_ssl_protocols">lua_ssl_protocols</a></li><li><a href="#lua_ssl_trusted_certificate">lua_ssl_trusted_certificate</a></li><li><a href="#lua_ssl_verify_depth">lua_ssl_verify_depth</a></li><li><a href="#lua_http10_buffering">lua_http10_buffering</a></li><li><a href="#rewrite_by_lua_no_postpone">rewrite_by_lua_no_postpone</a></li><li><a href="#access_by_lua_no_postpone">access_by_lua_no_postpone</a></li><li><a href="#lua_transform_underscores_in_response_headers">lua_transform_underscores_in_response_headers</a></li><li><a href="#lua_check_client_abort">lua_check_client_abort</a></li><li><a href="#lua_max_pending_timers">lua_max_pending_timers</a></li><li><a href="#lua_max_running_timers">lua_max_running_timers</a></li><li><a href="#lua_sa_restart">lua_sa_restart</a></li></ul></li></ul><!-- tocstop --><h1><span id="nginx-directives-for-lua">Nginx Directives For Lua</span></h1><p>The basic building blocks of scripting Nginx with Lua are directives. Directives are used to specify when the user Lua code is run and how the result will be used. Below is a diagram showing the order in which directives are executed.</p><p><a href="https://cloud.githubusercontent.com/assets/2137369/15272097/77d1c09e-1a37-11e6-97ef-d9767035fc3e.png" target="_blank" rel="noopener"><img src="https://cloud.githubusercontent.com/assets/2137369/15272097/77d1c09e-1a37-11e6-97ef-d9767035fc3e.png" alt="Lua Nginx Modules Directives"></a></p><h2><span id="lua_capture_error_log">lua_capture_error_log</span></h2><p><strong>syntax:</strong> <em>lua_capture_error_log size</em></p><p><strong>default:</strong> <em>none</em></p><p><strong>context:</strong> <em>http</em></p><p>Enables a buffer of the specified <code>size</code> for capturing all the nginx error log message data (not just those produced by this module or the nginx http subsystem, but everything) without touching files or disks.</p><p>You can use units like <code>k</code> and <code>m</code> in the <code>size</code> value, as in</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lua_capture_error_log 100k;</span><br></pre></td></tr></table></figure><p>As a rule of thumb, a 4KB buffer can usually hold about 20 typical error log messages. So do the maths!</p><p>This buffer never grows. If it is full, new error log messages will replace the oldest ones in the buffer.</p><p>The size of the buffer must be bigger than the maximum length of a single error log message (which is 4K in OpenResty and 2K in stock NGINX).</p><p>You can read the messages in the buffer on the Lua land via the <a href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/errlog.md#get_logs" target="_blank" rel="noopener">get_logs()</a> function of the <a href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/errlog.md#readme" target="_blank" rel="noopener">ngx.errlog</a> module of the <a href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/errlog.md#readme" target="_blank" rel="noopener">lua-resty-core</a> library. This Lua API function will return the captured error log messages and also remove these already read from the global capturing buffer, making room for any new error log data. For this reason, the user should not configure this buffer to be too big if the user read the buffered error log data fast enough.</p><p>Note that the log level specified in the standard <a href="http://nginx.org/r/error_log" target="_blank" rel="noopener">error_log</a> directive <em>does</em> have effect on this capturing facility. It only captures log messages of a level no lower than the specified log level in the <a href="http://nginx.org/r/error_log" target="_blank" rel="noopener">error_log</a> directive. The user can still choose to set an even higher filtering log level on the fly via the Lua API function <a href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/errlog.md#set_filter_level" target="_blank" rel="noopener">errlog.set_filter_level</a>. So it is more flexible than the static <a href="http://nginx.org/r/error_log" target="_blank" rel="noopener">error_log</a>directive.</p><p>It is worth noting that there is no way to capture the debugging logs without building OpenResty or NGINX with the <code>./configure</code> option <code>--with-debug</code>. And enabling debugging logs is strongly discouraged in production builds due to high overhead.</p><p>This directive was first introduced in the <code>v0.10.9</code> release.</p><h2><span id="lua_use_default_type">lua_use_default_type</span></h2><p><strong>syntax:</strong> <em>lua_use_default_type on | off</em></p><p><strong>default:</strong> <em>lua_use_default_type on</em></p><p><strong>context:</strong> <em>http, server, location, location if</em></p><p>Specifies whether to use the MIME type specified by the <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#default_type" target="_blank" rel="noopener">default_type</a> directive for the default value of the <code>Content-Type</code>response header. Deactivate this directive if a default <code>Content-Type</code> response header for Lua request handlers is not desired.</p><p>This directive is turned on by default.</p><p>This directive was first introduced in the <code>v0.9.1</code> release.</p><h2><span id="lua_malloc_trim">lua_malloc_trim</span></h2><p><strong>syntax:</strong> <em>lua_malloc_trim <request-count></request-count></em></p><p><strong>default:</strong> <em>lua_malloc_trim 1000</em></p><p><strong>context:</strong> <em>http</em></p><p>Asks the underlying <code>libc</code> runtime library to release its cached free memory back to the operating system every <code>N</code> requests processed by the NGINX core. By default, <code>N</code> is 1000. You can configure the request count by using your own numbers. Smaller numbers mean more frequent releases, which may introduce higher CPU time consumption and smaller memory footprint while larger numbers usually lead to less CPU time overhead and relatively larger memory footprint. Just tune the number for your own use cases.</p><p>Configuring the argument to <code>0</code> essentially turns off the periodical memory trimming altogether.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lua_malloc_trim 0;  # turn off trimming completely</span><br></pre></td></tr></table></figure><p>The current implementation uses an NGINX log phase handler to do the request counting. So the appearance of the<a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#log_subrequest" target="_blank" rel="noopener">log_subrequest on</a> directives in <code>nginx.conf</code> may make the counting faster when subrequests are involved. By default, only “main requests” count.</p><p>Note that this directive does <em>not</em> affect the memory allocated by LuaJIT’s own allocator based on the <code>mmap</code> system call.</p><p>This directive was first introduced in the <code>v0.10.7</code> release.</p><h2><span id="lua_code_cache">lua_code_cache</span></h2><p><strong>syntax:</strong> <em>lua_code_cache on | off</em></p><p><strong>default:</strong> <em>lua_code_cache on</em></p><p><strong>context:</strong> <em>http, server, location, location if</em></p><p>Enables or disables the Lua code cache for Lua code in <code>*_by_lua_file</code> directives (like <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#set_by_lua_file" target="_blank" rel="noopener">set_by_lua_file</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#content_by_lua_file" target="_blank" rel="noopener">content_by_lua_file</a>) and Lua modules.</p><p>When turning off, every request served by ngx_lua will run in a separate Lua VM instance, starting from the <code>0.9.3</code> release. So the Lua files referenced in <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#set_by_lua_file" target="_blank" rel="noopener">set_by_lua_file</a>, <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#content_by_lua_file" target="_blank" rel="noopener">content_by_lua_file</a>, <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#access_by_lua_file" target="_blank" rel="noopener">access_by_lua_file</a>, and etc will not be cached and all Lua modules used will be loaded from scratch. With this in place, developers can adopt an edit-and-refresh approach.</p><p>Please note however, that Lua code written inlined within nginx.conf such as those specified by <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#set_by_lua" target="_blank" rel="noopener">set_by_lua</a>, <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#content_by_lua" target="_blank" rel="noopener">content_by_lua</a>,<a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#access_by_lua" target="_blank" rel="noopener">access_by_lua</a>, and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#rewrite_by_lua" target="_blank" rel="noopener">rewrite_by_lua</a> will not be updated when you edit the inlined Lua code in your <code>nginx.conf</code> file because only the Nginx config file parser can correctly parse the <code>nginx.conf</code> file and the only way is to reload the config file by sending a <code>HUP</code> signal or just to restart Nginx.</p><p>Even when the code cache is enabled, Lua files which are loaded by <code>dofile</code> or <code>loadfile</code> in *_by_lua_file cannot be cached (unless you cache the results yourself). Usually you can either use the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#init_by_lua" target="_blank" rel="noopener">init_by_lua</a> or <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#init-by_lua_file" target="_blank" rel="noopener">init_by_lua_file</a> directives to load all such files or just make these Lua files true Lua modules and load them via <code>require</code>.</p><p>The ngx_lua module does not support the <code>stat</code> mode available with the Apache <code>mod_lua</code> module (yet).</p><p>Disabling the Lua code cache is strongly discouraged for production use and should only be used during development as it has a significant negative impact on overall performance. For example, the performance of a “hello world” Lua example can drop by an order of magnitude after disabling the Lua code cache.</p><h2><span id="lua_regex_cache_max_entries">lua_regex_cache_max_entries</span></h2><p><strong>syntax:</strong> <em>lua_regex_cache_max_entries <num></num></em></p><p><strong>default:</strong> <em>lua_regex_cache_max_entries 1024</em></p><p><strong>context:</strong> <em>http</em></p><p>Specifies the maximum number of entries allowed in the worker process level compiled regex cache.</p><p>The regular expressions used in <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxrematch" target="_blank" rel="noopener">ngx.re.match</a>, <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxregmatch" target="_blank" rel="noopener">ngx.re.gmatch</a>, <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxresub" target="_blank" rel="noopener">ngx.re.sub</a>, and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxregsub" target="_blank" rel="noopener">ngx.re.gsub</a> will be cached within this cache if the regex option <code>o</code> (i.e., compile-once flag) is specified.</p><p>The default number of entries allowed is 1024 and when this limit is reached, new regular expressions will not be cached (as if the <code>o</code> option was not specified) and there will be one, and only one, warning in the <code>error.log</code> file:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2011/08/27 23:18:26 [warn] 31997#0: *1 lua exceeding regex cache max entries (1024), ...</span><br></pre></td></tr></table></figure><p>If you are using the <code>ngx.re.*</code> implementation of <a href="https://github.com/openresty/lua-resty-core" target="_blank" rel="noopener">lua-resty-core</a> by loading the <code>resty.core.regex</code> module (or just the <code>resty.core</code> module), then an LRU cache is used for the regex cache being used here.</p><p>Do not activate the <code>o</code> option for regular expressions (and/or <code>replace</code> string arguments for <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxresub" target="_blank" rel="noopener">ngx.re.sub</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxregsub" target="_blank" rel="noopener">ngx.re.gsub</a>) that are generated <em>on the fly</em> and give rise to infinite variations to avoid hitting the specified limit.</p><h2><span id="lua_regex_match_limit">lua_regex_match_limit</span></h2><p><strong>syntax:</strong> <em>lua_regex_match_limit <num></num></em></p><p><strong>default:</strong> <em>lua_regex_match_limit 0</em></p><p><strong>context:</strong> <em>http</em></p><p>Specifies the “match limit” used by the PCRE library when executing the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxrematch" target="_blank" rel="noopener">ngx.re API</a>. To quote the PCRE manpage, “the limit … has the effect of limiting the amount of backtracking that can take place.”</p><p>When the limit is hit, the error string “pcre_exec() failed: -8” will be returned by the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxrematch" target="_blank" rel="noopener">ngx.re API</a> functions on the Lua land.</p><p>When setting the limit to 0, the default “match limit” when compiling the PCRE library is used. And this is the default value of this directive.</p><p>This directive was first introduced in the <code>v0.8.5</code> release.</p><h2><span id="lua_package_path">lua_package_path</span></h2><p><strong>syntax:</strong> <em>lua_package_path <lua-style-path-str></lua-style-path-str></em></p><p><strong>default:</strong> <em>The content of LUA_PATH environment variable or Lua’s compiled-in defaults.</em></p><p><strong>context:</strong> <em>http</em></p><p>Sets the Lua module search path used by scripts specified by <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#set_by_lua" target="_blank" rel="noopener">set_by_lua</a>, <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#content_by_lua" target="_blank" rel="noopener">content_by_lua</a> and others. The path string is in standard Lua path form, and <code>;;</code> can be used to stand for the original search paths.</p><p>As from the <code>v0.5.0rc29</code> release, the special notation <code>$prefix</code> or <code>${prefix}</code> can be used in the search path string to indicate the path of the <code>server prefix</code> usually determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p><h2><span id="lua_package_cpath">lua_package_cpath</span></h2><p><strong>syntax:</strong> <em>lua_package_cpath <lua-style-cpath-str></lua-style-cpath-str></em></p><p><strong>default:</strong> <em>The content of LUA_CPATH environment variable or Lua’s compiled-in defaults.</em></p><p><strong>context:</strong> <em>http</em></p><p>Sets the Lua C-module search path used by scripts specified by <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#set_by_lua" target="_blank" rel="noopener">set_by_lua</a>, <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#content_by_lua" target="_blank" rel="noopener">content_by_lua</a> and others. The cpath string is in standard Lua cpath form, and <code>;;</code> can be used to stand for the original cpath.</p><p>As from the <code>v0.5.0rc29</code> release, the special notation <code>$prefix</code> or <code>${prefix}</code> can be used in the search path string to indicate the path of the <code>server prefix</code> usually determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p><h2><span id="init_by_lua">init_by_lua</span></h2><p><strong>syntax:</strong> <em>init_by_lua <lua-script-str></lua-script-str></em></p><p><strong>context:</strong> <em>http</em></p><p><strong>phase:</strong> <em>loading-config</em></p><p><strong>NOTE</strong> Use of this directive is <em>discouraged</em> following the <code>v0.9.17</code> release. Use the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#init_by_lua_block" target="_blank" rel="noopener">init_by_lua_block</a> directive instead.</p><p>Runs the Lua code specified by the argument <code>&lt;lua-script-str&gt;</code> on the global Lua VM level when the Nginx master process (if any) is loading the Nginx config file.</p><p>When Nginx receives the <code>HUP</code> signal and starts reloading the config file, the Lua VM will also be re-created and <code>init_by_lua</code>will run again on the new Lua VM. In case that the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lua_code_cache" target="_blank" rel="noopener">lua_code_cache</a> directive is turned off (default on), the <code>init_by_lua</code>handler will run upon every request because in this special mode a standalone Lua VM is always created for each request.</p><p>Usually you can pre-load Lua modules at server start-up by means of this hook and take advantage of modern operating systems’ copy-on-write (COW) optimization. Here is an example for pre-loading Lua modules:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># this runs before forking out nginx worker processes:</span><br><span class="line">init_by_lua_block &#123; require &quot;cjson&quot; &#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    location = /api &#123;</span><br><span class="line">        content_by_lua_block &#123;</span><br><span class="line">            -- the following require() will just  return</span><br><span class="line">            -- the alrady loaded module from package.loaded:</span><br><span class="line">            ngx.say(require &quot;cjson&quot;.encode&#123;dog = 5, cat = 6&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>You can also initialize the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lua_shared_dict" target="_blank" rel="noopener">lua_shared_dict</a> shm storage at this phase. Here is an example for this:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">lua_shared_dict dogs 1m;</span><br><span class="line"></span><br><span class="line">init_by_lua_block &#123;</span><br><span class="line">    local dogs = ngx.shared.dogs;</span><br><span class="line">    dogs:set(&quot;Tom&quot;, 56)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    location = /api &#123;</span><br><span class="line">        content_by_lua_block &#123;</span><br><span class="line">            local dogs = ngx.shared.dogs;</span><br><span class="line">            ngx.say(dogs:get(&quot;Tom&quot;))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>But note that, the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lua_shared_dict" target="_blank" rel="noopener">lua_shared_dict</a>‘s shm storage will not be cleared through a config reload (via the <code>HUP</code> signal, for example). So if you do <em>not</em> want to re-initialize the shm storage in your <code>init_by_lua</code> code in this case, then you just need to set a custom flag in the shm storage and always check the flag in your <code>init_by_lua</code> code.</p><p>Because the Lua code in this context runs before Nginx forks its worker processes (if any), data or code loaded here will enjoy the <a href="http://en.wikipedia.org/wiki/Copy-on-write" target="_blank" rel="noopener">Copy-on-write (COW)</a> feature provided by many operating systems among all the worker processes, thus saving a lot of memory.</p><p>Do <em>not</em> initialize your own Lua global variables in this context because use of Lua global variables have performance penalties and can lead to global namespace pollution (see the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lua-variable-scope" target="_blank" rel="noopener">Lua Variable Scope</a> section for more details). The recommended way is to use proper <a href="http://www.lua.org/manual/5.1/manual.html#5.3" target="_blank" rel="noopener">Lua module</a> files (but do not use the standard Lua function <a href="http://www.lua.org/manual/5.1/manual.html#pdf-module" target="_blank" rel="noopener">module()</a> to define Lua modules because it pollutes the global namespace as well) and call <a href="http://www.lua.org/manual/5.1/manual.html#pdf-require" target="_blank" rel="noopener">require()</a> to load your own module files in <code>init_by_lua</code> or other contexts (<a href="http://www.lua.org/manual/5.1/manual.html#pdf-require" target="_blank" rel="noopener">require()</a>does cache the loaded Lua modules in the global <code>package.loaded</code> table in the Lua registry so your modules will only loaded once for the whole Lua VM instance).</p><p>Only a small set of the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#nginx-api-for-lua" target="_blank" rel="noopener">Nginx API for Lua</a> is supported in this context:</p><ul><li>Logging APIs: <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxlog" target="_blank" rel="noopener">ngx.log</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#print" target="_blank" rel="noopener">print</a>,</li><li>Shared Dictionary API: <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxshareddict" target="_blank" rel="noopener">ngx.shared.DICT</a>.</li></ul><p>More Nginx APIs for Lua may be supported in this context upon future user requests.</p><p>Basically you can safely use Lua libraries that do blocking I/O in this very context because blocking the master process during server start-up is completely okay. Even the Nginx core does blocking I/O (at least on resolving upstream’s host names) at the configure-loading phase.</p><p>You should be very careful about potential security vulnerabilities in your Lua code registered in this context because the Nginx master process is often run under the <code>root</code> account.</p><p>This directive was first introduced in the <code>v0.5.5</code> release.</p><h2><span id="init_by_lua_block">init_by_lua_block</span></h2><p><strong>syntax:</strong> <em>init_by_lua_block { lua-script }</em></p><p><strong>context:</strong> <em>http</em></p><p><strong>phase:</strong> <em>loading-config</em></p><p>Similar to the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#init_by_lua" target="_blank" rel="noopener">init_by_lua</a> directive except that this directive inlines the Lua source directly inside a pair of curly braces (<code>{}</code>) instead of in an NGINX string literal (which requires special character escaping).</p><p>For instance,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">init_by_lua_block &#123;</span><br><span class="line">    print(&quot;I need no extra escaping here, for example: \r\nblah&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This directive was first introduced in the <code>v0.9.17</code> release.</p><h2><span id="init_by_lua_file">init_by_lua_file</span></h2><p><strong>syntax:</strong> <em>init_by_lua_file <path-to-lua-script-file></path-to-lua-script-file></em></p><p><strong>context:</strong> <em>http</em></p><p><strong>phase:</strong> <em>loading-config</em></p><p>Equivalent to <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#init_by_lua" target="_blank" rel="noopener">init_by_lua</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code or <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lualuajit-bytecode-support" target="_blank" rel="noopener">Lua/LuaJIT bytecode</a> to be executed.</p><p>When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p><p>This directive was first introduced in the <code>v0.5.5</code> release.</p><h2><span id="init_worker_by_lua">init_worker_by_lua</span></h2><p><strong>syntax:</strong> <em>init_worker_by_lua <lua-script-str></lua-script-str></em></p><p><strong>context:</strong> <em>http</em></p><p><strong>phase:</strong> <em>starting-worker</em></p><p><strong>NOTE</strong> Use of this directive is <em>discouraged</em> following the <code>v0.9.17</code> release. Use the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#init_worker_by_lua_block" target="_blank" rel="noopener">init_worker_by_lua_block</a> directive instead.</p><p>Runs the specified Lua code upon every Nginx worker process’s startup when the master process is enabled. When the master process is disabled, this hook will just run after <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#init_by_lua" target="_blank" rel="noopener">init_by_lua*</a>.</p><p>This hook is often used to create per-worker reoccurring timers (via the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxtimerat" target="_blank" rel="noopener">ngx.timer.at</a> Lua API), either for backend health-check or other timed routine work. Below is an example,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">init_worker_by_lua &apos;</span><br><span class="line">    local delay = 3  -- in seconds</span><br><span class="line">    local new_timer = ngx.timer.at</span><br><span class="line">    local log = ngx.log</span><br><span class="line">    local ERR = ngx.ERR</span><br><span class="line">    local check</span><br><span class="line"></span><br><span class="line">    check = function(premature)</span><br><span class="line">        if not premature then</span><br><span class="line">            -- do the health check or other routine work</span><br><span class="line">            local ok, err = new_timer(delay, check)</span><br><span class="line">            if not ok then</span><br><span class="line">                log(ERR, &quot;failed to create timer: &quot;, err)</span><br><span class="line">                return</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    local hdl, err = new_timer(delay, check)</span><br><span class="line">    if not hdl then</span><br><span class="line">        log(ERR, &quot;failed to create timer: &quot;, err)</span><br><span class="line">        return</span><br><span class="line">    end</span><br><span class="line">&apos;;</span><br></pre></td></tr></table></figure><p>This directive was first introduced in the <code>v0.9.5</code> release.</p><p>This hook no longer runs in the cache manager and cache loader processes since the <code>v0.10.12</code> release.</p><h2><span id="init_worker_by_lua_block">init_worker_by_lua_block</span></h2><p><strong>syntax:</strong> <em>init_worker_by_lua_block { lua-script }</em></p><p><strong>context:</strong> <em>http</em></p><p><strong>phase:</strong> <em>starting-worker</em></p><p>Similar to the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#init_worker_by_lua" target="_blank" rel="noopener">init_worker_by_lua</a> directive except that this directive inlines the Lua source directly inside a pair of curly braces (<code>{}</code>) instead of in an NGINX string literal (which requires special character escaping).</p><p>For instance,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">init_worker_by_lua_block &#123;</span><br><span class="line">    print(&quot;I need no extra escaping here, for example: \r\nblah&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This directive was first introduced in the <code>v0.9.17</code> release.</p><p>This hook no longer runs in the cache manager and cache loader processes since the <code>v0.10.12</code> release.</p><h2><span id="init_worker_by_lua_file">init_worker_by_lua_file</span></h2><p><strong>syntax:</strong> <em>init_worker_by_lua_file <lua-file-path></lua-file-path></em></p><p><strong>context:</strong> <em>http</em></p><p><strong>phase:</strong> <em>starting-worker</em></p><p>Similar to <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#init_worker_by_lua" target="_blank" rel="noopener">init_worker_by_lua</a>, but accepts the file path to a Lua source file or Lua bytecode file.</p><p>This directive was first introduced in the <code>v0.9.5</code> release.</p><p>This hook no longer runs in the cache manager and cache loader processes since the <code>v0.10.12</code> release.</p><h2><span id="set_by_lua">set_by_lua</span></h2><p><strong>syntax:</strong> <em>set_by_lua $res <lua-script-str> [$arg1 $arg2 …]</lua-script-str></em></p><p><strong>context:</strong> <em>server, server if, location, location if</em></p><p><strong>phase:</strong> <em>rewrite</em></p><p><strong>NOTE</strong> Use of this directive is <em>discouraged</em> following the <code>v0.9.17</code> release. Use the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#set_by_lua_block" target="_blank" rel="noopener">set_by_lua_block</a> directive instead.</p><p>Executes code specified in <code>&lt;lua-script-str&gt;</code> with optional input arguments <code>$arg1 $arg2 ...</code>, and returns string output to <code>$res</code>. The code in <code>&lt;lua-script-str&gt;</code> can make <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#nginx-api-for-lua" target="_blank" rel="noopener">API calls</a> and can retrieve input arguments from the <code>ngx.arg</code> table (index starts from <code>1</code> and increases sequentially).</p><p>This directive is designed to execute short, fast running code blocks as the Nginx event loop is blocked during code execution. Time consuming code sequences should therefore be avoided.</p><p>This directive is implemented by injecting custom commands into the standard <a href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html" target="_blank" rel="noopener">ngx_http_rewrite_module</a>‘s command list. Because <a href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html" target="_blank" rel="noopener">ngx_http_rewrite_module</a> does not support nonblocking I/O in its commands, Lua APIs requiring yielding the current Lua “light thread” cannot work in this directive.</p><p>At least the following API functions are currently disabled within the context of <code>set_by_lua</code>:</p><ul><li>Output API functions (e.g., <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsay" target="_blank" rel="noopener">ngx.say</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsend_headers" target="_blank" rel="noopener">ngx.send_headers</a>)</li><li>Control API functions (e.g., <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxexit" target="_blank" rel="noopener">ngx.exit</a>)</li><li>Subrequest API functions (e.g., <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxlocationcapture" target="_blank" rel="noopener">ngx.location.capture</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxlocationcapture_multi" target="_blank" rel="noopener">ngx.location.capture_multi</a>)</li><li>Cosocket API functions (e.g., <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsockettcp" target="_blank" rel="noopener">ngx.socket.tcp</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxreqsocket" target="_blank" rel="noopener">ngx.req.socket</a>).</li><li>Sleeping API function <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsleep" target="_blank" rel="noopener">ngx.sleep</a>.</li></ul><p>In addition, note that this directive can only write out a value to a single Nginx variable at a time. However, a workaround is possible using the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxvarvariable" target="_blank" rel="noopener">ngx.var.VARIABLE</a> interface.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">location /foo &#123;</span><br><span class="line">    set $diff &apos;&apos;; # we have to predefine the $diff variable here</span><br><span class="line"></span><br><span class="line">    set_by_lua $sum &apos;</span><br><span class="line">        local a = 32</span><br><span class="line">        local b = 56</span><br><span class="line"></span><br><span class="line">        ngx.var.diff = a - b;  -- write to $diff directly</span><br><span class="line">        return a + b;          -- return the $sum value normally</span><br><span class="line">    &apos;;</span><br><span class="line"></span><br><span class="line">    echo &quot;sum = $sum, diff = $diff&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This directive can be freely mixed with all directives of the <a href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html" target="_blank" rel="noopener">ngx_http_rewrite_module</a>, <a href="http://github.com/openresty/set-misc-nginx-module" target="_blank" rel="noopener">set-misc-nginx-module</a>, and <a href="http://github.com/openresty/array-var-nginx-module" target="_blank" rel="noopener">array-var-nginx-module</a> modules. All of these directives will run in the same order as they appear in the config file.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set $foo 32;</span><br><span class="line">set_by_lua $bar &apos;return tonumber(ngx.var.foo) + 1&apos;;</span><br><span class="line">set $baz &quot;bar: $bar&quot;;  # $baz == &quot;bar: 33&quot;</span><br></pre></td></tr></table></figure><p>As from the <code>v0.5.0rc29</code> release, Nginx variable interpolation is disabled in the <code>&lt;lua-script-str&gt;</code> argument of this directive and therefore, the dollar sign character (<code>$</code>) can be used directly.</p><p>This directive requires the <a href="https://github.com/simplresty/ngx_devel_kit" target="_blank" rel="noopener">ngx_devel_kit</a> module.</p><h2><span id="set_by_lua_block">set_by_lua_block</span></h2><p><strong>syntax:</strong> <em>set_by_lua_block $res { lua-script }</em></p><p><strong>context:</strong> <em>server, server if, location, location if</em></p><p><strong>phase:</strong> <em>rewrite</em></p><p>Similar to the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#set_by_lua" target="_blank" rel="noopener">set_by_lua</a> directive except that</p><ol><li>this directive inlines the Lua source directly inside a pair of curly braces (<code>{}</code>) instead of in an NGINX string literal (which requires special character escaping), and</li><li>this directive does not support extra arguments after the Lua script as in <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#set_by_lua" target="_blank" rel="noopener">set_by_lua</a>.</li></ol><p>For example,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set_by_lua_block $res &#123; return 32 + math.cos(32) &#125;</span><br><span class="line"># $res now has the value &quot;32.834223360507&quot; or alike.</span><br></pre></td></tr></table></figure><p>No special escaping is required in the Lua code block.</p><p>This directive was first introduced in the <code>v0.9.17</code> release.</p><h2><span id="set_by_lua_file">set_by_lua_file</span></h2><p><strong>syntax:</strong> <em>set_by_lua_file $res <path-to-lua-script-file> [$arg1 $arg2 …]</path-to-lua-script-file></em></p><p><strong>context:</strong> <em>server, server if, location, location if</em></p><p><strong>phase:</strong> <em>rewrite</em></p><p>Equivalent to <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#set_by_lua" target="_blank" rel="noopener">set_by_lua</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or, as from the <code>v0.5.0rc32</code> release, the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lualuajit-bytecode-support" target="_blank" rel="noopener">Lua/LuaJIT bytecode</a> to be executed.</p><p>Nginx variable interpolation is supported in the <code>&lt;path-to-lua-script-file&gt;</code> argument string of this directive. But special care must be taken for injection attacks.</p><p>When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p><p>When the Lua code cache is turned on (by default), the user code is loaded once at the first request and cached and the Nginx config must be reloaded each time the Lua source file is modified. The Lua code cache can be temporarily disabled during development by switching <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lua_code_cache" target="_blank" rel="noopener">lua_code_cache</a> <code>off</code> in <code>nginx.conf</code> to avoid reloading Nginx.</p><p>This directive requires the <a href="https://github.com/simplresty/ngx_devel_kit" target="_blank" rel="noopener">ngx_devel_kit</a> module.</p><h2><span id="content_by_lua">content_by_lua</span></h2><p><strong>syntax:</strong> <em>content_by_lua <lua-script-str></lua-script-str></em></p><p><strong>context:</strong> <em>location, location if</em></p><p><strong>phase:</strong> <em>content</em></p><p><strong>NOTE</strong> Use of this directive is <em>discouraged</em> following the <code>v0.9.17</code> release. Use the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#content_by_lua_block" target="_blank" rel="noopener">content_by_lua_block</a> directive instead.</p><p>Acts as a “content handler” and executes Lua code string specified in <code>&lt;lua-script-str&gt;</code> for every request. The Lua code may make <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#nginx-api-for-lua" target="_blank" rel="noopener">API calls</a> and is executed as a new spawned coroutine in an independent global environment (i.e. a sandbox).</p><p>Do not use this directive and other content handler directives in the same location. For example, this directive and the <a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_pass" target="_blank" rel="noopener">proxy_pass</a> directive should not be used in the same location.</p><h2><span id="content_by_lua_block">content_by_lua_block</span></h2><p><strong>syntax:</strong> <em>content_by_lua_block { lua-script }</em></p><p><strong>context:</strong> <em>location, location if</em></p><p><strong>phase:</strong> <em>content</em></p><p>Similar to the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#content_by_lua" target="_blank" rel="noopener">content_by_lua</a> directive except that this directive inlines the Lua source directly inside a pair of curly braces (<code>{}</code>) instead of in an NGINX string literal (which requires special character escaping).</p><p>For instance,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">content_by_lua_block &#123;</span><br><span class="line">    ngx.say(&quot;I need no extra escaping here, for example: \r\nblah&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This directive was first introduced in the <code>v0.9.17</code> release.</p><h2><span id="content_by_lua_file">content_by_lua_file</span></h2><p><strong>syntax:</strong> <em>content_by_lua_file <path-to-lua-script-file></path-to-lua-script-file></em></p><p><strong>context:</strong> <em>location, location if</em></p><p><strong>phase:</strong> <em>content</em></p><p>Equivalent to <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#content_by_lua" target="_blank" rel="noopener">content_by_lua</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or, as from the <code>v0.5.0rc32</code> release, the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lualuajit-bytecode-support" target="_blank" rel="noopener">Lua/LuaJIT bytecode</a> to be executed.</p><p>Nginx variables can be used in the <code>&lt;path-to-lua-script-file&gt;</code> string to provide flexibility. This however carries some risks and is not ordinarily recommended.</p><p>When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p><p>When the Lua code cache is turned on (by default), the user code is loaded once at the first request and cached and the Nginx config must be reloaded each time the Lua source file is modified. The Lua code cache can be temporarily disabled during development by switching <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lua_code_cache" target="_blank" rel="noopener">lua_code_cache</a> <code>off</code> in <code>nginx.conf</code> to avoid reloading Nginx.</p><p>Nginx variables are supported in the file path for dynamic dispatch, for example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># CAUTION: contents in nginx var must be carefully filtered,</span><br><span class="line"># otherwise there&apos;ll be great security risk!</span><br><span class="line">location ~ ^/app/([-_a-zA-Z0-9/]+) &#123;</span><br><span class="line">    set $path $1;</span><br><span class="line">    content_by_lua_file /path/to/lua/app/root/$path.lua;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>But be very careful about malicious user inputs and always carefully validate or filter out the user-supplied path components.</p><h2><span id="rewrite_by_lua">rewrite_by_lua</span></h2><p><strong>syntax:</strong> <em>rewrite_by_lua <lua-script-str></lua-script-str></em></p><p><strong>context:</strong> <em>http, server, location, location if</em></p><p><strong>phase:</strong> <em>rewrite tail</em></p><p><strong>NOTE</strong> Use of this directive is <em>discouraged</em> following the <code>v0.9.17</code> release. Use the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#rewrite_by_lua_block" target="_blank" rel="noopener">rewrite_by_lua_block</a> directive instead.</p><p>Acts as a rewrite phase handler and executes Lua code string specified in <code>&lt;lua-script-str&gt;</code> for every request. The Lua code may make <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#nginx-api-for-lua" target="_blank" rel="noopener">API calls</a> and is executed as a new spawned coroutine in an independent global environment (i.e. a sandbox).</p><p>Note that this handler always runs <em>after</em> the standard <a href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html" target="_blank" rel="noopener">ngx_http_rewrite_module</a>. So the following will work as expected:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location /foo &#123;</span><br><span class="line">    set $a 12; # create and initialize $a</span><br><span class="line">    set $b &quot;&quot;; # create and initialize $b</span><br><span class="line">    rewrite_by_lua &apos;ngx.var.b = tonumber(ngx.var.a) + 1&apos;;</span><br><span class="line">    echo &quot;res = $b&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>because <code>set $a 12</code> and <code>set $b &quot;&quot;</code> run <em>before</em> <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#rewrite_by_lua" target="_blank" rel="noopener">rewrite_by_lua</a>.</p><p>On the other hand, the following will not work as expected:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">?  location /foo &#123;</span><br><span class="line">?      set $a 12; # create and initialize $a</span><br><span class="line">?      set $b &apos;&apos;; # create and initialize $b</span><br><span class="line">?      rewrite_by_lua &apos;ngx.var.b = tonumber(ngx.var.a) + 1&apos;;</span><br><span class="line">?      if ($b = &apos;13&apos;) &#123;</span><br><span class="line">?         rewrite ^ /bar redirect;</span><br><span class="line">?         break;</span><br><span class="line">?      &#125;</span><br><span class="line">?</span><br><span class="line">?      echo &quot;res = $b&quot;;</span><br><span class="line">?  &#125;</span><br></pre></td></tr></table></figure><p>because <code>if</code> runs <em>before</em> <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#rewrite_by_lua" target="_blank" rel="noopener">rewrite_by_lua</a> even if it is placed after <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#rewrite_by_lua" target="_blank" rel="noopener">rewrite_by_lua</a> in the config.</p><p>The right way of doing this is as follows:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">location /foo &#123;</span><br><span class="line">    set $a 12; # create and initialize $a</span><br><span class="line">    set $b &apos;&apos;; # create and initialize $b</span><br><span class="line">    rewrite_by_lua &apos;</span><br><span class="line">        ngx.var.b = tonumber(ngx.var.a) + 1</span><br><span class="line">        if tonumber(ngx.var.b) == 13 then</span><br><span class="line">            return ngx.redirect(&quot;/bar&quot;);</span><br><span class="line">        end</span><br><span class="line">    &apos;;</span><br><span class="line"></span><br><span class="line">    echo &quot;res = $b&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note that the <a href="http://www.grid.net.ru/nginx/eval.en.html" target="_blank" rel="noopener">ngx_eval</a> module can be approximated by using <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#rewrite_by_lua" target="_blank" rel="noopener">rewrite_by_lua</a>. For example,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    eval $res &#123;</span><br><span class="line">        proxy_pass http://foo.com/check-spam;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if ($res = &apos;spam&apos;) &#123;</span><br><span class="line">        rewrite ^ /terms-of-use.html redirect;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fastcgi_pass ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>can be implemented in ngx_lua as:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">location = /check-spam &#123;</span><br><span class="line">    internal;</span><br><span class="line">    proxy_pass http://foo.com/check-spam;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">    rewrite_by_lua &apos;</span><br><span class="line">        local res = ngx.location.capture(&quot;/check-spam&quot;)</span><br><span class="line">        if res.body == &quot;spam&quot; then</span><br><span class="line">            return ngx.redirect(&quot;/terms-of-use.html&quot;)</span><br><span class="line">        end</span><br><span class="line">    &apos;;</span><br><span class="line"></span><br><span class="line">    fastcgi_pass ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Just as any other rewrite phase handlers, <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#rewrite_by_lua" target="_blank" rel="noopener">rewrite_by_lua</a> also runs in subrequests.</p><p>Note that when calling <code>ngx.exit(ngx.OK)</code> within a <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#rewrite_by_lua" target="_blank" rel="noopener">rewrite_by_lua</a> handler, the nginx request processing control flow will still continue to the content handler. To terminate the current request from within a <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#rewrite_by_lua" target="_blank" rel="noopener">rewrite_by_lua</a> handler, calling <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxexit" target="_blank" rel="noopener">ngx.exit</a> with status &gt;= 200 (<code>ngx.HTTP_OK</code>) and status &lt; 300 (<code>ngx.HTTP_SPECIAL_RESPONSE</code>) for successful quits and <code>ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)</code> (or its friends) for failures.</p><p>If the <a href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html" target="_blank" rel="noopener">ngx_http_rewrite_module</a>‘s <a href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html#rewrite" target="_blank" rel="noopener">rewrite</a> directive is used to change the URI and initiate location re-lookups (internal redirections), then any <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#rewrite_by_lua" target="_blank" rel="noopener">rewrite_by_lua</a> or <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#rewrite_by_lua_file" target="_blank" rel="noopener">rewrite_by_lua_file</a> code sequences within the current location will not be executed. For example,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location /foo &#123;</span><br><span class="line">    rewrite ^ /bar;</span><br><span class="line">    rewrite_by_lua &apos;ngx.exit(503)&apos;;</span><br><span class="line">&#125;</span><br><span class="line">location /bar &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Here the Lua code <code>ngx.exit(503)</code> will never run. This will be the case if <code>rewrite ^ /bar last</code> is used as this will similarly initiate an internal redirection. If the <code>break</code> modifier is used instead, there will be no internal redirection and the <code>rewrite_by_lua</code> code will be executed.</p><p>The <code>rewrite_by_lua</code> code will always run at the end of the <code>rewrite</code> request-processing phase unless <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#rewrite_by_lua_no_postpone" target="_blank" rel="noopener">rewrite_by_lua_no_postpone</a> is turned on.</p><h2><span id="rewrite_by_lua_block">rewrite_by_lua_block</span></h2><p><strong>syntax:</strong> <em>rewrite_by_lua_block { lua-script }</em></p><p><strong>context:</strong> <em>http, server, location, location if</em></p><p><strong>phase:</strong> <em>rewrite tail</em></p><p>Similar to the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#rewrite_by_lua" target="_blank" rel="noopener">rewrite_by_lua</a> directive except that this directive inlines the Lua source directly inside a pair of curly braces (<code>{}</code>) instead of in an NGINX string literal (which requires special character escaping).</p><p>For instance,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rewrite_by_lua_block &#123;</span><br><span class="line">    do_something(&quot;hello, world!\nhiya\n&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This directive was first introduced in the <code>v0.9.17</code> release.</p><h2><span id="rewrite_by_lua_file">rewrite_by_lua_file</span></h2><p><strong>syntax:</strong> <em>rewrite_by_lua_file <path-to-lua-script-file></path-to-lua-script-file></em></p><p><strong>context:</strong> <em>http, server, location, location if</em></p><p><strong>phase:</strong> <em>rewrite tail</em></p><p>Equivalent to <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#rewrite_by_lua" target="_blank" rel="noopener">rewrite_by_lua</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or, as from the <code>v0.5.0rc32</code> release, the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lualuajit-bytecode-support" target="_blank" rel="noopener">Lua/LuaJIT bytecode</a> to be executed.</p><p>Nginx variables can be used in the <code>&lt;path-to-lua-script-file&gt;</code> string to provide flexibility. This however carries some risks and is not ordinarily recommended.</p><p>When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p><p>When the Lua code cache is turned on (by default), the user code is loaded once at the first request and cached and the Nginx config must be reloaded each time the Lua source file is modified. The Lua code cache can be temporarily disabled during development by switching <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lua_code_cache" target="_blank" rel="noopener">lua_code_cache</a> <code>off</code> in <code>nginx.conf</code> to avoid reloading Nginx.</p><p>The <code>rewrite_by_lua_file</code> code will always run at the end of the <code>rewrite</code> request-processing phase unless <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#rewrite_by_lua_no_postpone" target="_blank" rel="noopener">rewrite_by_lua_no_postpone</a> is turned on.</p><p>Nginx variables are supported in the file path for dynamic dispatch just as in <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#content_by_lua_file" target="_blank" rel="noopener">content_by_lua_file</a>.</p><h2><span id="access_by_lua">access_by_lua</span></h2><p><strong>syntax:</strong> <em>access_by_lua <lua-script-str></lua-script-str></em></p><p><strong>context:</strong> <em>http, server, location, location if</em></p><p><strong>phase:</strong> <em>access tail</em></p><p><strong>NOTE</strong> Use of this directive is <em>discouraged</em> following the <code>v0.9.17</code> release. Use the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#access_by_lua_block" target="_blank" rel="noopener">access_by_lua_block</a> directive instead.</p><p>Acts as an access phase handler and executes Lua code string specified in <code>&lt;lua-script-str&gt;</code> for every request. The Lua code may make <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#nginx-api-for-lua" target="_blank" rel="noopener">API calls</a> and is executed as a new spawned coroutine in an independent global environment (i.e. a sandbox).</p><p>Note that this handler always runs <em>after</em> the standard <a href="http://nginx.org/en/docs/http/ngx_http_access_module.html" target="_blank" rel="noopener">ngx_http_access_module</a>. So the following will work as expected:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    deny    192.168.1.1;</span><br><span class="line">    allow   192.168.1.0/24;</span><br><span class="line">    allow   10.1.1.0/16;</span><br><span class="line">    deny    all;</span><br><span class="line"></span><br><span class="line">    access_by_lua &apos;</span><br><span class="line">        local res = ngx.location.capture(&quot;/mysql&quot;, &#123; ... &#125;)</span><br><span class="line">        ...</span><br><span class="line">    &apos;;</span><br><span class="line"></span><br><span class="line">    # proxy_pass/fastcgi_pass/...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>That is, if a client IP address is in the blacklist, it will be denied before the MySQL query for more complex authentication is executed by <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#access_by_lua" target="_blank" rel="noopener">access_by_lua</a>.</p><p>Note that the <a href="http://mdounin.ru/hg/ngx_http_auth_request_module/" target="_blank" rel="noopener">ngx_auth_request</a> module can be approximated by using <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#access_by_lua" target="_blank" rel="noopener">access_by_lua</a>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    auth_request /auth;</span><br><span class="line"></span><br><span class="line">    # proxy_pass/fastcgi_pass/postgres_pass/...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>can be implemented in ngx_lua as:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    access_by_lua &apos;</span><br><span class="line">        local res = ngx.location.capture(&quot;/auth&quot;)</span><br><span class="line"></span><br><span class="line">        if res.status == ngx.HTTP_OK then</span><br><span class="line">            return</span><br><span class="line">        end</span><br><span class="line"></span><br><span class="line">        if res.status == ngx.HTTP_FORBIDDEN then</span><br><span class="line">            ngx.exit(res.status)</span><br><span class="line">        end</span><br><span class="line"></span><br><span class="line">        ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)</span><br><span class="line">    &apos;;</span><br><span class="line"></span><br><span class="line">    # proxy_pass/fastcgi_pass/postgres_pass/...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>As with other access phase handlers, <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#access_by_lua" target="_blank" rel="noopener">access_by_lua</a> will <em>not</em> run in subrequests.</p><p>Note that when calling <code>ngx.exit(ngx.OK)</code> within a <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#access_by_lua" target="_blank" rel="noopener">access_by_lua</a> handler, the nginx request processing control flow will still continue to the content handler. To terminate the current request from within a <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#access_by_lua" target="_blank" rel="noopener">access_by_lua</a> handler, calling <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxexit" target="_blank" rel="noopener">ngx.exit</a> with status &gt;= 200 (<code>ngx.HTTP_OK</code>) and status &lt; 300 (<code>ngx.HTTP_SPECIAL_RESPONSE</code>) for successful quits and <code>ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)</code> (or its friends) for failures.</p><p>Starting from the <code>v0.9.20</code> release, you can use the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#access_by_lua_no_postpone" target="_blank" rel="noopener">access_by_lua_no_postpone</a> directive to control when to run this handler inside the “access” request-processing phase of NGINX.</p><h2><span id="access_by_lua_block">access_by_lua_block</span></h2><p><strong>syntax:</strong> <em>access_by_lua_block { lua-script }</em></p><p><strong>context:</strong> <em>http, server, location, location if</em></p><p><strong>phase:</strong> <em>access tail</em></p><p>Similar to the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#access_by_lua" target="_blank" rel="noopener">access_by_lua</a> directive except that this directive inlines the Lua source directly inside a pair of curly braces (<code>{}</code>) instead of in an NGINX string literal (which requires special character escaping).</p><p>For instance,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">access_by_lua_block &#123;</span><br><span class="line">    do_something(&quot;hello, world!\nhiya\n&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This directive was first introduced in the <code>v0.9.17</code> release.</p><h2><span id="access_by_lua_file">access_by_lua_file</span></h2><p><strong>syntax:</strong> <em>access_by_lua_file <path-to-lua-script-file></path-to-lua-script-file></em></p><p><strong>context:</strong> <em>http, server, location, location if</em></p><p><strong>phase:</strong> <em>access tail</em></p><p>Equivalent to <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#access_by_lua" target="_blank" rel="noopener">access_by_lua</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or, as from the <code>v0.5.0rc32</code> release, the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lualuajit-bytecode-support" target="_blank" rel="noopener">Lua/LuaJIT bytecode</a> to be executed.</p><p>Nginx variables can be used in the <code>&lt;path-to-lua-script-file&gt;</code> string to provide flexibility. This however carries some risks and is not ordinarily recommended.</p><p>When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p><p>When the Lua code cache is turned on (by default), the user code is loaded once at the first request and cached and the Nginx config must be reloaded each time the Lua source file is modified. The Lua code cache can be temporarily disabled during development by switching <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lua_code_cache" target="_blank" rel="noopener">lua_code_cache</a> <code>off</code> in <code>nginx.conf</code> to avoid repeatedly reloading Nginx.</p><p>Nginx variables are supported in the file path for dynamic dispatch just as in <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#content_by_lua_file" target="_blank" rel="noopener">content_by_lua_file</a>.</p><h2><span id="header_filter_by_lua">header_filter_by_lua</span></h2><p><strong>syntax:</strong> <em>header_filter_by_lua <lua-script-str></lua-script-str></em></p><p><strong>context:</strong> <em>http, server, location, location if</em></p><p><strong>phase:</strong> <em>output-header-filter</em></p><p><strong>NOTE</strong> Use of this directive is <em>discouraged</em> following the <code>v0.9.17</code> release. Use the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#header_filter_by_lua_block" target="_blank" rel="noopener">header_filter_by_lua_block</a> directive instead.</p><p>Uses Lua code specified in <code>&lt;lua-script-str&gt;</code> to define an output header filter.</p><p>Note that the following API functions are currently disabled within this context:</p><ul><li>Output API functions (e.g., <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsay" target="_blank" rel="noopener">ngx.say</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsend_headers" target="_blank" rel="noopener">ngx.send_headers</a>)</li><li>Control API functions (e.g., <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxredirect" target="_blank" rel="noopener">ngx.redirect</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxexec" target="_blank" rel="noopener">ngx.exec</a>)</li><li>Subrequest API functions (e.g., <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxlocationcapture" target="_blank" rel="noopener">ngx.location.capture</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxlocationcapture_multi" target="_blank" rel="noopener">ngx.location.capture_multi</a>)</li><li>Cosocket API functions (e.g., <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsockettcp" target="_blank" rel="noopener">ngx.socket.tcp</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxreqsocket" target="_blank" rel="noopener">ngx.req.socket</a>).</li></ul><p>Here is an example of overriding a response header (or adding one if absent) in our Lua header filter:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    proxy_pass http://mybackend;</span><br><span class="line">    header_filter_by_lua &apos;ngx.header.Foo = &quot;blah&quot;&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This directive was first introduced in the <code>v0.2.1rc20</code> release.</p><h2><span id="header_filter_by_lua_block">header_filter_by_lua_block</span></h2><p><strong>syntax:</strong> <em>header_filter_by_lua_block { lua-script }</em></p><p><strong>context:</strong> <em>http, server, location, location if</em></p><p><strong>phase:</strong> <em>output-header-filter</em></p><p>Similar to the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#header_filter_by_lua" target="_blank" rel="noopener">header_filter_by_lua</a> directive except that this directive inlines the Lua source directly inside a pair of curly braces (<code>{}</code>) instead of in an NGINX string literal (which requires special character escaping).</p><p>For instance,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">header_filter_by_lua_block &#123;</span><br><span class="line">    ngx.header[&quot;content-length&quot;] = nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This directive was first introduced in the <code>v0.9.17</code> release.</p><h2><span id="header_filter_by_lua_file">header_filter_by_lua_file</span></h2><p><strong>syntax:</strong> <em>header_filter_by_lua_file <path-to-lua-script-file></path-to-lua-script-file></em></p><p><strong>context:</strong> <em>http, server, location, location if</em></p><p><strong>phase:</strong> <em>output-header-filter</em></p><p>Equivalent to <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#header_filter_by_lua" target="_blank" rel="noopener">header_filter_by_lua</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or as from the <code>v0.5.0rc32</code> release, the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lualuajit-bytecode-support" target="_blank" rel="noopener">Lua/LuaJIT bytecode</a> to be executed.</p><p>When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p><p>This directive was first introduced in the <code>v0.2.1rc20</code> release.</p><h2><span id="body_filter_by_lua">body_filter_by_lua</span></h2><p><strong>syntax:</strong> <em>body_filter_by_lua <lua-script-str></lua-script-str></em></p><p><strong>context:</strong> <em>http, server, location, location if</em></p><p><strong>phase:</strong> <em>output-body-filter</em></p><p><strong>NOTE</strong> Use of this directive is <em>discouraged</em> following the <code>v0.9.17</code> release. Use the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#body_filter_by_lua_block" target="_blank" rel="noopener">body_filter_by_lua_block</a> directive instead.</p><p>Uses Lua code specified in <code>&lt;lua-script-str&gt;</code> to define an output body filter.</p><p>The input data chunk is passed via <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxarg" target="_blank" rel="noopener">ngx.arg</a>[1] (as a Lua string value) and the “eof” flag indicating the end of the response body data stream is passed via <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxarg" target="_blank" rel="noopener">ngx.arg</a>[2] (as a Lua boolean value).</p><p>Behind the scene, the “eof” flag is just the <code>last_buf</code> (for main requests) or <code>last_in_chain</code> (for subrequests) flag of the Nginx chain link buffers. (Before the <code>v0.7.14</code> release, the “eof” flag does not work at all in subrequests.)</p><p>The output data stream can be aborted immediately by running the following Lua statement:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return ngx.ERROR</span><br></pre></td></tr></table></figure><p>This will truncate the response body and usually result in incomplete and also invalid responses.</p><p>The Lua code can pass its own modified version of the input data chunk to the downstream Nginx output body filters by overriding <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxarg" target="_blank" rel="noopener">ngx.arg</a>[1] with a Lua string or a Lua table of strings. For example, to transform all the lowercase letters in the response body, we can just write:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    proxy_pass http://mybackend;</span><br><span class="line">    body_filter_by_lua &apos;ngx.arg[1] = string.upper(ngx.arg[1])&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>When setting <code>nil</code> or an empty Lua string value to <code>ngx.arg[1]</code>, no data chunk will be passed to the downstream Nginx output filters at all.</p><p>Likewise, new “eof” flag can also be specified by setting a boolean value to <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxarg" target="_blank" rel="noopener">ngx.arg</a>[2]. For example,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">location /t &#123;</span><br><span class="line">    echo hello world;</span><br><span class="line">    echo hiya globe;</span><br><span class="line"></span><br><span class="line">    body_filter_by_lua &apos;</span><br><span class="line">        local chunk = ngx.arg[1]</span><br><span class="line">        if string.match(chunk, &quot;hello&quot;) then</span><br><span class="line">            ngx.arg[2] = true  -- new eof</span><br><span class="line">            return</span><br><span class="line">        end</span><br><span class="line"></span><br><span class="line">        -- just throw away any remaining chunk data</span><br><span class="line">        ngx.arg[1] = nil</span><br><span class="line">    &apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Then <code>GET /t</code> will just return the output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br></pre></td></tr></table></figure><p>That is, when the body filter sees a chunk containing the word “hello”, then it will set the “eof” flag to true immediately, resulting in truncated but still valid responses.</p><p>When the Lua code may change the length of the response body, then it is required to always clear out the <code>Content-Length</code>response header (if any) in a header filter to enforce streaming output, as in</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location /foo &#123;</span><br><span class="line">    # fastcgi_pass/proxy_pass/...</span><br><span class="line"></span><br><span class="line">    header_filter_by_lua_block &#123; ngx.header.content_length = nil &#125;</span><br><span class="line">    body_filter_by_lua &apos;ngx.arg[1] = string.len(ngx.arg[1]) .. &quot;\\n&quot;&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note that the following API functions are currently disabled within this context due to the limitations in NGINX output filter’s current implementation:</p><ul><li>Output API functions (e.g., <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsay" target="_blank" rel="noopener">ngx.say</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsend_headers" target="_blank" rel="noopener">ngx.send_headers</a>)</li><li>Control API functions (e.g., <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxexit" target="_blank" rel="noopener">ngx.exit</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxexec" target="_blank" rel="noopener">ngx.exec</a>)</li><li>Subrequest API functions (e.g., <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxlocationcapture" target="_blank" rel="noopener">ngx.location.capture</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxlocationcapture_multi" target="_blank" rel="noopener">ngx.location.capture_multi</a>)</li><li>Cosocket API functions (e.g., <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsockettcp" target="_blank" rel="noopener">ngx.socket.tcp</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxreqsocket" target="_blank" rel="noopener">ngx.req.socket</a>).</li></ul><p>Nginx output filters may be called multiple times for a single request because response body may be delivered in chunks. Thus, the Lua code specified by in this directive may also run multiple times in the lifetime of a single HTTP request.</p><p>This directive was first introduced in the <code>v0.5.0rc32</code> release.</p><h2><span id="body_filter_by_lua_block">body_filter_by_lua_block</span></h2><p><strong>syntax:</strong> <em>body_filter_by_lua_block { lua-script-str }</em></p><p><strong>context:</strong> <em>http, server, location, location if</em></p><p><strong>phase:</strong> <em>output-body-filter</em></p><p>Similar to the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#body_filter_by_lua" target="_blank" rel="noopener">body_filter_by_lua</a> directive except that this directive inlines the Lua source directly inside a pair of curly braces (<code>{}</code>) instead of in an NGINX string literal (which requires special character escaping).</p><p>For instance,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">body_filter_by_lua_block &#123;</span><br><span class="line">    local data, eof = ngx.arg[1], ngx.arg[2]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This directive was first introduced in the <code>v0.9.17</code> release.</p><h2><span id="body_filter_by_lua_file">body_filter_by_lua_file</span></h2><p><strong>syntax:</strong> <em>body_filter_by_lua_file <path-to-lua-script-file></path-to-lua-script-file></em></p><p><strong>context:</strong> <em>http, server, location, location if</em></p><p><strong>phase:</strong> <em>output-body-filter</em></p><p>Equivalent to <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#body_filter_by_lua" target="_blank" rel="noopener">body_filter_by_lua</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or, as from the <code>v0.5.0rc32</code> release, the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lualuajit-bytecode-support" target="_blank" rel="noopener">Lua/LuaJIT bytecode</a> to be executed.</p><p>When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p><p>This directive was first introduced in the <code>v0.5.0rc32</code> release.</p><h2><span id="log_by_lua">log_by_lua</span></h2><p><strong>syntax:</strong> <em>log_by_lua <lua-script-str></lua-script-str></em></p><p><strong>context:</strong> <em>http, server, location, location if</em></p><p><strong>phase:</strong> <em>log</em></p><p><strong>NOTE</strong> Use of this directive is <em>discouraged</em> following the <code>v0.9.17</code> release. Use the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#log_by_lua_block" target="_blank" rel="noopener">log_by_lua_block</a> directive instead.</p><p>Runs the Lua source code inlined as the <code>&lt;lua-script-str&gt;</code> at the <code>log</code> request processing phase. This does not replace the current access logs, but runs before.</p><p>Note that the following API functions are currently disabled within this context:</p><ul><li>Output API functions (e.g., <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsay" target="_blank" rel="noopener">ngx.say</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsend_headers" target="_blank" rel="noopener">ngx.send_headers</a>)</li><li>Control API functions (e.g., <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxexit" target="_blank" rel="noopener">ngx.exit</a>)</li><li>Subrequest API functions (e.g., <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxlocationcapture" target="_blank" rel="noopener">ngx.location.capture</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxlocationcapture_multi" target="_blank" rel="noopener">ngx.location.capture_multi</a>)</li><li>Cosocket API functions (e.g., <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsockettcp" target="_blank" rel="noopener">ngx.socket.tcp</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxreqsocket" target="_blank" rel="noopener">ngx.req.socket</a>).</li></ul><p>Here is an example of gathering average data for <a href="http://nginx.org/en/docs/http/ngx_http_upstream_module.html#var_upstream_response_time" target="_blank" rel="noopener">$upstream_response_time</a>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">lua_shared_dict log_dict 5M;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://mybackend;</span><br><span class="line"></span><br><span class="line">        log_by_lua &apos;</span><br><span class="line">            local log_dict = ngx.shared.log_dict</span><br><span class="line">            local upstream_time = tonumber(ngx.var.upstream_response_time)</span><br><span class="line"></span><br><span class="line">            local sum = log_dict:get(&quot;upstream_time-sum&quot;) or 0</span><br><span class="line">            sum = sum + upstream_time</span><br><span class="line">            log_dict:set(&quot;upstream_time-sum&quot;, sum)</span><br><span class="line"></span><br><span class="line">            local newval, err = log_dict:incr(&quot;upstream_time-nb&quot;, 1)</span><br><span class="line">            if not newval and err == &quot;not found&quot; then</span><br><span class="line">                log_dict:add(&quot;upstream_time-nb&quot;, 0)</span><br><span class="line">                log_dict:incr(&quot;upstream_time-nb&quot;, 1)</span><br><span class="line">            end</span><br><span class="line">        &apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location = /status &#123;</span><br><span class="line">        content_by_lua_block &#123;</span><br><span class="line">            local log_dict = ngx.shared.log_dict</span><br><span class="line">            local sum = log_dict:get(&quot;upstream_time-sum&quot;)</span><br><span class="line">            local nb = log_dict:get(&quot;upstream_time-nb&quot;)</span><br><span class="line"></span><br><span class="line">            if nb and sum then</span><br><span class="line">                ngx.say(&quot;average upstream response time: &quot;, sum / nb,</span><br><span class="line">                        &quot; (&quot;, nb, &quot; reqs)&quot;)</span><br><span class="line">            else</span><br><span class="line">                ngx.say(&quot;no data yet&quot;)</span><br><span class="line">            end</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This directive was first introduced in the <code>v0.5.0rc31</code> release.</p><h2><span id="log_by_lua_block">log_by_lua_block</span></h2><p><strong>syntax:</strong> <em>log_by_lua_block { lua-script }</em></p><p><strong>context:</strong> <em>http, server, location, location if</em></p><p><strong>phase:</strong> <em>log</em></p><p>Similar to the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#log_by_lua" target="_blank" rel="noopener">log_by_lua</a> directive except that this directive inlines the Lua source directly inside a pair of curly braces (<code>{}</code>) instead of in an NGINX string literal (which requires special character escaping).</p><p>For instance,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">log_by_lua_block &#123;</span><br><span class="line">    print(&quot;I need no extra escaping here, for example: \r\nblah&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This directive was first introduced in the <code>v0.9.17</code> release.</p><h2><span id="log_by_lua_file">log_by_lua_file</span></h2><p><strong>syntax:</strong> <em>log_by_lua_file <path-to-lua-script-file></path-to-lua-script-file></em></p><p><strong>context:</strong> <em>http, server, location, location if</em></p><p><strong>phase:</strong> <em>log</em></p><p>Equivalent to <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#log_by_lua" target="_blank" rel="noopener">log_by_lua</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or, as from the <code>v0.5.0rc32</code> release, the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lualuajit-bytecode-support" target="_blank" rel="noopener">Lua/LuaJIT bytecode</a> to be executed.</p><p>When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p><p>This directive was first introduced in the <code>v0.5.0rc31</code> release.</p><h2><span id="balancer_by_lua_block">balancer_by_lua_block</span></h2><p><strong>syntax:</strong> <em>balancer_by_lua_block { lua-script }</em></p><p><strong>context:</strong> <em>upstream</em></p><p><strong>phase:</strong> <em>content</em></p><p>This directive runs Lua code as an upstream balancer for any upstream entities defined by the <code>upstream {}</code> configuration block.</p><p>For instance,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">upstream foo &#123;</span><br><span class="line">    server 127.0.0.1;</span><br><span class="line">    balancer_by_lua_block &#123;</span><br><span class="line">        -- use Lua to do something interesting here</span><br><span class="line">        -- as a dynamic balancer</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://foo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The resulting Lua load balancer can work with any existing nginx upstream modules like <a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html" target="_blank" rel="noopener">ngx_proxy</a> and <a href="http://nginx.org/en/docs/http/ngx_http_fastcgi_module.html" target="_blank" rel="noopener">ngx_fastcgi</a>.</p><p>Also, the Lua load balancer can work with the standard upstream connection pool mechanism, i.e., the standard <a href="http://nginx.org/en/docs/http/ngx_http_upstream_module.html#keepalive" target="_blank" rel="noopener">keepalive</a>directive. Just ensure that the <a href="http://nginx.org/en/docs/http/ngx_http_upstream_module.html#keepalive" target="_blank" rel="noopener">keepalive</a> directive is used <em>after</em> this <code>balancer_by_lua_block</code> directive in a single <code>upstream {}</code>configuration block.</p><p>The Lua load balancer can totally ignore the list of servers defined in the <code>upstream {}</code> block and select peer from a completely dynamic server list (even changing per request) via the <a href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/balancer.md" target="_blank" rel="noopener">ngx.balancer</a> module from the <a href="https://github.com/openresty/lua-resty-core" target="_blank" rel="noopener">lua-resty-core</a> library.</p><p>The Lua code handler registered by this directive might get called more than once in a single downstream request when the nginx upstream mechanism retries the request on conditions specified by directives like the <a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_next_upstream" target="_blank" rel="noopener">proxy_next_upstream</a> directive.</p><p>This Lua code execution context does not support yielding, so Lua APIs that may yield (like cosockets and “light threads”) are disabled in this context. One can usually work around this limitation by doing such operations in an earlier phase handler (like<a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#access_by_lua" target="_blank" rel="noopener">access_by_lua*</a>) and passing along the result into this context via the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxctx" target="_blank" rel="noopener">ngx.ctx</a> table.</p><p>This directive was first introduced in the <code>v0.10.0</code> release.</p><h2><span id="balancer_by_lua_file">balancer_by_lua_file</span></h2><p><strong>syntax:</strong> <em>balancer_by_lua_file <path-to-lua-script-file></path-to-lua-script-file></em></p><p><strong>context:</strong> <em>upstream</em></p><p><strong>phase:</strong> <em>content</em></p><p>Equivalent to <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#balancer_by_lua_block" target="_blank" rel="noopener">balancer_by_lua_block</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or, as from the <code>v0.5.0rc32</code> release, the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lualuajit-bytecode-support" target="_blank" rel="noopener">Lua/LuaJIT bytecode</a> to be executed.</p><p>When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p><p>This directive was first introduced in the <code>v0.10.0</code> release.</p><h2><span id="lua_need_request_body">lua_need_request_body</span></h2><p><strong>syntax:</strong> <em>lua_need_request_body &lt;on|off&gt;</em></p><p><strong>default:</strong> <em>off</em></p><p><strong>context:</strong> <em>http, server, location, location if</em></p><p><strong>phase:</strong> <em>depends on usage</em></p><p>Determines whether to force the request body data to be read before running rewrite/access/access_by_lua* or not. The Nginx core does not read the client request body by default and if request body data is required, then this directive should be turned <code>on</code> or the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxreqread_body" target="_blank" rel="noopener">ngx.req.read_body</a> function should be called within the Lua code.</p><p>To read the request body data within the <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#var_request_body" target="_blank" rel="noopener">$request_body</a> variable, <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_buffer_size" target="_blank" rel="noopener">client_body_buffer_size</a> must have the same value as <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#client_max_body_size" target="_blank" rel="noopener">client_max_body_size</a>. Because when the content length exceeds <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_buffer_size" target="_blank" rel="noopener">client_body_buffer_size</a> but less than <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#client_max_body_size" target="_blank" rel="noopener">client_max_body_size</a>, Nginx will buffer the data into a temporary file on the disk, which will lead to empty value in the <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#var_request_body" target="_blank" rel="noopener">$request_body</a> variable.</p><p>If the current location includes <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#rewrite_by_lua" target="_blank" rel="noopener">rewrite_by_lua*</a> directives, then the request body will be read just before the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#rewrite_by_lua" target="_blank" rel="noopener">rewrite_by_lua*</a>code is run (and also at the <code>rewrite</code> phase). Similarly, if only <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#content_by_lua" target="_blank" rel="noopener">content_by_lua</a> is specified, the request body will not be read until the content handler’s Lua code is about to run (i.e., the request body will be read during the content phase).</p><p>It is recommended however, to use the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxreqread_body" target="_blank" rel="noopener">ngx.req.read_body</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxreqdiscard_body" target="_blank" rel="noopener">ngx.req.discard_body</a> functions for finer control over the request body reading process instead.</p><p>This also applies to <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#access_by_lua" target="_blank" rel="noopener">access_by_lua*</a>.</p><h2><span id="ssl_certificate_by_lua_block">ssl_certificate_by_lua_block</span></h2><p><strong>syntax:</strong> <em>ssl_certificate_by_lua_block { lua-script }</em></p><p><strong>context:</strong> <em>server</em></p><p><strong>phase:</strong> <em>right-before-SSL-handshake</em></p><p>This directive runs user Lua code when NGINX is about to start the SSL handshake for the downstream SSL (https) connections.</p><p>It is particularly useful for setting the SSL certificate chain and the corresponding private key on a per-request basis. It is also useful to load such handshake configurations nonblockingly from the remote (for example, with the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsockettcp" target="_blank" rel="noopener">cosocket</a> API). And one can also do per-request OCSP stapling handling in pure Lua here as well.</p><p>Another typical use case is to do SSL handshake traffic control nonblockingly in this context, with the help of the <a href="https://github.com/openresty/lua-resty-limit-traffic" target="_blank" rel="noopener">lua-resty-limit-traffic#readme</a> library, for example.</p><p>One can also do interesting things with the SSL handshake requests from the client side, like rejecting old SSL clients using the SSLv3 protocol or even below selectively.</p><p>The <a href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl.md" target="_blank" rel="noopener">ngx.ssl</a> and <a href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ocsp.md" target="_blank" rel="noopener">ngx.ocsp</a> Lua modules provided by the <a href="https://github.com/openresty/lua-resty-core/#readme" target="_blank" rel="noopener">lua-resty-core</a> library are particularly useful in this context. You can use the Lua API offered by these two Lua modules to manipulate the SSL certificate chain and private key for the current SSL connection being initiated.</p><p>This Lua handler does not run at all, however, when NGINX/OpenSSL successfully resumes the SSL session via SSL session IDs or TLS session tickets for the current SSL connection. In other words, this Lua handler only runs when NGINX has to initiate a full SSL handshake.</p><p>Below is a trivial example using the <a href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl.md" target="_blank" rel="noopener">ngx.ssl</a> module at the same time:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name   test.com;</span><br><span class="line"></span><br><span class="line">    ssl_certificate_by_lua_block &#123;</span><br><span class="line">        print(&quot;About to initiate a new SSL handshake!&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>See more complicated examples in the <a href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl.md" target="_blank" rel="noopener">ngx.ssl</a> and <a href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ocsp.md" target="_blank" rel="noopener">ngx.ocsp</a> Lua modules’ official documentation.</p><p>Uncaught Lua exceptions in the user Lua code immediately abort the current SSL session, so does the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxexit" target="_blank" rel="noopener">ngx.exit</a> call with an error code like <code>ngx.ERROR</code>.</p><p>This Lua code execution context <em>does</em> support yielding, so Lua APIs that may yield (like cosockets, sleeping, and “light threads”) are enabled in this context.</p><p>Note, however, you still need to configure the <a href="http://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_certificate" target="_blank" rel="noopener">ssl_certificate</a> and <a href="http://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_certificate_key" target="_blank" rel="noopener">ssl_certificate_key</a> directives even though you will not use this static certificate and private key at all. This is because the NGINX core requires their appearance otherwise you are seeing the following error while starting NGINX:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx: [emerg] no ssl configured for the server</span><br></pre></td></tr></table></figure><p>This directive currently requires the following NGINX core patch to work correctly:</p><p><a href="http://mailman.nginx.org/pipermail/nginx-devel/2016-January/007748.html" target="_blank" rel="noopener">http://mailman.nginx.org/pipermail/nginx-devel/2016-January/007748.html</a></p><p>The bundled version of the NGINX core in OpenResty 1.9.7.2 (or above) already has this patch applied.</p><p>Furthermore, one needs at least OpenSSL 1.0.2e for this directive to work.</p><p>This directive was first introduced in the <code>v0.10.0</code> release.</p><h2><span id="ssl_certificate_by_lua_file">ssl_certificate_by_lua_file</span></h2><p><strong>syntax:</strong> <em>ssl_certificate_by_lua_file <path-to-lua-script-file></path-to-lua-script-file></em></p><p><strong>context:</strong> <em>server</em></p><p><strong>phase:</strong> <em>right-before-SSL-handshake</em></p><p>Equivalent to <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ssl_certificate_by_lua_block" target="_blank" rel="noopener">ssl_certificate_by_lua_block</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or, as from the <code>v0.5.0rc32</code> release, the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lualuajit-bytecode-support" target="_blank" rel="noopener">Lua/LuaJIT bytecode</a> to be executed.</p><p>When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p><p>This directive was first introduced in the <code>v0.10.0</code> release.</p><h2><span id="ssl_session_fetch_by_lua_block">ssl_session_fetch_by_lua_block</span></h2><p><strong>syntax:</strong> <em>ssl_session_fetch_by_lua_block { lua-script }</em></p><p><strong>context:</strong> <em>http</em></p><p><strong>phase:</strong> <em>right-before-SSL-handshake</em></p><p>This directive runs Lua code to look up and load the SSL session (if any) according to the session ID provided by the current SSL handshake request for the downstream.</p><p>The Lua API for obtaining the current session ID and loading a cached SSL session data is provided in the <a href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl/session.md" target="_blank" rel="noopener">ngx.ssl.session</a> Lua module shipped with the <a href="https://github.com/openresty/lua-resty-core#readme" target="_blank" rel="noopener">lua-resty-core</a> library.</p><p>Lua APIs that may yield, like <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsleep" target="_blank" rel="noopener">ngx.sleep</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsockettcp" target="_blank" rel="noopener">cosockets</a>, are enabled in this context.</p><p>This hook, together with the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ssl_session_store_by_lua_block" target="_blank" rel="noopener">ssl_session_store_by_lua*</a> hook, can be used to implement distributed caching mechanisms in pure Lua (based on the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsockettcp" target="_blank" rel="noopener">cosocket</a> API, for example). If a cached SSL session is found and loaded into the current SSL connection context, SSL session resumption can then get immediately initiated and bypass the full SSL handshake process which is very expensive in terms of CPU time.</p><p>Please note that TLS session tickets are very different and it is the clients’ responsibility to cache the SSL session state when session tickets are used. SSL session resumptions based on TLS session tickets would happen automatically without going through this hook (nor the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ssl_session_store_by_lua_block" target="_blank" rel="noopener">ssl_session_store_by_lua*</a> hook). This hook is mainly for older or less capable SSL clients that can only do SSL sessions by session IDs.</p><p>When <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ssl_certificate_by_lua_block" target="_blank" rel="noopener">ssl_certificate_by_lua*</a> is specified at the same time, this hook usually runs before <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ssl_certificate_by_lua_block" target="_blank" rel="noopener">ssl_certificate_by_lua*</a>. When the SSL session is found and successfully loaded for the current SSL connection, SSL session resumption will happen and thus bypass the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ssl_certificate_by_lua_block" target="_blank" rel="noopener">ssl_certificate_by_lua*</a> hook completely. In this case, NGINX also bypasses the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ssl_session_store_by_lua_block" target="_blank" rel="noopener">ssl_session_store_by_lua*</a> hook, for obvious reasons.</p><p>To easily test this hook locally with a modern web browser, you can temporarily put the following line in your https server block to disable the TLS session ticket support:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssl_session_tickets off;</span><br></pre></td></tr></table></figure><p>But do not forget to comment this line out before publishing your site to the world.</p><p>If you are using the <a href="http://openresty.org/en/linux-packages.html" target="_blank" rel="noopener">official pre-built packages</a> for <a href="https://openresty.org/" target="_blank" rel="noopener">OpenResty</a> 1.11.2.1 or later, then everything should work out of the box.</p><p>If you are using OpenSSL libraries not provided by <a href="https://openresty.org/" target="_blank" rel="noopener">OpenResty</a>, then you need to apply the following patch for OpenSSL 1.0.2h or later:</p><p><a href="https://github.com/openresty/openresty/blob/master/patches/openssl-1.0.2h-sess_set_get_cb_yield.patch" target="_blank" rel="noopener">https://github.com/openresty/openresty/blob/master/patches/openssl-1.0.2h-sess_set_get_cb_yield.patch</a></p><p>If you are not using the NGINX core shipped with <a href="https://openresty.org/" target="_blank" rel="noopener">OpenResty</a> 1.11.2.1 or later, then you need to apply the following patch to the standard NGINX core 1.11.2 or later:</p><p><a href="http://openresty.org/download/nginx-1.11.2-nonblocking_ssl_handshake_hooks.patch" target="_blank" rel="noopener">http://openresty.org/download/nginx-1.11.2-nonblocking_ssl_handshake_hooks.patch</a></p><p>This directive was first introduced in the <code>v0.10.6</code> release.</p><p>Note that: this directive is only allowed to used in <strong>http context</strong> from the <code>v0.10.7</code> release (because SSL session resumption happens before server name dispatch).</p><h2><span id="ssl_session_fetch_by_lua_file">ssl_session_fetch_by_lua_file</span></h2><p><strong>syntax:</strong> <em>ssl_session_fetch_by_lua_file <path-to-lua-script-file></path-to-lua-script-file></em></p><p><strong>context:</strong> <em>http</em></p><p><strong>phase:</strong> <em>right-before-SSL-handshake</em></p><p>Equivalent to <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ssl_session_fetch_by_lua_block" target="_blank" rel="noopener">ssl_session_fetch_by_lua_block</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or rather, the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lualuajit-bytecode-support" target="_blank" rel="noopener">Lua/LuaJIT bytecode</a> to be executed.</p><p>When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p><p>This directive was first introduced in the <code>v0.10.6</code> release.</p><p>Note that: this directive is only allowed to used in <strong>http context</strong> from the <code>v0.10.7</code> release (because SSL session resumption happens before server name dispatch).</p><h2><span id="ssl_session_store_by_lua_block">ssl_session_store_by_lua_block</span></h2><p><strong>syntax:</strong> <em>ssl_session_store_by_lua_block { lua-script }</em></p><p><strong>context:</strong> <em>http</em></p><p><strong>phase:</strong> <em>right-after-SSL-handshake</em></p><p>This directive runs Lua code to fetch and save the SSL session (if any) according to the session ID provided by the current SSL handshake request for the downstream. The saved or cached SSL session data can be used for future SSL connections to resume SSL sessions without going through the full SSL handshake process (which is very expensive in terms of CPU time).</p><p>Lua APIs that may yield, like <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsleep" target="_blank" rel="noopener">ngx.sleep</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsockettcp" target="_blank" rel="noopener">cosockets</a>, are <em>disabled</em> in this context. You can still, however, use the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxtimerat" target="_blank" rel="noopener">ngx.timer.at</a>API to create 0-delay timers to save the SSL session data asynchronously to external services (like <code>redis</code> or <code>memcached</code>).</p><p>The Lua API for obtaining the current session ID and the associated session state data is provided in the <a href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl/session.md#readme" target="_blank" rel="noopener">ngx.ssl.session</a> Lua module shipped with the <a href="https://github.com/openresty/lua-resty-core#readme" target="_blank" rel="noopener">lua-resty-core</a> library.</p><p>To easily test this hook locally with a modern web browser, you can temporarily put the following line in your https server block to disable the TLS session ticket support:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssl_session_tickets off;</span><br></pre></td></tr></table></figure><p>But do not forget to comment this line out before publishing your site to the world.</p><p>This directive was first introduced in the <code>v0.10.6</code> release.</p><p>Note that: this directive is only allowed to used in <strong>http context</strong> from the <code>v0.10.7</code> release (because SSL session resumption happens before server name dispatch).</p><h2><span id="ssl_session_store_by_lua_file">ssl_session_store_by_lua_file</span></h2><p><strong>syntax:</strong> <em>ssl_session_store_by_lua_file <path-to-lua-script-file></path-to-lua-script-file></em></p><p><strong>context:</strong> <em>http</em></p><p><strong>phase:</strong> <em>right-after-SSL-handshake</em></p><p>Equivalent to <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ssl_session_store_by_lua_block" target="_blank" rel="noopener">ssl_session_store_by_lua_block</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or rather, the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lualuajit-bytecode-support" target="_blank" rel="noopener">Lua/LuaJIT bytecode</a> to be executed.</p><p>When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p><p>This directive was first introduced in the <code>v0.10.6</code> release.</p><p>Note that: this directive is only allowed to used in <strong>http context</strong> from the <code>v0.10.7</code> release (because SSL session resumption happens before server name dispatch).</p><h2><span id="lua_shared_dict">lua_shared_dict</span></h2><p><strong>syntax:</strong> <em>lua_shared_dict <name> <size></size></name></em></p><p><strong>default:</strong> <em>no</em></p><p><strong>context:</strong> <em>http</em></p><p><strong>phase:</strong> <em>depends on usage</em></p><p>Declares a shared memory zone, <code>&lt;name&gt;</code>, to serve as storage for the shm based Lua dictionary <code>ngx.shared.&lt;name&gt;</code>.</p><p>Shared memory zones are always shared by all the nginx worker processes in the current nginx server instance.</p><p>The <code>&lt;size&gt;</code> argument accepts size units such as <code>k</code> and <code>m</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    lua_shared_dict dogs 10m;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The hard-coded minimum size is 8KB while the practical minimum size depends on actual user data set (some people start with 12KB).</p><p>See <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxshareddict" target="_blank" rel="noopener">ngx.shared.DICT</a> for details.</p><p>This directive was first introduced in the <code>v0.3.1rc22</code> release.</p><h2><span id="lua_socket_connect_timeout">lua_socket_connect_timeout</span></h2><p><strong>syntax:</strong> <em>lua_socket_connect_timeout <time></time></em></p><p><strong>default:</strong> <em>lua_socket_connect_timeout 60s</em></p><p><strong>context:</strong> <em>http, server, location</em></p><p>This directive controls the default timeout value used in TCP/unix-domain socket object’s <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#tcpsockconnect" target="_blank" rel="noopener">connect</a> method and can be overridden by the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#tcpsocksettimeout" target="_blank" rel="noopener">settimeout</a> or <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#tcpsocksettimeouts" target="_blank" rel="noopener">settimeouts</a> methods.</p><p>The <code>&lt;time&gt;</code> argument can be an integer, with an optional time unit, like <code>s</code> (second), <code>ms</code> (millisecond), <code>m</code> (minute). The default time unit is <code>s</code>, i.e., “second”. The default setting is <code>60s</code>.</p><p>This directive was first introduced in the <code>v0.5.0rc1</code> release.</p><h2><span id="lua_socket_send_timeout">lua_socket_send_timeout</span></h2><p><strong>syntax:</strong> <em>lua_socket_send_timeout <time></time></em></p><p><strong>default:</strong> <em>lua_socket_send_timeout 60s</em></p><p><strong>context:</strong> <em>http, server, location</em></p><p>Controls the default timeout value used in TCP/unix-domain socket object’s <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#tcpsocksend" target="_blank" rel="noopener">send</a> method and can be overridden by the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#tcpsocksettimeout" target="_blank" rel="noopener">settimeout</a> or <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#tcpsocksettimeouts" target="_blank" rel="noopener">settimeouts</a> methods.</p><p>The <code>&lt;time&gt;</code> argument can be an integer, with an optional time unit, like <code>s</code> (second), <code>ms</code> (millisecond), <code>m</code> (minute). The default time unit is <code>s</code>, i.e., “second”. The default setting is <code>60s</code>.</p><p>This directive was first introduced in the <code>v0.5.0rc1</code> release.</p><h2><span id="lua_socket_send_lowat">lua_socket_send_lowat</span></h2><p><strong>syntax:</strong> <em>lua_socket_send_lowat <size></size></em></p><p><strong>default:</strong> <em>lua_socket_send_lowat 0</em></p><p><strong>context:</strong> <em>http, server, location</em></p><p>Controls the <code>lowat</code> (low water) value for the cosocket send buffer.</p><h2><span id="lua_socket_read_timeout">lua_socket_read_timeout</span></h2><p><strong>syntax:</strong> <em>lua_socket_read_timeout <time></time></em></p><p><strong>default:</strong> <em>lua_socket_read_timeout 60s</em></p><p><strong>context:</strong> <em>http, server, location</em></p><p><strong>phase:</strong> <em>depends on usage</em></p><p>This directive controls the default timeout value used in TCP/unix-domain socket object’s <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#tcpsockreceive" target="_blank" rel="noopener">receive</a> method and iterator functions returned by the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#tcpsockreceiveuntil" target="_blank" rel="noopener">receiveuntil</a> method. This setting can be overridden by the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#tcpsocksettimeout" target="_blank" rel="noopener">settimeout</a> or <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#tcpsocksettimeouts" target="_blank" rel="noopener">settimeouts</a> methods.</p><p>The <code>&lt;time&gt;</code> argument can be an integer, with an optional time unit, like <code>s</code> (second), <code>ms</code> (millisecond), <code>m</code> (minute). The default time unit is <code>s</code>, i.e., “second”. The default setting is <code>60s</code>.</p><p>This directive was first introduced in the <code>v0.5.0rc1</code> release.</p><h2><span id="lua_socket_buffer_size">lua_socket_buffer_size</span></h2><p><strong>syntax:</strong> <em>lua_socket_buffer_size <size></size></em></p><p><strong>default:</strong> <em>lua_socket_buffer_size 4k/8k</em></p><p><strong>context:</strong> <em>http, server, location</em></p><p>Specifies the buffer size used by cosocket reading operations.</p><p>This buffer does not have to be that big to hold everything at the same time because cosocket supports 100% non-buffered reading and parsing. So even <code>1</code> byte buffer size should still work everywhere but the performance could be terrible.</p><p>This directive was first introduced in the <code>v0.5.0rc1</code> release.</p><h2><span id="lua_socket_pool_size">lua_socket_pool_size</span></h2><p><strong>syntax:</strong> <em>lua_socket_pool_size <size></size></em></p><p><strong>default:</strong> <em>lua_socket_pool_size 30</em></p><p><strong>context:</strong> <em>http, server, location</em></p><p>Specifies the size limit (in terms of connection count) for every cosocket connection pool associated with every remote server (i.e., identified by either the host-port pair or the unix domain socket file path).</p><p>Default to 30 connections for every pool.</p><p>When the connection pool exceeds the available size limit, the least recently used (idle) connection already in the pool will be closed to make room for the current connection.</p><p>Note that the cosocket connection pool is per nginx worker process rather than per nginx server instance, so size limit specified here also applies to every single nginx worker process.</p><p>This directive was first introduced in the <code>v0.5.0rc1</code> release.</p><h2><span id="lua_socket_keepalive_timeout">lua_socket_keepalive_timeout</span></h2><p><strong>syntax:</strong> <em>lua_socket_keepalive_timeout <time></time></em></p><p><strong>default:</strong> <em>lua_socket_keepalive_timeout 60s</em></p><p><strong>context:</strong> <em>http, server, location</em></p><p>This directive controls the default maximal idle time of the connections in the cosocket built-in connection pool. When this timeout reaches, idle connections will be closed and removed from the pool. This setting can be overridden by cosocket objects’ <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#tcpsocksetkeepalive" target="_blank" rel="noopener">setkeepalive</a> method.</p><p>The <code>&lt;time&gt;</code> argument can be an integer, with an optional time unit, like <code>s</code> (second), <code>ms</code> (millisecond), <code>m</code> (minute). The default time unit is <code>s</code>, i.e., “second”. The default setting is <code>60s</code>.</p><p>This directive was first introduced in the <code>v0.5.0rc1</code> release.</p><h2><span id="lua_socket_log_errors">lua_socket_log_errors</span></h2><p><strong>syntax:</strong> <em>lua_socket_log_errors on|off</em></p><p><strong>default:</strong> <em>lua_socket_log_errors on</em></p><p><strong>context:</strong> <em>http, server, location</em></p><p>This directive can be used to toggle error logging when a failure occurs for the TCP or UDP cosockets. If you are already doing proper error handling and logging in your Lua code, then it is recommended to turn this directive off to prevent data flushing in your nginx error log files (which is usually rather expensive).</p><p>This directive was first introduced in the <code>v0.5.13</code> release.</p><h2><span id="lua_ssl_ciphers">lua_ssl_ciphers</span></h2><p><strong>syntax:</strong> <em>lua_ssl_ciphers <ciphers></ciphers></em></p><p><strong>default:</strong> <em>lua_ssl_ciphers DEFAULT</em></p><p><strong>context:</strong> <em>http, server, location</em></p><p>Specifies the enabled ciphers for requests to a SSL/TLS server in the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#tcpsocksslhandshake" target="_blank" rel="noopener">tcpsock:sslhandshake</a> method. The ciphers are specified in the format understood by the OpenSSL library.</p><p>The full list can be viewed using the “openssl ciphers” command.</p><p>This directive was first introduced in the <code>v0.9.11</code> release.</p><h2><span id="lua_ssl_crl">lua_ssl_crl</span></h2><p><strong>syntax:</strong> <em>lua_ssl_crl <file></file></em></p><p><strong>default:</strong> <em>no</em></p><p><strong>context:</strong> <em>http, server, location</em></p><p>Specifies a file with revoked certificates (CRL) in the PEM format used to verify the certificate of the SSL/TLS server in the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#tcpsocksslhandshake" target="_blank" rel="noopener">tcpsock:sslhandshake</a> method.</p><p>This directive was first introduced in the <code>v0.9.11</code> release.</p><h2><span id="lua_ssl_protocols">lua_ssl_protocols</span></h2><p><strong>syntax:</strong> <em>lua_ssl_protocols [SSLv2] [SSLv3] [TLSv1] [TLSv1.1] [TLSv1.2] [TLSv1.3]</em></p><p><strong>default:</strong> <em>lua_ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2</em></p><p><strong>context:</strong> <em>http, server, location</em></p><p>Enables the specified protocols for requests to a SSL/TLS server in the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#tcpsocksslhandshake" target="_blank" rel="noopener">tcpsock:sslhandshake</a> method.</p><p>The support for the <code>TLSv1.3</code> parameter requires version <code>v0.10.12</code> <em>and</em> OpenSSL 1.1.1.</p><p>This directive was first introduced in the <code>v0.9.11</code> release.</p><h2><span id="lua_ssl_trusted_certificate">lua_ssl_trusted_certificate</span></h2><p><strong>syntax:</strong> <em>lua_ssl_trusted_certificate <file></file></em></p><p><strong>default:</strong> <em>no</em></p><p><strong>context:</strong> <em>http, server, location</em></p><p>Specifies a file path with trusted CA certificates in the PEM format used to verify the certificate of the SSL/TLS server in the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#tcpsocksslhandshake" target="_blank" rel="noopener">tcpsock:sslhandshake</a> method.</p><p>This directive was first introduced in the <code>v0.9.11</code> release.</p><p>See also <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lua_ssl_verify_depth" target="_blank" rel="noopener">lua_ssl_verify_depth</a>.</p><h2><span id="lua_ssl_verify_depth">lua_ssl_verify_depth</span></h2><p><strong>syntax:</strong> <em>lua_ssl_verify_depth <number></number></em></p><p><strong>default:</strong> <em>lua_ssl_verify_depth 1</em></p><p><strong>context:</strong> <em>http, server, location</em></p><p>Sets the verification depth in the server certificates chain.</p><p>This directive was first introduced in the <code>v0.9.11</code> release.</p><p>See also <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lua_ssl_trusted_certificate" target="_blank" rel="noopener">lua_ssl_trusted_certificate</a>.</p><h2><span id="lua_http10_buffering">lua_http10_buffering</span></h2><p><strong>syntax:</strong> <em>lua_http10_buffering on|off</em></p><p><strong>default:</strong> <em>lua_http10_buffering on</em></p><p><strong>context:</strong> <em>http, server, location, location-if</em></p><p>Enables or disables automatic response buffering for HTTP 1.0 (or older) requests. This buffering mechanism is mainly used for HTTP 1.0 keep-alive which relies on a proper <code>Content-Length</code> response header.</p><p>If the Lua code explicitly sets a <code>Content-Length</code> response header before sending the headers (either explicitly via <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsend_headers" target="_blank" rel="noopener">ngx.send_headers</a> or implicitly via the first <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsay" target="_blank" rel="noopener">ngx.say</a> or <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxprint" target="_blank" rel="noopener">ngx.print</a> call), then the HTTP 1.0 response buffering will be disabled even when this directive is turned on.</p><p>To output very large response data in a streaming fashion (via the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxflush" target="_blank" rel="noopener">ngx.flush</a> call, for example), this directive MUST be turned off to minimize memory usage.</p><p>This directive is turned <code>on</code> by default.</p><p>This directive was first introduced in the <code>v0.5.0rc19</code> release.</p><h2><span id="rewrite_by_lua_no_postpone">rewrite_by_lua_no_postpone</span></h2><p><strong>syntax:</strong> <em>rewrite_by_lua_no_postpone on|off</em></p><p><strong>default:</strong> <em>rewrite_by_lua_no_postpone off</em></p><p><strong>context:</strong> <em>http</em></p><p>Controls whether or not to disable postponing <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#rewrite_by_lua" target="_blank" rel="noopener">rewrite_by_lua*</a> directives to run at the end of the <code>rewrite</code> request-processing phase. By default, this directive is turned off and the Lua code is postponed to run at the end of the <code>rewrite</code> phase.</p><p>This directive was first introduced in the <code>v0.5.0rc29</code> release.</p><h2><span id="access_by_lua_no_postpone">access_by_lua_no_postpone</span></h2><p><strong>syntax:</strong> <em>access_by_lua_no_postpone on|off</em></p><p><strong>default:</strong> <em>access_by_lua_no_postpone off</em></p><p><strong>context:</strong> <em>http</em></p><p>Controls whether or not to disable postponing <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#access_by_lua" target="_blank" rel="noopener">access_by_lua*</a> directives to run at the end of the <code>access</code> request-processing phase. By default, this directive is turned off and the Lua code is postponed to run at the end of the <code>access</code> phase.</p><p>This directive was first introduced in the <code>v0.9.20</code> release.</p><h2><span id="lua_transform_underscores_in_response_headers">lua_transform_underscores_in_response_headers</span></h2><p><strong>syntax:</strong> <em>lua_transform_underscores_in_response_headers on|off</em></p><p><strong>default:</strong> <em>lua_transform_underscores_in_response_headers on</em></p><p><strong>context:</strong> <em>http, server, location, location-if</em></p><p>Controls whether to transform underscores (<code>_</code>) in the response header names specified in the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxheaderheader" target="_blank" rel="noopener">ngx.header.HEADER</a> API to hypens (<code>-</code>).</p><p>This directive was first introduced in the <code>v0.5.0rc32</code> release.</p><h2><span id="lua_check_client_abort">lua_check_client_abort</span></h2><p><strong>syntax:</strong> <em>lua_check_client_abort on|off</em></p><p><strong>default:</strong> <em>lua_check_client_abort off</em></p><p><strong>context:</strong> <em>http, server, location, location-if</em></p><p>This directive controls whether to check for premature client connection abortion.</p><p>When this directive is on, the ngx_lua module will monitor the premature connection close event on the downstream connections and when there is such an event, it will call the user Lua function callback (registered by <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxon_abort" target="_blank" rel="noopener">ngx.on_abort</a>) or just stop and clean up all the Lua “light threads” running in the current request’s request handler when there is no user callback function registered.</p><p>According to the current implementation, however, if the client closes the connection before the Lua code finishes reading the request body data via <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxreqsocket" target="_blank" rel="noopener">ngx.req.socket</a>, then ngx_lua will neither stop all the running “light threads” nor call the user callback (if <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxon_abort" target="_blank" rel="noopener">ngx.on_abort</a> has been called). Instead, the reading operation on <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxreqsocket" target="_blank" rel="noopener">ngx.req.socket</a> will just return the error message “client aborted” as the second return value (the first return value is surely <code>nil</code>).</p><p>When TCP keepalive is disabled, it is relying on the client side to close the socket gracefully (by sending a <code>FIN</code> packet or something like that). For (soft) real-time web applications, it is highly recommended to configure the <a href="http://tldp.org/HOWTO/TCP-Keepalive-HOWTO/overview.html" target="_blank" rel="noopener">TCP keepalive</a> support in your system’s TCP stack implementation in order to detect “half-open” TCP connections in time.</p><p>For example, on Linux, you can configure the standard <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#listen" target="_blank" rel="noopener">listen</a> directive in your <code>nginx.conf</code> file like this:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listen 80 so_keepalive=2s:2s:8;</span><br></pre></td></tr></table></figure><p>On FreeBSD, you can only tune the system-wide configuration for TCP keepalive, for example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># sysctl net.inet.tcp.keepintvl=2000</span><br><span class="line"># sysctl net.inet.tcp.keepidle=2000</span><br></pre></td></tr></table></figure><p>This directive was first introduced in the <code>v0.7.4</code> release.</p><p>See also <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxon_abort" target="_blank" rel="noopener">ngx.on_abort</a>.</p><h2><span id="lua_max_pending_timers">lua_max_pending_timers</span></h2><p><strong>syntax:</strong> <em>lua_max_pending_timers <count></count></em></p><p><strong>default:</strong> <em>lua_max_pending_timers 1024</em></p><p><strong>context:</strong> <em>http</em></p><p>Controls the maximum number of pending timers allowed.</p><p>Pending timers are those timers that have not expired yet.</p><p>When exceeding this limit, the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxtimerat" target="_blank" rel="noopener">ngx.timer.at</a> call will immediately return <code>nil</code> and the error string “too many pending timers”.</p><p>This directive was first introduced in the <code>v0.8.0</code> release.</p><h2><span id="lua_max_running_timers">lua_max_running_timers</span></h2><p><strong>syntax:</strong> <em>lua_max_running_timers <count></count></em></p><p><strong>default:</strong> <em>lua_max_running_timers 256</em></p><p><strong>context:</strong> <em>http</em></p><p>Controls the maximum number of “running timers” allowed.</p><p>Running timers are those timers whose user callback functions are still running.</p><p>When exceeding this limit, Nginx will stop running the callbacks of newly expired timers and log an error message “N lua_max_running_timers are not enough” where “N” is the current value of this directive.</p><p>This directive was first introduced in the <code>v0.8.0</code> release.</p><h2><span id="lua_sa_restart">lua_sa_restart</span></h2><p><strong>syntax:</strong> <em>lua_sa_restart on|off</em></p><p><strong>default:</strong> <em>lua_sa_restart on</em></p><p><strong>context:</strong> <em>http</em></p><p>When enabled, this module will set the <code>SA_RESTART</code> flag on nginx workers signal dispositions.</p><p>This allows Lua I/O primitives to not be interrupted by nginx’s handling of various signals.</p><p>This directive was first introduced in the <code>v0.10.14</code> release</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#nginx-directives-for-lua&quot;&gt;Nginx Directives For Lua&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#lua_capture_error_log&quot;&gt;lua_capture_
      
    
    </summary>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>nginx-lua-API</title>
    <link href="http://yoursite.com/2018/03/01/nginx-lua-API/"/>
    <id>http://yoursite.com/2018/03/01/nginx-lua-API/</id>
    <published>2018-03-01T04:17:54.000Z</published>
    <updated>2019-03-01T06:26:12.196Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#nginx-api-for-lua">Nginx API for Lua</a><ul><li><a href="#introduction">Introduction</a></li><li><a href="#ngxarg">ngx.arg</a></li><li><a href="#ngxvarvariable">ngx.var.VARIABLE</a></li><li><a href="#core-constants">Core constants</a></li><li><a href="#http-method-constants">HTTP method constants</a></li><li><a href="#http-status-constants">HTTP status constants</a></li><li><a href="#nginx-log-level-constants">Nginx log level constants</a></li><li><a href="#print">print</a></li><li><a href="#ngxctx">ngx.ctx</a></li><li><a href="#ngxlocationcapture">ngx.location.capture</a></li><li><a href="#ngxlocationcapture_multi">ngx.location.capture_multi</a></li><li><a href="#ngxstatus">ngx.status</a></li><li><a href="#ngxheaderheader">ngx.header.HEADER</a></li><li><a href="#ngxrespget_headers">ngx.resp.get_headers</a></li><li><a href="#ngxreqis_internal">ngx.req.is_internal</a></li><li><a href="#ngxreqstart_time">ngx.req.start_time</a></li><li><a href="#ngxreqhttp_version">ngx.req.http_version</a></li><li><a href="#ngxreqraw_header">ngx.req.raw_header</a></li><li><a href="#ngxreqget_method">ngx.req.get_method</a></li><li><a href="#ngxreqset_method">ngx.req.set_method</a></li><li><a href="#ngxreqset_uri">ngx.req.set_uri</a></li><li><a href="#ngxreqset_uri_args">ngx.req.set_uri_args</a></li><li><a href="#ngxreqget_uri_args">ngx.req.get_uri_args</a></li><li><a href="#ngxreqget_post_args">ngx.req.get_post_args</a></li><li><a href="#ngxreqget_headers">ngx.req.get_headers</a></li><li><a href="#ngxreqset_header">ngx.req.set_header</a></li><li><a href="#ngxreqclear_header">ngx.req.clear_header</a></li><li><a href="#ngxreqread_body">ngx.req.read_body</a></li><li><a href="#ngxreqdiscard_body">ngx.req.discard_body</a></li><li><a href="#ngxreqget_body_data">ngx.req.get_body_data</a></li><li><a href="#ngxreqget_body_file">ngx.req.get_body_file</a></li><li><a href="#ngxreqset_body_data">ngx.req.set_body_data</a></li><li><a href="#ngxreqset_body_file">ngx.req.set_body_file</a></li><li><a href="#ngxreqinit_body">ngx.req.init_body</a></li><li><a href="#ngxreqappend_body">ngx.req.append_body</a></li><li><a href="#ngxreqfinish_body">ngx.req.finish_body</a></li><li><a href="#ngxreqsocket">ngx.req.socket</a></li><li><a href="#ngxexec">ngx.exec</a></li><li><a href="#ngxredirect">ngx.redirect</a></li><li><a href="#ngxsend_headers">ngx.send_headers</a></li><li><a href="#ngxheaders_sent">ngx.headers_sent</a></li><li><a href="#ngxprint">ngx.print</a></li><li><a href="#ngxsay">ngx.say</a></li><li><a href="#ngxlog">ngx.log</a></li><li><a href="#ngxflush">ngx.flush</a></li><li><a href="#ngxexit">ngx.exit</a></li><li><a href="#ngxeof">ngx.eof</a></li><li><a href="#ngxsleep">ngx.sleep</a></li><li><a href="#ngxescape_uri">ngx.escape_uri</a></li><li><a href="#ngxunescape_uri">ngx.unescape_uri</a></li><li><a href="#ngxencode_args">ngx.encode_args</a></li><li><a href="#ngxdecode_args">ngx.decode_args</a></li><li><a href="#ngxencode_base64">ngx.encode_base64</a></li><li><a href="#ngxdecode_base64">ngx.decode_base64</a></li><li><a href="#ngxcrc32_short">ngx.crc32_short</a></li><li><a href="#ngxcrc32_long">ngx.crc32_long</a></li><li><a href="#ngxhmac_sha1">ngx.hmac_sha1</a></li><li><a href="#ngxmd5">ngx.md5</a></li><li><a href="#ngxmd5_bin">ngx.md5_bin</a></li><li><a href="#ngxsha1_bin">ngx.sha1_bin</a></li><li><a href="#ngxquote_sql_str">ngx.quote_sql_str</a></li><li><a href="#ngxtoday">ngx.today</a></li><li><a href="#ngxtime">ngx.time</a></li><li><a href="#ngxnow">ngx.now</a></li><li><a href="#ngxupdate_time">ngx.update_time</a></li><li><a href="#ngxlocaltime">ngx.localtime</a></li><li><a href="#ngxutctime">ngx.utctime</a></li><li><a href="#ngxcookie_time">ngx.cookie_time</a></li><li><a href="#ngxhttp_time">ngx.http_time</a></li><li><a href="#ngxparse_http_time">ngx.parse_http_time</a></li><li><a href="#ngxis_subrequest">ngx.is_subrequest</a></li><li><a href="#ngxrematch">ngx.re.match</a></li><li><a href="#ngxrefind">ngx.re.find</a></li><li><a href="#ngxregmatch">ngx.re.gmatch</a></li><li><a href="#ngxresub">ngx.re.sub</a></li><li><a href="#ngxregsub">ngx.re.gsub</a></li><li><a href="#ngxshareddict">ngx.shared.DICT</a></li><li><a href="#ngxshareddictget">ngx.shared.DICT.get</a></li><li><a href="#ngxshareddictget_stale">ngx.shared.DICT.get_stale</a></li><li><a href="#ngxshareddictset">ngx.shared.DICT.set</a></li><li><a href="#ngxshareddictsafe_set">ngx.shared.DICT.safe_set</a></li><li><a href="#ngxshareddictadd">ngx.shared.DICT.add</a></li><li><a href="#ngxshareddictsafe_add">ngx.shared.DICT.safe_add</a></li><li><a href="#ngxshareddictreplace">ngx.shared.DICT.replace</a></li><li><a href="#ngxshareddictdelete">ngx.shared.DICT.delete</a></li><li><a href="#ngxshareddictincr">ngx.shared.DICT.incr</a></li><li><a href="#ngxshareddictlpush">ngx.shared.DICT.lpush</a></li><li><a href="#ngxshareddictrpush">ngx.shared.DICT.rpush</a></li><li><a href="#ngxshareddictlpop">ngx.shared.DICT.lpop</a></li><li><a href="#ngxshareddictrpop">ngx.shared.DICT.rpop</a></li><li><a href="#ngxshareddictllen">ngx.shared.DICT.llen</a></li><li><a href="#ngxshareddictttl">ngx.shared.DICT.ttl</a></li><li><a href="#ngxshareddictexpire">ngx.shared.DICT.expire</a></li><li><a href="#ngxshareddictflush_all">ngx.shared.DICT.flush_all</a></li><li><a href="#ngxshareddictflush_expired">ngx.shared.DICT.flush_expired</a></li><li><a href="#ngxshareddictget_keys">ngx.shared.DICT.get_keys</a></li><li><a href="#ngxshareddictcapacity">ngx.shared.DICT.capacity</a></li><li><a href="#ngxshareddictfree_space">ngx.shared.DICT.free_space</a></li><li><a href="#ngxsocketudp">ngx.socket.udp</a></li><li><a href="#udpsocksetpeername">udpsock:setpeername</a></li><li><a href="#udpsocksend">udpsock:send</a></li><li><a href="#udpsockreceive">udpsock:receive</a></li><li><a href="#udpsockclose">udpsock:close</a></li><li><a href="#udpsocksettimeout">udpsock:settimeout</a></li><li><a href="#ngxsocketstream">ngx.socket.stream</a></li><li><a href="#ngxsockettcp">ngx.socket.tcp</a></li><li><a href="#tcpsockconnect">tcpsock:connect</a></li><li><a href="#tcpsocksslhandshake">tcpsock:sslhandshake</a></li><li><a href="#tcpsocksend">tcpsock:send</a></li><li><a href="#tcpsockreceive">tcpsock:receive</a></li><li><a href="#tcpsockreceiveany">tcpsock:receiveany</a></li><li><a href="#tcpsockreceiveuntil">tcpsock:receiveuntil</a></li><li><a href="#tcpsockclose">tcpsock:close</a></li><li><a href="#tcpsocksettimeout">tcpsock:settimeout</a></li><li><a href="#tcpsocksettimeouts">tcpsock:settimeouts</a></li><li><a href="#tcpsocksetoption">tcpsock:setoption</a></li><li><a href="#tcpsocksetkeepalive">tcpsock:setkeepalive</a></li><li><a href="#tcpsockgetreusedtimes">tcpsock:getreusedtimes</a></li><li><a href="#ngxsocketconnect">ngx.socket.connect</a></li><li><a href="#ngxget_phase">ngx.get_phase</a></li><li><a href="#ngxthreadspawn">ngx.thread.spawn</a></li><li><a href="#ngxthreadwait">ngx.thread.wait</a></li><li><a href="#ngxthreadkill">ngx.thread.kill</a></li><li><a href="#ngxon_abort">ngx.on_abort</a></li><li><a href="#ngxtimerat">ngx.timer.at</a></li><li><a href="#ngxtimerevery">ngx.timer.every</a></li><li><a href="#ngxtimerrunning_count">ngx.timer.running_count</a></li><li><a href="#ngxtimerpending_count">ngx.timer.pending_count</a></li><li><a href="#ngxconfigsubsystem">ngx.config.subsystem</a></li><li><a href="#ngxconfigdebug">ngx.config.debug</a></li><li><a href="#ngxconfigprefix">ngx.config.prefix</a></li><li><a href="#ngxconfignginx_version">ngx.config.nginx_version</a></li><li><a href="#ngxconfignginx_configure">ngx.config.nginx_configure</a></li><li><a href="#ngxconfigngx_lua_version">ngx.config.ngx_lua_version</a></li><li><a href="#ngxworkerexiting">ngx.worker.exiting</a></li><li><a href="#ngxworkerpid">ngx.worker.pid</a></li><li><a href="#ngxworkercount">ngx.worker.count</a></li><li><a href="#ngxworkerid">ngx.worker.id</a></li><li><a href="#ngxsemaphore">ngx.semaphore</a></li><li><a href="#ngxbalancer">ngx.balancer</a></li><li><a href="#ngxssl">ngx.ssl</a></li><li><a href="#ngxocsp">ngx.ocsp</a></li><li><a href="#ndkset_vardirective">ndk.set_var.DIRECTIVE</a></li><li><a href="#coroutinecreate">coroutine.create</a></li><li><a href="#coroutineresume">coroutine.resume</a></li><li><a href="#coroutineyield">coroutine.yield</a></li><li><a href="#coroutinewrap">coroutine.wrap</a></li><li><a href="#coroutinerunning">coroutine.running</a></li><li><a href="#coroutinestatus">coroutine.status</a></li></ul></li></ul><!-- tocstop --><p>本文是GitHub上nginx-lua-module自述文档的一部分，详细列举说明了OpenResty所有的Lua API。</p><p>放到这里，方便查阅。</p><h1><span id="nginx-api-for-lua">Nginx API for Lua</span></h1><h2><span id="introduction">Introduction</span></h2><p>The various <code>*_by_lua</code>, <code>*_by_lua_block</code> and <code>*_by_lua_file</code> configuration directives serve as gateways to the Lua API within the <code>nginx.conf</code> file. The Nginx Lua API described below can only be called within the user Lua code run in the context of these configuration directives.</p><p>The API is exposed to Lua in the form of two standard packages <code>ngx</code> and <code>ndk</code>. These packages are in the default global scope within ngx_lua and are always available within ngx_lua directives.</p><p>The packages can be introduced into external Lua modules like this:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">local say = ngx.say</span><br><span class="line"></span><br><span class="line">local _M = &#123;&#125;</span><br><span class="line"></span><br><span class="line">function _M.foo(a)</span><br><span class="line">    say(a)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">return _M</span><br></pre></td></tr></table></figure><p>Use of the <a href="http://www.lua.org/manual/5.1/manual.html#pdf-package.seeall" target="_blank" rel="noopener">package.seeall</a> flag is strongly discouraged due to its various bad side-effects.</p><p>It is also possible to directly require the packages in external Lua modules:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local ngx = require &quot;ngx&quot;</span><br><span class="line">local ndk = require &quot;ndk&quot;</span><br></pre></td></tr></table></figure><p>The ability to require these packages was introduced in the <code>v0.2.1rc19</code> release.</p><p>Network I/O operations in user code should only be done through the Nginx Lua API calls as the Nginx event loop may be blocked and performance drop off dramatically otherwise. Disk operations with relatively small amount of data can be done using the standard Lua <code>io</code> library but huge file reading and writing should be avoided wherever possible as they may block the Nginx process significantly. Delegating all network and disk I/O operations to Nginx’s subrequests (via the [ngx.location.capture]</p><h2><span id="ngxarg">ngx.arg</span></h2><p><strong>syntax:</strong> <em>val = ngx.arg[index]</em></p><p><strong>context:</strong> set_by_lua*, body_filter_by_lua*</p><p>When this is used in the context of the [set_by_lua*]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value = ngx.arg[n]</span><br></pre></td></tr></table></figure><p>Here is an example</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">location /foo &#123;</span><br><span class="line">    set $a 32;</span><br><span class="line">    set $b 56;</span><br><span class="line"></span><br><span class="line">    set_by_lua $sum</span><br><span class="line">        &apos;return tonumber(ngx.arg[1]) + tonumber(ngx.arg[2])&apos;</span><br><span class="line">        $a $b;</span><br><span class="line"></span><br><span class="line">    echo $sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>that writes out <code>88</code>, the sum of <code>32</code> and <code>56</code>.</p><p>When this table is used in the context of [body_filter_by_lua*]</p><p>The data chunk and “eof” flag passed to the downstream Nginx output filters can also be overridden by assigning values directly to the corresponding table elements. When setting <code>nil</code> or an empty Lua string value to <code>ngx.arg[1]</code>, no data chunk will be passed to the downstream Nginx output filters at all.</p><h2><span id="ngxvarvariable">ngx.var.VARIABLE</span></h2><p><strong>syntax:</strong> <em>ngx.var.VAR_NAME</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*</p><p>Read and write Nginx variable values.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value = ngx.var.some_nginx_variable_name</span><br><span class="line">ngx.var.some_nginx_variable_name = value</span><br></pre></td></tr></table></figure><p>Note that only already defined nginx variables can be written to. For example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location /foo &#123;</span><br><span class="line">    set $my_var &apos;&apos;; # this line is required to create $my_var at config time</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        ngx.var.my_var = 123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>That is, nginx variables cannot be created on-the-fly.</p><p>Some special nginx variables like <code>$args</code> and <code>$limit_rate</code> can be assigned a value, many others are not, like <code>$query_string</code>, <code>$arg_PARAMETER</code>, and <code>$http_NAME</code>.</p><p>Nginx regex group capturing variables <code>$1</code>, <code>$2</code>, <code>$3</code>, and etc, can be read by this interface as well, by writing <code>ngx.var[1]</code>, <code>ngx.var[2]</code>, <code>ngx.var[3]</code>, and etc.</p><p>Setting <code>ngx.var.Foo</code> to a <code>nil</code> value will unset the <code>$Foo</code> Nginx variable.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.var.args = nil</span><br></pre></td></tr></table></figure><p><strong>CAUTION</strong> When reading from an Nginx variable, Nginx will allocate memory in the per-request memory pool which is freed only at request termination. So when you need to read from an Nginx variable repeatedly in your Lua code, cache the Nginx variable value to your own Lua variable, for example,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local val = ngx.var.some_var</span><br><span class="line">--- use the val repeatedly later</span><br></pre></td></tr></table></figure><p>to prevent (temporary) memory leaking within the current request’s lifetime. Another way of caching the result is to use the [ngx.ctx]</p><p>Undefined NGINX variables are evaluated to <code>nil</code> while uninitialized (but defined) NGINX variables are evaluated to an empty Lua string.</p><p>This API requires a relatively expensive metamethod call and it is recommended to avoid using it on hot code paths.</p><h2><span id="core-constants">Core constants</span></h2><p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, *log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ngx.OK (0)</span><br><span class="line">ngx.ERROR (-1)</span><br><span class="line">ngx.AGAIN (-2)</span><br><span class="line">ngx.DONE (-4)</span><br><span class="line">ngx.DECLINED (-5)</span><br></pre></td></tr></table></figure><p>Note that only three of these constants are utilized by the [Nginx API for Lua]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.null</span><br></pre></td></tr></table></figure><p>The <code>ngx.null</code> constant is a <code>NULL</code> light userdata usually used to represent nil values in Lua tables etc and is similar to the <a href="http://www.kyne.com.au/~mark/software/lua-cjson.php" target="_blank" rel="noopener">lua-cjson</a> library’s <code>cjson.null</code> constant. This constant was first introduced in the <code>v0.5.0rc5</code> release.</p><p>The <code>ngx.DECLINED</code> constant was first introduced in the <code>v0.5.0rc19</code> release.</p><h2><span id="http-method-constants">HTTP method constants</span></h2><p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ngx.HTTP_GET</span><br><span class="line">ngx.HTTP_HEAD</span><br><span class="line">ngx.HTTP_PUT</span><br><span class="line">ngx.HTTP_POST</span><br><span class="line">ngx.HTTP_DELETE</span><br><span class="line">ngx.HTTP_OPTIONS   (added in the v0.5.0rc24 release)</span><br><span class="line">ngx.HTTP_MKCOL     (added in the v0.8.2 release)</span><br><span class="line">ngx.HTTP_COPY      (added in the v0.8.2 release)</span><br><span class="line">ngx.HTTP_MOVE      (added in the v0.8.2 release)</span><br><span class="line">ngx.HTTP_PROPFIND  (added in the v0.8.2 release)</span><br><span class="line">ngx.HTTP_PROPPATCH (added in the v0.8.2 release)</span><br><span class="line">ngx.HTTP_LOCK      (added in the v0.8.2 release)</span><br><span class="line">ngx.HTTP_UNLOCK    (added in the v0.8.2 release)</span><br><span class="line">ngx.HTTP_PATCH     (added in the v0.8.2 release)</span><br><span class="line">ngx.HTTP_TRACE     (added in the v0.8.2 release)</span><br></pre></td></tr></table></figure><p>These constants are usually used in [ngx.location.capture]</p><h2><span id="http-status-constants">HTTP status constants</span></h2><p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">value = ngx.HTTP_CONTINUE (100) (first added in the v0.9.20 release)</span><br><span class="line">value = ngx.HTTP_SWITCHING_PROTOCOLS (101) (first added in the v0.9.20 release)</span><br><span class="line">value = ngx.HTTP_OK (200)</span><br><span class="line">value = ngx.HTTP_CREATED (201)</span><br><span class="line">value = ngx.HTTP_ACCEPTED (202) (first added in the v0.9.20 release)</span><br><span class="line">value = ngx.HTTP_NO_CONTENT (204) (first added in the v0.9.20 release)</span><br><span class="line">value = ngx.HTTP_PARTIAL_CONTENT (206) (first added in the v0.9.20 release)</span><br><span class="line">value = ngx.HTTP_SPECIAL_RESPONSE (300)</span><br><span class="line">value = ngx.HTTP_MOVED_PERMANENTLY (301)</span><br><span class="line">value = ngx.HTTP_MOVED_TEMPORARILY (302)</span><br><span class="line">value = ngx.HTTP_SEE_OTHER (303)</span><br><span class="line">value = ngx.HTTP_NOT_MODIFIED (304)</span><br><span class="line">value = ngx.HTTP_TEMPORARY_REDIRECT (307) (first added in the v0.9.20 release)</span><br><span class="line">value = ngx.HTTP_PERMANENT_REDIRECT (308)</span><br><span class="line">value = ngx.HTTP_BAD_REQUEST (400)</span><br><span class="line">value = ngx.HTTP_UNAUTHORIZED (401)</span><br><span class="line">value = ngx.HTTP_PAYMENT_REQUIRED (402) (first added in the v0.9.20 release)</span><br><span class="line">value = ngx.HTTP_FORBIDDEN (403)</span><br><span class="line">value = ngx.HTTP_NOT_FOUND (404)</span><br><span class="line">value = ngx.HTTP_NOT_ALLOWED (405)</span><br><span class="line">value = ngx.HTTP_NOT_ACCEPTABLE (406) (first added in the v0.9.20 release)</span><br><span class="line">value = ngx.HTTP_REQUEST_TIMEOUT (408) (first added in the v0.9.20 release)</span><br><span class="line">value = ngx.HTTP_CONFLICT (409) (first added in the v0.9.20 release)</span><br><span class="line">value = ngx.HTTP_GONE (410)</span><br><span class="line">value = ngx.HTTP_UPGRADE_REQUIRED (426) (first added in the v0.9.20 release)</span><br><span class="line">value = ngx.HTTP_TOO_MANY_REQUESTS (429) (first added in the v0.9.20 release)</span><br><span class="line">value = ngx.HTTP_CLOSE (444) (first added in the v0.9.20 release)</span><br><span class="line">value = ngx.HTTP_ILLEGAL (451) (first added in the v0.9.20 release)</span><br><span class="line">value = ngx.HTTP_INTERNAL_SERVER_ERROR (500)</span><br><span class="line">value = ngx.HTTP_METHOD_NOT_IMPLEMENTED (501)</span><br><span class="line">value = ngx.HTTP_BAD_GATEWAY (502) (first added in the v0.9.20 release)</span><br><span class="line">value = ngx.HTTP_SERVICE_UNAVAILABLE (503)</span><br><span class="line">value = ngx.HTTP_GATEWAY_TIMEOUT (504) (first added in the v0.3.1rc38 release)</span><br><span class="line">value = ngx.HTTP_VERSION_NOT_SUPPORTED (505) (first added in the v0.9.20 release)</span><br><span class="line">value = ngx.HTTP_INSUFFICIENT_STORAGE (507) (first added in the v0.9.20 release)</span><br></pre></td></tr></table></figure><h2><span id="nginx-log-level-constants">Nginx log level constants</span></h2><p><strong>context:</strong> init_by_lua*, init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ngx.STDERR</span><br><span class="line">ngx.EMERG</span><br><span class="line">ngx.ALERT</span><br><span class="line">ngx.CRIT</span><br><span class="line">ngx.ERR</span><br><span class="line">ngx.WARN</span><br><span class="line">ngx.NOTICE</span><br><span class="line">ngx.INFO</span><br><span class="line">ngx.DEBUG</span><br></pre></td></tr></table></figure><p>These constants are usually used by the [ngx.log]</p><h2><span id="print">print</span></h2><p><strong>syntax:</strong> <em>print(…)</em></p><p><strong>context:</strong> init_by_lua*, init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Writes argument values into the nginx <code>error.log</code> file with the <code>ngx.NOTICE</code> log level.</p><p>It is equivalent to</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.log(ngx.NOTICE, ...)</span><br></pre></td></tr></table></figure><p>Lua <code>nil</code> arguments are accepted and result in literal <code>&quot;nil&quot;</code> strings while Lua booleans result in literal <code>&quot;true&quot;</code> or <code>&quot;false&quot;</code>strings. And the <code>ngx.null</code> constant will yield the <code>&quot;null&quot;</code> string output.</p><p>There is a hard coded <code>2048</code> byte limitation on error message lengths in the Nginx core. This limit includes trailing newlines and leading time stamps. If the message size exceeds this limit, Nginx will truncate the message text accordingly. This limit can be manually modified by editing the <code>NGX_MAX_ERROR_STR</code> macro definition in the <code>src/core/ngx_log.h</code> file in the Nginx source tree.</p><h2><span id="ngxctx">ngx.ctx</span></h2><p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*</p><p>This table can be used to store per-request Lua context data and has a life time identical to the current request (as with the Nginx variables).</p><p>Consider the following example,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">location /test &#123;</span><br><span class="line">    rewrite_by_lua_block &#123;</span><br><span class="line">        ngx.ctx.foo = 76</span><br><span class="line">    &#125;</span><br><span class="line">    access_by_lua_block &#123;</span><br><span class="line">        ngx.ctx.foo = ngx.ctx.foo + 3</span><br><span class="line">    &#125;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        ngx.say(ngx.ctx.foo)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Then <code>GET /test</code> will yield the output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">79</span><br></pre></td></tr></table></figure><p>That is, the <code>ngx.ctx.foo</code> entry persists across the rewrite, access, and content phases of a request.</p><p>Every request, including subrequests, has its own copy of the table. For example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">location /sub &#123;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        ngx.say(&quot;sub pre: &quot;, ngx.ctx.blah)</span><br><span class="line">        ngx.ctx.blah = 32</span><br><span class="line">        ngx.say(&quot;sub post: &quot;, ngx.ctx.blah)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /main &#123;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        ngx.ctx.blah = 73</span><br><span class="line">        ngx.say(&quot;main pre: &quot;, ngx.ctx.blah)</span><br><span class="line">        local res = ngx.location.capture(&quot;/sub&quot;)</span><br><span class="line">        ngx.print(res.body)</span><br><span class="line">        ngx.say(&quot;main post: &quot;, ngx.ctx.blah)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Then <code>GET /main</code> will give the output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main pre: 73</span><br><span class="line">sub pre: nil</span><br><span class="line">sub post: 32</span><br><span class="line">main post: 73</span><br></pre></td></tr></table></figure><p>Here, modification of the <code>ngx.ctx.blah</code> entry in the subrequest does not affect the one in the parent request. This is because they have two separate versions of <code>ngx.ctx.blah</code>.</p><p>Internal redirection will destroy the original request <code>ngx.ctx</code> data (if any) and the new request will have an empty <code>ngx.ctx</code>table. For instance,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">location /new &#123;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        ngx.say(ngx.ctx.foo)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /orig &#123;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        ngx.ctx.foo = &quot;hello&quot;</span><br><span class="line">        ngx.exec(&quot;/new&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Then <code>GET /orig</code> will give</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nil</span><br></pre></td></tr></table></figure><p>rather than the original <code>&quot;hello&quot;</code> value.</p><p>Arbitrary data values, including Lua closures and nested tables, can be inserted into this “magic” table. It also allows the registration of custom meta methods.</p><p>Overriding <code>ngx.ctx</code> with a new Lua table is also supported, for example,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.ctx = &#123; foo = 32, bar = 54 &#125;</span><br></pre></td></tr></table></figure><p>When being used in the context of [init_worker_by_lua*]</p><p>The <code>ngx.ctx</code> lookup requires relatively expensive metamethod calls and it is much slower than explicitly passing per-request data along by your own function arguments. So do not abuse this API for saving your own function arguments because it usually has quite some performance impact.</p><p>Because of the metamethod magic, never “local” the <code>ngx.ctx</code> table outside your Lua function scope on the Lua module level due to [worker-level data sharing]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-- mymodule.lua</span><br><span class="line">local _M = &#123;&#125;</span><br><span class="line"></span><br><span class="line">-- the following line is bad since ngx.ctx is a per-request</span><br><span class="line">-- data while this &lt;code&gt;ctx&lt;/code&gt; variable is on the Lua module level</span><br><span class="line">-- and thus is per-nginx-worker.</span><br><span class="line">local ctx = ngx.ctx</span><br><span class="line"></span><br><span class="line">function _M.main()</span><br><span class="line">    ctx.foo = &quot;bar&quot;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">return _M</span><br></pre></td></tr></table></figure><p>Use the following instead:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- mymodule.lua</span><br><span class="line">local _M = &#123;&#125;</span><br><span class="line"></span><br><span class="line">function _M.main(ctx)</span><br><span class="line">    ctx.foo = &quot;bar&quot;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">return _M</span><br></pre></td></tr></table></figure><p>That is, let the caller pass the <code>ctx</code> table explicitly via a function argument.</p><h2><span id="ngxlocationcapture">ngx.location.capture</span></h2><p><strong>syntax:</strong> <em>res = ngx.location.capture(uri, options?)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*</p><p>Issues a synchronous but still non-blocking <em>Nginx Subrequest</em> using <code>uri</code>.</p><p>Nginx’s subrequests provide a powerful way to make non-blocking internal requests to other locations configured with disk file directory or <em>any</em> other nginx C modules like <code>ngx_proxy</code>, <code>ngx_fastcgi</code>, <code>ngx_memc</code>, <code>ngx_postgres</code>, <code>ngx_drizzle</code>, and even ngx_lua itself and etc etc etc.</p><p>Also note that subrequests just mimic the HTTP interface but there is <em>no</em> extra HTTP/TCP traffic <em>nor</em> IPC involved. Everything works internally, efficiently, on the C level.</p><p>Subrequests are completely different from HTTP 301/302 redirection (via [ngx.redirect]</p><p>You should always read the request body (by either calling [ngx.req.read_body]</p><p>This API function (as well as [ngx.location.capture_multi]</p><p>Here is a basic example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = ngx.location.capture(uri)</span><br></pre></td></tr></table></figure><p>Returns a Lua table with 4 slots: <code>res.status</code>, <code>res.header</code>, <code>res.body</code>, and <code>res.truncated</code>.</p><p><code>res.status</code> holds the response status code for the subrequest response.</p><p><code>res.header</code> holds all the response headers of the subrequest and it is a normal Lua table. For multi-value response headers, the value is a Lua (array) table that holds all the values in the order that they appear. For instance, if the subrequest response headers contain the following lines:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: a=3</span><br><span class="line">Set-Cookie: foo=bar</span><br><span class="line">Set-Cookie: baz=blah</span><br></pre></td></tr></table></figure><p>Then <code>res.header[&quot;Set-Cookie&quot;]</code> will be evaluated to the table value <code>{&quot;a=3&quot;, &quot;foo=bar&quot;, &quot;baz=blah&quot;}</code>.</p><p><code>res.body</code> holds the subrequest’s response body data, which might be truncated. You always need to check the <code>res.truncated</code> boolean flag to see if <code>res.body</code> contains truncated data. The data truncation here can only be caused by those unrecoverable errors in your subrequests like the cases that the remote end aborts the connection prematurely in the middle of the response body data stream or a read timeout happens when your subrequest is receiving the response body data from the remote.</p><p>URI query strings can be concatenated to URI itself, for instance,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = ngx.location.capture(&apos;/foo/bar?a=3&amp;b=4&apos;)</span><br></pre></td></tr></table></figure><p>Named locations like <code>@foo</code> are not allowed due to a limitation in the nginx core. Use normal locations combined with the <code>internal</code> directive to prepare internal-only locations.</p><p>An optional option table can be fed as the second argument, which supports the options:</p><ul><li><code>method</code> specify the subrequest’s request method, which only accepts constants like <code>ngx.HTTP_POST</code>.</li><li><code>body</code> specify the subrequest’s request body (string value only).</li><li><code>args</code> specify the subrequest’s URI query arguments (both string value and Lua tables are accepted)</li><li><code>ctx</code> specify a Lua table to be the [ngx.ctx]</li><li><code>vars</code> take a Lua table which holds the values to set the specified Nginx variables in the subrequest as this option’s value. This option was first introduced in the <code>v0.3.1rc31</code> release.</li><li><code>copy_all_vars</code> specify whether to copy over all the Nginx variable values of the current request to the subrequest in question. modifications of the nginx variables in the subrequest will not affect the current (parent) request. This option was first introduced in the <code>v0.3.1rc31</code> release.</li><li><code>share_all_vars</code> specify whether to share all the Nginx variables of the subrequest with the current (parent) request. modifications of the Nginx variables in the subrequest will affect the current (parent) request. Enabling this option may lead to hard-to-debug issues due to bad side-effects and is considered bad and harmful. Only enable this option when you completely know what you are doing.</li><li><code>always_forward_body</code> when set to true, the current (parent) request’s request body will always be forwarded to the subrequest being created if the <code>body</code> option is not specified. The request body read by either [ngx.req.read_body()]</li></ul><p>Issuing a POST subrequest, for example, can be done as follows</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">res = ngx.location.capture(</span><br><span class="line">    &apos;/foo/bar&apos;,</span><br><span class="line">    &#123; method = ngx.HTTP_POST, body = &apos;hello, world&apos; &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>See HTTP method constants methods other than POST. The <code>method</code> option is <code>ngx.HTTP_GET</code> by default.</p><p>The <code>args</code> option can specify extra URI arguments, for instance,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ngx.location.capture(&apos;/foo?a=1&apos;,</span><br><span class="line">    &#123; args = &#123; b = 3, c = &apos;:&apos; &#125; &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>is equivalent to</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.location.capture(&apos;/foo?a=1&amp;b=3&amp;c=%3a&apos;)</span><br></pre></td></tr></table></figure><p>that is, this method will escape argument keys and values according to URI rules and concatenate them together into a complete query string. The format for the Lua table passed as the <code>args</code> argument is identical to the format used in the [ngx.encode_args]</p><p>The <code>args</code> option can also take plain query strings:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ngx.location.capture(&apos;/foo?a=1&apos;,</span><br><span class="line">    &#123; args = &apos;b=3&amp;c=%3a&apos; &#125; &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>This is functionally identical to the previous examples.</p><p>The <code>share_all_vars</code> option controls whether to share nginx variables among the current request and its subrequests. If this option is set to <code>true</code>, then the current request and associated subrequests will share the same Nginx variable scope. Hence, changes to Nginx variables made by a subrequest will affect the current request.</p><p>Care should be taken in using this option as variable scope sharing can have unexpected side effects. The <code>args</code>, <code>vars</code>, or <code>copy_all_vars</code> options are generally preferable instead.</p><p>This option is set to <code>false</code> by default</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">location /other &#123;</span><br><span class="line">    set $dog &quot;$dog world&quot;;</span><br><span class="line">    echo &quot;$uri dog: $dog&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /lua &#123;</span><br><span class="line">    set $dog &apos;hello&apos;;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        res = ngx.location.capture(&quot;/other&quot;,</span><br><span class="line">            &#123; share_all_vars = true &#125;);</span><br><span class="line"></span><br><span class="line">        ngx.print(res.body)</span><br><span class="line">        ngx.say(ngx.var.uri, &quot;: &quot;, ngx.var.dog)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Accessing location <code>/lua</code> gives</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/other dog: hello world</span><br><span class="line">/lua: hello world</span><br></pre></td></tr></table></figure><p>The <code>copy_all_vars</code> option provides a copy of the parent request’s Nginx variables to subrequests when such subrequests are issued. Changes made to these variables by such subrequests will not affect the parent request or any other subrequests sharing the parent request’s variables.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">location /other &#123;</span><br><span class="line">    set $dog &quot;$dog world&quot;;</span><br><span class="line">    echo &quot;$uri dog: $dog&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /lua &#123;</span><br><span class="line">    set $dog &apos;hello&apos;;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        res = ngx.location.capture(&quot;/other&quot;,</span><br><span class="line">            &#123; copy_all_vars = true &#125;);</span><br><span class="line"></span><br><span class="line">        ngx.print(res.body)</span><br><span class="line">        ngx.say(ngx.var.uri, &quot;: &quot;, ngx.var.dog)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Request <code>GET /lua</code> will give the output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/other dog: hello world</span><br><span class="line">/lua: hello</span><br></pre></td></tr></table></figure><p>Note that if both <code>share_all_vars</code> and <code>copy_all_vars</code> are set to true, then <code>share_all_vars</code> takes precedence.</p><p>In addition to the two settings above, it is possible to specify values for variables in the subrequest using the <code>vars</code> option. These variables are set after the sharing or copying of variables has been evaluated, and provides a more efficient method of passing specific values to a subrequest over encoding them as URL arguments and unescaping them in the Nginx config file.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">location /other &#123;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        ngx.say(&quot;dog = &quot;, ngx.var.dog)</span><br><span class="line">        ngx.say(&quot;cat = &quot;, ngx.var.cat)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /lua &#123;</span><br><span class="line">    set $dog &apos;&apos;;</span><br><span class="line">    set $cat &apos;&apos;;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        res = ngx.location.capture(&quot;/other&quot;,</span><br><span class="line">            &#123; vars = &#123; dog = &quot;hello&quot;, cat = 32 &#125;&#125;);</span><br><span class="line"></span><br><span class="line">        ngx.print(res.body)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Accessing <code>/lua</code> will yield the output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dog = hello</span><br><span class="line">cat = 32</span><br></pre></td></tr></table></figure><p>The <code>ctx</code> option can be used to specify a custom Lua table to serve as the [ngx.ctx]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">location /sub &#123;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        ngx.ctx.foo = &quot;bar&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">location /lua &#123;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        local ctx = &#123;&#125;</span><br><span class="line">        res = ngx.location.capture(&quot;/sub&quot;, &#123; ctx = ctx &#125;)</span><br><span class="line"></span><br><span class="line">        ngx.say(ctx.foo);</span><br><span class="line">        ngx.say(ngx.ctx.foo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Then request <code>GET /lua</code> gives</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bar</span><br><span class="line">nil</span><br></pre></td></tr></table></figure><p>It is also possible to use this <code>ctx</code> option to share the same [ngx.ctx]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">location /sub &#123;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        ngx.ctx.foo = &quot;bar&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">location /lua &#123;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        res = ngx.location.capture(&quot;/sub&quot;, &#123; ctx = ngx.ctx &#125;)</span><br><span class="line">        ngx.say(ngx.ctx.foo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Request <code>GET /lua</code> yields the output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bar</span><br></pre></td></tr></table></figure><p>Note that subrequests issued by [ngx.location.capture]</p><p>When the <code>body</code> option is not specified and the <code>always_forward_body</code> option is false (the default value), the <code>POST</code> and <code>PUT</code>subrequests will inherit the request bodies of the parent request (if any).</p><p>There is a hard-coded upper limit on the number of concurrent subrequests possible for every main request. In older versions of Nginx, the limit was <code>50</code> concurrent subrequests and in more recent versions, Nginx <code>1.1.x</code> onwards, this was increased to <code>200</code> concurrent subrequests. When this limit is exceeded, the following error message is added to the <code>error.log</code> file:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[error] 13983#0: *1 subrequests cycle while processing &quot;/uri&quot;</span><br></pre></td></tr></table></figure><p>The limit can be manually modified if required by editing the definition of the <code>NGX_HTTP_MAX_SUBREQUESTS</code> macro in the <code>nginx/src/http/ngx_http_request.h</code> file in the Nginx source tree.</p><p>Please also refer to restrictions on capturing locations configured by [subrequest directives of other modules]</p><h2><span id="ngxlocationcapture_multi">ngx.location.capture_multi</span></h2><p><strong>syntax:</strong> <em>res1, res2, … = ngx.location.capture_multi({ {uri, options?}, {uri, options?}, … })</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*</p><p>Just like [ngx.location.capture]</p><p>This function issues several parallel subrequests specified by the input table and returns their results in the same order. For example,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">res1, res2, res3 = ngx.location.capture_multi&#123;</span><br><span class="line">    &#123; &quot;/foo&quot;, &#123; args = &quot;a=3&amp;b=4&quot; &#125; &#125;,</span><br><span class="line">    &#123; &quot;/bar&quot; &#125;,</span><br><span class="line">    &#123; &quot;/baz&quot;, &#123; method = ngx.HTTP_POST, body = &quot;hello&quot; &#125; &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if res1.status == ngx.HTTP_OK then</span><br><span class="line">    ...</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">if res2.body == &quot;BLAH&quot; then</span><br><span class="line">    ...</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>This function will not return until all the subrequests terminate. The total latency is the longest latency of the individual subrequests rather than the sum.</p><p>Lua tables can be used for both requests and responses when the number of subrequests to be issued is not known in advance:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-- construct the requests table</span><br><span class="line">local reqs = &#123;&#125;</span><br><span class="line">table.insert(reqs, &#123; &quot;/mysql&quot; &#125;)</span><br><span class="line">table.insert(reqs, &#123; &quot;/postgres&quot; &#125;)</span><br><span class="line">table.insert(reqs, &#123; &quot;/redis&quot; &#125;)</span><br><span class="line">table.insert(reqs, &#123; &quot;/memcached&quot; &#125;)</span><br><span class="line"></span><br><span class="line">-- issue all the requests at once and wait until they all return</span><br><span class="line">local resps = &#123; ngx.location.capture_multi(reqs) &#125;</span><br><span class="line"></span><br><span class="line">-- loop over the responses table</span><br><span class="line">for i, resp in ipairs(resps) do</span><br><span class="line">    -- process the response table &quot;resp&quot;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>The [ngx.location.capture]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ngx.location.capture =</span><br><span class="line">    function (uri, args)</span><br><span class="line">        return ngx.location.capture_multi(&#123; &#123;uri, args&#125; &#125;)</span><br><span class="line">    end</span><br></pre></td></tr></table></figure><p>Please also refer to restrictions on capturing locations configured by [subrequest directives of other modules]</p><h2><span id="ngxstatus">ngx.status</span></h2><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*</p><p>Read and write the current request’s response status. This should be called before sending out the response headers.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ngx.status = ngx.HTTP_CREATED</span><br><span class="line">status = ngx.status</span><br></pre></td></tr></table></figure><p>Setting <code>ngx.status</code> after the response header is sent out has no effect but leaving an error message in your nginx’s error log file:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">attempt to set ngx.status after sending out response headers</span><br></pre></td></tr></table></figure><h2><span id="ngxheaderheader">ngx.header.HEADER</span></h2><p><strong>syntax:</strong> <em>ngx.header.HEADER = VALUE</em></p><p><strong>syntax:</strong> <em>value = ngx.header.HEADER</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*</p><p>Set, add to, or clear the current request’s <code>HEADER</code> response header that is to be sent.</p><p>Underscores (<code>_</code>) in the header names will be replaced by hyphens (<code>-</code>) by default. This transformation can be turned off via the [lua_transform_underscores_in_response_headers]</p><p>The header names are matched case-insensitively.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- equivalent to ngx.header[&quot;Content-Type&quot;] = &apos;text/plain&apos;</span><br><span class="line">ngx.header.content_type = &apos;text/plain&apos;;</span><br><span class="line"></span><br><span class="line">ngx.header[&quot;X-My-Header&quot;] = &apos;blah blah&apos;;</span><br></pre></td></tr></table></figure><p>Multi-value headers can be set this way:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.header[&apos;Set-Cookie&apos;] = &#123;&apos;a=32; path=/&apos;, &apos;b=4; path=/&apos;&#125;</span><br></pre></td></tr></table></figure><p>will yield</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: a=32; path=/</span><br><span class="line">Set-Cookie: b=4; path=/</span><br></pre></td></tr></table></figure><p>in the response headers.</p><p>Only Lua tables are accepted (Only the last element in the table will take effect for standard headers such as <code>Content-Type</code>that only accept a single value).</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.header.content_type = &#123;&apos;a&apos;, &apos;b&apos;&#125;</span><br></pre></td></tr></table></figure><p>is equivalent to</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.header.content_type = &apos;b&apos;</span><br></pre></td></tr></table></figure><p>Setting a slot to <code>nil</code> effectively removes it from the response headers:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.header[&quot;X-My-Header&quot;] = nil;</span><br></pre></td></tr></table></figure><p>The same applies to assigning an empty table:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.header[&quot;X-My-Header&quot;] = &#123;&#125;;</span><br></pre></td></tr></table></figure><p>Setting <code>ngx.header.HEADER</code> after sending out response headers (either explicitly with [ngx.send_headers]</p><p>Reading <code>ngx.header.HEADER</code> will return the value of the response header named <code>HEADER</code>.</p><p>Underscores (<code>_</code>) in the header names will also be replaced by dashes (<code>-</code>) and the header names will be matched case-insensitively. If the response header is not present at all, <code>nil</code> will be returned.</p><p>This is particularly useful in the context of [header_filter_by_lua*]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">location /test &#123;</span><br><span class="line">    set $footer &apos;&apos;;</span><br><span class="line"></span><br><span class="line">    proxy_pass http://some-backend;</span><br><span class="line"></span><br><span class="line">    header_filter_by_lua_block &#123;</span><br><span class="line">        if ngx.header[&quot;X-My-Header&quot;] == &quot;blah&quot; then</span><br><span class="line">            ngx.var.footer = &quot;some value&quot;</span><br><span class="line">        end</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    echo_after_body $footer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>For multi-value headers, all of the values of header will be collected in order and returned as a Lua table. For example, response headers</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Foo: bar</span><br><span class="line">Foo: baz</span><br></pre></td></tr></table></figure><p>will result in</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;bar&quot;, &quot;baz&quot;&#125;</span><br></pre></td></tr></table></figure><p>to be returned when reading <code>ngx.header.Foo</code>.</p><p>Note that <code>ngx.header</code> is not a normal Lua table and as such, it is not possible to iterate through it using the Lua <code>ipairs</code>function.</p><p>For reading <em>request</em> headers, use the [ngx.req.get_headers]</p><h2><span id="ngxrespget_headers">ngx.resp.get_headers</span></h2><p><strong>syntax:</strong> <em>headers, err = ngx.resp.get_headers(max_headers?, raw?)</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, balancer_by_lua*</p><p>Returns a Lua table holding all the current response headers for the current request.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">local h, err = ngx.resp.get_headers()</span><br><span class="line"></span><br><span class="line">if err == &quot;truncated&quot; then</span><br><span class="line">    -- one can choose to ignore or reject the current response here</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">for k, v in pairs(h) do</span><br><span class="line">    ...</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>This function has the same signature as [ngx.req.get_headers]</p><p>Note that a maximum of 100 response headers are parsed by default (including those with the same name) and that additional response headers are silently discarded to guard against potential denial of service attacks. Since <code>v0.10.13</code>, when the limit is exceeded, it will return a second value which is the string <code>&quot;truncated&quot;</code>.</p><p>This API was first introduced in the <code>v0.9.5</code> release.</p><h2><span id="ngxreqis_internal">ngx.req.is_internal</span></h2><p><strong>syntax:</strong> <em>is_internal = ngx.req.is_internal()</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*</p><p>Returns a boolean indicating whether the current request is an “internal request”, i.e., a request initiated from inside the current nginx server instead of from the client side.</p><p>Subrequests are all internal requests and so are requests after internal redirects.</p><p>This API was first introduced in the <code>v0.9.20</code> release.</p><h2><span id="ngxreqstart_time">ngx.req.start_time</span></h2><p><strong>syntax:</strong> <em>secs = ngx.req.start_time()</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*</p><p>Returns a floating-point number representing the timestamp (including milliseconds as the decimal part) when the current request was created.</p><p>The following example emulates the <code>$request_time</code> variable value (provided by <a href="http://nginx.org/en/docs/http/ngx_http_log_module.html" target="_blank" rel="noopener">ngx_http_log_module</a>) in pure Lua:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">local request_time = ngx.now() - ngx.req.start_time()</span><br></pre></td></tr></table></figure><p>This function was first introduced in the <code>v0.7.7</code> release.</p><p>See also [ngx.now]</p><h2><span id="ngxreqhttp_version">ngx.req.http_version</span></h2><p><strong>syntax:</strong> <em>num = ngx.req.http_version()</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*</p><p>Returns the HTTP version number for the current request as a Lua number.</p><p>Current possible values are 2.0, 1.0, 1.1, and 0.9. Returns <code>nil</code> for unrecognized values.</p><p>This method was first introduced in the <code>v0.7.17</code> release.</p><h2><span id="ngxreqraw_header">ngx.req.raw_header</span></h2><p><strong>syntax:</strong> <em>str = ngx.req.raw_header(no_request_line?)</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*</p><p>Returns the original raw HTTP protocol header received by the Nginx server.</p><p>By default, the request line and trailing <code>CR LF</code> terminator will also be included. For example,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.print(ngx.req.raw_header())</span><br></pre></td></tr></table></figure><p>gives something like this:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /t HTTP/1.1</span><br><span class="line">Host: localhost</span><br><span class="line">Connection: close</span><br><span class="line">Foo: bar</span><br></pre></td></tr></table></figure><p>You can specify the optional <code>no_request_line</code> argument as a <code>true</code> value to exclude the request line from the result. For example,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.print(ngx.req.raw_header(true))</span><br></pre></td></tr></table></figure><p>outputs something like this:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Host: localhost</span><br><span class="line">Connection: close</span><br><span class="line">Foo: bar</span><br></pre></td></tr></table></figure><p>This method was first introduced in the <code>v0.7.17</code> release.</p><p>This method does not work in HTTP/2 requests yet.</p><h2><span id="ngxreqget_method">ngx.req.get_method</span></h2><p><strong>syntax:</strong> <em>method_name = ngx.req.get_method()</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, balancer_by_lua*, log_by_lua*</p><p>Retrieves the current request’s request method name. Strings like <code>&quot;GET&quot;</code> and <code>&quot;POST&quot;</code> are returned instead of numerical [method constants]</p><p>If the current request is an Nginx subrequest, then the subrequest’s method name will be returned.</p><p>This method was first introduced in the <code>v0.5.6</code> release.</p><p>See also [ngx.req.set_method]</p><h2><span id="ngxreqset_method">ngx.req.set_method</span></h2><p><strong>syntax:</strong> <em>ngx.req.set_method(method_id)</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*</p><p>Overrides the current request’s request method with the <code>method_id</code> argument. Currently only numerical [method constants]</p><p>If the current request is an Nginx subrequest, then the subrequest’s method will be overridden.</p><p>This method was first introduced in the <code>v0.5.6</code> release.</p><p>See also [ngx.req.get_method]</p><h2><span id="ngxreqset_uri">ngx.req.set_uri</span></h2><p><strong>syntax:</strong> <em>ngx.req.set_uri(uri, jump?)</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*</p><p>Rewrite the current request’s (parsed) URI by the <code>uri</code> argument. The <code>uri</code> argument must be a Lua string and cannot be of zero length, or a Lua exception will be thrown.</p><p>The optional boolean <code>jump</code> argument can trigger location rematch (or location jump) as <a href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html" target="_blank" rel="noopener">ngx_http_rewrite_module</a>‘s <a href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html#rewrite" target="_blank" rel="noopener">rewrite</a>directive, that is, when <code>jump</code> is <code>true</code> (default to <code>false</code>), this function will never return and it will tell Nginx to try re-searching locations with the new URI value at the later <code>post-rewrite</code> phase and jumping to the new location.</p><p>Location jump will not be triggered otherwise, and only the current request’s URI will be modified, which is also the default behavior. This function will return but with no returned values when the <code>jump</code> argument is <code>false</code> or absent altogether.</p><p>For example, the following nginx config snippet</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rewrite ^ /foo last;</span><br></pre></td></tr></table></figure><p>can be coded in Lua like this:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.req.set_uri(&quot;/foo&quot;, true)</span><br></pre></td></tr></table></figure><p>Similarly, Nginx config</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rewrite ^ /foo break;</span><br></pre></td></tr></table></figure><p>can be coded in Lua as</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.req.set_uri(&quot;/foo&quot;, false)</span><br></pre></td></tr></table></figure><p>or equivalently,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.req.set_uri(&quot;/foo&quot;)</span><br></pre></td></tr></table></figure><p>The <code>jump</code> argument can only be set to <code>true</code> in [rewrite_by_lua*]</p><p>A more sophisticated example involving regex substitutions is as follows</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location /test &#123;</span><br><span class="line">    rewrite_by_lua_block &#123;</span><br><span class="line">        local uri = ngx.re.sub(ngx.var.uri, &quot;^/test/(.*)&quot;, &quot;/$1&quot;, &quot;o&quot;)</span><br><span class="line">        ngx.req.set_uri(uri)</span><br><span class="line">    &#125;</span><br><span class="line">    proxy_pass http://my_backend;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>which is functionally equivalent to</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location /test &#123;</span><br><span class="line">    rewrite ^/test/(.*) /$1 break;</span><br><span class="line">    proxy_pass http://my_backend;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note that it is not possible to use this interface to rewrite URI arguments and that [ngx.req.set_uri_args]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rewrite ^ /foo?a=3? last;</span><br></pre></td></tr></table></figure><p>can be coded as</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ngx.req.set_uri_args(&quot;a=3&quot;)</span><br><span class="line">ngx.req.set_uri(&quot;/foo&quot;, true)</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ngx.req.set_uri_args(&#123;a = 3&#125;)</span><br><span class="line">ngx.req.set_uri(&quot;/foo&quot;, true)</span><br></pre></td></tr></table></figure><p>This interface was first introduced in the <code>v0.3.1rc14</code> release.</p><h2><span id="ngxreqset_uri_args">ngx.req.set_uri_args</span></h2><p><strong>syntax:</strong> <em>ngx.req.set_uri_args(args)</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*</p><p>Rewrite the current request’s URI query arguments by the <code>args</code> argument. The <code>args</code> argument can be either a Lua string, as in</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.req.set_uri_args(&quot;a=3&amp;b=hello%20world&quot;)</span><br></pre></td></tr></table></figure><p>or a Lua table holding the query arguments’ key-value pairs, as in</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.req.set_uri_args(&#123; a = 3, b = &quot;hello world&quot; &#125;)</span><br></pre></td></tr></table></figure><p>where in the latter case, this method will escape argument keys and values according to the URI escaping rule.</p><p>Multi-value arguments are also supported:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.req.set_uri_args(&#123; a = 3, b = &#123;5, 6&#125; &#125;)</span><br></pre></td></tr></table></figure><p>which will result in a query string like <code>a=3&amp;b=5&amp;b=6</code>.</p><p>This interface was first introduced in the <code>v0.3.1rc13</code> release.</p><p>See also [ngx.req.set_uri]</p><h2><span id="ngxreqget_uri_args">ngx.req.get_uri_args</span></h2><p><strong>syntax:</strong> <em>args, err = ngx.req.get_uri_args(max_args?)</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, balancer_by_lua*</p><p>Returns a Lua table holding all the current request URL query arguments.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">location = /test &#123;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        local args, err = ngx.req.get_uri_args()</span><br><span class="line"></span><br><span class="line">        if err == &quot;truncated&quot; then</span><br><span class="line">            -- one can choose to ignore or reject the current request here</span><br><span class="line">        end</span><br><span class="line"></span><br><span class="line">        for key, val in pairs(args) do</span><br><span class="line">            if type(val) == &quot;table&quot; then</span><br><span class="line">                ngx.say(key, &quot;: &quot;, table.concat(val, &quot;, &quot;))</span><br><span class="line">            else</span><br><span class="line">                ngx.say(key, &quot;: &quot;, val)</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Then <code>GET /test?foo=bar&amp;bar=baz&amp;bar=blah</code> will yield the response body</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo: bar</span><br><span class="line">bar: baz, blah</span><br></pre></td></tr></table></figure><p>Multiple occurrences of an argument key will result in a table value holding all the values for that key in order.</p><p>Keys and values are unescaped according to URI escaping rules. In the settings above, <code>GET /test?a%20b=1%61+2</code> will yield:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a b: 1a 2</span><br></pre></td></tr></table></figure><p>Arguments without the <code>=&lt;value&gt;</code> parts are treated as boolean arguments. <code>GET /test?foo&amp;bar</code> will yield:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo: true</span><br><span class="line">bar: true</span><br></pre></td></tr></table></figure><p>That is, they will take Lua boolean values <code>true</code>. However, they are different from arguments taking empty string values. <code>GET /test?foo=&amp;bar=</code> will give something like</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo:</span><br><span class="line">bar:</span><br></pre></td></tr></table></figure><p>Empty key arguments are discarded. <code>GET /test?=hello&amp;=world</code> will yield an empty output for instance.</p><p>Updating query arguments via the nginx variable <code>$args</code> (or <code>ngx.var.args</code> in Lua) at runtime is also supported:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ngx.var.args = &quot;a=3&amp;b=42&quot;</span><br><span class="line">local args, err = ngx.req.get_uri_args()</span><br></pre></td></tr></table></figure><p>Here the <code>args</code> table will always look like</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;a = 3, b = 42&#125;</span><br></pre></td></tr></table></figure><p>regardless of the actual request query string.</p><p>Note that a maximum of 100 request arguments are parsed by default (including those with the same name) and that additional request arguments are silently discarded to guard against potential denial of service attacks. Since <code>v0.10.13</code>, when the limit is exceeded, it will return a second value which is the string <code>&quot;truncated&quot;</code>.</p><p>However, the optional <code>max_args</code> function argument can be used to override this limit:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">local args, err = ngx.req.get_uri_args(10)</span><br><span class="line">if err == &quot;truncated&quot; then</span><br><span class="line">    -- one can choose to ignore or reject the current request here</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>This argument can be set to zero to remove the limit and to process all request arguments received:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">local args, err = ngx.req.get_uri_args(0)</span><br></pre></td></tr></table></figure><p>Removing the <code>max_args</code> cap is strongly discouraged.</p><h2><span id="ngxreqget_post_args">ngx.req.get_post_args</span></h2><p><strong>syntax:</strong> <em>args, err = ngx.req.get_post_args(max_args?)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*</p><p>Returns a Lua table holding all the current request POST query arguments (of the MIME type <code>application/x-www-form-urlencoded</code>). Call [ngx.req.read_body]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">location = /test &#123;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        ngx.req.read_body()</span><br><span class="line">        local args, err = ngx.req.get_post_args()</span><br><span class="line"></span><br><span class="line">        if err == &quot;truncated&quot; then</span><br><span class="line">            -- one can choose to ignore or reject the current request here</span><br><span class="line">        end</span><br><span class="line"></span><br><span class="line">        if not args then</span><br><span class="line">            ngx.say(&quot;failed to get post args: &quot;, err)</span><br><span class="line">            return</span><br><span class="line">        end</span><br><span class="line">        for key, val in pairs(args) do</span><br><span class="line">            if type(val) == &quot;table&quot; then</span><br><span class="line">                ngx.say(key, &quot;: &quot;, table.concat(val, &quot;, &quot;))</span><br><span class="line">            else</span><br><span class="line">                ngx.say(key, &quot;: &quot;, val)</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Then</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Post request with the body &apos;foo=bar&amp;bar=baz&amp;bar=blah&apos;</span><br><span class="line">$ curl --data &apos;foo=bar&amp;bar=baz&amp;bar=blah&apos; localhost/test</span><br></pre></td></tr></table></figure><p>will yield the response body like</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo: bar</span><br><span class="line">bar: baz, blah</span><br></pre></td></tr></table></figure><p>Multiple occurrences of an argument key will result in a table value holding all of the values for that key in order.</p><p>Keys and values will be unescaped according to URI escaping rules.</p><p>With the settings above,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># POST request with body &apos;a%20b=1%61+2&apos;</span><br><span class="line">$ curl -d &apos;a%20b=1%61+2&apos; localhost/test</span><br></pre></td></tr></table></figure><p>will yield:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a b: 1a 2</span><br></pre></td></tr></table></figure><p>Arguments without the <code>=&lt;value&gt;</code> parts are treated as boolean arguments. <code>POST /test</code> with the request body <code>foo&amp;bar</code> will yield:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo: true</span><br><span class="line">bar: true</span><br></pre></td></tr></table></figure><p>That is, they will take Lua boolean values <code>true</code>. However, they are different from arguments taking empty string values. <code>POST /test</code> with request body <code>foo=&amp;bar=</code> will return something like</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo:</span><br><span class="line">bar:</span><br></pre></td></tr></table></figure><p>Empty key arguments are discarded. <code>POST /test</code> with body <code>=hello&amp;=world</code> will yield empty outputs for instance.</p><p>Note that a maximum of 100 request arguments are parsed by default (including those with the same name) and that additional request arguments are silently discarded to guard against potential denial of service attacks. Since <code>v0.10.13</code>, when the limit is exceeded, it will return a second value which is the string <code>&quot;truncated&quot;</code>.</p><p>However, the optional <code>max_args</code> function argument can be used to override this limit:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">local args, err = ngx.req.get_post_args(10)</span><br><span class="line">if err == &quot;truncated&quot; then</span><br><span class="line">    -- one can choose to ignore or reject the current request here</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>This argument can be set to zero to remove the limit and to process all request arguments received:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">local args, err = ngx.req.get_post_args(0)</span><br></pre></td></tr></table></figure><p>Removing the <code>max_args</code> cap is strongly discouraged.</p><h2><span id="ngxreqget_headers">ngx.req.get_headers</span></h2><p><strong>syntax:</strong> <em>headers, err = ngx.req.get_headers(max_headers?, raw?)</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*</p><p>Returns a Lua table holding all the current request headers.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">local h, err = ngx.req.get_headers()</span><br><span class="line"></span><br><span class="line">if err == &quot;truncated&quot; then</span><br><span class="line">    -- one can choose to ignore or reject the current request here</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">for k, v in pairs(h) do</span><br><span class="line">    ...</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>To read an individual header:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.say(&quot;Host: &quot;, ngx.req.get_headers()[&quot;Host&quot;])</span><br></pre></td></tr></table></figure><p>Note that the [ngx.var.HEADER]</p><p>For multiple instances of request headers such as:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Foo: foo</span><br><span class="line">Foo: bar</span><br><span class="line">Foo: baz</span><br></pre></td></tr></table></figure><p>the value of <code>ngx.req.get_headers()[&quot;Foo&quot;]</code> will be a Lua (array) table such as:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;&#125;</span><br></pre></td></tr></table></figure><p>Note that a maximum of 100 request headers are parsed by default (including those with the same name) and that additional request headers are silently discarded to guard against potential denial of service attacks. Since <code>v0.10.13</code>, when the limit is exceeded, it will return a second value which is the string <code>&quot;truncated&quot;</code>.</p><p>However, the optional <code>max_headers</code> function argument can be used to override this limit:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">local headers, err = ngx.req.get_headers(10)</span><br><span class="line"></span><br><span class="line">if err == &quot;truncated&quot; then</span><br><span class="line">    -- one can choose to ignore or reject the current request here</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>This argument can be set to zero to remove the limit and to process all request headers received:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">local headers, err = ngx.req.get_headers(0)</span><br></pre></td></tr></table></figure><p>Removing the <code>max_headers</code> cap is strongly discouraged.</p><p>Since the <code>0.6.9</code> release, all the header names in the Lua table returned are converted to the pure lower-case form by default, unless the <code>raw</code> argument is set to <code>true</code> (default to <code>false</code>).</p><p>Also, by default, an <code>__index</code> metamethod is added to the resulting Lua table and will normalize the keys to a pure lowercase form with all underscores converted to dashes in case of a lookup miss. For example, if a request header <code>My-Foo-Header</code> is present, then the following invocations will all pick up the value of this header correctly:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ngx.say(headers.my_foo_header)</span><br><span class="line">ngx.say(headers[&quot;My-Foo-Header&quot;])</span><br><span class="line">ngx.say(headers[&quot;my-foo-header&quot;])</span><br></pre></td></tr></table></figure><p>The <code>__index</code> metamethod will not be added when the <code>raw</code> argument is set to <code>true</code>.</p><h2><span id="ngxreqset_header">ngx.req.set_header</span></h2><p><strong>syntax:</strong> <em>ngx.req.set_header(header_name, header_value)</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*</p><p>Set the current request’s request header named <code>header_name</code> to value <code>header_value</code>, overriding any existing ones.</p><p>By default, all the subrequests subsequently initiated by [ngx.location.capture]</p><p>Here is an example of setting the <code>Content-Type</code> header:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.req.set_header(&quot;Content-Type&quot;, &quot;text/css&quot;)</span><br></pre></td></tr></table></figure><p>The <code>header_value</code> can take an array list of values, for example,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.req.set_header(&quot;Foo&quot;, &#123;&quot;a&quot;, &quot;abc&quot;&#125;)</span><br></pre></td></tr></table></figure><p>will produce two new request headers:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Foo: a</span><br><span class="line">Foo: abc</span><br></pre></td></tr></table></figure><p>and old <code>Foo</code> headers will be overridden if there is any.</p><p>When the <code>header_value</code> argument is <code>nil</code>, the request header will be removed. So</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.req.set_header(&quot;X-Foo&quot;, nil)</span><br></pre></td></tr></table></figure><p>is equivalent to</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.req.clear_header(&quot;X-Foo&quot;)</span><br></pre></td></tr></table></figure><h2><span id="ngxreqclear_header">ngx.req.clear_header</span></h2><p><strong>syntax:</strong> <em>ngx.req.clear_header(header_name)</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*</p><p>Clears the current request’s request header named <code>header_name</code>. None of the current request’s existing subrequests will be affected but subsequently initiated subrequests will inherit the change by default.</p><h2><span id="ngxreqread_body">ngx.req.read_body</span></h2><p><strong>syntax:</strong> <em>ngx.req.read_body()</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*</p><p>Reads the client request body synchronously without blocking the Nginx event loop.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ngx.req.read_body()</span><br><span class="line">local args = ngx.req.get_post_args()</span><br></pre></td></tr></table></figure><p>If the request body is already read previously by turning on [lua_need_request_body]</p><p>If the request body has already been explicitly discarded, either by the [ngx.req.discard_body]</p><p>In case of errors, such as connection errors while reading the data, this method will throw out a Lua exception <em>or</em> terminate the current request with a 500 status code immediately.</p><p>The request body data read using this function can be retrieved later via [ngx.req.get_body_data]</p><ol><li>whether the current request body is already larger than the <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_buffer_size" target="_blank" rel="noopener">client_body_buffer_size</a>,</li><li>and whether <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_in_file_only" target="_blank" rel="noopener">client_body_in_file_only</a> has been switched on.</li></ol><p>In cases where current request may have a request body and the request body data is not required, The [ngx.req.discard_body]</p><p>This function was first introduced in the <code>v0.3.1rc17</code> release.</p><h2><span id="ngxreqdiscard_body">ngx.req.discard_body</span></h2><p><strong>syntax:</strong> <em>ngx.req.discard_body()</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*</p><p>Explicitly discard the request body, i.e., read the data on the connection and throw it away immediately (without using the request body by any means).</p><p>This function is an asynchronous call and returns immediately.</p><p>If the request body has already been read, this function does nothing and returns immediately.</p><p>This function was first introduced in the <code>v0.3.1rc17</code> release.</p><p>See also [ngx.req.read_body]</p><h2><span id="ngxreqget_body_data">ngx.req.get_body_data</span></h2><p><strong>syntax:</strong> <em>data = ngx.req.get_body_data()</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, log_by_lua*</p><p>Retrieves in-memory request body data. It returns a Lua string rather than a Lua table holding all the parsed query arguments. Use the [ngx.req.get_post_args]</p><p>This function returns <code>nil</code> if</p><ol><li>the request body has not been read,</li><li>the request body has been read into disk temporary files,</li><li>or the request body has zero size.</li></ol><p>If the request body has not been read yet, call [ngx.req.read_body]</p><p>If the request body has been read into disk files, try calling the [ngx.req.get_body_file]</p><p>To force in-memory request bodies, try setting <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_buffer_size" target="_blank" rel="noopener">client_body_buffer_size</a> to the same size value in <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#client_max_body_size" target="_blank" rel="noopener">client_max_body_size</a>.</p><p>Note that calling this function instead of using <code>ngx.var.request_body</code> or <code>ngx.var.echo_request_body</code> is more efficient because it can save one dynamic memory allocation and one data copy.</p><p>This function was first introduced in the <code>v0.3.1rc17</code> release.</p><p>See also [ngx.req.get_body_file]</p><h2><span id="ngxreqget_body_file">ngx.req.get_body_file</span></h2><p><strong>syntax:</strong> <em>file_name = ngx.req.get_body_file()</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*</p><p>Retrieves the file name for the in-file request body data. Returns <code>nil</code> if the request body has not been read or has been read into memory.</p><p>The returned file is read only and is usually cleaned up by Nginx’s memory pool. It should not be manually modified, renamed, or removed in Lua code.</p><p>If the request body has not been read yet, call [ngx.req.read_body]</p><p>If the request body has been read into memory, try calling the [ngx.req.get_body_data]</p><p>To force in-file request bodies, try turning on <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_in_file_only" target="_blank" rel="noopener">client_body_in_file_only</a>.</p><p>This function was first introduced in the <code>v0.3.1rc17</code> release.</p><p>See also [ngx.req.get_body_data]</p><h2><span id="ngxreqset_body_data">ngx.req.set_body_data</span></h2><p><strong>syntax:</strong> <em>ngx.req.set_body_data(data)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*</p><p>Set the current request’s request body using the in-memory data specified by the <code>data</code> argument.</p><p>If the request body has not been read yet, call [ngx.req.read_body]</p><p>Whether the previous request body has been read into memory or buffered into a disk file, it will be freed or the disk file will be cleaned up immediately, respectively.</p><p>This function was first introduced in the <code>v0.3.1rc18</code> release.</p><p>See also [ngx.req.set_body_file]</p><h2><span id="ngxreqset_body_file">ngx.req.set_body_file</span></h2><p><strong>syntax:</strong> <em>ngx.req.set_body_file(file_name, auto_clean?)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*</p><p>Set the current request’s request body using the in-file data specified by the <code>file_name</code> argument.</p><p>If the request body has not been read yet, call [ngx.req.read_body]</p><p>If the optional <code>auto_clean</code> argument is given a <code>true</code> value, then this file will be removed at request completion or the next time this function or [ngx.req.set_body_data]</p><p>Please ensure that the file specified by the <code>file_name</code> argument exists and is readable by an Nginx worker process by setting its permission properly to avoid Lua exception errors.</p><p>Whether the previous request body has been read into memory or buffered into a disk file, it will be freed or the disk file will be cleaned up immediately, respectively.</p><p>This function was first introduced in the <code>v0.3.1rc18</code> release.</p><p>See also [ngx.req.set_body_data]</p><h2><span id="ngxreqinit_body">ngx.req.init_body</span></h2><p><strong>syntax:</strong> <em>ngx.req.init_body(buffer_size?)</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*</p><p>Creates a new blank request body for the current request and inializes the buffer for later request body data writing via the [ngx.req.append_body]</p><p>If the <code>buffer_size</code> argument is specified, then its value will be used for the size of the memory buffer for body writing with [ngx.req.append_body]</p><p>When the data can no longer be hold in the memory buffer for the request body, then the data will be flushed onto a temporary file just like the standard request body reader in the Nginx core.</p><p>It is important to always call the [ngx.req.finish_body]</p><p>The usage of this function is often like this:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ngx.req.init_body(128 * 1024)  -- buffer is 128KB</span><br><span class="line">for chunk in next_data_chunk() do</span><br><span class="line">    ngx.req.append_body(chunk) -- each chunk can be 4KB</span><br><span class="line">end</span><br><span class="line">ngx.req.finish_body()</span><br></pre></td></tr></table></figure><p>This function can be used with [ngx.req.append_body]</p><p>This function was first introduced in the <code>v0.5.11</code> release.</p><h2><span id="ngxreqappend_body">ngx.req.append_body</span></h2><p><strong>syntax:</strong> <em>ngx.req.append_body(data_chunk)</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*</p><p>Append new data chunk specified by the <code>data_chunk</code> argument onto the existing request body created by the [ngx.req.init_body]</p><p>When the data can no longer be hold in the memory buffer for the request body, then the data will be flushed onto a temporary file just like the standard request body reader in the Nginx core.</p><p>It is important to always call the [ngx.req.finish_body]</p><p>This function can be used with [ngx.req.init_body]</p><p>This function was first introduced in the <code>v0.5.11</code> release.</p><p>See also [ngx.req.init_body]</p><h2><span id="ngxreqfinish_body">ngx.req.finish_body</span></h2><p><strong>syntax:</strong> <em>ngx.req.finish_body()</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*</p><p>Completes the construction process of the new request body created by the [ngx.req.init_body]</p><p>This function can be used with [ngx.req.init_body]</p><p>This function was first introduced in the <code>v0.5.11</code> release.</p><p>See also [ngx.req.init_body]</p><h2><span id="ngxreqsocket">ngx.req.socket</span></h2><p><strong>syntax:</strong> <em>tcpsock, err = ngx.req.socket()</em></p><p><strong>syntax:</strong> <em>tcpsock, err = ngx.req.socket(raw)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*</p><p>Returns a read-only cosocket object that wraps the downstream connection. Only [receive]</p><p>In case of error, <code>nil</code> will be returned as well as a string describing the error.</p><p>The socket object returned by this method is usually used to read the current request’s body in a streaming fashion. Do not turn on the [lua_need_request_body]</p><p>If any request body data has been pre-read into the Nginx core request header buffer, the resulting cosocket object will take care of this to avoid potential data loss resulting from such pre-reading. Chunked request bodies are not yet supported in this API.</p><p>Since the <code>v0.9.0</code> release, this function accepts an optional boolean <code>raw</code> argument. When this argument is <code>true</code>, this function returns a full-duplex cosocket object wrapping around the raw downstream connection socket, upon which you can call the [receive]</p><p>When the <code>raw</code> argument is <code>true</code>, it is required that no pending data from any previous [ngx.say]</p><p>You can use the “raw request socket” returned by <code>ngx.req.socket(true)</code> to implement fancy protocols like <a href="http://en.wikipedia.org/wiki/WebSocket" target="_blank" rel="noopener">WebSocket</a>, or just emit your own raw HTTP response header or body data. You can refer to the [lua-resty-websocket library]</p><p>This function was first introduced in the <code>v0.5.0rc1</code> release.</p><h2><span id="ngxexec">ngx.exec</span></h2><p><strong>syntax:</strong> <em>ngx.exec(uri, args?)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*</p><p>Does an internal redirect to <code>uri</code> with <code>args</code> and is similar to the <a href="http://github.com/openresty/echo-nginx-module#echo_exec" target="_blank" rel="noopener">echo_exec</a> directive of the <a href="http://github.com/openresty/echo-nginx-module" target="_blank" rel="noopener">echo-nginx-module</a>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ngx.exec(&apos;/some-location&apos;);</span><br><span class="line">ngx.exec(&apos;/some-location&apos;, &apos;a=3&amp;b=5&amp;c=6&apos;);</span><br><span class="line">ngx.exec(&apos;/some-location?a=3&amp;b=5&apos;, &apos;c=6&apos;);</span><br></pre></td></tr></table></figure><p>The optional second <code>args</code> can be used to specify extra URI query arguments, for example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.exec(&quot;/foo&quot;, &quot;a=3&amp;b=hello%20world&quot;)</span><br></pre></td></tr></table></figure><p>Alternatively, a Lua table can be passed for the <code>args</code> argument for ngx_lua to carry out URI escaping and string concatenation.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.exec(&quot;/foo&quot;, &#123; a = 3, b = &quot;hello world&quot; &#125;)</span><br></pre></td></tr></table></figure><p>The result is exactly the same as the previous example.</p><p>The format for the Lua table passed as the <code>args</code> argument is identical to the format used in the [ngx.encode_args]</p><p>Named locations are also supported but the second <code>args</code> argument will be ignored if present and the querystring for the new target is inherited from the referring location (if any).</p><p><code>GET /foo/file.php?a=hello</code> will return “hello” and not “goodbye” in the example below</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">location /foo &#123;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        ngx.exec(&quot;@bar&quot;, &quot;a=goodbye&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location @bar &#123;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        local args = ngx.req.get_uri_args()</span><br><span class="line">        for key, val in pairs(args) do</span><br><span class="line">            if key == &quot;a&quot; then</span><br><span class="line">                ngx.say(val)</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note that the <code>ngx.exec</code> method is different from [ngx.redirect]</p><p>Also note that this method call terminates the processing of the current request and that it <em>must</em> be called before [ngx.send_headers]</p><p>It is recommended that a coding style that combines this method call with the <code>return</code> statement, i.e., <code>return ngx.exec(...)</code>be adopted when this method call is used in contexts other than [header_filter_by_lua*]</p><h2><span id="ngxredirect">ngx.redirect</span></h2><p><strong>syntax:</strong> <em>ngx.redirect(uri, status?)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*</p><p>Issue an <code>HTTP 301</code> or <code>302</code> redirection to <code>uri</code>.</p><p>The optional <code>status</code> parameter specifies the HTTP status code to be used. The following status codes are supported right now:</p><ul><li><code>301</code></li><li><code>302</code> (default)</li><li><code>303</code></li><li><code>307</code></li><li><code>308</code></li></ul><p>It is <code>302</code> (<code>ngx.HTTP_MOVED_TEMPORARILY</code>) by default.</p><p>Here is an example assuming the current server name is <code>localhost</code> and that it is listening on port 1984:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return ngx.redirect(&quot;/foo&quot;)</span><br></pre></td></tr></table></figure><p>which is equivalent to</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return ngx.redirect(&quot;/foo&quot;, ngx.HTTP_MOVED_TEMPORARILY)</span><br></pre></td></tr></table></figure><p>Redirecting arbitrary external URLs is also supported, for example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return ngx.redirect(&quot;http://www.google.com&quot;)</span><br></pre></td></tr></table></figure><p>We can also use the numerical code directly as the second <code>status</code> argument:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return ngx.redirect(&quot;/foo&quot;, 301)</span><br></pre></td></tr></table></figure><p>This method is similar to the <a href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html#rewrite" target="_blank" rel="noopener">rewrite</a> directive with the <code>redirect</code> modifier in the standard <a href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html" target="_blank" rel="noopener">ngx_http_rewrite_module</a>, for example, this <code>nginx.conf</code> snippet</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rewrite ^ /foo? redirect;  # nginx config</span><br></pre></td></tr></table></figure><p>is equivalent to the following Lua code</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return ngx.redirect(&apos;/foo&apos;);  -- Lua code</span><br></pre></td></tr></table></figure><p>while</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rewrite ^ /foo? permanent;  # nginx config</span><br></pre></td></tr></table></figure><p>is equivalent to</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return ngx.redirect(&apos;/foo&apos;, ngx.HTTP_MOVED_PERMANENTLY)  -- Lua code</span><br></pre></td></tr></table></figure><p>URI arguments can be specified as well, for example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return ngx.redirect(&apos;/foo?a=3&amp;b=4&apos;)</span><br></pre></td></tr></table></figure><p>Note that this method call terminates the processing of the current request and that it <em>must</em> be called before [ngx.send_headers]</p><p>It is recommended that a coding style that combines this method call with the <code>return</code> statement, i.e., <code>return ngx.redirect(...)</code> be adopted when this method call is used in contexts other than [header_filter_by_lua*]</p><h2><span id="ngxsend_headers">ngx.send_headers</span></h2><p><strong>syntax:</strong> <em>ok, err = ngx.send_headers()</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*</p><p>Explicitly send out the response headers.</p><p>Since <code>v0.8.3</code> this function returns <code>1</code> on success, or returns <code>nil</code> and a string describing the error otherwise.</p><p>Note that there is normally no need to manually send out response headers as ngx_lua will automatically send headers out before content is output with [ngx.say]</p><h2><span id="ngxheaders_sent">ngx.headers_sent</span></h2><p><strong>syntax:</strong> <em>value = ngx.headers_sent</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*</p><p>Returns <code>true</code> if the response headers have been sent (by ngx_lua), and <code>false</code> otherwise.</p><p>This API was first introduced in ngx_lua v0.3.1rc6.</p><h2><span id="ngxprint">ngx.print</span></h2><p><strong>syntax:</strong> <em>ok, err = ngx.print(…)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*</p><p>Emits arguments concatenated to the HTTP client (as response body). If response headers have not been sent, this function will send headers out first and then output body data.</p><p>Since <code>v0.8.3</code> this function returns <code>1</code> on success, or returns <code>nil</code> and a string describing the error otherwise.</p><p>Lua <code>nil</code> values will output <code>&quot;nil&quot;</code> strings and Lua boolean values will output <code>&quot;true&quot;</code> and <code>&quot;false&quot;</code> literal strings respectively.</p><p>Nested arrays of strings are permitted and the elements in the arrays will be sent one by one:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">local table = &#123;</span><br><span class="line">    &quot;hello, &quot;,</span><br><span class="line">    &#123;&quot;world: &quot;, true, &quot; or &quot;, false,</span><br><span class="line">        &#123;&quot;: &quot;, nil&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line">ngx.print(table)</span><br></pre></td></tr></table></figure><p>will yield the output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello, world: true or false: nil</span><br></pre></td></tr></table></figure><p>Non-array table arguments will cause a Lua exception to be thrown.</p><p>The <code>ngx.null</code> constant will yield the <code>&quot;null&quot;</code> string output.</p><p>This is an asynchronous call and will return immediately without waiting for all the data to be written into the system send buffer. To run in synchronous mode, call <code>ngx.flush(true)</code> after calling <code>ngx.print</code>. This can be particularly useful for streaming output. See [ngx.flush]</p><p>Please note that both <code>ngx.print</code> and [ngx.say] will always invoke the whole Nginx output body filter chain, which is an expensive operation. So be careful when calling either of these two in a tight loop; buffer the data yourself in Lua and save the calls.</p><h2><span id="ngxsay">ngx.say</span></h2><p><strong>syntax:</strong> <em>ok, err = ngx.say(…)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*</p><p>Just as [ngx.print]</p><h2><span id="ngxlog">ngx.log</span></h2><p><strong>syntax:</strong> <em>ngx.log(log_level, …)</em></p><p><strong>context:</strong> init_by_lua*, init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Log arguments concatenated to error.log with the given logging level.</p><p>Lua <code>nil</code> arguments are accepted and result in literal <code>&quot;nil&quot;</code> string while Lua booleans result in literal <code>&quot;true&quot;</code> or <code>&quot;false&quot;</code>string outputs. And the <code>ngx.null</code> constant will yield the <code>&quot;null&quot;</code> string output.</p><p>The <code>log_level</code> argument can take constants like <code>ngx.ERR</code> and <code>ngx.WARN</code>. Check out [Nginx log level constants]</p><p>There is a hard coded <code>2048</code> byte limitation on error message lengths in the Nginx core. This limit includes trailing newlines and leading time stamps. If the message size exceeds this limit, Nginx will truncate the message text accordingly. This limit can be manually modified by editing the <code>NGX_MAX_ERROR_STR</code> macro definition in the <code>src/core/ngx_log.h</code> file in the Nginx source tree.</p><h2><span id="ngxflush">ngx.flush</span></h2><p><strong>syntax:</strong> <em>ok, err = ngx.flush(wait?)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*</p><p>Flushes response output to the client.</p><p><code>ngx.flush</code> accepts an optional boolean <code>wait</code> argument (Default: <code>false</code>) first introduced in the <code>v0.3.1rc34</code> release. When called with the default argument, it issues an asynchronous call (Returns immediately without waiting for output data to be written into the system send buffer). Calling the function with the <code>wait</code> argument set to <code>true</code> switches to synchronous mode.</p><p>In synchronous mode, the function will not return until all output data has been written into the system send buffer or until the <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#send_timeout" target="_blank" rel="noopener">send_timeout</a> setting has expired. Note that using the Lua coroutine mechanism means that this function does not block the Nginx event loop even in the synchronous mode.</p><p>When <code>ngx.flush(true)</code> is called immediately after [ngx.print]</p><p>Note that <code>ngx.flush</code> is not functional when in the HTTP 1.0 output buffering mode. See [HTTP 1.0 support]</p><p>Since <code>v0.8.3</code> this function returns <code>1</code> on success, or returns <code>nil</code> and a string describing the error otherwise.</p><h2><span id="ngxexit">ngx.exit</span></h2><p><strong>syntax:</strong> <em>ngx.exit(status)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>When <code>status &gt;= 200</code> (i.e., <code>ngx.HTTP_OK</code> and above), it will interrupt the execution of the current request and return status code to nginx.</p><p>When <code>status == 0</code> (i.e., <code>ngx.OK</code>), it will only quit the current phase handler (or the content handler if the [content_by_lua*]</p><p>The <code>status</code> argument can be <code>ngx.OK</code>, <code>ngx.ERROR</code>, <code>ngx.HTTP_NOT_FOUND</code>, <code>ngx.HTTP_MOVED_TEMPORARILY</code>, or other [HTTP status constants]</p><p>To return an error page with custom contents, use code snippets like this:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ngx.status = ngx.HTTP_GONE</span><br><span class="line">ngx.say(&quot;This is our own content&quot;)</span><br><span class="line">-- to cause quit the whole request rather than the current phase handler</span><br><span class="line">ngx.exit(ngx.HTTP_OK)</span><br></pre></td></tr></table></figure><p>The effect in action:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ curl -i http://localhost/test</span><br><span class="line">HTTP/1.1 410 Gone</span><br><span class="line">Server: nginx/1.0.6</span><br><span class="line">Date: Thu, 15 Sep 2011 00:51:48 GMT</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">This is our own content</span><br></pre></td></tr></table></figure><p>Number literals can be used directly as the argument, for instance,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.exit(501)</span><br></pre></td></tr></table></figure><p>Note that while this method accepts all [HTTP status constants]</p><p>Also note that this method call terminates the processing of the current request and that it is recommended that a coding style that combines this method call with the <code>return</code> statement, i.e., <code>return ngx.exit(...)</code> be used to reinforce the fact that the request processing is being terminated.</p><p>When being used in the contexts of [header_filter_by_lua*]</p><h2><span id="ngxeof">ngx.eof</span></h2><p><strong>syntax:</strong> <em>ok, err = ngx.eof()</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*</p><p>Explicitly specify the end of the response output stream. In the case of HTTP 1.1 chunked encoded output, it will just trigger the Nginx core to send out the “last chunk”.</p><p>When you disable the HTTP 1.1 keep-alive feature for your downstream connections, you can rely on well written HTTP clients to close the connection actively for you when you call this method. This trick can be used do back-ground jobs without letting the HTTP clients to wait on the connection, as in the following example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location = /async &#123;</span><br><span class="line">    keepalive_timeout 0;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        ngx.say(&quot;got the task!&quot;)</span><br><span class="line">        ngx.eof()  -- well written HTTP clients will close the connection at this point</span><br><span class="line">        -- access MySQL, PostgreSQL, Redis, Memcached, and etc here...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>But if you create subrequests to access other locations configured by Nginx upstream modules, then you should configure those upstream modules to ignore client connection abortions if they are not by default. For example, by default the standard <a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html" target="_blank" rel="noopener">ngx_http_proxy_module</a> will terminate both the subrequest and the main request as soon as the client closes the connection, so it is important to turn on the <a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_ignore_client_abort" target="_blank" rel="noopener">proxy_ignore_client_abort</a> directive in your location block configured by <a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html" target="_blank" rel="noopener">ngx_http_proxy_module</a>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy_ignore_client_abort on;</span><br></pre></td></tr></table></figure><p>A better way to do background jobs is to use the [ngx.timer.at]</p><p>Since <code>v0.8.3</code> this function returns <code>1</code> on success, or returns <code>nil</code> and a string describing the error otherwise.</p><h2><span id="ngxsleep">ngx.sleep</span></h2><p><strong>syntax:</strong> <em>ngx.sleep(seconds)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p><p>Sleeps for the specified seconds without blocking. One can specify time resolution up to 0.001 seconds (i.e., one milliseconds).</p><p>Behind the scene, this method makes use of the Nginx timers.</p><p>Since the <code>0.7.20</code> release, The <code>0</code> time argument can also be specified.</p><p>This method was introduced in the <code>0.5.0rc30</code> release.</p><h2><span id="ngxescape_uri">ngx.escape_uri</span></h2><p><strong>syntax:</strong> <em>newstr = ngx.escape_uri(str)</em></p><p><strong>context:</strong> init_by_lua*, init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Escape <code>str</code> as a URI component.</p><h2><span id="ngxunescape_uri">ngx.unescape_uri</span></h2><p><strong>syntax:</strong> <em>newstr = ngx.unescape_uri(str)</em></p><p><strong>context:</strong> init_by_lua*, init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*</p><p>Unescape <code>str</code> as an escaped URI component.</p><p>For example,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.say(ngx.unescape_uri(&quot;b%20r56+7&quot;))</span><br></pre></td></tr></table></figure><p>gives the output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b r56 7</span><br></pre></td></tr></table></figure><h2><span id="ngxencode_args">ngx.encode_args</span></h2><p><strong>syntax:</strong> <em>str = ngx.encode_args(table)</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*</p><p>Encode the Lua table to a query args string according to the URI encoded rules.</p><p>For example,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.encode_args(&#123;foo = 3, [&quot;b r&quot;] = &quot;hello world&quot;&#125;)</span><br></pre></td></tr></table></figure><p>yields</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo=3&amp;b%20r=hello%20world</span><br></pre></td></tr></table></figure><p>The table keys must be Lua strings.</p><p>Multi-value query args are also supported. Just use a Lua table for the argument’s value, for example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.encode_args(&#123;baz = &#123;32, &quot;hello&quot;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>gives</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">baz=32&amp;baz=hello</span><br></pre></td></tr></table></figure><p>If the value table is empty and the effect is equivalent to the <code>nil</code> value.</p><p>Boolean argument values are also supported, for instance,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.encode_args(&#123;a = true, b = 1&#125;)</span><br></pre></td></tr></table></figure><p>yields</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a&amp;b=1</span><br></pre></td></tr></table></figure><p>If the argument value is <code>false</code>, then the effect is equivalent to the <code>nil</code> value.</p><p>This method was first introduced in the <code>v0.3.1rc27</code> release.</p><h2><span id="ngxdecode_args">ngx.decode_args</span></h2><p><strong>syntax:</strong> <em>table, err = ngx.decode_args(str, max_args?)</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Decodes a URI encoded query-string into a Lua table. This is the inverse function of [ngx.encode_args]</p><p>The optional <code>max_args</code> argument can be used to specify the maximum number of arguments parsed from the <code>str</code>argument. By default, a maximum of 100 request arguments are parsed (including those with the same name) and that additional URI arguments are silently discarded to guard against potential denial of service attacks. Since <code>v0.10.13</code>, when the limit is exceeded, it will return a second value which is the string <code>&quot;truncated&quot;</code>.</p><p>This argument can be set to zero to remove the limit and to process all request arguments received:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">local args = ngx.decode_args(str, 0)</span><br></pre></td></tr></table></figure><p>Removing the <code>max_args</code> cap is strongly discouraged.</p><p>This method was introduced in the <code>v0.5.0rc29</code>.</p><h2><span id="ngxencode_base64">ngx.encode_base64</span></h2><p><strong>syntax:</strong> <em>newstr = ngx.encode_base64(str, no_padding?)</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Encodes <code>str</code> to a base64 digest.</p><p>Since the <code>0.9.16</code> release, an optional boolean-typed <code>no_padding</code> argument can be specified to control whether the base64 padding should be appended to the resulting digest (default to <code>false</code>, i.e., with padding enabled).</p><h2><span id="ngxdecode_base64">ngx.decode_base64</span></h2><p><strong>syntax:</strong> <em>newstr = ngx.decode_base64(str)</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Decodes the <code>str</code> argument as a base64 digest to the raw form. Returns <code>nil</code> if <code>str</code> is not well formed.</p><h2><span id="ngxcrc32_short">ngx.crc32_short</span></h2><p><strong>syntax:</strong> <em>intval = ngx.crc32_short(str)</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Calculates the CRC-32 (Cyclic Redundancy Code) digest for the <code>str</code> argument.</p><p>This method performs better on relatively short <code>str</code> inputs (i.e., less than 30 ~ 60 bytes), as compared to [ngx.crc32_long]</p><p>Behind the scene, it is just a thin wrapper around the <code>ngx_crc32_short</code> function defined in the Nginx core.</p><p>This API was first introduced in the <code>v0.3.1rc8</code> release.</p><h2><span id="ngxcrc32_long">ngx.crc32_long</span></h2><p><strong>syntax:</strong> <em>intval = ngx.crc32_long(str)</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Calculates the CRC-32 (Cyclic Redundancy Code) digest for the <code>str</code> argument.</p><p>This method performs better on relatively long <code>str</code> inputs (i.e., longer than 30 ~ 60 bytes), as compared to [ngx.crc32_short]</p><p>Behind the scene, it is just a thin wrapper around the <code>ngx_crc32_long</code> function defined in the Nginx core.</p><p>This API was first introduced in the <code>v0.3.1rc8</code> release.</p><h2><span id="ngxhmac_sha1">ngx.hmac_sha1</span></h2><p><strong>syntax:</strong> <em>digest = ngx.hmac_sha1(secret_key, str)</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Computes the <a href="http://en.wikipedia.org/wiki/HMAC" target="_blank" rel="noopener">HMAC-SHA1</a> digest of the argument <code>str</code> and turns the result using the secret key <code>&lt;secret_key&gt;</code>.</p><p>The raw binary form of the <code>HMAC-SHA1</code> digest will be generated, use [ngx.encode_base64]</p><p>For example,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">local key = &quot;thisisverysecretstuff&quot;</span><br><span class="line">local src = &quot;some string we want to sign&quot;</span><br><span class="line">local digest = ngx.hmac_sha1(key, src)</span><br><span class="line">ngx.say(ngx.encode_base64(digest))</span><br></pre></td></tr></table></figure><p>yields the output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R/pvxzHC4NLtj7S+kXFg/NePTmk=</span><br></pre></td></tr></table></figure><p>This API requires the OpenSSL library enabled in the Nginx build (usually by passing the <code>--with-http_ssl_module</code> option to the <code>./configure</code> script).</p><p>This function was first introduced in the <code>v0.3.1rc29</code> release.</p><h2><span id="ngxmd5">ngx.md5</span></h2><p><strong>syntax:</strong> <em>digest = ngx.md5(str)</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Returns the hexadecimal representation of the MD5 digest of the <code>str</code> argument.</p><p>For example,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location = /md5 &#123;</span><br><span class="line">    content_by_lua_block &#123; ngx.say(ngx.md5(&quot;hello&quot;)) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>yields the output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5d41402abc4b2a76b9719d911017c592</span><br></pre></td></tr></table></figure><p>See [ngx.md5_bin]</p><h2><span id="ngxmd5_bin">ngx.md5_bin</span></h2><p><strong>syntax:</strong> <em>digest = ngx.md5_bin(str)</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Returns the binary form of the MD5 digest of the <code>str</code> argument.</p><p>See [ngx.md5]</p><h2><span id="ngxsha1_bin">ngx.sha1_bin</span></h2><p><strong>syntax:</strong> <em>digest = ngx.sha1_bin(str)</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Returns the binary form of the SHA-1 digest of the <code>str</code> argument.</p><p>This function requires SHA-1 support in the Nginx build. (This usually just means OpenSSL should be installed while building Nginx).</p><p>This function was first introduced in the <code>v0.5.0rc6</code>.</p><h2><span id="ngxquote_sql_str">ngx.quote_sql_str</span></h2><p><strong>syntax:</strong> <em>quoted_value = ngx.quote_sql_str(raw_value)</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Returns a quoted SQL string literal according to the MySQL quoting rules.</p><h2><span id="ngxtoday">ngx.today</span></h2><p><strong>syntax:</strong> <em>str = ngx.today()</em></p><p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Returns current date (in the format <code>yyyy-mm-dd</code>) from the nginx cached time (no syscall involved unlike Lua’s date library).</p><p>This is the local time.</p><h2><span id="ngxtime">ngx.time</span></h2><p><strong>syntax:</strong> <em>secs = ngx.time()</em></p><p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Returns the elapsed seconds from the epoch for the current time stamp from the nginx cached time (no syscall involved unlike Lua’s date library).</p><p>Updates of the Nginx time cache can be forced by calling [ngx.update_time]</p><h2><span id="ngxnow">ngx.now</span></h2><p><strong>syntax:</strong> <em>secs = ngx.now()</em></p><p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Returns a floating-point number for the elapsed time in seconds (including milliseconds as the decimal part) from the epoch for the current time stamp from the nginx cached time (no syscall involved unlike Lua’s date library).</p><p>You can forcibly update the Nginx time cache by calling [ngx.update_time]</p><p>This API was first introduced in <code>v0.3.1rc32</code>.</p><h2><span id="ngxupdate_time">ngx.update_time</span></h2><p><strong>syntax:</strong> <em>ngx.update_time()</em></p><p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Forcibly updates the Nginx current time cache. This call involves a syscall and thus has some overhead, so do not abuse it.</p><p>This API was first introduced in <code>v0.3.1rc32</code>.</p><h2><span id="ngxlocaltime">ngx.localtime</span></h2><p><strong>syntax:</strong> <em>str = ngx.localtime()</em></p><p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Returns the current time stamp (in the format <code>yyyy-mm-dd hh:mm:ss</code>) of the nginx cached time (no syscall involved unlike Lua’s <a href="http://www.lua.org/manual/5.1/manual.html#pdf-os.date" target="_blank" rel="noopener">os.date</a> function).</p><p>This is the local time.</p><h2><span id="ngxutctime">ngx.utctime</span></h2><p><strong>syntax:</strong> <em>str = ngx.utctime()</em></p><p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Returns the current time stamp (in the format <code>yyyy-mm-dd hh:mm:ss</code>) of the nginx cached time (no syscall involved unlike Lua’s <a href="http://www.lua.org/manual/5.1/manual.html#pdf-os.date" target="_blank" rel="noopener">os.date</a> function).</p><p>This is the UTC time.</p><h2><span id="ngxcookie_time">ngx.cookie_time</span></h2><p><strong>syntax:</strong> <em>str = ngx.cookie_time(sec)</em></p><p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Returns a formatted string can be used as the cookie expiration time. The parameter <code>sec</code> is the time stamp in seconds (like those returned from [ngx.time]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ngx.say(ngx.cookie_time(1290079655))</span><br><span class="line">    -- yields &quot;Thu, 18-Nov-10 11:27:35 GMT&quot;</span><br></pre></td></tr></table></figure><h2><span id="ngxhttp_time">ngx.http_time</span></h2><p><strong>syntax:</strong> <em>str = ngx.http_time(sec)</em></p><p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Returns a formated string can be used as the http header time (for example, being used in <code>Last-Modified</code> header). The parameter <code>sec</code> is the time stamp in seconds (like those returned from [ngx.time]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ngx.say(ngx.http_time(1290079655))</span><br><span class="line">    -- yields &quot;Thu, 18 Nov 2010 11:27:35 GMT&quot;</span><br></pre></td></tr></table></figure><h2><span id="ngxparse_http_time">ngx.parse_http_time</span></h2><p><strong>syntax:</strong> <em>sec = ngx.parse_http_time(str)</em></p><p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Parse the http time string (as returned by [ngx.http_time]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">local time = ngx.parse_http_time(&quot;Thu, 18 Nov 2010 11:27:35 GMT&quot;)</span><br><span class="line">if time == nil then</span><br><span class="line">    ...</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2><span id="ngxis_subrequest">ngx.is_subrequest</span></h2><p><strong>syntax:</strong> <em>value = ngx.is_subrequest</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*</p><p>Returns <code>true</code> if the current request is an nginx subrequest, or <code>false</code> otherwise.</p><h2><span id="ngxrematch">ngx.re.match</span></h2><p><strong>syntax:</strong> <em>captures, err = ngx.re.match(subject, regex, options?, ctx?, res_table?)</em></p><p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Matches the <code>subject</code> string using the Perl compatible regular expression <code>regex</code> with the optional <code>options</code>.</p><p>Only the first occurrence of the match is returned, or <code>nil</code> if no match is found. In case of errors, like seeing a bad regular expression or exceeding the PCRE stack limit, <code>nil</code> and a string describing the error will be returned.</p><p>When a match is found, a Lua table <code>captures</code> is returned, where <code>captures[0]</code> holds the whole substring being matched, and <code>captures[1]</code> holds the first parenthesized sub-pattern’s capturing, <code>captures[2]</code> the second, and so on.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">local m, err = ngx.re.match(&quot;hello, 1234&quot;, &quot;[0-9]+&quot;)</span><br><span class="line">if m then</span><br><span class="line">    -- m[0] == &quot;1234&quot;</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line">    if err then</span><br><span class="line">        ngx.log(ngx.ERR, &quot;error: &quot;, err)</span><br><span class="line">        return</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    ngx.say(&quot;match not found&quot;)</span><br><span class="line">end</span><br><span class="line">local m, err = ngx.re.match(&quot;hello, 1234&quot;, &quot;([0-9])[0-9]+&quot;)</span><br><span class="line">-- m[0] == &quot;1234&quot;</span><br><span class="line">-- m[1] == &quot;1&quot;</span><br></pre></td></tr></table></figure><p>Named captures are also supported since the <code>v0.7.14</code> release and are returned in the same Lua table as key-value pairs as the numbered captures.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">local m, err = ngx.re.match(&quot;hello, 1234&quot;, &quot;([0-9][$1]?&lt;remaining&gt;[0-9]+)&quot;)</span><br><span class="line">-- m[0] == &quot;1234&quot;</span><br><span class="line">-- m[1] == &quot;1&quot;</span><br><span class="line">-- m[2] == &quot;234&quot;</span><br><span class="line">-- m[&quot;remaining&quot;] == &quot;234&quot;</span><br></pre></td></tr></table></figure><p>Unmatched subpatterns will have <code>false</code> values in their <code>captures</code> table fields.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">local m, err = ngx.re.match(&quot;hello, world&quot;, &quot;(world)|(hello)|(?&lt;named&gt;howdy)&quot;)</span><br><span class="line">-- m[0] == &quot;hello&quot;</span><br><span class="line">-- m[1] == false</span><br><span class="line">-- m[2] == &quot;hello&quot;</span><br><span class="line">-- m[3] == false</span><br><span class="line">-- m[&quot;named&quot;] == false</span><br></pre></td></tr></table></figure><p>Specify <code>options</code> to control how the match operation will be performed. The following option characters are supported:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">a             anchored mode (only match from the beginning)</span><br><span class="line"></span><br><span class="line">d             enable the DFA mode (or the longest token match semantics).</span><br><span class="line">              this requires PCRE 6.0+ or else a Lua exception will be thrown.</span><br><span class="line">              first introduced in ngx_lua v0.3.1rc30.</span><br><span class="line"></span><br><span class="line">D             enable duplicate named pattern support. This allows named</span><br><span class="line">              subpattern names to be repeated, returning the captures in</span><br><span class="line">              an array-like Lua table. for example,</span><br><span class="line">                local m = ngx.re.match(&quot;hello, world&quot;,</span><br><span class="line">                                       &quot;(?&lt;named&gt;\w+), (?&lt;named&gt;\w+)&quot;,</span><br><span class="line">                                       &quot;D&quot;)</span><br><span class="line">                -- m[&quot;named&quot;] == &#123;&quot;hello&quot;, &quot;world&quot;&#125;</span><br><span class="line">              this option was first introduced in the v0.7.14 release.</span><br><span class="line">              this option requires at least PCRE 8.12.</span><br><span class="line"></span><br><span class="line">i             case insensitive mode (similar to Perl&apos;s /i modifier)</span><br><span class="line"></span><br><span class="line">j             enable PCRE JIT compilation, this requires PCRE 8.21+ which</span><br><span class="line">              must be built with the --enable-jit option. for optimum performance,</span><br><span class="line">              this option should always be used together with the &apos;o&apos; option.</span><br><span class="line">              first introduced in ngx_lua v0.3.1rc30.</span><br><span class="line"></span><br><span class="line">J             enable the PCRE Javascript compatible mode. this option was</span><br><span class="line">              first introduced in the v0.7.14 release. this option requires</span><br><span class="line">              at least PCRE 8.12.</span><br><span class="line"></span><br><span class="line">m             multi-line mode (similar to Perl&apos;s /m modifier)</span><br><span class="line"></span><br><span class="line">o             compile-once mode (similar to Perl&apos;s /o modifier),</span><br><span class="line">              to enable the worker-process-level compiled-regex cache</span><br><span class="line"></span><br><span class="line">s             single-line mode (similar to Perl&apos;s /s modifier)</span><br><span class="line"></span><br><span class="line">u             UTF-8 mode. this requires PCRE to be built with</span><br><span class="line">              the --enable-utf8 option or else a Lua exception will be thrown.</span><br><span class="line"></span><br><span class="line">U             similar to &quot;u&quot; but disables PCRE&apos;s UTF-8 validity check on</span><br><span class="line">              the subject string. first introduced in ngx_lua v0.8.1.</span><br><span class="line"></span><br><span class="line">x             extended mode (similar to Perl&apos;s /x modifier)</span><br></pre></td></tr></table></figure><p>These options can be combined:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">local m, err = ngx.re.match(&quot;hello, world&quot;, &quot;HEL LO&quot;, &quot;ix&quot;)</span><br><span class="line">-- m[0] == &quot;hello&quot;</span><br><span class="line">local m, err = ngx.re.match(&quot;hello, 美好生活&quot;, &quot;HELLO, (.&#123;2&#125;)&quot;, &quot;iu&quot;)</span><br><span class="line">-- m[0] == &quot;hello, 美好&quot;</span><br><span class="line">-- m[1] == &quot;美好&quot;</span><br></pre></td></tr></table></figure><p>The <code>o</code> option is useful for performance tuning, because the regex pattern in question will only be compiled once, cached in the worker-process level, and shared among all requests in the current Nginx worker process. The upper limit of the regex cache can be tuned via the [lua_regex_cache_max_entries]</p><p>The optional fourth argument, <code>ctx</code>, can be a Lua table holding an optional <code>pos</code> field. When the <code>pos</code> field in the <code>ctx</code> table argument is specified, <code>ngx.re.match</code> will start matching from that offset (starting from 1). Regardless of the presence of the <code>pos</code> field in the <code>ctx</code> table, <code>ngx.re.match</code> will always set this <code>pos</code> field to the position <em>after</em> the substring matched by the whole pattern in case of a successful match. When match fails, the <code>ctx</code> table will be left intact.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">local ctx = &#123;&#125;</span><br><span class="line">local m, err = ngx.re.match(&quot;1234, hello&quot;, &quot;[0-9]+&quot;, &quot;&quot;, ctx)</span><br><span class="line">     -- m[0] = &quot;1234&quot;</span><br><span class="line">     -- ctx.pos == 5</span><br><span class="line">local ctx = &#123; pos = 2 &#125;</span><br><span class="line">local m, err = ngx.re.match(&quot;1234, hello&quot;, &quot;[0-9]+&quot;, &quot;&quot;, ctx)</span><br><span class="line">     -- m[0] = &quot;234&quot;</span><br><span class="line">     -- ctx.pos == 5</span><br></pre></td></tr></table></figure><p>The <code>ctx</code> table argument combined with the <code>a</code> regex modifier can be used to construct a lexer atop <code>ngx.re.match</code>.</p><p>Note that, the <code>options</code> argument is not optional when the <code>ctx</code> argument is specified and that the empty Lua string (<code>&quot;&quot;</code>) must be used as placeholder for <code>options</code> if no meaningful regex options are required.</p><p>This method requires the PCRE library enabled in Nginx. ([Known Issue With Special Escaping Sequences]</p><p>To confirm that PCRE JIT is enabled, activate the Nginx debug log by adding the <code>--with-debug</code> option to Nginx or OpenResty’s <code>./configure</code> script. Then, enable the “debug” error log level in <code>error_log</code> directive. The following message will be generated if PCRE JIT is enabled:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pcre JIT compiling result: 1</span><br></pre></td></tr></table></figure><p>Starting from the <code>0.9.4</code> release, this function also accepts a 5th argument, <code>res_table</code>, for letting the caller supply the Lua table used to hold all the capturing results. Starting from <code>0.9.6</code>, it is the caller’s responsibility to ensure this table is empty. This is very useful for recycling Lua tables and saving GC and table allocation overhead.</p><p>This feature was introduced in the <code>v0.2.1rc11</code> release.</p><h2><span id="ngxrefind">ngx.re.find</span></h2><p><strong>syntax:</strong> <em>from, to, err = ngx.re.find(subject, regex, options?, ctx?, nth?)</em></p><p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Similar to [ngx.re.match]</p><p>In case of errors (like bad regexes or any PCRE runtime errors), this API function returns two <code>nil</code> values followed by a string describing the error.</p><p>If no match is found, this function just returns a <code>nil</code> value.</p><p>Below is an example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">local s = &quot;hello, 1234&quot;</span><br><span class="line">local from, to, err = ngx.re.find(s, &quot;([0-9]+)&quot;, &quot;jo&quot;)</span><br><span class="line">if from then</span><br><span class="line">    ngx.say(&quot;from: &quot;, from)</span><br><span class="line">    ngx.say(&quot;to: &quot;, to)</span><br><span class="line">    ngx.say(&quot;matched: &quot;, string.sub(s, from, to))</span><br><span class="line">else</span><br><span class="line">    if err then</span><br><span class="line">        ngx.say(&quot;error: &quot;, err)</span><br><span class="line">        return</span><br><span class="line">    end</span><br><span class="line">    ngx.say(&quot;not matched!&quot;)</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>This example produces the output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from: 8</span><br><span class="line">to: 11</span><br><span class="line">matched: 1234</span><br></pre></td></tr></table></figure><p>Because this API function does not create new Lua strings nor new Lua tables, it is much faster than [ngx.re.match]</p><p>Since the <code>0.9.3</code> release, an optional 5th argument, <code>nth</code>, is supported to specify which (submatch) capture’s indexes to return. When <code>nth</code> is 0 (which is the default), the indexes for the whole matched substring is returned; when <code>nth</code> is 1, then the 1st submatch capture’s indexes are returned; when <code>nth</code> is 2, then the 2nd submatch capture is returned, and so on. When the specified submatch does not have a match, then two <code>nil</code> values will be returned. Below is an example for this:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">local str = &quot;hello, 1234&quot;</span><br><span class="line">local from, to = ngx.re.find(str, &quot;([0-9][$1][0-9]+)&quot;, &quot;jo&quot;, nil, 2)</span><br><span class="line">if from then</span><br><span class="line">    ngx.say(&quot;matched 2nd submatch: &quot;, string.sub(str, from, to))  -- yields &quot;234&quot;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>This API function was first introduced in the <code>v0.9.2</code> release.</p><h2><span id="ngxregmatch">ngx.re.gmatch</span></h2><p><strong>syntax:</strong> <em>iterator, err = ngx.re.gmatch(subject, regex, options?)</em></p><p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Similar to [ngx.re.match]</p><p>In case of errors, like seeing an ill-formed regular expression, <code>nil</code> and a string describing the error will be returned.</p><p>Here is a small example to demonstrate its basic usage:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">local iterator, err = ngx.re.gmatch(&quot;hello, world!&quot;, &quot;([a-z]+)&quot;, &quot;i&quot;)</span><br><span class="line">if not iterator then</span><br><span class="line">    ngx.log(ngx.ERR, &quot;error: &quot;, err)</span><br><span class="line">    return</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">local m</span><br><span class="line">m, err = iterator()    -- m[0] == m[1] == &quot;hello&quot;</span><br><span class="line">if err then</span><br><span class="line">    ngx.log(ngx.ERR, &quot;error: &quot;, err)</span><br><span class="line">    return</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">m, err = iterator()    -- m[0] == m[1] == &quot;world&quot;</span><br><span class="line">if err then</span><br><span class="line">    ngx.log(ngx.ERR, &quot;error: &quot;, err)</span><br><span class="line">    return</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">m, err = iterator()    -- m == nil</span><br><span class="line">if err then</span><br><span class="line">    ngx.log(ngx.ERR, &quot;error: &quot;, err)</span><br><span class="line">    return</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>More often we just put it into a Lua loop:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">local it, err = ngx.re.gmatch(&quot;hello, world!&quot;, &quot;([a-z]+)&quot;, &quot;i&quot;)</span><br><span class="line">if not it then</span><br><span class="line">    ngx.log(ngx.ERR, &quot;error: &quot;, err)</span><br><span class="line">    return</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">while true do</span><br><span class="line">    local m, err = it()</span><br><span class="line">    if err then</span><br><span class="line">        ngx.log(ngx.ERR, &quot;error: &quot;, err)</span><br><span class="line">        return</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    if not m then</span><br><span class="line">        -- no match found (any more)</span><br><span class="line">        break</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    -- found a match</span><br><span class="line">    ngx.say(m[0])</span><br><span class="line">    ngx.say(m[1])</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>The optional <code>options</code> argument takes exactly the same semantics as the [ngx.re.match]</p><p>The current implementation requires that the iterator returned should only be used in a single request. That is, one should <em>not</em>assign it to a variable belonging to persistent namespace like a Lua package.</p><p>This method requires the PCRE library enabled in Nginx. ([Known Issue With Special Escaping Sequences]</p><p>This feature was first introduced in the <code>v0.2.1rc12</code> release.</p><h2><span id="ngxresub">ngx.re.sub</span></h2><p><strong>syntax:</strong> <em>newstr, n, err = ngx.re.sub(subject, regex, replace, options?)</em></p><p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Substitutes the first match of the Perl compatible regular expression <code>regex</code> on the <code>subject</code> argument string with the string or function argument <code>replace</code>. The optional <code>options</code> argument has exactly the same meaning as in [ngx.re.match]</p><p>This method returns the resulting new string as well as the number of successful substitutions. In case of failures, like syntax errors in the regular expressions or the <code>&lt;replace&gt;</code> string argument, it will return <code>nil</code> and a string describing the error.</p><p>When the <code>replace</code> is a string, then it is treated as a special template for string replacement. For example,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">local newstr, n, err = ngx.re.sub(&quot;hello, 1234&quot;, &quot;([0-9])[0-9]&quot;, &quot;[$0][$1]&quot;)</span><br><span class="line">if newstr then</span><br><span class="line">    -- newstr == &quot;hello, [12][1]34&quot;</span><br><span class="line">    -- n == 1</span><br><span class="line">else</span><br><span class="line">    ngx.log(ngx.ERR, &quot;error: &quot;, err)</span><br><span class="line">    return</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>where <code>$0</code> referring to the whole substring matched by the pattern and <code>$1</code> referring to the first parenthesized capturing substring.</p><p>Curly braces can also be used to disambiguate variable names from the background string literals:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">local newstr, n, err = ngx.re.sub(&quot;hello, 1234&quot;, &quot;[0-9]&quot;, &quot;$&#123;0&#125;00&quot;)</span><br><span class="line">    -- newstr == &quot;hello, 100234&quot;</span><br><span class="line">    -- n == 1</span><br></pre></td></tr></table></figure><p>Literal dollar sign characters (<code>$</code>) in the <code>replace</code> string argument can be escaped by another dollar sign, for instance,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">local newstr, n, err = ngx.re.sub(&quot;hello, 1234&quot;, &quot;[0-9]&quot;, &quot;$$&quot;)</span><br><span class="line">    -- newstr == &quot;hello, $234&quot;</span><br><span class="line">    -- n == 1</span><br></pre></td></tr></table></figure><p>Do not use backlashes to escape dollar signs; it will not work as expected.</p><p>When the <code>replace</code> argument is of type “function”, then it will be invoked with the “match table” as the argument to generate the replace string literal for substitution. The “match table” fed into the <code>replace</code> function is exactly the same as the return value of [ngx.re.match]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">local func = function (m)</span><br><span class="line">    return &quot;[&quot; .. m[0] .. &quot;][&quot; .. m[1] .. &quot;]&quot;</span><br><span class="line">end</span><br><span class="line">local newstr, n, err = ngx.re.sub(&quot;hello, 1234&quot;, &quot;( [0-9] ) [0-9]&quot;, func, &quot;x&quot;)</span><br><span class="line">    -- newstr == &quot;hello, [12][1]34&quot;</span><br><span class="line">    -- n == 1</span><br></pre></td></tr></table></figure><p>The dollar sign characters in the return value of the <code>replace</code> function argument are not special at all.</p><p>This method requires the PCRE library enabled in Nginx. ([Known Issue With Special Escaping Sequences]</p><p>This feature was first introduced in the <code>v0.2.1rc13</code> release.</p><h2><span id="ngxregsub">ngx.re.gsub</span></h2><p><strong>syntax:</strong> <em>newstr, n, err = ngx.re.gsub(subject, regex, replace, options?)</em></p><p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Just like [ngx.re.sub]</p><p>Here is some examples:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">local newstr, n, err = ngx.re.gsub(&quot;hello, world&quot;, &quot;([a-z])[a-z]+&quot;, &quot;[$0,$1]&quot;, &quot;i&quot;)</span><br><span class="line">if newstr then</span><br><span class="line">    -- newstr == &quot;[hello,h], [world,w]&quot;</span><br><span class="line">    -- n == 2</span><br><span class="line">else</span><br><span class="line">    ngx.log(ngx.ERR, &quot;error: &quot;, err)</span><br><span class="line">    return</span><br><span class="line">end</span><br><span class="line">local func = function (m)</span><br><span class="line">    return &quot;[&quot; .. m[0] .. &quot;,&quot; .. m[1] .. &quot;]&quot;</span><br><span class="line">end</span><br><span class="line">local newstr, n, err = ngx.re.gsub(&quot;hello, world&quot;, &quot;([a-z])[a-z]+&quot;, func, &quot;i&quot;)</span><br><span class="line">    -- newstr == &quot;[hello,h], [world,w]&quot;</span><br><span class="line">    -- n == 2</span><br></pre></td></tr></table></figure><p>This method requires the PCRE library enabled in Nginx. ([Known Issue With Special Escaping Sequences]</p><p>This feature was first introduced in the <code>v0.2.1rc15</code> release.</p><h2><span id="ngxshareddict">ngx.shared.DICT</span></h2><p><strong>syntax:</strong> <em>dict = ngx.shared.DICT</em></p><p><strong>syntax:</strong> <em>dict = ngx.shared[name_var]</em></p><p><strong>context:</strong> init_by_lua*, init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Fetching the shm-based Lua dictionary object for the shared memory zone named <code>DICT</code> defined by the [lua_shared_dict]</p><p>Shared memory zones are always shared by all the nginx worker processes in the current nginx server instance.</p><p>The resulting object <code>dict</code> has the following methods:</p><ul><li>[get]</li><li>[get_stale]</li><li>[set]</li><li>[safe_set]</li><li>[add]</li><li>[safe_add]</li><li>[replace]</li><li>[delete]</li><li>[incr]</li><li>[lpush]</li><li>[rpush]</li><li>[lpop]</li><li>[rpop]</li><li>[llen]</li><li>[ttl]</li><li>[expire]</li><li>[flush_all]</li><li>[flush_expired]</li><li>[get_keys]</li><li>[capacity]</li><li>[free_space]</li></ul><p>All these methods are <em>atomic</em> operations, that is, safe from concurrent accesses from multiple nginx worker processes for the same <code>lua_shared_dict</code> zone.</p><p>Here is an example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    lua_shared_dict dogs 10m;</span><br><span class="line">    server &#123;</span><br><span class="line">        location /set &#123;</span><br><span class="line">            content_by_lua_block &#123;</span><br><span class="line">                local dogs = ngx.shared.dogs</span><br><span class="line">                dogs:set(&quot;Jim&quot;, 8)</span><br><span class="line">                ngx.say(&quot;STORED&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        location /get &#123;</span><br><span class="line">            content_by_lua_block &#123;</span><br><span class="line">                local dogs = ngx.shared.dogs</span><br><span class="line">                ngx.say(dogs:get(&quot;Jim&quot;))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Let us test it:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ curl localhost/set</span><br><span class="line">STORED</span><br><span class="line"></span><br><span class="line">$ curl localhost/get</span><br><span class="line">8</span><br><span class="line"></span><br><span class="line">$ curl localhost/get</span><br><span class="line">8</span><br></pre></td></tr></table></figure><p>The number <code>8</code> will be consistently output when accessing <code>/get</code> regardless of how many Nginx workers there are because the <code>dogs</code> dictionary resides in the shared memory and visible to <em>all</em> of the worker processes.</p><p>The shared dictionary will retain its contents through a server config reload (either by sending the <code>HUP</code> signal to the Nginx process or by using the <code>-s reload</code> command-line option).</p><p>The contents in the dictionary storage will be lost, however, when the Nginx server quits.</p><p>This feature was first introduced in the <code>v0.3.1rc22</code> release.</p><h2><span id="ngxshareddictget">ngx.shared.DICT.get</span></h2><p><strong>syntax:</strong> <em>value, flags = ngx.shared.DICT:get(key)</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Retrieving the value in the dictionary [ngx.shared.DICT]</p><p>In case of errors, <code>nil</code> and a string describing the error will be returned.</p><p>The value returned will have the original data type when they were inserted into the dictionary, for example, Lua booleans, numbers, or strings.</p><p>The first argument to this method must be the dictionary object itself, for example,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local cats = ngx.shared.cats</span><br><span class="line">local value, flags = cats.get(cats, &quot;Marry&quot;)</span><br></pre></td></tr></table></figure><p>or use Lua’s syntactic sugar for method calls:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local cats = ngx.shared.cats</span><br><span class="line">local value, flags = cats:get(&quot;Marry&quot;)</span><br></pre></td></tr></table></figure><p>These two forms are fundamentally equivalent.</p><p>If the user flags is <code>0</code> (the default), then no flags value will be returned.</p><p>This feature was first introduced in the <code>v0.3.1rc22</code> release.</p><p>See also [ngx.shared.DICT]</p><h2><span id="ngxshareddictget_stale">ngx.shared.DICT.get_stale</span></h2><p><strong>syntax:</strong> <em>value, flags, stale = ngx.shared.DICT:get_stale(key)</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Similar to the [get]</p><p>Returns a 3rd value, <code>stale</code>, indicating whether the key has expired or not.</p><p>Note that the value of an expired key is not guaranteed to be available so one should never rely on the availability of expired items.</p><p>This method was first introduced in the <code>0.8.6</code> release.</p><p>See also [ngx.shared.DICT]</p><h2><span id="ngxshareddictset">ngx.shared.DICT.set</span></h2><p><strong>syntax:</strong> <em>success, err, forcible = ngx.shared.DICT:set(key, value, exptime?, flags?)</em></p><p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Unconditionally sets a key-value pair into the shm-based dictionary [ngx.shared.DICT]</p><ul><li><code>success</code>: boolean value to indicate whether the key-value pair is stored or not.</li><li><code>err</code>: textual error message, can be <code>&quot;no memory&quot;</code>.</li><li><code>forcible</code>: a boolean value to indicate whether other valid items have been removed forcibly when out of storage in the shared memory zone.</li></ul><p>The <code>value</code> argument inserted can be Lua booleans, numbers, strings, or <code>nil</code>. Their value type will also be stored into the dictionary and the same data type can be retrieved later via the [get]</p><p>The optional <code>exptime</code> argument specifies expiration time (in seconds) for the inserted key-value pair. The time resolution is <code>0.001</code> seconds. If the <code>exptime</code> takes the value <code>0</code> (which is the default), then the item will never expire.</p><p>The optional <code>flags</code> argument specifies a user flags value associated with the entry to be stored. It can also be retrieved later with the value. The user flags is stored as an unsigned 32-bit integer internally. Defaults to <code>0</code>. The user flags argument was first introduced in the <code>v0.5.0rc2</code> release.</p><p>When it fails to allocate memory for the current key-value item, then <code>set</code> will try removing existing items in the storage according to the Least-Recently Used (LRU) algorithm. Note that, LRU takes priority over expiration time here. If up to tens of existing items have been removed and the storage left is still insufficient (either due to the total capacity limit specified by [lua_shared_dict]</p><p>If this method succeeds in storing the current item by forcibly removing other not-yet-expired items in the dictionary via LRU, the <code>forcible</code> return value will be <code>true</code>. If it stores the item without forcibly removing other valid items, then the return value <code>forcible</code> will be <code>false</code>.</p><p>The first argument to this method must be the dictionary object itself, for example,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local cats = ngx.shared.cats</span><br><span class="line">local succ, err, forcible = cats.set(cats, &quot;Marry&quot;, &quot;it is a nice cat!&quot;)</span><br></pre></td></tr></table></figure><p>or use Lua’s syntactic sugar for method calls:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local cats = ngx.shared.cats</span><br><span class="line">local succ, err, forcible = cats:set(&quot;Marry&quot;, &quot;it is a nice cat!&quot;)</span><br></pre></td></tr></table></figure><p>These two forms are fundamentally equivalent.</p><p>This feature was first introduced in the <code>v0.3.1rc22</code> release.</p><p>Please note that while internally the key-value pair is set atomically, the atomicity does not go across the method call boundary.</p><p>See also [ngx.shared.DICT]</p><h2><span id="ngxshareddictsafe_set">ngx.shared.DICT.safe_set</span></h2><p><strong>syntax:</strong> <em>ok, err = ngx.shared.DICT:safe_set(key, value, exptime?, flags?)</em></p><p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Similar to the [set]</p><p>This feature was first introduced in the <code>v0.7.18</code> release.</p><p>See also [ngx.shared.DICT]</p><h2><span id="ngxshareddictadd">ngx.shared.DICT.add</span></h2><p><strong>syntax:</strong> <em>success, err, forcible = ngx.shared.DICT:add(key, value, exptime?, flags?)</em></p><p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Just like the [set]</p><p>If the <code>key</code> argument already exists in the dictionary (and not expired for sure), the <code>success</code> return value will be <code>false</code> and the <code>err</code> return value will be <code>&quot;exists&quot;</code>.</p><p>This feature was first introduced in the <code>v0.3.1rc22</code> release.</p><p>See also [ngx.shared.DICT]</p><h2><span id="ngxshareddictsafe_add">ngx.shared.DICT.safe_add</span></h2><p><strong>syntax:</strong> <em>ok, err = ngx.shared.DICT:safe_add(key, value, exptime?, flags?)</em></p><p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Similar to the [add]</p><p>This feature was first introduced in the <code>v0.7.18</code> release.</p><p>See also [ngx.shared.DICT]</p><h2><span id="ngxshareddictreplace">ngx.shared.DICT.replace</span></h2><p><strong>syntax:</strong> <em>success, err, forcible = ngx.shared.DICT:replace(key, value, exptime?, flags?)</em></p><p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Just like the [set]</p><p>If the <code>key</code> argument does <em>not</em> exist in the dictionary (or expired already), the <code>success</code> return value will be <code>false</code> and the <code>err</code> return value will be <code>&quot;not found&quot;</code>.</p><p>This feature was first introduced in the <code>v0.3.1rc22</code> release.</p><p>See also [ngx.shared.DICT]</p><h2><span id="ngxshareddictdelete">ngx.shared.DICT.delete</span></h2><p><strong>syntax:</strong> <em>ngx.shared.DICT:delete(key)</em></p><p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Unconditionally removes the key-value pair from the shm-based dictionary [ngx.shared.DICT]</p><p>It is equivalent to <code>ngx.shared.DICT:set(key, nil)</code>.</p><p>This feature was first introduced in the <code>v0.3.1rc22</code> release.</p><p>See also [ngx.shared.DICT]</p><h2><span id="ngxshareddictincr">ngx.shared.DICT.incr</span></h2><p><strong>syntax:</strong> <em>newval, err, forcible? = ngx.shared.DICT:incr(key, value, init?, init_ttl?)</em></p><p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p><strong>optional requirement:</strong> <code>resty.core.shdict</code> or <code>resty.core</code></p><p>Increments the (numerical) value for <code>key</code> in the shm-based dictionary [ngx.shared.DICT]</p><p>When the key does not exist or has already expired in the shared dictionary,</p><ol><li>if the <code>init</code> argument is not specified or takes the value <code>nil</code>, this method will return <code>nil</code> and the error string <code>&quot;not found&quot;</code>, or</li><li>if the <code>init</code> argument takes a number value, this method will create a new <code>key</code> with the value <code>init + value</code>.</li></ol><p>Like the [add]</p><p>The optional <code>init_ttl</code> argument specifies expiration time (in seconds) of the value when it is initialized via the <code>init</code>argument. The time resolution is <code>0.001</code> seconds. If <code>init_ttl</code> takes the value <code>0</code> (which is the default), then the item will never expire. This argument cannot be provided without providing the <code>init</code> argument as well, and has no effect if the value already exists (e.g., if it was previously inserted via [set]</p><p><strong>Note:</strong> Usage of the <code>init_ttl</code> argument requires the <code>resty.core.shdict</code> or <code>resty.core</code> modules from the [lua-resty-core]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">require &quot;resty.core&quot;</span><br><span class="line"></span><br><span class="line">local cats = ngx.shared.cats</span><br><span class="line">local newval, err = cats:incr(&quot;black_cats&quot;, 1, 0, 0.1)</span><br><span class="line"></span><br><span class="line">print(newval) -- 1</span><br><span class="line"></span><br><span class="line">ngx.sleep(0.2)</span><br><span class="line"></span><br><span class="line">local val, err = cats:get(&quot;black_cats&quot;)</span><br><span class="line">print(val) -- nil</span><br></pre></td></tr></table></figure><p>The <code>forcible</code> return value will always be <code>nil</code> when the <code>init</code> argument is not specified.</p><p>If this method succeeds in storing the current item by forcibly removing other not-yet-expired items in the dictionary via LRU, the <code>forcible</code> return value will be <code>true</code>. If it stores the item without forcibly removing other valid items, then the return value <code>forcible</code> will be <code>false</code>.</p><p>If the original value is not a valid Lua number in the dictionary, it will return <code>nil</code> and <code>&quot;not a number&quot;</code>.</p><p>The <code>value</code> argument and <code>init</code> argument can be any valid Lua numbers, like negative numbers or floating-point numbers.</p><p>This method was first introduced in the <code>v0.3.1rc22</code> release.</p><p>The optional <code>init</code> parameter was first added in the <code>v0.10.6</code> release.</p><p>The optional <code>init_ttl</code> parameter was introduced in the <code>v0.10.12rc2</code> release.</p><p>See also [ngx.shared.DICT]</p><h2><span id="ngxshareddictlpush">ngx.shared.DICT.lpush</span></h2><p><strong>syntax:</strong> <em>length, err = ngx.shared.DICT:lpush(key, value)</em></p><p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Inserts the specified (numerical or string) <code>value</code> at the head of the list named <code>key</code> in the shm-based dictionary [ngx.shared.DICT]</p><p>If <code>key</code> does not exist, it is created as an empty list before performing the push operation. When the <code>key</code> already takes a value that is not a list, it will return <code>nil</code> and <code>&quot;value not a list&quot;</code>.</p><p>It never overrides the (least recently used) unexpired items in the store when running out of storage in the shared memory zone. In this case, it will immediately return <code>nil</code> and the string “no memory”.</p><p>This feature was first introduced in the <code>v0.10.6</code> release.</p><p>See also [ngx.shared.DICT]</p><h2><span id="ngxshareddictrpush">ngx.shared.DICT.rpush</span></h2><p><strong>syntax:</strong> <em>length, err = ngx.shared.DICT:rpush(key, value)</em></p><p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Similar to the [lpush]</p><p>This feature was first introduced in the <code>v0.10.6</code> release.</p><p>See also [ngx.shared.DICT]</p><h2><span id="ngxshareddictlpop">ngx.shared.DICT.lpop</span></h2><p><strong>syntax:</strong> <em>val, err = ngx.shared.DICT:lpop(key)</em></p><p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Removes and returns the first element of the list named <code>key</code> in the shm-based dictionary [ngx.shared.DICT]</p><p>If <code>key</code> does not exist, it will return <code>nil</code>. When the <code>key</code> already takes a value that is not a list, it will return <code>nil</code> and <code>&quot;value not a list&quot;</code>.</p><p>This feature was first introduced in the <code>v0.10.6</code> release.</p><p>See also [ngx.shared.DICT]</p><h2><span id="ngxshareddictrpop">ngx.shared.DICT.rpop</span></h2><p><strong>syntax:</strong> <em>val, err = ngx.shared.DICT:rpop(key)</em></p><p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Removes and returns the last element of the list named <code>key</code> in the shm-based dictionary [ngx.shared.DICT]</p><p>If <code>key</code> does not exist, it will return <code>nil</code>. When the <code>key</code> already takes a value that is not a list, it will return <code>nil</code> and <code>&quot;value not a list&quot;</code>.</p><p>This feature was first introduced in the <code>v0.10.6</code> release.</p><p>See also [ngx.shared.DICT]</p><h2><span id="ngxshareddictllen">ngx.shared.DICT.llen</span></h2><p><strong>syntax:</strong> <em>len, err = ngx.shared.DICT:llen(key)</em></p><p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Returns the number of elements in the list named <code>key</code> in the shm-based dictionary [ngx.shared.DICT]</p><p>If key does not exist, it is interpreted as an empty list and 0 is returned. When the <code>key</code> already takes a value that is not a list, it will return <code>nil</code> and <code>&quot;value not a list&quot;</code>.</p><p>This feature was first introduced in the <code>v0.10.6</code> release.</p><p>See also [ngx.shared.DICT]</p><h2><span id="ngxshareddictttl">ngx.shared.DICT.ttl</span></h2><p><strong>syntax:</strong> <em>ttl, err = ngx.shared.DICT:ttl(key)</em></p><p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p><strong>requires:</strong> <code>resty.core.shdict</code> or <code>resty.core</code></p><p>Retrieves the remaining TTL (time-to-live in seconds) of a key-value pair in the shm-based dictionary [ngx.shared.DICT]</p><p>If the key does not exist (or has already expired), this method will return <code>nil</code> and the error string <code>&quot;not found&quot;</code>.</p><p>The TTL is originally determined by the <code>exptime</code> argument of the [set]</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">require &quot;resty.core&quot;</span><br><span class="line"></span><br><span class="line">local cats = ngx.shared.cats</span><br><span class="line">local succ, err = cats:set(&quot;Marry&quot;, &quot;a nice cat&quot;, 0.5)</span><br><span class="line"></span><br><span class="line">ngx.sleep(0.2)</span><br><span class="line"></span><br><span class="line">local ttl, err = cats:ttl(&quot;Marry&quot;)</span><br><span class="line">ngx.say(ttl) -- 0.3</span><br></pre></td></tr></table></figure><p>This feature was first introduced in the <code>v0.10.11</code> release.</p><p><strong>Note:</strong> This method requires the <code>resty.core.shdict</code> or <code>resty.core</code> modules from the [lua-resty-core]</p><p>See also [ngx.shared.DICT]</p><h2><span id="ngxshareddictexpire">ngx.shared.DICT.expire</span></h2><p><strong>syntax:</strong> <em>success, err = ngx.shared.DICT:expire(key, exptime)</em></p><p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p><strong>requires:</strong> <code>resty.core.shdict</code> or <code>resty.core</code></p><p>Updates the <code>exptime</code> (in second) of a key-value pair in the shm-based dictionary [ngx.shared.DICT]</p><p>If the key does not exist, this method will return <code>nil</code> and the error string <code>&quot;not found&quot;</code>.</p><p>The <code>exptime</code> argument has a resolution of <code>0.001</code> seconds. If <code>exptime</code> is <code>0</code>, then the item will never expire.</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">require &quot;resty.core&quot;</span><br><span class="line"></span><br><span class="line">local cats = ngx.shared.cats</span><br><span class="line">local succ, err = cats:set(&quot;Marry&quot;, &quot;a nice cat&quot;, 0.1)</span><br><span class="line"></span><br><span class="line">succ, err = cats:expire(&quot;Marry&quot;, 0.5)</span><br><span class="line"></span><br><span class="line">ngx.sleep(0.2)</span><br><span class="line"></span><br><span class="line">local val, err = cats:get(&quot;Marry&quot;)</span><br><span class="line">ngx.say(val) -- &quot;a nice cat&quot;</span><br></pre></td></tr></table></figure><p>This feature was first introduced in the <code>v0.10.11</code> release.</p><p><strong>Note:</strong> This method requires the <code>resty.core.shdict</code> or <code>resty.core</code> modules from the [lua-resty-core]</p><p>See also [ngx.shared.DICT]</p><h2><span id="ngxshareddictflush_all">ngx.shared.DICT.flush_all</span></h2><p><strong>syntax:</strong> <em>ngx.shared.DICT:flush_all()</em></p><p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Flushes out all the items in the dictionary. This method does not actuall free up all the memory blocks in the dictionary but just marks all the existing items as expired.</p><p>This feature was first introduced in the <code>v0.5.0rc17</code> release.</p><p>See also [ngx.shared.DICT.flush_expired]</p><h2><span id="ngxshareddictflush_expired">ngx.shared.DICT.flush_expired</span></h2><p><strong>syntax:</strong> <em>flushed = ngx.shared.DICT:flush_expired(max_count?)</em></p><p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Flushes out the expired items in the dictionary, up to the maximal number specified by the optional <code>max_count</code> argument. When the <code>max_count</code> argument is given <code>0</code> or not given at all, then it means unlimited. Returns the number of items that have actually been flushed.</p><p>Unlike the [flush_all]</p><p>This feature was first introduced in the <code>v0.6.3</code> release.</p><p>See also [ngx.shared.DICT.flush_all]</p><h2><span id="ngxshareddictget_keys">ngx.shared.DICT.get_keys</span></h2><p><strong>syntax:</strong> <em>keys = ngx.shared.DICT:get_keys(max_count?)</em></p><p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Fetch a list of the keys from the dictionary, up to <code>&lt;max_count&gt;</code>.</p><p>By default, only the first 1024 keys (if any) are returned. When the <code>&lt;max_count&gt;</code> argument is given the value <code>0</code>, then all the keys will be returned even there is more than 1024 keys in the dictionary.</p><p><strong>CAUTION</strong> Avoid calling this method on dictionaries with a very large number of keys as it may lock the dictionary for significant amount of time and block Nginx worker processes trying to access the dictionary.</p><p>This feature was first introduced in the <code>v0.7.3</code> release.</p><h2><span id="ngxshareddictcapacity">ngx.shared.DICT.capacity</span></h2><p><strong>syntax:</strong> <em>capacity_bytes = ngx.shared.DICT:capacity()</em></p><p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p><strong>requires:</strong> <code>resty.core.shdict</code> or <code>resty.core</code></p><p>Retrieves the capacity in bytes for the shm-based dictionary [ngx.shared.DICT]</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">require &quot;resty.core.shdict&quot;</span><br><span class="line"></span><br><span class="line">local cats = ngx.shared.cats</span><br><span class="line">local capacity_bytes = cats:capacity()</span><br></pre></td></tr></table></figure><p>This feature was first introduced in the <code>v0.10.11</code> release.</p><p><strong>Note:</strong> This method requires the <code>resty.core.shdict</code> or <code>resty.core</code> modules from the [lua-resty-core]</p><p>This feature requires at least nginx core version <code>0.7.3</code>.</p><p>See also [ngx.shared.DICT]</p><h2><span id="ngxshareddictfree_space">ngx.shared.DICT.free_space</span></h2><p><strong>syntax:</strong> <em>free_page_bytes = ngx.shared.DICT:free_space()</em></p><p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p><strong>requires:</strong> <code>resty.core.shdict</code> or <code>resty.core</code></p><p>Retrieves the free page size in bytes for the shm-based dictionary [ngx.shared.DICT]</p><p><strong>Note:</strong> The memory for ngx.shared.DICT is allocated via the nginx slab allocator which has each slot for data size ranges like ~8, 9~16, 17~32, …, 1025~2048, 2048~ bytes. And pages are assigned to a slot if there is no room in already assigned pages for the slot.</p><p>So even if the return value of the <code>free_space</code> method is zero, there may be room in already assigned pages, so you may successfully set a new key value pair to the shared dict without getting <code>true</code> for <code>forcible</code> or non nil <code>err</code> from the <code>ngx.shared.DICT.set</code>.</p><p>On the other hand, if already assigned pages for a slot are full and a new key value pair is added to the slot and there is no free page, you may get <code>true</code> for <code>forcible</code> or non nil <code>err</code> from the <code>ngx.shared.DICT.set</code> method.</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">require &quot;resty.core.shdict&quot;</span><br><span class="line"></span><br><span class="line">local cats = ngx.shared.cats</span><br><span class="line">local free_page_bytes = cats:free_space()</span><br></pre></td></tr></table></figure><p>This feature was first introduced in the <code>v0.10.11</code> release.</p><p><strong>Note:</strong> This method requires the <code>resty.core.shdict</code> or <code>resty.core</code> modules from the [lua-resty-core]</p><p>This feature requires at least nginx core version <code>1.11.7</code>.</p><p>See also [ngx.shared.DICT]</p><h2><span id="ngxsocketudp">ngx.socket.udp</span></h2><p><strong>syntax:</strong> <em>udpsock = ngx.socket.udp()</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p><p>Creates and returns a UDP or datagram-oriented unix domain socket object (also known as one type of the “cosocket” objects). The following methods are supported on this object:</p><ul><li>[setpeername]</li><li>[send]</li><li>[receive]</li><li>[close]</li><li>[settimeout]</li></ul><p>It is intended to be compatible with the UDP API of the <a href="http://w3.impa.br/~diego/software/luasocket/udp.html" target="_blank" rel="noopener">LuaSocket</a> library but is 100% nonblocking out of the box.</p><p>This feature was first introduced in the <code>v0.5.7</code> release.</p><p>See also [ngx.socket.tcp]</p><h2><span id="udpsocksetpeername">udpsock:setpeername</span></h2><p><strong>syntax:</strong> <em>ok, err = udpsock:setpeername(host, port)</em></p><p><strong>syntax:</strong> <em>ok, err = udpsock:setpeername(“unix:/path/to/unix-domain.socket”)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p><p>Attempts to connect a UDP socket object to a remote server or to a datagram unix domain socket file. Because the datagram protocol is actually connection-less, this method does not really establish a “connection”, but only just set the name of the remote peer for subsequent read/write operations.</p><p>Both IP addresses and domain names can be specified as the <code>host</code> argument. In case of domain names, this method will use Nginx core’s dynamic resolver to parse the domain name without blocking and it is required to configure the <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#resolver" target="_blank" rel="noopener">resolver</a>directive in the <code>nginx.conf</code> file like this:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resolver 8.8.8.8;  # use Google&apos;s public DNS nameserver</span><br></pre></td></tr></table></figure><p>If the nameserver returns multiple IP addresses for the host name, this method will pick up one randomly.</p><p>In case of error, the method returns <code>nil</code> followed by a string describing the error. In case of success, the method returns <code>1</code>.</p><p>Here is an example for connecting to a UDP (memcached) server:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">location /test &#123;</span><br><span class="line">    resolver 8.8.8.8;</span><br><span class="line"></span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        local sock = ngx.socket.udp()</span><br><span class="line">        local ok, err = sock:setpeername(&quot;my.memcached.server.domain&quot;, 11211)</span><br><span class="line">        if not ok then</span><br><span class="line">            ngx.say(&quot;failed to connect to memcached: &quot;, err)</span><br><span class="line">            return</span><br><span class="line">        end</span><br><span class="line">        ngx.say(&quot;successfully connected to memcached!&quot;)</span><br><span class="line">        sock:close()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Since the <code>v0.7.18</code> release, connecting to a datagram unix domain socket file is also possible on Linux:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">local sock = ngx.socket.udp()</span><br><span class="line">local ok, err = sock:setpeername(&quot;unix:/tmp/some-datagram-service.sock&quot;)</span><br><span class="line">if not ok then</span><br><span class="line">    ngx.say(&quot;failed to connect to the datagram unix domain socket: &quot;, err)</span><br><span class="line">    return</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>assuming the datagram service is listening on the unix domain socket file <code>/tmp/some-datagram-service.sock</code> and the client socket will use the “autobind” feature on Linux.</p><p>Calling this method on an already connected socket object will cause the original connection to be closed first.</p><p>This method was first introduced in the <code>v0.5.7</code> release.</p><h2><span id="udpsocksend">udpsock:send</span></h2><p><strong>syntax:</strong> <em>ok, err = udpsock:send(data)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p><p>Sends data on the current UDP or datagram unix domain socket object.</p><p>In case of success, it returns <code>1</code>. Otherwise, it returns <code>nil</code> and a string describing the error.</p><p>The input argument <code>data</code> can either be a Lua string or a (nested) Lua table holding string fragments. In case of table arguments, this method will copy all the string elements piece by piece to the underlying Nginx socket send buffers, which is usually optimal than doing string concatenation operations on the Lua land.</p><p>This feature was first introduced in the <code>v0.5.7</code> release.</p><h2><span id="udpsockreceive">udpsock:receive</span></h2><p><strong>syntax:</strong> <em>data, err = udpsock:receive(size?)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p><p>Receives data from the UDP or datagram unix domain socket object with an optional receive buffer size argument, <code>size</code>.</p><p>This method is a synchronous operation and is 100% nonblocking.</p><p>In case of success, it returns the data received; in case of error, it returns <code>nil</code> with a string describing the error.</p><p>If the <code>size</code> argument is specified, then this method will use this size as the receive buffer size. But when this size is greater than <code>8192</code>, then <code>8192</code> will be used instead.</p><p>If no argument is specified, then the maximal buffer size, <code>8192</code> is assumed.</p><p>Timeout for the reading operation is controlled by the [lua_socket_read_timeout]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sock:settimeout(1000)  -- one second timeout</span><br><span class="line">local data, err = sock:receive()</span><br><span class="line">if not data then</span><br><span class="line">    ngx.say(&quot;failed to read a packet: &quot;, err)</span><br><span class="line">    return</span><br><span class="line">end</span><br><span class="line">ngx.say(&quot;successfully read a packet: &quot;, data)</span><br></pre></td></tr></table></figure><p>It is important here to call the [settimeout]</p><p>This feature was first introduced in the <code>v0.5.7</code> release.</p><h2><span id="udpsockclose">udpsock:close</span></h2><p><strong>syntax:</strong> <em>ok, err = udpsock:close()</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p><p>Closes the current UDP or datagram unix domain socket. It returns the <code>1</code> in case of success and returns <code>nil</code> with a string describing the error otherwise.</p><p>Socket objects that have not invoked this method (and associated connections) will be closed when the socket object is released by the Lua GC (Garbage Collector) or the current client HTTP request finishes processing.</p><p>This feature was first introduced in the <code>v0.5.7</code> release.</p><h2><span id="udpsocksettimeout">udpsock:settimeout</span></h2><p><strong>syntax:</strong> <em>udpsock:settimeout(time)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p><p>Set the timeout value in milliseconds for subsequent socket operations (like [receive]</p><p>Settings done by this method takes priority over those config directives, like [lua_socket_read_timeout]</p><p>This feature was first introduced in the <code>v0.5.7</code> release.</p><h2><span id="ngxsocketstream">ngx.socket.stream</span></h2><p>Just an alias to [ngx.socket.tcp]</p><p>This API function was first added to the <code>v0.10.1</code> release.</p><h2><span id="ngxsockettcp">ngx.socket.tcp</span></h2><p><strong>syntax:</strong> <em>tcpsock = ngx.socket.tcp()</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p><p>Creates and returns a TCP or stream-oriented unix domain socket object (also known as one type of the “cosocket” objects). The following methods are supported on this object:</p><ul><li>[connect]</li><li>[sslhandshake]</li><li>[send]</li><li>[receive]</li><li>[close]</li><li>[settimeout]</li><li>[settimeouts]</li><li>[setoption]</li><li>[receiveany]</li><li>[receiveuntil]</li><li>[setkeepalive]</li><li>[getreusedtimes]</li></ul><p>It is intended to be compatible with the TCP API of the <a href="http://w3.impa.br/~diego/software/luasocket/tcp.html" target="_blank" rel="noopener">LuaSocket</a> library but is 100% nonblocking out of the box. Also, we introduce some new APIs to provide more functionalities.</p><p>The cosocket object created by this API function has exactly the same lifetime as the Lua handler creating it. So never pass the cosocket object to any other Lua handler (including ngx.timer callback functions) and never share the cosocket object between different NGINX requests.</p><p>For every cosocket object’s underlying connection, if you do not explicitly close it (via [close]</p><ul><li>the current request handler completes, or</li><li>the Lua cosocket object value gets collected by the Lua GC.</li></ul><p>Fatal errors in cosocket operations always automatically close the current connection (note that, read timeout error is the only error that is not fatal), and if you call [close]</p><p>Starting from the <code>0.9.9</code> release, the cosocket object here is full-duplex, that is, a reader “light thread” and a writer “light thread” can operate on a single cosocket object simultaneously (both “light threads” must belong to the same Lua handler though, see reasons above). But you cannot have two “light threads” both reading (or writing or connecting) the same cosocket, otherwise you might get an error like “socket busy reading” when calling the methods of the cosocket object.</p><p>This feature was first introduced in the <code>v0.5.0rc1</code> release.</p><p>See also [ngx.socket.udp]</p><h2><span id="tcpsockconnect">tcpsock:connect</span></h2><p><strong>syntax:</strong> <em>ok, err = tcpsock:connect(host, port, options_table?)</em></p><p><strong>syntax:</strong> <em>ok, err = tcpsock:connect(“unix:/path/to/unix-domain.socket”, options_table?)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p><p>Attempts to connect a TCP socket object to a remote server or to a stream unix domain socket file without blocking.</p><p>Before actually resolving the host name and connecting to the remote backend, this method will always look up the connection pool for matched idle connections created by previous calls of this method (or the [ngx.socket.connect]</p><p>Both IP addresses and domain names can be specified as the <code>host</code> argument. In case of domain names, this method will use Nginx core’s dynamic resolver to parse the domain name without blocking and it is required to configure the <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#resolver" target="_blank" rel="noopener">resolver</a>directive in the <code>nginx.conf</code> file like this:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resolver 8.8.8.8;  # use Google&apos;s public DNS nameserver</span><br></pre></td></tr></table></figure><p>If the nameserver returns multiple IP addresses for the host name, this method will pick up one randomly.</p><p>In case of error, the method returns <code>nil</code> followed by a string describing the error. In case of success, the method returns <code>1</code>.</p><p>Here is an example for connecting to a TCP server:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">location /test &#123;</span><br><span class="line">    resolver 8.8.8.8;</span><br><span class="line"></span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        local sock = ngx.socket.tcp()</span><br><span class="line">        local ok, err = sock:connect(&quot;www.google.com&quot;, 80)</span><br><span class="line">        if not ok then</span><br><span class="line">            ngx.say(&quot;failed to connect to google: &quot;, err)</span><br><span class="line">            return</span><br><span class="line">        end</span><br><span class="line">        ngx.say(&quot;successfully connected to google!&quot;)</span><br><span class="line">        sock:close()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Connecting to a Unix Domain Socket file is also possible:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">local sock = ngx.socket.tcp()</span><br><span class="line">local ok, err = sock:connect(&quot;unix:/tmp/memcached.sock&quot;)</span><br><span class="line">if not ok then</span><br><span class="line">    ngx.say(&quot;failed to connect to the memcached unix domain socket: &quot;, err)</span><br><span class="line">    return</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>assuming memcached (or something else) is listening on the unix domain socket file <code>/tmp/memcached.sock</code>.</p><p>Timeout for the connecting operation is controlled by the [lua_socket_connect_timeout]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">local sock = ngx.socket.tcp()</span><br><span class="line">sock:settimeout(1000)  -- one second timeout</span><br><span class="line">local ok, err = sock:connect(host, port)</span><br></pre></td></tr></table></figure><p>It is important here to call the [settimeout]</p><p>Calling this method on an already connected socket object will cause the original connection to be closed first.</p><p>An optional Lua table can be specified as the last argument to this method to specify various connect options:</p><ul><li><code>pool</code> specify a custom name for the connection pool being used. If omitted, then the connection pool name will be generated from the string template <code>&quot;&lt;host&gt;:&lt;port&gt;&quot;</code> or <code>&quot;&lt;unix-socket-path&gt;&quot;</code>.</li><li><code>pool_size</code> specify the size of the connection pool. If omitted and no <code>backlog</code> option was provided, no pool will be created. If omitted but <code>backlog</code> was provided, the pool will be created with a default size equal to the value of the [lua_socket_pool_size]</li><li><code>backlog</code> if specified, this module will limit the total number of opened connections for this pool. No more connections than <code>pool_size</code> can be opened for this pool at any time. If the connection pool is full, subsequent connect operations will be queued into a queue equal to this option’s value (the “backlog” queue). If the number of queued connect operations is equal to <code>backlog</code>, subsequent connect operations will fail and return <code>nil</code> plus the error string <code>&quot;too many waiting connect operations&quot;</code>. The queued connect operations will be resumed once the number of connections in the pool is less than <code>pool_size</code>. The queued connect operation will abort once they have been queued for more than <code>connect_timeout</code>, controlled by [settimeouts]</li></ul><p>The support for the options table argument was first introduced in the <code>v0.5.7</code> release.</p><p>This method was first introduced in the <code>v0.5.0rc1</code> release.</p><h2><span id="tcpsocksslhandshake">tcpsock:sslhandshake</span></h2><p><strong>syntax:</strong> <em>session, err = tcpsock:sslhandshake(reused_session?, server_name?, ssl_verify?, send_status_req?)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p><p>Does SSL/TLS handshake on the currently established connection.</p><p>The optional <code>reused_session</code> argument can take a former SSL session userdata returned by a previous <code>sslhandshake</code> call for exactly the same target. For short-lived connections, reusing SSL sessions can usually speed up the handshake by one order by magnitude but it is not so useful if the connection pool is enabled. This argument defaults to <code>nil</code>. If this argument takes the boolean <code>false</code> value, no SSL session userdata would return by this call and only a Lua boolean will be returned as the first return value; otherwise the current SSL session will always be returned as the first argument in case of successes.</p><p>The optional <code>server_name</code> argument is used to specify the server name for the new TLS extension Server Name Indication (SNI). Use of SNI can make different servers share the same IP address on the server side. Also, when SSL verification is enabled, this <code>server_name</code> argument is also used to validate the server name specified in the server certificate sent from the remote.</p><p>The optional <code>ssl_verify</code> argument takes a Lua boolean value to control whether to perform SSL verification. When set to <code>true</code>, the server certificate will be verified according to the CA certificates specified by the [lua_ssl_trusted_certificate]</p><p>The optional <code>send_status_req</code> argument takes a boolean that controls whether to send the OCSP status request in the SSL handshake request (which is for requesting OCSP stapling).</p><p>For connections that have already done SSL/TLS handshake, this method returns immediately.</p><p>This method was first introduced in the <code>v0.9.11</code> release.</p><h2><span id="tcpsocksend">tcpsock:send</span></h2><p><strong>syntax:</strong> <em>bytes, err = tcpsock:send(data)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p><p>Sends data without blocking on the current TCP or Unix Domain Socket connection.</p><p>This method is a synchronous operation that will not return until <em>all</em> the data has been flushed into the system socket send buffer or an error occurs.</p><p>In case of success, it returns the total number of bytes that have been sent. Otherwise, it returns <code>nil</code> and a string describing the error.</p><p>The input argument <code>data</code> can either be a Lua string or a (nested) Lua table holding string fragments. In case of table arguments, this method will copy all the string elements piece by piece to the underlying Nginx socket send buffers, which is usually optimal than doing string concatenation operations on the Lua land.</p><p>Timeout for the sending operation is controlled by the [lua_socket_send_timeout]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sock:settimeout(1000)  -- one second timeout</span><br><span class="line">local bytes, err = sock:send(request)</span><br></pre></td></tr></table></figure><p>It is important here to call the [settimeout]</p><p>In case of any connection errors, this method always automatically closes the current connection.</p><p>This feature was first introduced in the <code>v0.5.0rc1</code> release.</p><h2><span id="tcpsockreceive">tcpsock:receive</span></h2><p><strong>syntax:</strong> <em>data, err, partial = tcpsock:receive(size)</em></p><p><strong>syntax:</strong> <em>data, err, partial = tcpsock:receive(pattern?)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p><p>Receives data from the connected socket according to the reading pattern or size.</p><p>This method is a synchronous operation just like the [send]</p><p>In case of success, it returns the data received; in case of error, it returns <code>nil</code> with a string describing the error and the partial data received so far.</p><p>If a number-like argument is specified (including strings that look like numbers), then it is interpreted as a size. This method will not return until it reads exactly this size of data or an error occurs.</p><p>If a non-number-like string argument is specified, then it is interpreted as a “pattern”. The following patterns are supported:</p><ul><li><code>&#39;*a&#39;</code>: reads from the socket until the connection is closed. No end-of-line translation is performed;</li><li><code>&#39;*l&#39;</code>: reads a line of text from the socket. The line is terminated by a <code>Line Feed</code> (LF) character (ASCII 10), optionally preceded by a <code>Carriage Return</code> (CR) character (ASCII 13). The CR and LF characters are not included in the returned line. In fact, all CR characters are ignored by the pattern.</li></ul><p>If no argument is specified, then it is assumed to be the pattern <code>&#39;*l&#39;</code>, that is, the line reading pattern.</p><p>Timeout for the reading operation is controlled by the [lua_socket_read_timeout]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sock:settimeout(1000)  -- one second timeout</span><br><span class="line">local line, err, partial = sock:receive()</span><br><span class="line">if not line then</span><br><span class="line">    ngx.say(&quot;failed to read a line: &quot;, err)</span><br><span class="line">    return</span><br><span class="line">end</span><br><span class="line">ngx.say(&quot;successfully read a line: &quot;, line)</span><br></pre></td></tr></table></figure><p>It is important here to call the [settimeout]</p><p>Since the <code>v0.8.8</code> release, this method no longer automatically closes the current connection when the read timeout error happens. For other connection errors, this method always automatically closes the connection.</p><p>This feature was first introduced in the <code>v0.5.0rc1</code> release.</p><h2><span id="tcpsockreceiveany">tcpsock:receiveany</span></h2><p><strong>syntax:</strong> <em>data, err = tcpsock:receiveany(max)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p><p>Returns any data received by the connected socket, at most <code>max</code> bytes.</p><p>This method is a synchronous operation just like the [send]</p><p>In case of success, it returns the data received; in case of error, it returns <code>nil</code> with a string describing the error.</p><p>If the received data is more than this size, this method will return with exactly this size of data. The remaining data in the underlying receive buffer could be returned in the next reading operation.</p><p>Timeout for the reading operation is controlled by the [lua_socket_read_timeout]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sock:settimeouts(1000, 1000, 1000)  -- one second timeout for connect/read/write</span><br><span class="line">local data, err = sock:receiveany(10 * 1024 * 1024) -- read any data, at most 10K</span><br><span class="line">if not data then</span><br><span class="line">    ngx.say(&quot;failed to read any data: &quot;, err)</span><br><span class="line">    return</span><br><span class="line">end</span><br><span class="line">ngx.say(&quot;successfully read: &quot;, data)</span><br></pre></td></tr></table></figure><p>This method doesn’t automatically close the current connection when the read timeout error occurs. For other connection errors, this method always automatically closes the connection.</p><p>This feature was first introduced in the <code>v0.10.14</code> release.</p><h2><span id="tcpsockreceiveuntil">tcpsock:receiveuntil</span></h2><p><strong>syntax:</strong> <em>iterator = tcpsock:receiveuntil(pattern, options?)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p><p>This method returns an iterator Lua function that can be called to read the data stream until it sees the specified pattern or an error occurs.</p><p>Here is an example for using this method to read a data stream with the boundary sequence <code>--abcedhb</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">local reader = sock:receiveuntil(&quot;\r\n--abcedhb&quot;)</span><br><span class="line">local data, err, partial = reader()</span><br><span class="line">if not data then</span><br><span class="line">    ngx.say(&quot;failed to read the data stream: &quot;, err)</span><br><span class="line">end</span><br><span class="line">ngx.say(&quot;read the data stream: &quot;, data)</span><br></pre></td></tr></table></figure><p>When called without any argument, the iterator function returns the received data right <em>before</em> the specified pattern string in the incoming data stream. So for the example above, if the incoming data stream is <code>&#39;hello, world! -agentzh\r\n--abcedhb blah blah&#39;</code>, then the string <code>&#39;hello, world! -agentzh&#39;</code> will be returned.</p><p>In case of error, the iterator function will return <code>nil</code> along with a string describing the error and the partial data bytes that have been read so far.</p><p>The iterator function can be called multiple times and can be mixed safely with other cosocket method calls or other iterator function calls.</p><p>The iterator function behaves differently (i.e., like a real iterator) when it is called with a <code>size</code> argument. That is, it will read that <code>size</code> of data on each invocation and will return <code>nil</code> at the last invocation (either sees the boundary pattern or meets an error). For the last successful invocation of the iterator function, the <code>err</code> return value will be <code>nil</code> too. The iterator function will be reset after the last successful invocation that returns <code>nil</code> data and <code>nil</code> error. Consider the following example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">local reader = sock:receiveuntil(&quot;\r\n--abcedhb&quot;)</span><br><span class="line"></span><br><span class="line">while true do</span><br><span class="line">    local data, err, partial = reader(4)</span><br><span class="line">    if not data then</span><br><span class="line">        if err then</span><br><span class="line">            ngx.say(&quot;failed to read the data stream: &quot;, err)</span><br><span class="line">            break</span><br><span class="line">        end</span><br><span class="line"></span><br><span class="line">        ngx.say(&quot;read done&quot;)</span><br><span class="line">        break</span><br><span class="line">    end</span><br><span class="line">    ngx.say(&quot;read chunk: [&quot;, data, &quot;]&quot;)</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>Then for the incoming data stream <code>&#39;hello, world! -agentzh\r\n--abcedhb blah blah&#39;</code>, we shall get the following output from the sample code above:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">read chunk: [hell]</span><br><span class="line">read chunk: [o, w]</span><br><span class="line">read chunk: [orld]</span><br><span class="line">read chunk: [! -a]</span><br><span class="line">read chunk: [gent]</span><br><span class="line">read chunk: [zh]</span><br><span class="line">read done</span><br></pre></td></tr></table></figure><p>Note that, the actual data returned <em>might</em> be a little longer than the size limit specified by the <code>size</code> argument when the boundary pattern has ambiguity for streaming parsing. Near the boundary of the data stream, the data string actually returned could also be shorter than the size limit.</p><p>Timeout for the iterator function’s reading operation is controlled by the [lua_socket_read_timeout]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">local readline = sock:receiveuntil(&quot;\r\n&quot;)</span><br><span class="line"></span><br><span class="line">sock:settimeout(1000)  -- one second timeout</span><br><span class="line">line, err, partial = readline()</span><br><span class="line">if not line then</span><br><span class="line">    ngx.say(&quot;failed to read a line: &quot;, err)</span><br><span class="line">    return</span><br><span class="line">end</span><br><span class="line">ngx.say(&quot;successfully read a line: &quot;, line)</span><br></pre></td></tr></table></figure><p>It is important here to call the [settimeout]</p><p>As from the <code>v0.5.1</code> release, this method also takes an optional <code>options</code> table argument to control the behavior. The following options are supported:</p><ul><li><code>inclusive</code></li></ul><p>The <code>inclusive</code> takes a boolean value to control whether to include the pattern string in the returned data string. Default to <code>false</code>. For example,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">local reader = tcpsock:receiveuntil(&quot;_END_&quot;, &#123; inclusive = true &#125;)</span><br><span class="line">local data = reader()</span><br><span class="line">ngx.say(data)</span><br></pre></td></tr></table></figure><p>Then for the input data stream <code>&quot;hello world _END_ blah blah blah&quot;</code>, then the example above will output <code>hello world _END_</code>, including the pattern string <code>_END_</code> itself.</p><p>Since the <code>v0.8.8</code> release, this method no longer automatically closes the current connection when the read timeout error happens. For other connection errors, this method always automatically closes the connection.</p><p>This method was first introduced in the <code>v0.5.0rc1</code> release.</p><h2><span id="tcpsockclose">tcpsock:close</span></h2><p><strong>syntax:</strong> <em>ok, err = tcpsock:close()</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p><p>Closes the current TCP or stream unix domain socket. It returns the <code>1</code> in case of success and returns <code>nil</code> with a string describing the error otherwise.</p><p>Note that there is no need to call this method on socket objects that have invoked the [setkeepalive]</p><p>Socket objects that have not invoked this method (and associated connections) will be closed when the socket object is released by the Lua GC (Garbage Collector) or the current client HTTP request finishes processing.</p><p>This feature was first introduced in the <code>v0.5.0rc1</code> release.</p><h2><span id="tcpsocksettimeout">tcpsock:settimeout</span></h2><p><strong>syntax:</strong> <em>tcpsock:settimeout(time)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p><p>Set the timeout value in milliseconds for subsequent socket operations ([connect]</p><p>Settings done by this method takes priority over those config directives, i.e., [lua_socket_connect_timeout]</p><p>Note that this method does <em>not</em> affect the [lua_socket_keepalive_timeout]</p><p>This feature was first introduced in the <code>v0.5.0rc1</code> release.</p><h2><span id="tcpsocksettimeouts">tcpsock:settimeouts</span></h2><p><strong>syntax:</strong> <em>tcpsock:settimeouts(connect_timeout, send_timeout, read_timeout)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p><p>Sets the connect timeout thresold, send timeout threshold, and read timeout threshold, respetively, in milliseconds, for subsequent socket operations ([connect]</p><p>Settings done by this method takes priority over those config directives, i.e., [lua_socket_connect_timeout]</p><p>You are recommended to use [settimeouts]</p><p>Note that this method does <em>not</em> affect the [lua_socket_keepalive_timeout]</p><p>This feature was first introduced in the <code>v0.10.7</code> release.</p><h2><span id="tcpsocksetoption">tcpsock:setoption</span></h2><p><strong>syntax:</strong> <em>tcpsock:setoption(option, value?)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p><p>This function is added for <a href="http://w3.impa.br/~diego/software/luasocket/tcp.html" target="_blank" rel="noopener">LuaSocket</a> API compatibility and does nothing for now. Its functionality will be implemented in future.</p><p>This feature was first introduced in the <code>v0.5.0rc1</code> release.</p><h2><span id="tcpsocksetkeepalive">tcpsock:setkeepalive</span></h2><p><strong>syntax:</strong> <em>ok, err = tcpsock:setkeepalive(timeout?, size?)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p><p>Puts the current socket’s connection immediately into the cosocket built-in connection pool and keep it alive until other [connect]</p><p>The first optional argument, <code>timeout</code>, can be used to specify the maximal idle timeout (in milliseconds) for the current connection. If omitted, the default setting in the [lua_socket_keepalive_timeout]</p><p>The second optional argument <code>size</code> is considered deprecated since the <code>v0.10.14</code> release of this module, in favor of the<code>pool_size</code> option of the [connect]</p><p>In case of success, this method returns <code>1</code>; otherwise, it returns <code>nil</code> and a string describing the error.</p><p>When the system receive buffer for the current connection has unread data, then this method will return the “connection in dubious state” error message (as the second return value) because the previous session has unread data left behind for the next session and the connection is not safe to be reused.</p><p>This method also makes the current cosocket object enter the “closed” state, so there is no need to manually call the [close]</p><p>This feature was first introduced in the <code>v0.5.0rc1</code> release.</p><h2><span id="tcpsockgetreusedtimes">tcpsock:getreusedtimes</span></h2><p><strong>syntax:</strong> <em>count, err = tcpsock:getreusedtimes()</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p><p>This method returns the (successfully) reused times for the current connection. In case of error, it returns <code>nil</code> and a string describing the error.</p><p>If the current connection does not come from the built-in connection pool, then this method always returns <code>0</code>, that is, the connection has never been reused (yet). If the connection comes from the connection pool, then the return value is always non-zero. So this method can also be used to determine if the current connection comes from the pool.</p><p>This feature was first introduced in the <code>v0.5.0rc1</code> release.</p><h2><span id="ngxsocketconnect">ngx.socket.connect</span></h2><p><strong>syntax:</strong> <em>tcpsock, err = ngx.socket.connect(host, port)</em></p><p><strong>syntax:</strong> <em>tcpsock, err = ngx.socket.connect(“unix:/path/to/unix-domain.socket”)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.**</p><p>This function is a shortcut for combining [ngx.socket.tcp()]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">local sock = ngx.socket.tcp()</span><br><span class="line">local ok, err = sock:connect(...)</span><br><span class="line">if not ok then</span><br><span class="line">    return nil, err</span><br><span class="line">end</span><br><span class="line">return sock</span><br></pre></td></tr></table></figure><p>There is no way to use the [settimeout]</p><p>This feature was first introduced in the <code>v0.5.0rc1</code> release.</p><h2><span id="ngxget_phase">ngx.get_phase</span></h2><p><strong>syntax:</strong> <em>str = ngx.get_phase()</em></p><p><strong>context:</strong> init_by_lua*, init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Retrieves the current running phase name. Possible return values are</p><ul><li><code>init</code> for the context of [init_by_lua*]</li><li><code>init_worker</code> for the context of [init_worker_by_lua*]</li><li><code>ssl_cert</code> for the context of [ssl_certificate_by_lua*]</li><li><code>ssl_session_fetch</code> for the context of [ssl_session_fetch_by_lua*]</li><li><code>ssl_session_store</code> for the context of [ssl_session_store_by_lua*]</li><li><code>set</code> for the context of [set_by_lua*]</li><li><code>rewrite</code> for the context of [rewrite_by_lua*]</li><li><code>balancer</code> for the context of [balancer_by_lua*]</li><li><code>access</code> for the context of [access_by_lua*]</li><li><code>content</code> for the context of [content_by_lua*]</li><li><code>header_filter</code> for the context of [header_filter_by_lua*]</li><li><code>body_filter</code> for the context of [body_filter_by_lua*]</li><li><code>log</code> for the context of [log_by_lua*]</li><li><code>timer</code> for the context of user callback functions for [ngx.timer.*]</li></ul><p>This API was first introduced in the <code>v0.5.10</code> release.</p><h2><span id="ngxthreadspawn">ngx.thread.spawn</span></h2><p><strong>syntax:</strong> <em>co = ngx.thread.spawn(func, arg1, arg2, …)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p><p>Spawns a new user “light thread” with the Lua function <code>func</code> as well as those optional arguments <code>arg1</code>, <code>arg2</code>, and etc. Returns a Lua thread (or Lua coroutine) object represents this “light thread”.</p><p>“Light threads” are just a special kind of Lua coroutines that are scheduled by the ngx_lua module.</p><p>Before <code>ngx.thread.spawn</code> returns, the <code>func</code> will be called with those optional arguments until it returns, aborts with an error, or gets yielded due to I/O operations via the [Nginx API for Lua]</p><p>After <code>ngx.thread.spawn</code> returns, the newly-created “light thread” will keep running asynchronously usually at various I/O events.</p><p>All the Lua code chunks running by [rewrite_by_lua]</p><p>By default, the corresponding Nginx handler (e.g., [rewrite_by_lua]</p><ol><li>both the “entry thread” and all the user “light threads” terminates,</li><li>a “light thread” (either the “entry thread” or a user “light thread” aborts by calling [ngx.exit]</li><li>the “entry thread” terminates with a Lua error.</li></ol><p>When the user “light thread” terminates with a Lua error, however, it will not abort other running “light threads” like the “entry thread” does.</p><p>Due to the limitation in the Nginx subrequest model, it is not allowed to abort a running Nginx subrequest in general. So it is also prohibited to abort a running “light thread” that is pending on one ore more Nginx subrequests. You must call [ngx.thread.wait]</p><p>The “light threads” are not scheduled in a pre-emptive way. In other words, no time-slicing is performed automatically. A “light thread” will keep running exclusively on the CPU until</p><ol><li>a (nonblocking) I/O operation cannot be completed in a single run,</li><li>it calls [coroutine.yield]</li><li>it is aborted by a Lua error or an invocation of [ngx.exit]</li></ol><p>For the first two cases, the “light thread” will usually be resumed later by the ngx_lua scheduler unless a “stop-the-world” event happens.</p><p>User “light threads” can create “light threads” themselves. And normal user coroutines created by [coroutine.create]</p><p>The “parent coroutine” can call [ngx.thread.wait]</p><p>You can call coroutine.status() and coroutine.yield() on the “light thread” coroutines.</p><p>The status of the “light thread” coroutine can be “zombie” if</p><ol><li>the current “light thread” already terminates (either successfully or with an error),</li><li>its parent coroutine is still alive, and</li><li>its parent coroutine is not waiting on it with [ngx.thread.wait]</li></ol><p>The following example demonstrates the use of coroutine.yield() in the “light thread” coroutines to do manual time-slicing:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">local yield = coroutine.yield</span><br><span class="line"></span><br><span class="line">function f()</span><br><span class="line">    local self = coroutine.running()</span><br><span class="line">    ngx.say(&quot;f 1&quot;)</span><br><span class="line">    yield(self)</span><br><span class="line">    ngx.say(&quot;f 2&quot;)</span><br><span class="line">    yield(self)</span><br><span class="line">    ngx.say(&quot;f 3&quot;)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">local self = coroutine.running()</span><br><span class="line">ngx.say(&quot;0&quot;)</span><br><span class="line">yield(self)</span><br><span class="line"></span><br><span class="line">ngx.say(&quot;1&quot;)</span><br><span class="line">ngx.thread.spawn(f)</span><br><span class="line"></span><br><span class="line">ngx.say(&quot;2&quot;)</span><br><span class="line">yield(self)</span><br><span class="line"></span><br><span class="line">ngx.say(&quot;3&quot;)</span><br><span class="line">yield(self)</span><br><span class="line"></span><br><span class="line">ngx.say(&quot;4&quot;)</span><br></pre></td></tr></table></figure><p>Then it will generate the output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">f 1</span><br><span class="line">2</span><br><span class="line">f 2</span><br><span class="line">3</span><br><span class="line">f 3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>“Light threads” are mostly useful for making concurrent upstream requests in a single Nginx request handler, much like a generalized version of [ngx.location.capture_multi]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">-- query mysql, memcached, and a remote http service at the same time,</span><br><span class="line">-- output the results in the order that they</span><br><span class="line">-- actually return the results.</span><br><span class="line"></span><br><span class="line">local mysql = require &quot;resty.mysql&quot;</span><br><span class="line">local memcached = require &quot;resty.memcached&quot;</span><br><span class="line"></span><br><span class="line">local function query_mysql()</span><br><span class="line">    local db = mysql:new()</span><br><span class="line">    db:connect&#123;</span><br><span class="line">                host = &quot;127.0.0.1&quot;,</span><br><span class="line">                port = 3306,</span><br><span class="line">                database = &quot;test&quot;,</span><br><span class="line">                user = &quot;monty&quot;,</span><br><span class="line">                password = &quot;mypass&quot;</span><br><span class="line">              &#125;</span><br><span class="line">    local res, err, errno, sqlstate =</span><br><span class="line">            db:query(&quot;select * from cats order by id asc&quot;)</span><br><span class="line">    db:set_keepalive(0, 100)</span><br><span class="line">    ngx.say(&quot;mysql done: &quot;, cjson.encode(res))</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">local function query_memcached()</span><br><span class="line">    local memc = memcached:new()</span><br><span class="line">    memc:connect(&quot;127.0.0.1&quot;, 11211)</span><br><span class="line">    local res, err = memc:get(&quot;some_key&quot;)</span><br><span class="line">    ngx.say(&quot;memcached done: &quot;, res)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">local function query_http()</span><br><span class="line">    local res = ngx.location.capture(&quot;/my-http-proxy&quot;)</span><br><span class="line">    ngx.say(&quot;http done: &quot;, res.body)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">ngx.thread.spawn(query_mysql)      -- create thread 1</span><br><span class="line">ngx.thread.spawn(query_memcached)  -- create thread 2</span><br><span class="line">ngx.thread.spawn(query_http)       -- create thread 3</span><br></pre></td></tr></table></figure><p>This API was first enabled in the <code>v0.7.0</code> release.</p><h2><span id="ngxthreadwait">ngx.thread.wait</span></h2><p><strong>syntax:</strong> <em>ok, res1, res2, … = ngx.thread.wait(thread1, thread2, …)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p><p>Waits on one or more child “light threads” and returns the results of the first “light thread” that terminates (either successfully or with an error).</p><p>The arguments <code>thread1</code>, <code>thread2</code>, and etc are the Lua thread objects returned by earlier calls of [ngx.thread.spawn]</p><p>The return values have exactly the same meaning as [coroutine.resume]</p><p>Only the direct “parent coroutine” can wait on its child “light thread”, otherwise a Lua exception will be raised.</p><p>The following example demonstrates the use of <code>ngx.thread.wait</code> and [ngx.location.capture]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">local capture = ngx.location.capture</span><br><span class="line">local spawn = ngx.thread.spawn</span><br><span class="line">local wait = ngx.thread.wait</span><br><span class="line">local say = ngx.say</span><br><span class="line"></span><br><span class="line">local function fetch(uri)</span><br><span class="line">    return capture(uri)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">local threads = &#123;</span><br><span class="line">    spawn(fetch, &quot;/foo&quot;),</span><br><span class="line">    spawn(fetch, &quot;/bar&quot;),</span><br><span class="line">    spawn(fetch, &quot;/baz&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for i = 1, #threads do</span><br><span class="line">    local ok, res = wait(threads[i])</span><br><span class="line">    if not ok then</span><br><span class="line">        say(i, &quot;: failed to run: &quot;, res)</span><br><span class="line">    else</span><br><span class="line">        say(i, &quot;: status: &quot;, res.status)</span><br><span class="line">        say(i, &quot;: body: &quot;, res.body)</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>Here it essentially implements the “wait all” model.</p><p>And below is an example demonstrating the “wait any” model:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">function f()</span><br><span class="line">    ngx.sleep(0.2)</span><br><span class="line">    ngx.say(&quot;f: hello&quot;)</span><br><span class="line">    return &quot;f done&quot;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">function g()</span><br><span class="line">    ngx.sleep(0.1)</span><br><span class="line">    ngx.say(&quot;g: hello&quot;)</span><br><span class="line">    return &quot;g done&quot;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">local tf, err = ngx.thread.spawn(f)</span><br><span class="line">if not tf then</span><br><span class="line">    ngx.say(&quot;failed to spawn thread f: &quot;, err)</span><br><span class="line">    return</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">ngx.say(&quot;f thread created: &quot;, coroutine.status(tf))</span><br><span class="line"></span><br><span class="line">local tg, err = ngx.thread.spawn(g)</span><br><span class="line">if not tg then</span><br><span class="line">    ngx.say(&quot;failed to spawn thread g: &quot;, err)</span><br><span class="line">    return</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">ngx.say(&quot;g thread created: &quot;, coroutine.status(tg))</span><br><span class="line"></span><br><span class="line">ok, res = ngx.thread.wait(tf, tg)</span><br><span class="line">if not ok then</span><br><span class="line">    ngx.say(&quot;failed to wait: &quot;, res)</span><br><span class="line">    return</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">ngx.say(&quot;res: &quot;, res)</span><br><span class="line"></span><br><span class="line">-- stop the &quot;world&quot;, aborting other running threads</span><br><span class="line">ngx.exit(ngx.OK)</span><br></pre></td></tr></table></figure><p>And it will generate the following output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f thread created: running</span><br><span class="line">g thread created: running</span><br><span class="line">g: hello</span><br><span class="line">res: g done</span><br></pre></td></tr></table></figure><p>This API was first enabled in the <code>v0.7.0</code> release.</p><h2><span id="ngxthreadkill">ngx.thread.kill</span></h2><p><strong>syntax:</strong> <em>ok, err = ngx.thread.kill(thread)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.**</p><p>Kills a running “light thread” created by [ngx.thread.spawn]</p><p>According to the current implementation, only the parent coroutine (or “light thread”) can kill a thread. Also, a running “light thread” with pending NGINX subrequests (initiated by [ngx.location.capture]</p><p>This API was first enabled in the <code>v0.9.9</code> release.</p><h2><span id="ngxon_abort">ngx.on_abort</span></h2><p><strong>syntax:</strong> <em>ok, err = ngx.on_abort(callback)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*</p><p>Registers a user Lua function as the callback which gets called automatically when the client closes the (downstream) connection prematurely.</p><p>Returns <code>1</code> if the callback is registered successfully or returns <code>nil</code> and a string describing the error otherwise.</p><p>All the [Nginx API for Lua]</p><p>The callback function can decide what to do with the client abortion event all by itself. For example, it can simply ignore the event by doing nothing and the current Lua request handler will continue executing without interruptions. And the callback function can also decide to terminate everything by calling [ngx.exit]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">local function my_cleanup()</span><br><span class="line">    -- custom cleanup work goes here, like cancelling a pending DB transaction</span><br><span class="line"></span><br><span class="line">    -- now abort all the &quot;light threads&quot; running in the current request handler</span><br><span class="line">    ngx.exit(499)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">local ok, err = ngx.on_abort(my_cleanup)</span><br><span class="line">if not ok then</span><br><span class="line">    ngx.log(ngx.ERR, &quot;failed to register the on_abort callback: &quot;, err)</span><br><span class="line">    ngx.exit(500)</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>When [lua_check_client_abort]</p><p>According to the current implementation, this function can only be called once in a single request handler; subsequent calls will return the error message “duplicate call”.</p><p>This API was first introduced in the <code>v0.7.4</code> release.</p><p>See also [lua_check_client_abort]</p><h2><span id="ngxtimerat">ngx.timer.at</span></h2><p><strong>syntax:</strong> <em>hdl, err = ngx.timer.at(delay, callback, user_arg1, user_arg2, …)</em></p><p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Creates an Nginx timer with a user callback function as well as optional user arguments.</p><p>The first argument, <code>delay</code>, specifies the delay for the timer, in seconds. One can specify fractional seconds like <code>0.001</code> to mean 1 millisecond here. <code>0</code> delay can also be specified, in which case the timer will immediately expire when the current handler yields execution.</p><p>The second argument, <code>callback</code>, can be any Lua function, which will be invoked later in a background “light thread” after the delay specified. The user callback will be called automatically by the Nginx core with the arguments <code>premature</code>, <code>user_arg1</code>, <code>user_arg2</code>, and etc, where the <code>premature</code> argument takes a boolean value indicating whether it is a premature timer expiration or not, and <code>user_arg1</code>, <code>user_arg2</code>, and etc, are those (extra) user arguments specified when calling <code>ngx.timer.at</code>as the remaining arguments.</p><p>Premature timer expiration happens when the Nginx worker process is trying to shut down, as in an Nginx configuration reload triggered by the <code>HUP</code> signal or in an Nginx server shutdown. When the Nginx worker is trying to shut down, one can no longer call <code>ngx.timer.at</code> to create new timers with nonzero delays and in that case <code>ngx.timer.at</code> will return a “conditional false” value and a string describing the error, that is, “process exiting”.</p><p>Starting from the <code>v0.9.3</code> release, it is allowed to create zero-delay timers even when the Nginx worker process starts shutting down.</p><p>When a timer expires, the user Lua code in the timer callback is running in a “light thread” detached completely from the original request creating the timer. So objects with the same lifetime as the request creating them, like [cosockets]</p><p>Here is a simple example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    ...</span><br><span class="line">    log_by_lua_block &#123;</span><br><span class="line">        local function push_data(premature, uri, args, status)</span><br><span class="line">            -- push the data uri, args, and status to the remote</span><br><span class="line">            -- via ngx.socket.tcp or ngx.socket.udp</span><br><span class="line">            -- (one may want to buffer the data in Lua a bit to</span><br><span class="line">            -- save I/O operations)</span><br><span class="line">        end</span><br><span class="line">        local ok, err = ngx.timer.at(0, push_data,</span><br><span class="line">                                     ngx.var.uri, ngx.var.args, ngx.header.status)</span><br><span class="line">        if not ok then</span><br><span class="line">            ngx.log(ngx.ERR, &quot;failed to create timer: &quot;, err)</span><br><span class="line">            return</span><br><span class="line">        end</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>One can also create infinite re-occurring timers, for instance, a timer getting triggered every <code>5</code> seconds, by calling <code>ngx.timer.at</code> recursively in the timer callback function. Here is such an example,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">local delay = 5</span><br><span class="line">local handler</span><br><span class="line">handler = function (premature)</span><br><span class="line">    -- do some routine job in Lua just like a cron job</span><br><span class="line">    if premature then</span><br><span class="line">        return</span><br><span class="line">    end</span><br><span class="line">    local ok, err = ngx.timer.at(delay, handler)</span><br><span class="line">    if not ok then</span><br><span class="line">        ngx.log(ngx.ERR, &quot;failed to create the timer: &quot;, err)</span><br><span class="line">        return</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">local ok, err = ngx.timer.at(delay, handler)</span><br><span class="line">if not ok then</span><br><span class="line">    ngx.log(ngx.ERR, &quot;failed to create the timer: &quot;, err)</span><br><span class="line">    return</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>It is recommended, however, to use the [ngx.timer.every]</p><p>Because timer callbacks run in the background and their running time will not add to any client request’s response time, they can easily accumulate in the server and exhaust system resources due to either Lua programming mistakes or just too much client traffic. To prevent extreme consequences like crashing the Nginx server, there are built-in limitations on both the number of “pending timers” and the number of “running timers” in an Nginx worker process. The “pending timers” here mean timers that have not yet been expired and “running timers” are those whose user callbacks are currently running.</p><p>The maximal number of pending timers allowed in an Nginx worker is controlled by the [lua_max_pending_timers]</p><p>According to the current implementation, each “running timer” will take one (fake) connection record from the global connection record list configured by the standard <a href="http://nginx.org/en/docs/ngx_core_module.html#worker_connections" target="_blank" rel="noopener">worker_connections</a> directive in <code>nginx.conf</code>. So ensure that the<a href="http://nginx.org/en/docs/ngx_core_module.html#worker_connections" target="_blank" rel="noopener">worker_connections</a> directive is set to a large enough value that takes into account both the real connections and fake connections required by timer callbacks (as limited by the [lua_max_running_timers]</p><p>A lot of the Lua APIs for Nginx are enabled in the context of the timer callbacks, like stream/datagram cosockets ([ngx.socket.tcp]</p><p>You can pass most of the standard Lua values (nils, booleans, numbers, strings, tables, closures, file handles, and etc) into the timer callback, either explicitly as user arguments or implicitly as upvalues for the callback closure. There are several exceptions, however: you <em>cannot</em> pass any thread objects returned by [coroutine.create]</p><p>This API was first introduced in the <code>v0.8.0</code> release.</p><h2><span id="ngxtimerevery">ngx.timer.every</span></h2><p><strong>syntax:</strong> <em>hdl, err = ngx.timer.every(delay, callback, user_arg1, user_arg2, …)</em></p><p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Similar to the [ngx.timer.at]</p><ol><li><code>delay</code> <em>cannot</em> be zero,</li><li>timer will be created every <code>delay</code> seconds until the current Nginx worker process starts exiting.</li></ol><p>When success, returns a “conditional true” value (but not a <code>true</code>). Otherwise, returns a “conditional false” value and a string describing the error.</p><p>This API also respect the [lua_max_pending_timers]</p><p>This API was first introduced in the <code>v0.10.9</code> release.</p><h2><span id="ngxtimerrunning_count">ngx.timer.running_count</span></h2><p><strong>syntax:</strong> <em>count = ngx.timer.running_count()</em></p><p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Returns the number of timers currently running.</p><p>This directive was first introduced in the <code>v0.9.20</code> release.</p><h2><span id="ngxtimerpending_count">ngx.timer.pending_count</span></h2><p><strong>syntax:</strong> <em>count = ngx.timer.pending_count()</em></p><p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Returns the number of pending timers.</p><p>This directive was first introduced in the <code>v0.9.20</code> release.</p><h2><span id="ngxconfigsubsystem">ngx.config.subsystem</span></h2><p><strong>syntax:</strong> <em>subsystem = ngx.config.subsystem</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_by_lua*, init_worker_by_lua*</p><p>This string field indicates the current NGINX subsystem the current Lua environment is based on. For this module, this field always takes the string value <code>&quot;http&quot;</code>. For [ngx_stream_lua_module]</p><p>This field was first introduced in the <code>0.10.1</code>.</p><h2><span id="ngxconfigdebug">ngx.config.debug</span></h2><p><strong>syntax:</strong> <em>debug = ngx.config.debug</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_by_lua*, init_worker_by_lua*</p><p>This boolean field indicates whether the current Nginx is a debug build, i.e., being built by the <code>./configure</code> option <code>--with-debug</code>.</p><p>This field was first introduced in the <code>0.8.7</code>.</p><h2><span id="ngxconfigprefix">ngx.config.prefix</span></h2><p><strong>syntax:</strong> <em>prefix = ngx.config.prefix()</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_by_lua*, init_worker_by_lua*</p><p>Returns the Nginx server “prefix” path, as determined by the <code>-p</code> command-line option when running the nginx executable, or the path specified by the <code>--prefix</code> command-line option when building Nginx with the <code>./configure</code> script.</p><p>This function was first introduced in the <code>0.9.2</code>.</p><h2><span id="ngxconfignginx_version">ngx.config.nginx_version</span></h2><p><strong>syntax:</strong> <em>ver = ngx.config.nginx_version</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_by_lua*, init_worker_by_lua*</p><p>This field take an integral value indicating the version number of the current Nginx core being used. For example, the version number <code>1.4.3</code> results in the Lua number 1004003.</p><p>This API was first introduced in the <code>0.9.3</code> release.</p><h2><span id="ngxconfignginx_configure">ngx.config.nginx_configure</span></h2><p><strong>syntax:</strong> <em>str = ngx.config.nginx_configure()</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_by_lua*</p><p>This function returns a string for the NGINX <code>./configure</code> command’s arguments string.</p><p>This API was first introduced in the <code>0.9.5</code> release.</p><h2><span id="ngxconfigngx_lua_version">ngx.config.ngx_lua_version</span></h2><p><strong>syntax:</strong> <em>ver = ngx.config.ngx_lua_version</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_by_lua*</p><p>This field take an integral value indicating the version number of the current <code>ngx_lua</code> module being used. For example, the version number <code>0.9.3</code> results in the Lua number 9003.</p><p>This API was first introduced in the <code>0.9.3</code> release.</p><h2><span id="ngxworkerexiting">ngx.worker.exiting</span></h2><p><strong>syntax:</strong> <em>exiting = ngx.worker.exiting()</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_by_lua*, init_worker_by_lua*</p><p>This function returns a boolean value indicating whether the current Nginx worker process already starts exiting. Nginx worker process exiting happens on Nginx server quit or configuration reload (aka HUP reload).</p><p>This API was first introduced in the <code>0.9.3</code> release.</p><h2><span id="ngxworkerpid">ngx.worker.pid</span></h2><p><strong>syntax:</strong> <em>pid = ngx.worker.pid()</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_by_lua*, init_worker_by_lua*</p><p>This function returns a Lua number for the process ID (PID) of the current Nginx worker process. This API is more efficient than <code>ngx.var.pid</code> and can be used in contexts where the [ngx.var.VARIABLE]</p><p>This API was first introduced in the <code>0.9.5</code> release.</p><h2><span id="ngxworkercount">ngx.worker.count</span></h2><p><strong>syntax:</strong> <em>count = ngx.worker.count()</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_by_lua*, init_worker_by_lua*</p><p>Returns the total number of the Nginx worker processes (i.e., the value configured by the <a href="http://nginx.org/en/docs/ngx_core_module.html#worker_processes" target="_blank" rel="noopener">worker_processes</a> directive in <code>nginx.conf</code>).</p><p>This API was first introduced in the <code>0.9.20</code> release.</p><h2><span id="ngxworkerid">ngx.worker.id</span></h2><p><strong>syntax:</strong> <em>count = ngx.worker.id()</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_worker_by_lua*</p><p>Returns the ordinal number of the current Nginx worker processes (starting from number 0).</p><p>So if the total number of workers is <code>N</code>, then this method may return a number between 0 and <code>N - 1</code> (inclusive).</p><p>This function returns meaningful values only for NGINX 1.9.1+. With earlier versions of NGINX, it always returns <code>nil</code>.</p><p>See also [ngx.worker.count]</p><p>This API was first introduced in the <code>0.9.20</code> release.</p><h2><span id="ngxsemaphore">ngx.semaphore</span></h2><p><strong>syntax:</strong> <em>local semaphore = require “ngx.semaphore”</em></p><p>This is a Lua module that implements a classic-style semaphore API for efficient synchronizations among different “light threads”. Sharing the same semaphore among different “light threads” created in different (request) contexts are also supported as long as the “light threads” reside in the same NGINX worker process and the [lua_code_cache]</p><p>This Lua module does not ship with this ngx_lua module itself rather it is shipped with the [lua-resty-core]</p><p>Please refer to the [documentation]</p><p>This feature requires at least ngx_lua <code>v0.10.0</code>.</p><h2><span id="ngxbalancer">ngx.balancer</span></h2><p><strong>syntax:</strong> <em>local balancer = require “ngx.balancer”</em></p><p>This is a Lua module that provides a Lua API to allow defining completely dynamic load balancers in pure Lua.</p><p>This Lua module does not ship with this ngx_lua module itself rather it is shipped with the [lua-resty-core]</p><p>Please refer to the [documentation]</p><p>This feature requires at least ngx_lua <code>v0.10.0</code>.</p><h2><span id="ngxssl">ngx.ssl</span></h2><p><strong>syntax:</strong> <em>local ssl = require “ngx.ssl”</em></p><p>This Lua module provides API functions to control the SSL handshake process in contexts like [ssl_certificate_by_lua*]</p><p>This Lua module does not ship with this ngx_lua module itself rather it is shipped with the [lua-resty-core]</p><p>Please refer to the [documentation]</p><p>This feature requires at least ngx_lua <code>v0.10.0</code>.</p><h2><span id="ngxocsp">ngx.ocsp</span></h2><p><strong>syntax:</strong> <em>local ocsp = require “ngx.ocsp”</em></p><p>This Lua module provides API to perform OCSP queries, OCSP response validations, and OCSP stapling planting.</p><p>Usually, this module is used together with the [ngx.ssl]</p><p>This Lua module does not ship with this ngx_lua module itself rather it is shipped with the [lua-resty-core]</p><p>Please refer to the [documentation]</p><p>This feature requires at least ngx_lua <code>v0.10.0</code>.</p><h2><span id="ndkset_vardirective">ndk.set_var.DIRECTIVE</span></h2><p><strong>syntax:</strong> <em>res = ndk.set_var.DIRECTIVE_NAME</em></p><p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>This mechanism allows calling other nginx C modules’ directives that are implemented by [Nginx Devel Kit]</p><p>For example, the following <a href="http://github.com/openresty/set-misc-nginx-module" target="_blank" rel="noopener">set-misc-nginx-module</a> directives can be invoked this way:</p><ul><li><a href="http://github.com/openresty/set-misc-nginx-module#set_quote_sql_str" target="_blank" rel="noopener">set_quote_sql_str</a></li><li><a href="http://github.com/openresty/set-misc-nginx-module#set_quote_pgsql_str" target="_blank" rel="noopener">set_quote_pgsql_str</a></li><li><a href="http://github.com/openresty/set-misc-nginx-module#set_quote_json_str" target="_blank" rel="noopener">set_quote_json_str</a></li><li><a href="http://github.com/openresty/set-misc-nginx-module#set_unescape_uri" target="_blank" rel="noopener">set_unescape_uri</a></li><li><a href="http://github.com/openresty/set-misc-nginx-module#set_escape_uri" target="_blank" rel="noopener">set_escape_uri</a></li><li><a href="http://github.com/openresty/set-misc-nginx-module#set_encode_base32" target="_blank" rel="noopener">set_encode_base32</a></li><li><a href="http://github.com/openresty/set-misc-nginx-module#set_decode_base32" target="_blank" rel="noopener">set_decode_base32</a></li><li><a href="http://github.com/openresty/set-misc-nginx-module#set_encode_base64" target="_blank" rel="noopener">set_encode_base64</a></li><li><a href="http://github.com/openresty/set-misc-nginx-module#set_decode_base64" target="_blank" rel="noopener">set_decode_base64</a></li><li><a href="http://github.com/openresty/set-misc-nginx-module#set_encode_base64" target="_blank" rel="noopener">set_encode_hex</a></li><li><a href="http://github.com/openresty/set-misc-nginx-module#set_decode_base64" target="_blank" rel="noopener">set_decode_hex</a></li><li><a href="http://github.com/openresty/set-misc-nginx-module#set_encode_base64" target="_blank" rel="noopener">set_sha1</a></li><li><a href="http://github.com/openresty/set-misc-nginx-module#set_decode_base64" target="_blank" rel="noopener">set_md5</a></li></ul><p>For instance,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local res = ndk.set_var.set_escape_uri(&apos;a/b&apos;);</span><br><span class="line">-- now res == &apos;a%2fb&apos;</span><br></pre></td></tr></table></figure><p>Similarly, the following directives provided by <a href="http://github.com/openresty/encrypted-session-nginx-module" target="_blank" rel="noopener">encrypted-session-nginx-module</a> can be invoked from within Lua too:</p><ul><li><a href="http://github.com/openresty/encrypted-session-nginx-module#set_encrypt_session" target="_blank" rel="noopener">set_encrypt_session</a></li><li><a href="http://github.com/openresty/encrypted-session-nginx-module#set_decrypt_session" target="_blank" rel="noopener">set_decrypt_session</a></li></ul><p>This feature requires the [ngx_devel_kit]</p><h2><span id="coroutinecreate">coroutine.create</span></h2><p><strong>syntax:</strong> <em>co = coroutine.create(f)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, init_by_lua*, ngx.timer.*, header_filter_by_lua*, body_filter_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Creates a user Lua coroutines with a Lua function, and returns a coroutine object.</p><p>Similar to the standard Lua <a href="http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.create" target="_blank" rel="noopener">coroutine.create</a> API, but works in the context of the Lua coroutines created by ngx_lua.</p><p>This API was first usable in the context of [init_by_lua*]</p><p>This API was first introduced in the <code>v0.6.0</code> release.</p><h2><span id="coroutineresume">coroutine.resume</span></h2><p><strong>syntax:</strong> <em>ok, … = coroutine.resume(co, …)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, init_by_lua*, ngx.timer.*, header_filter_by_lua*, body_filter_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Resumes the executation of a user Lua coroutine object previously yielded or just created.</p><p>Similar to the standard Lua <a href="http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.resume" target="_blank" rel="noopener">coroutine.resume</a> API, but works in the context of the Lua coroutines created by ngx_lua.</p><p>This API was first usable in the context of [init_by_lua*]</p><p>This API was first introduced in the <code>v0.6.0</code> release.</p><h2><span id="coroutineyield">coroutine.yield</span></h2><p><strong>syntax:</strong> <em>… = coroutine.yield(…)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, init_by_lua*, ngx.timer.*, header_filter_by_lua*, body_filter_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Yields the execution of the current user Lua coroutine.</p><p>Similar to the standard Lua <a href="http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.yield" target="_blank" rel="noopener">coroutine.yield</a> API, but works in the context of the Lua coroutines created by ngx_lua.</p><p>This API was first usable in the context of [init_by_lua*]</p><p>This API was first introduced in the <code>v0.6.0</code> release.</p><h2><span id="coroutinewrap">coroutine.wrap</span></h2><p><strong>syntax:</strong> <em>co = coroutine.wrap(f)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, init_by_lua*, ngx.timer.*, header_filter_by_lua*, body_filter_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Similar to the standard Lua <a href="http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.wrap" target="_blank" rel="noopener">coroutine.wrap</a> API, but works in the context of the Lua coroutines created by ngx_lua.</p><p>This API was first usable in the context of [init_by_lua*]</p><p>This API was first introduced in the <code>v0.6.0</code> release.</p><h2><span id="coroutinerunning">coroutine.running</span></h2><p><strong>syntax:</strong> <em>co = coroutine.running()</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, init_by_lua*, ngx.timer.*, header_filter_by_lua*, body_filter_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Identical to the standard Lua <a href="http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.running" target="_blank" rel="noopener">coroutine.running</a> API.</p><p>This API was first usable in the context of [init_by_lua*]</p><p>This API was first enabled in the <code>v0.6.0</code> release.</p><h2><span id="coroutinestatus">coroutine.status</span></h2><p><strong>syntax:</strong> <em>status = coroutine.status(co)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, init_by_lua*, ngx.timer.*, header_filter_by_lua*, body_filter_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Identical to the standard Lua <a href="http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.status" target="_blank" rel="noopener">coroutine.status</a> API.</p><p>This API was first usable in the context of [init_by_lua*]</p><p>This API was first enabled in the <code>v0.6.0</code> release.</p><p>##</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#nginx-api-for-lua&quot;&gt;Nginx API for Lua&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#introduction&quot;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx+Lua=OpenResty</title>
    <link href="http://yoursite.com/2018/02/28/Nginx-Lua-OpenResty/"/>
    <id>http://yoursite.com/2018/02/28/Nginx-Lua-OpenResty/</id>
    <published>2018-02-28T08:23:27.000Z</published>
    <updated>2019-03-01T06:26:01.525Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="openresty">openresty</span></h1><h2><span id="应用场景">应用场景</span></h2><p>理论上可以使用ngx_lua开发各种复杂的web应用，不过lua是一种脚本/动态语言，不适合业务逻辑比较重的场景，适合小巧的应用场景，代码行数保持在几十行到几千行。目前见到的一些应用场景有：</p><ul><li>web应用：进行一些业务逻辑的处理，模板渲染，一般流程：mysql/redis/http获取数据-&gt;业务处理-&gt;产生JSON/XML/模板渲染内容，比如京东的列表页/商品详情页；</li><li>接入网关：实现如数据校验前置、缓存前置、数据过滤、API请求聚合、AB测试、灰度发布、降级、监控等功能，比如京东的交易大Nginx节点、无线网关、实时价格、动态服务；</li><li>Web防火墙：可以进行IP/URL/UserAgent/Referer黑名单、限流功能；</li><li>缓存服务器：可以对响应内容进行缓存，减少到后端的请求，从而提高性能；</li><li>其他：如静态资源服务器、消息推送服务、缩略图裁剪等</li></ul><h2><span id="location">location</span></h2><h3><span id="内部调用">内部调用</span></h3><p>对数据库、内部公共函数的统一接口，可以把它们放到统一的location中。</p><p>为了保护这些内部接口，都会把这些接口设置为internal。这么做的好处是可以让这个内部接口相对独立，不受外界干扰。</p><p><em>ngx.say()是怎么调用的？</em></p><p><em>这是个API，供lua调用。那这个api的定义和实现都在哪里呢？</em></p><p>示例代码：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">location = /sum &#123;</span><br><span class="line">    # 只允许内部调用</span><br><span class="line">    internal;</span><br><span class="line"></span><br><span class="line">    # 这里做了一个求和运算只是一个例子，可以在这里完成一些数据库、</span><br><span class="line">    # 缓存服务器的操作，达到基础模块和业务逻辑分离目的</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        <span class="keyword">local</span> args = ngx.req.get_uri_args()</span><br><span class="line">        # ngx.say 打印到response body并换行</span><br><span class="line">        ngx.say(<span class="built_in">tonumber</span>(args.a) + <span class="built_in">tonumber</span>(args.b))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location = /app/test &#123;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        <span class="keyword">local</span> res = ngx.location.capture(</span><br><span class="line">                        <span class="string">"/sum"</span>, &#123;args=&#123;a=<span class="number">3</span>, b=<span class="number">8</span>&#125;&#125;</span><br><span class="line">                        )</span><br><span class="line">        ngx.say(<span class="string">"status:"</span>, res.<span class="built_in">status</span>, <span class="string">" response:"</span>, res.body)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[root@geek work]# curl localhost/app/test</span><br><span class="line"><span class="built_in">status</span>:<span class="number">200</span>response:<span class="number">11</span></span><br></pre></td></tr></table></figure><p>并行请求的效果，示例如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">location = /sum &#123;</span><br><span class="line">    internal;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        ngx.sleep(<span class="number">0.1</span>)</span><br><span class="line">        <span class="keyword">local</span> args = ngx.req.get_uri_args()</span><br><span class="line">        ngx.<span class="built_in">print</span>(<span class="built_in">tonumber</span>(args.a) + <span class="built_in">tonumber</span>(args.b))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location = /subduction &#123;</span><br><span class="line">    internal;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        ngx.sleep(<span class="number">0.1</span>)</span><br><span class="line">        <span class="keyword">local</span> args = ngx.req.get_uri_args()</span><br><span class="line">        ngx.<span class="built_in">print</span>(<span class="built_in">tonumber</span>(args.a) - <span class="built_in">tonumber</span>(args.b))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location = /app/test_parallels &#123;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        <span class="keyword">local</span> start_time = ngx.now()</span><br><span class="line">        <span class="keyword">local</span> res1, res2 = ngx.location.capture_multi( &#123;</span><br><span class="line">                        &#123;<span class="string">"/sum"</span>, &#123;args=&#123;a=<span class="number">3</span>, b=<span class="number">8</span>&#125;&#125;&#125;,</span><br><span class="line">                        &#123;<span class="string">"/subduction"</span>, &#123;args=&#123;a=<span class="number">3</span>, b=<span class="number">8</span>&#125;&#125;&#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">        ngx.say(<span class="string">"status:"</span>, res1.<span class="built_in">status</span>, <span class="string">" response:"</span>, res1.body)</span><br><span class="line">        ngx.say(<span class="string">"status:"</span>, res2.<span class="built_in">status</span>, <span class="string">" response:"</span>, res2.body)</span><br><span class="line">        ngx.say(<span class="string">"time used:"</span>, ngx.now() - start_time)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location = /app/test_queue &#123;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        <span class="keyword">local</span> start_time = ngx.now()</span><br><span class="line">        <span class="keyword">local</span> res1 = ngx.location.capture_multi( &#123;</span><br><span class="line">                        &#123;<span class="string">"/sum"</span>, &#123;args=&#123;a=<span class="number">3</span>, b=<span class="number">8</span>&#125;&#125;&#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">        <span class="keyword">local</span> res2 = ngx.location.capture_multi( &#123;</span><br><span class="line">                        &#123;<span class="string">"/subduction"</span>, &#123;args=&#123;a=<span class="number">3</span>, b=<span class="number">8</span>&#125;&#125;&#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">        ngx.say(<span class="string">"status:"</span>, res1.<span class="built_in">status</span>, <span class="string">" response:"</span>, res1.body)</span><br><span class="line">        ngx.say(<span class="string">"status:"</span>, res2.<span class="built_in">status</span>, <span class="string">" response:"</span>, res2.body)</span><br><span class="line">        ngx.say(<span class="string">"time used:"</span>, ngx.now() - start_time)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 测试结果</span><br><span class="line">➜  ~ curl <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>/app/test_parallels</span><br><span class="line"><span class="built_in">status</span>:<span class="number">200</span> response:<span class="number">11</span></span><br><span class="line"><span class="built_in">status</span>:<span class="number">200</span> response:<span class="number">-5</span></span><br><span class="line"><span class="built_in">time</span> used:<span class="number">0.10099983215332</span></span><br><span class="line">➜  ~ curl <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>/app/test_queue</span><br><span class="line"><span class="built_in">status</span>:<span class="number">200</span> response:<span class="number">11</span></span><br><span class="line"><span class="built_in">status</span>:<span class="number">200</span> response:<span class="number">-5</span></span><br><span class="line"><span class="built_in">time</span> used:<span class="number">0.20199990272522</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;openresty&quot;&gt;openresty&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span id=&quot;应用场景&quot;&gt;应用场景&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;理论上可以使用ngx_lua开发各种复杂的web应用，不过lua是一种脚本/动态语言，不适合业务逻辑比较重的场
      
    
    </summary>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>深入剖析Nginx</title>
    <link href="http://yoursite.com/2018/02/26/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Nginx/"/>
    <id>http://yoursite.com/2018/02/26/深入剖析Nginx/</id>
    <published>2018-02-26T08:29:57.000Z</published>
    <updated>2019-02-28T00:48:00.919Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#跟踪和调试">跟踪和调试</a><ul><li><a href="#利用gdb调试">利用gdb调试</a></li><li><a href="#利用stracepstack调试nginx">利用strace/pstack调试Nginx</a></li><li><a href="#获得nginx完整执行流程">获得Nginx完整执行流程</a></li><li><a href="#加桩调试">加桩调试</a></li><li><a href="#特殊应用逻辑的调试">特殊应用逻辑的调试</a></li></ul></li><li><a href="#进程模型">进程模型</a><ul><li><a href="#整体架构">整体架构</a></li><li><a href="#核心进程模型">核心进程模型</a><ul><li><a href="#master进程">master进程</a></li><li><a href="#工作进程">工作进程</a></li><li><a href="#cache进程模型">Cache进程模型</a></li><li><a href="#cache管理进程">Cache管理进程</a></li><li><a href="#cache加载进程">Cache加载进程</a></li></ul></li><li><a href="#进程通信">进程通信</a></li><li><a href="#共享内存">共享内存</a></li><li><a href="#slab机制">slab机制</a></li><li><a href="#信号处理">信号处理</a></li><li><a href="#准备工作">准备工作</a></li><li><a href="#设置生效">设置生效</a></li><li><a href="#处理实例">处理实例</a></li></ul></li><li><a href="#数据结构">数据结构</a><ul><li><a href="#内存池">内存池</a></li><li><a href="#hash">Hash</a></li><li><a href="#radix-tree">Radix tree</a></li></ul></li><li><a href="#配置解析">配置解析</a><ul><li><a href="#配置文件格式">配置文件格式</a></li><li><a href="#配置项目解析准备">配置项目解析准备</a></li><li><a href="#配置文件解析流程">配置文件解析流程</a></li><li><a href="#配置信息组织结构">配置信息组织结构</a></li><li><a href="#配置信息的继承">配置信息的继承</a></li></ul></li><li><a href="#模块综述">模块综述</a><ul><li><a href="#handler模块">Handler模块</a></li><li><a href="#filter模块">Filter模块</a></li><li><a href="#upstream模块">Upstream模块</a></li><li><a href="#load-balance模块">Load balance模块</a></li></ul></li><li><a href="#事件管理机制">事件管理机制</a><ul><li><a href="#io多路复用模型">IO多路复用模型</a></li><li><a href="#epoll模型">epoll模型</a></li><li><a href="#事件处理">事件处理</a></li><li><a href="#负载均衡">负载均衡</a></li><li><a href="#客户端请求均衡">客户端请求均衡</a></li><li><a href="#多核绑定">多核绑定</a></li><li><a href="#超时管理">超时管理</a></li></ul></li><li><a href="#变量机制">变量机制</a></li><li><a href="#请求处理与响应">请求处理与响应</a></li><li><a href="#请求定位">请求定位</a></li><li><a href="#动态页面请求处理">动态页面请求处理</a></li><li><a href="#过滤模块负载均衡访问控制">过滤模块负载均衡访问控制</a></li></ul><!-- tocstop --><h1><span id="跟踪和调试">跟踪和调试</span></h1><h2><span id="利用gdb调试">利用gdb调试</span></h2><ul><li><p>绑定Nginx到gdb</p><p><code>./configure --with-cc-opt=&#39;-g -O0&#39;</code></p><p>or</p><p><code>CFLAGS=&quot;-g -O0&quot; ./configure</code></p></li></ul><h2><span id="利用stracepstack调试nginx">利用strace/pstack调试Nginx</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@geek example]# ps -ef | grep nginx</span><br><span class="line">root      8971     1  0 2月26 ?       00:00:00 nginx: master process objs</span><br><span class="line">nobody    8972  8971  0 2月26 ?       00:00:00 nginx: worker process</span><br><span class="line">root     14396 12063  0 01:12 pts/1    00:00:00 grep --color=auto nginx</span><br><span class="line">[root@geek example]# strace -p 8972</span><br><span class="line">strace: Process 8972 attached</span><br><span class="line">epoll_wait(8,</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@geek example]# wget 127.0.0.1:8080</span><br><span class="line">--2019-02-27 01:12:54--  http://127.0.0.1:8080/</span><br><span class="line">正在连接 127.0.0.1:8080... 已连接。</span><br><span class="line">已发出 HTTP 请求，正在等待回应... 200 OK</span><br><span class="line">长度：612 [text/html]</span><br><span class="line">正在保存至: “index.html”</span><br><span class="line"></span><br><span class="line">100%[===============================&gt;] 612         --.-K/s 用时 0.004s</span><br><span class="line"></span><br><span class="line">2019-02-27 01:12:54 (167 KB/s) - 已保存 “index.html” [612/612])</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[root@geek example]<span class="meta"># strace -p 8972</span></span><br><span class="line">strace: Process <span class="number">8972</span> attached</span><br><span class="line">epoll_wait(<span class="number">8</span>, [&#123;EPOLLIN, &#123;u32=<span class="number">1462673424</span>, u64=<span class="number">139776878354448</span>&#125;&#125;], <span class="number">512</span>, <span class="number">-1</span>) = <span class="number">1</span></span><br><span class="line">    <span class="comment">// 返回值为1，表示有1个描述符存在可读/写事件，这里是可读事件</span></span><br><span class="line">accept4(<span class="number">6</span>, &#123;sa_family=AF_INET, sin_port=htons(<span class="number">44738</span>), </span><br><span class="line">sin_addr=inet_addr(<span class="string">"127.0.0.1"</span>)&#125;, [<span class="number">16</span>], SOCK_NONBLOCK) = <span class="number">3</span></span><br><span class="line">    <span class="comment">// 接受该请求，返回的数字3表示socket的文件描述符</span></span><br><span class="line">epoll_ctl(<span class="number">8</span>, EPOLL_CTL_ADD, <span class="number">3</span>, &#123;EPOLLIN|EPOLLRDHUP|EPOLLET, &#123;u32=<span class="number">1462673872</span>, u64=<span class="number">139776878354896</span>&#125;&#125;) = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 把accept4建立的socket套接字（参数3）加入到事件监听机制里</span></span><br><span class="line">epoll_wait(<span class="number">8</span>, [&#123;EPOLLIN, &#123;u32=<span class="number">1462673872</span>, u64=<span class="number">139776878354896</span>&#125;&#125;], <span class="number">512</span>, <span class="number">60000</span>) = <span class="number">1</span></span><br><span class="line">recvfrom(<span class="number">3</span>, <span class="string">"GET / HTTP/1.1\r\nUser-Agent: Wget"</span>..., <span class="number">1024</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>) = <span class="number">112</span></span><br><span class="line">    <span class="comment">// 从发生可读事件的socket文件描述符内读取数据，读取的数据存在第二个参数内，读取了112个字节</span></span><br><span class="line">stat(<span class="string">"/usr/local/nginx/html/index.html"</span>, &#123;st_mode=S_IFREG|<span class="number">0644</span>, st_size=<span class="number">612</span>, ...&#125;) = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 判断客户端请求的html文件是否存在，返回值0表示存在</span></span><br><span class="line">open(<span class="string">"/usr/local/nginx/html/index.html"</span>, O_RDONLY|O_NONBLOCK) = <span class="number">10</span></span><br><span class="line">fstat(<span class="number">10</span>, &#123;st_mode=S_IFREG|<span class="number">0644</span>, st_size=<span class="number">612</span>, ...&#125;) = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 打开并获取文件状态信息</span></span><br><span class="line">writev(<span class="number">3</span>, [&#123;<span class="string">"HTTP/1.1 200 OK\r\nServer: nginx/1"</span>..., <span class="number">238</span>&#125;], <span class="number">1</span>) = <span class="number">238</span></span><br><span class="line">    <span class="comment">// 把响应头通过文件描述符3代表的socket套接字发给客户端</span></span><br><span class="line">sendfile(<span class="number">3</span>, <span class="number">10</span>, [<span class="number">0</span>] =&gt; [<span class="number">612</span>], <span class="number">612</span>)      = <span class="number">612</span></span><br><span class="line">    <span class="comment">// 把文件描述符10代表的响应体通过文件描述符3代表的socket套接字发给客户端</span></span><br><span class="line">write(<span class="number">4</span>, <span class="string">"127.0.0.1 - - [27/Feb/2019:01:12"</span>..., <span class="number">104</span>) = <span class="number">104</span></span><br><span class="line">    <span class="comment">// 往文件描述符4代表的日志文件内write一条日志信息</span></span><br><span class="line">close(<span class="number">10</span>)                               = <span class="number">0</span></span><br><span class="line">setsockopt(<span class="number">3</span>, SOL_TCP, TCP_NODELAY, [<span class="number">1</span>], <span class="number">4</span>) = <span class="number">0</span></span><br><span class="line">epoll_wait(<span class="number">8</span>, [&#123;EPOLLIN|EPOLLRDHUP, &#123;u32=<span class="number">1462673872</span>, u64=<span class="number">139776878354896</span>&#125;&#125;], <span class="number">512</span>, <span class="number">65000</span>) = <span class="number">1</span></span><br><span class="line">recvfrom(<span class="number">3</span>, <span class="string">""</span>, <span class="number">1024</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>)    = <span class="number">0</span></span><br><span class="line">close(<span class="number">3</span>)                                = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 最后，关闭文件描述符3代表的socket套接字</span></span><br><span class="line">epoll_wait(<span class="number">8</span>,</span><br></pre></td></tr></table></figure><p>由于strace能够提供Nginx执行过程中的这些内部信息，所以在出现一些奇怪现象时，比如Nginx启动失败、响应的文件数据和预期不一致、莫名其妙的Segmentation Fault段错误、存在性能瓶颈（利用-T选项跟踪各个函数的消耗时间），利用strace也许能提供一些相关帮助。</p><p>想知道Nginx当前内部到底在执行什么函数，可使用pstack。</p><p>比如在无客户端请求的情况下，Nginx阻塞在epoll_wait系统调用处，此时利用pstack查看Nginx函数调用栈关系，如下所示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@geek example]<span class="meta"># pstack 8972</span></span><br><span class="line">#<span class="number">0</span>  <span class="number">0x00007f205637d463</span> in __epoll_wait_nocancel () from /lib64/libc.so<span class="number">.6</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x000000000044c1eb</span> <span class="function">in <span class="title">ngx_epoll_process_events</span> <span class="params">(cycle=<span class="number">0x1eaf0c0</span>,</span></span></span><br><span class="line">    timer=18446744073709551615, flags=1) at src/event/modules/ngx_epoll_module.c:800</span><br><span class="line">#<span class="number">2</span>  <span class="number">0x000000000043ddb6</span> in ngx_process_events_and_timers </span><br><span class="line">        (cycle=<span class="number">0x1eaf0c0</span>) at src/event/ngx_event.c:<span class="number">242</span></span><br><span class="line">#<span class="number">3</span>  <span class="number">0x000000000044a0b8</span> <span class="function">in <span class="title">ngx_worker_process_cycle</span> <span class="params">(cycle=<span class="number">0x1eaf0c0</span>, </span></span></span><br><span class="line">        data=0x0) at src/os/unix/ngx_process_cycle.c:750</span><br><span class="line">#<span class="number">4</span>  <span class="number">0x0000000000446f87</span> <span class="function">in <span class="title">ngx_spawn_process</span> <span class="params">(cycle=<span class="number">0x1eaf0c0</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">            proc=<span class="number">0x44a00a</span> &lt;ngx_worker_process_cycle&gt;, data=<span class="number">0x0</span>, name=<span class="number">0x4cacd0</span></span></span></span><br><span class="line">            "worker process", respawn=-3) at src/os/unix/ngx_process.c:199</span><br><span class="line">#<span class="number">5</span>  <span class="number">0x00000000004492e9</span> in ngx_start_worker_processes </span><br><span class="line">     (cycle=<span class="number">0x1eaf0c0</span>, n=<span class="number">1</span>, type=<span class="number">-3</span>) at src/os/unix/ngx_process_cycle.c:<span class="number">359</span></span><br><span class="line">#<span class="number">6</span>  <span class="number">0x0000000000448a49</span> in ngx_master_process_cycle </span><br><span class="line">                (cycle=<span class="number">0x1eaf0c0</span>) at src/os/unix/ngx_process_cycle.c:<span class="number">131</span></span><br><span class="line">#<span class="number">7</span>  <span class="number">0x000000000040ba0a</span> <span class="function">in <span class="title">main</span> <span class="params">(argc=<span class="number">1</span>, argv=<span class="number">0x7ffdcc4edf68</span>)</span> at</span></span><br><span class="line">           src/core/nginx.c:382</span><br></pre></td></tr></table></figure><p>从main()函数到epoll_wait()函数的调用关系一目了然。</p><h2><span id="获得nginx完整执行流程">获得Nginx完整执行流程</span></h2><p>参照<a href="https://jeychu.github.io/2019/02/27/如何追踪函数的完整调用过程/" target="_blank" rel="noopener">如何追踪函数的完整调用过程</a>中使用gdb的方法，来获取Nginx完整的执行流程。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@geek ~]# readelf -s /root/nginx-1.14.2/objs/nginx  | gawk &apos; &#123;    </span><br><span class="line">if($4 == &quot;FUNC&quot; &amp;&amp; $2 != 0) &#123; </span><br><span class="line">  print &quot;# code for &quot; $NF;</span><br><span class="line">  print &quot;b *0x&quot; $2;</span><br><span class="line">  print &quot;commands&quot;;</span><br><span class="line">  print &quot;silent&quot;;   </span><br><span class="line">  print &quot;bt 1&quot;;</span><br><span class="line">  print &quot;c&quot;;</span><br><span class="line">  print &quot;end&quot;;     </span><br><span class="line">  print &quot;&quot;;    </span><br><span class="line">&#125;  </span><br><span class="line">&#125;&apos; &gt; ngsym;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[root@geek ~]# cat ngsym</span><br><span class="line"># code for ngx_http_upstream_free_ro</span><br><span class="line">b *0x0000000000480aea</span><br><span class="line">commands</span><br><span class="line">silent</span><br><span class="line">bt 1</span><br><span class="line">c</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"># code for ngx_http_test_content_typ</span><br><span class="line">b *0x0000000000452bb8</span><br><span class="line">commands</span><br><span class="line">silent</span><br><span class="line">bt 1</span><br><span class="line">c</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"># code for ngx_libc_crypt</span><br><span class="line">b *0x00000000004485b4</span><br><span class="line">commands</span><br><span class="line">silent</span><br><span class="line">bt 1</span><br><span class="line">c</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"># code for ngx_timezone_update</span><br><span class="line">b *0x00000000004438f2</span><br><span class="line">commands</span><br><span class="line">silent</span><br><span class="line">bt 1</span><br><span class="line">c</span><br><span class="line">end</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@geek ~]# gdb --command=ngsym nginx-1.14.2/objs/nginx -q</span><br></pre></td></tr></table></figure><p>进入gdb交互界面，输入r，执行命令，就可以获得Nginx完整的执行流程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@geek ~]# gdb --command=ngsym nginx-1.14.2/objs/nginx -q | tee nginx_flow</span><br></pre></td></tr></table></figure><p>可将输出重定向到<a href="https://github.com/jeychu/nginx-deepin" target="_blank" rel="noopener">nginx_flow</a>文件中。</p><h2><span id="加桩调试">加桩调试</span></h2><p>为了让一个模块执行起来，额外添加一些支撑的代码，称为加桩。</p><p>Nginx很多的基础实现（比如slab机制、红黑树、chain链、array数组等）都比较独立，要调试它们需提供少量的桩代码进行加桩测试。</p><p>以slab为例。</p><h2><span id="特殊应用逻辑的调试">特殊应用逻辑的调试</span></h2><h1><span id="进程模型">进程模型</span></h1><h2><span id="整体架构">整体架构</span></h2><p><img src="/2018/02/26/深入剖析Nginx/1551226860880.png" alt="1551226860880"></p><h2><span id="核心进程模型">核心进程模型</span></h2><p><img src="/2018/02/26/深入剖析Nginx/1551227609447.png" alt="1551227609447"></p><h3><span id="master进程">master进程</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// src/os/unix/ngx_process_cycle.c</span><br><span class="line">void</span><br><span class="line">ngx_master_process_cycle(ngx_cycle_t *cycle)&#123;</span><br><span class="line">    ...</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        ...</span><br><span class="line">        sigsuspend(&amp;set);</span><br><span class="line">        ...</span><br><span class="line">        if (ngx_reap)&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        if (!live &amp;&amp; (ngx_terminate || ngx_quit)) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        if (ngx_terminate) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        if (ngx_quit) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>master进程的无限for(;;)循环内有一个关键的四个suspend()函数调用，该函数使得master大部分时间处于挂起等待状态，直到master接收到信号为止。</p><h3><span id="工作进程">工作进程</span></h3><h3><span id="cache进程模型">Cache进程模型</span></h3><h3><span id="cache管理进程">Cache管理进程</span></h3><h3><span id="cache加载进程">Cache加载进程</span></h3><h2><span id="进程通信">进程通信</span></h2><h2><span id="共享内存">共享内存</span></h2><h2><span id="slab机制">slab机制</span></h2><h2><span id="信号处理">信号处理</span></h2><h2><span id="准备工作">准备工作</span></h2><h2><span id="设置生效">设置生效</span></h2><h2><span id="处理实例">处理实例</span></h2><h1><span id="数据结构">数据结构</span></h1><h2><span id="内存池">内存池</span></h2><h2><span id="hash">Hash</span></h2><h2><span id="radix-tree">Radix tree</span></h2><h1><span id="配置解析">配置解析</span></h1><h2><span id="配置文件格式">配置文件格式</span></h2><h2><span id="配置项目解析准备">配置项目解析准备</span></h2><h2><span id="配置文件解析流程">配置文件解析流程</span></h2><h2><span id="配置信息组织结构">配置信息组织结构</span></h2><h2><span id="配置信息的继承">配置信息的继承</span></h2><h1><span id="模块综述">模块综述</span></h1><h2><span id="handler模块">Handler模块</span></h2><h2><span id="filter模块">Filter模块</span></h2><h2><span id="upstream模块">Upstream模块</span></h2><h2><span id="load-balance模块">Load balance模块</span></h2><h1><span id="事件管理机制">事件管理机制</span></h1><h2><span id="io多路复用模型">IO多路复用模型</span></h2><h2><span id="epoll模型">epoll模型</span></h2><h2><span id="事件处理">事件处理</span></h2><h2><span id="负载均衡">负载均衡</span></h2><h2><span id="客户端请求均衡">客户端请求均衡</span></h2><h2><span id="多核绑定">多核绑定</span></h2><h2><span id="超时管理">超时管理</span></h2><h1><span id="变量机制">变量机制</span></h1><h1><span id="请求处理与响应">请求处理与响应</span></h1><h1><span id="请求定位">请求定位</span></h1><h1><span id="动态页面请求处理">动态页面请求处理</span></h1><h1><span id="过滤模块负载均衡访问控制">过滤模块负载均衡访问控制</span></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#跟踪和调试&quot;&gt;跟踪和调试&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#利用gdb调试&quot;&gt;利用gdb调试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#利用stracepstack调试nginx&quot;&gt;利用strace/p
      
    
    </summary>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>亿级流量详情页开发</title>
    <link href="http://yoursite.com/2018/02/25/%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F%E8%AF%A6%E6%83%85%E9%A1%B5%E5%BC%80%E5%8F%91/"/>
    <id>http://yoursite.com/2018/02/25/亿级流量详情页开发/</id>
    <published>2018-02-25T05:28:39.000Z</published>
    <updated>2019-02-28T00:47:53.320Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>持续交付</title>
    <link href="http://yoursite.com/2018/02/23/%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98/"/>
    <id>http://yoursite.com/2018/02/23/持续交付/</id>
    <published>2018-02-23T07:46:12.000Z</published>
    <updated>2019-03-01T06:26:40.915Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#持续交付的价值">持续交付的价值</a><ul><li><a href="#持续交付的定义">持续交付的定义</a></li><li><a href="#持续集成-持续交付和持续部署的关系">持续集成、持续交付和持续部署的关系</a></li><li><a href="#持续交付的显性价值">持续交付的显性价值</a></li><li><a href="#持续交付的隐性价值">持续交付的隐性价值</a></li><li><a href="#如何评估持续交付的价值">如何评估持续交付的价值</a></li></ul></li><li><a href="#影响持续交付的因素">影响持续交付的因素</a><ul><li><a href="#组织和文化因素">组织和文化因素</a></li><li><a href="#代码分支策略的选择">代码分支策略的选择</a><ul><li><a href="#主干开发tbd">主干开发（TBD）</a></li><li><a href="#特性分支开发">特性分支开发</a></li></ul></li></ul></li><li><a href="#依赖管理">依赖管理</a></li><li><a href="#代码回滚">代码回滚</a><ul><li><a href="#什么是代码回滚">什么是代码回滚？</a></li><li><a href="#哪些情况下需要回滚代码">哪些情况下需要回滚代码？</a></li><li><a href="#哪些情况下包的回滚无需回滚代码">哪些情况下包的回滚无需回滚代码？</a></li><li><a href="#代码回滚必须遵循的原则">代码回滚必须遵循的原则</a></li><li><a href="#三种典型回滚场景及回滚策略">三种典型回滚场景及回滚策略</a></li></ul></li><li><a href="#测试环境">测试环境</a><ul><li><a href="#互联网公司测试环境的结构">互联网公司测试环境的结构</a></li><li><a href="#什么是好的测试环境">什么是好的测试环境？</a></li><li><a href="#测试环境的成本">测试环境的成本</a></li><li><a href="#如何调节效率和成本的矛盾">如何调节效率和成本的矛盾？</a></li></ul></li><li><a href="#环境自描性">环境自描性</a><ul><li><a href="#环境一定要标准化">环境一定要标准化</a></li><li><a href="#约定大于配置">约定大于配置</a></li><li><a href="#让环境自己能开口说话">让环境自己能开口说话</a></li></ul></li><li><a href="#各种配置方法">各种配置方法</a></li><li><a href="#分钟级搭建环境">分钟级搭建环境</a><ul><li><a href="#环境构建流水线">环境构建流水线</a></li></ul></li><li><a href="#构建提速">构建提速</a></li><li><a href="#发布">发布</a><ul><li><a href="#发布是持续交付的最后一公里">发布是持续交付的最后一公里</a></li><li><a href="#任何变更都需要发布">任何变更都需要发布</a></li><li><a href="#发布系统一定要注意用户体验">发布系统一定要注意用户体验</a></li><li><a href="#发布系统的核心架构和功能设计">发布系统的核心架构和功能设计</a></li></ul></li><li><a href="#利用监控保障发布质量">利用监控保障发布质量</a></li><li><a href="#代码静态检查">代码静态检查</a></li><li><a href="#破坏性测试">破坏性测试</a></li><li><a href="#自动化回归">自动化回归</a></li><li><a href="#平台化设计持续交付">平台化设计持续交付</a></li><li><a href="#持续交付中的宝贵数据">持续交付中的宝贵数据</a></li><li><a href="#移动app的持续交付生命周期">移动APP的持续交付生命周期</a></li><li><a href="#快速构建持续交付系统">快速构建持续交付系统</a><ul><li><a href="#需求分析">需求分析</a><ul><li><a href="#模拟团队介绍">模拟团队介绍</a></li><li><a href="#模拟系统介绍">模拟系统介绍</a></li></ul></li><li><a href="#gitlab解决代码管理问题">Gitlab解决代码管理问题</a></li><li><a href="#jenkins解决集成打包问题">Jenkins解决集成打包问题</a></li><li><a href="#ansible解决自动部署问题">Ansible解决自动部署问题</a></li></ul></li></ul><!-- tocstop --><h1><span id="持续交付的价值">持续交付的价值</span></h1><h2><span id="持续交付的定义">持续交付的定义</span></h2><blockquote><p>持续交付是软件研发人员，如何将一个好点子，以最快的速度交付给用户的方法。</p><p>From 《持续交付：发布可靠软件的系统方法》</p></blockquote><h2><span id="持续集成-持续交付和持续部署的关系">持续集成、持续交付和持续部署的关系</span></h2><p>我们通常会把软件研发工作拆解，拆分成不同模块或不同团队后进行编码，编码完成后，进行集成构建和测试。这个从编码到构建再到测试的反复持续的过程，就叫做“持续集成”。</p><p>“持续集成”一旦完成，则代表产品处于一个可交付的状态，但并不代表这是最优状态，还需要根据外部使用者的反馈逐步优化。当然这里的使用者并不一定是真正的用户，还可能是测试人员、产品人员、用户体验工程师、安全工程师、企业领导等等。</p><p>这个“持续集成”之后，获取外部对软件的反馈再通过“持续集成”进行优化的过程就叫做“持续交付”，它是“持续集成”的自然延续。</p><p>传统安装型软件，要现场调试，要用户购买等等，其难度可想而知。即使是可达度最高的互联网应用，由于生成环境的多样性、架构的复杂性、影响的广泛性（需要灰度发布）等等，就算产品已是待交付的状态，要真正达到用户可用的标准，还有大量的问题需要解决。</p><p>而“持续部署”就是将可交付产品，快速且安全地交付用户使用的一套方法和系统，它是“持续交付”的最后“一公里”。</p><h2><span id="持续交付的显性价值">持续交付的显性价值</span></h2><p>持续交付也通常以“发布流水线”的方式来解释，即研发团队从开发，到测试，再到部署，最终将产品交付给最终用户使用的过程。</p><p>虽然持续交付着重打造的是发布流水线的部分，但它索要达到的目标是在“最终用户”和“研发团队”之间建立紧密的反馈环：通过持续交付新的软件版本，以验证新想法和软件改动的正确性，并衡量这些改动对软件价值的影响。</p><p>这里所说的“软件价值”，就是收入、日活、GMV等KPI指标了。</p><p>通常我们在实施持续交付后，都能够做到在保证交付质量的前提下，加快交付速度，从而更快地得到市场反馈，引领产品的方向，最终达到扩大收益的目的。</p><p>速度为王的今天，持续交付的能力，正成为评定一家互联网公司研发能力的重要指标。</p><h2><span id="持续交付的隐性价值">持续交付的隐性价值</span></h2><p>无论是什么企业，无论你的职位高低，都可以或者应该尝试持续交付，它一定会让你觉得物超所值。</p><p>它可以实现的能力：</p><ul><li><p>解决技术选型的难题</p><p>技术选型最大的难点在于影响大，又难以验证（或者验证效率低下）。而造成这些困境的绝大多数原因是没有合适的测试环境，比如环境差异造成测试数据缺乏说服力，又比如缺少隔离环境造成服务冲突等等。而这正是持续交付的用武之地。</p><p>持续交付的实施，将全面改善企业对测试环境的关联方法，使得环境管理更合理、更自由。</p></li><li><p>让制定的标准更好落地：</p><p>标准、规范、流程的落地，都需要载体，而最好的载体就是平台工具。而持续交付是一整套平台工具的落地，几乎涵盖了研发的整个生命周期，是天然的、最佳的载体。</p><p>另外，持续交付的落地本身伴随着各类标准、规范、流程的制定和实施，可以说两者相互依存，是非常好的管理思想落地方案。</p></li><li><p>提高跨部门协作的效率</p><p>每一个持续交付的实施团队，都可以说是最厉害的“拆墙大队”，拆的就是各个研发协作部门间的“隔离墙”。</p><p>持续交付能够向各个协作部门输出统一的标准、流程和工具，提升沟通效率；并且通过大量的自动化，进一步提升各部门工作效率；还可以快速集成，把各个分散的团队，无论是横向的业务研发团队，还是纵向的技术框架团队，紧紧地联系在一起，共同进退。</p></li><li><p>从容面对故障</p><p>任何故障都有一个天敌，叫做：快速恢复。</p><p>假设，所有的故障都可以在3分钟内恢复，你是不是觉得天下无敌了。那恢复故障最快、最有效的手段又是什么呢？当然就是回滚（或者重新部署）了，而这正是持续交付所包含和着力打造的能力之一。</p></li><li><p>让知识能够传承</p><p>互联网公司的人才流动之频繁已经远远超过了你我的想象。人来人往，如何将知识传承下来？</p><p>持续交付将团队赖以生存的工作流程进行固化；</p><p>利用代码静态检查等工具，能够很好地传承团队多年来的代码规范，并作为检查项进行自动化校验；</p><p>自动化测试脚本，同样是团队经验的产物。</p></li><li><p>让团队专注于业务而非工程</p><p>持续交付体系也如同中间件一样，能够从日常的业务研发工作中抽象出来，其不同只在于中间件解决架构问题，而持续交付解决工程问题。</p><p>这样研发团队能够全力应付业务的需求，而不用总是重复奔波于一些烦人且耗时的工程问题，比如按照测试机、准备编译服务器等等。</p></li><li><p>让产品经理成为产品真正的第一个用户</p><p>持续交付不仅仅是可以保证每一个变化都能及时得到测试以及反馈，更多的是解决测试与实际发布时存在差异的问题。</p><p>产品人员将真正成为第一个用户，而不再是最后一个QA。</p></li><li><p>让产品经理能够完全知悉当前进度和质量</p><p>持续交付能够实时地反应当前的开发情况，从而帮助产品人员决策和调整。</p></li><li><p>产品随时能发布</p><p>计划永远赶不上变化，如何产品人员都希望自己的产品能够随时处于可发布状态。这样就灵活地交付已完成的功能，迎合市场或业务的需要。</p><p>本质上，<strong>做到代码上线和业务上线的解耦分离</strong>，这也正是交付方法论强调的一个重点。</p></li><li><p>可以让程序员进一步加强对整个软件工程的认识</p><p>持续交付涵盖了软件交付端到端的整个周期，其覆盖面不仅仅包括编码，还包括：设计、测试、部署、运维、运营等等。</p><p>研发效率的提高往往不是个人能力的提高，而是集体协同效率的提高。</p></li><li><p>提高个人的工作效率和质量</p><p>随着持续交付的流行，其配套的实践和工具也层出不穷。ping-pong式结对编程（A写测试，B写实现，然后B写下一个测试，A写重构和实现），让编程充满乐趣，也很好的保证了代码质量。</p></li></ul><h2><span id="如何评估持续交付的价值">如何评估持续交付的价值</span></h2><p>量化？</p><p>产品的交付速度是否变快了。但是，实际情况下影响产品交付速度的因素实在太多，持续交付又积极作用，但到底占比多少呢？难以回答。</p><p>各个自动化过程的速度是否变快了？如：编译速度、发布速度、回滚速度、自动化测试速度等等。这些指标确实很好地反应了持续交付的价值，但总觉得这些并不是全部，持续交付的标准化、推行的新流程、改革的环境治理结构，好像都没有体现出来。</p><p>如果很难量化，也可以具象化。在整个工程生命周期中有多少被开发人员诟病，或者阻碍开发人员自主处理的问题点，即‘不可持续点’：</p><blockquote><p>开发不能按需产生隔离的测试环境；</p><p>生成代码回滚后，要手工处理代码分支；</p><p>预发布流量要能自动分离，以便预发布测试。</p></blockquote><p>以消灭这些不可持续点作为目标，拆解出来的可行动点，作为关键结果，来完成绩效考评。</p><h1><span id="影响持续交付的因素">影响持续交付的因素</span></h1><h2><span id="组织和文化因素">组织和文化因素</span></h2><p>持续交付一定是整个组织层面的事情，是跨部门合作的产物，所以组织和文化因素，是要首先考虑的问题。</p><p>紧密配合</p><p>集思广益</p><p>自我驱动</p><p>组织的问题，还是需要通过组织变更来解决。通常我们会采用以下三种方案：</p><ul><li>成立项目管理办公室</li><li>独立建立工程效能部门</li><li>使用敏捷形式，如Scrum，打破职能部门之间的隔离墙，以产品的形式组织团队</li></ul><h2><span id="代码分支策略的选择">代码分支策略的选择</span></h2><h3><span id="主干开发tbd">主干开发（TBD）</span></h3><p>主干开发是一个源代码控制的分支模型，开发者在一个称为“trunck”的分支（Git称master）中对代码进行协作，除了发布分支外没有其他开发分支。</p><p>Google和Facebook都是采用“主干开发”的方式，代码一般直接提交到主干的头部，这样可以保证所有用户看到的都是同一份代码的最新版本。</p><p>“主干开发”确实避免了合并分支时的麻烦，因此像Google这样的公司一般就不采用分支开发，分支只用来发布。</p><p>大多数时候，发布分支是主干某个时点的快照。以后的改Bug和功能增强，都是提交到主干，必要时cherry-pick（选择部分变更集合并到其他分支）到发布分支。与主干长期并行的特性分支极为少见。</p><p>由于不采用“特性分支开发”，所有提交的代码都被集成到了主干，为了保证主干上线后的有效性，一般会使用特性切换（feature toggle）。特性切换就像一个开关可以在运行期间隐藏、启用或禁用特定功能，项目团队可以借助这种方式加速开发过程。</p><p>特性切换在大型项目持续交付中变得越来越重要，因为它有助于将部署从发布中解耦除了。但是，特性切换也会导致代码更为脆弱、更难测试、更难理解和维护、更难提供技术支持，而且更不安全。（From Jim Bird）</p><p>特性切换需要健壮的工程过程、可靠的技术设计和成熟的特性切换生命周期管理，如果不具备这三个关键的条件，使用特性切换反而会降低生产力。</p><p>根据上面的分析，主干开发的分支策略虽然有利于开展持续交付，但是它对开发团队的能力要求也更高。</p><h3><span id="特性分支开发">特性分支开发</span></h3><p>和主干开发行对的时“特性分支开发”。在这个大类里面，我们来分析Git Flow、Github Flow和Gitlab Flow：</p><ul><li><p>Git Flow</p></li><li><p>Github Flow</p><p>是Github所使用的一种简单流程。该流程只使用master和特性分支，并借助Github的pull request功能。</p><p>在Github Flow中，master分支中包含稳定的代码，它已经或即将部署到生产环境。任何开发人员都不允许把未测试或未审查的代码直接提交到master分支。对代码的任何修改，不可Bug修复、热修复、新功能开发等都在单独的分支中进行。不管是一行代码的小改动，还是需要几个星期开发的新功能，都采用同样的方式来管理。</p><p>当需要修改时，从master分支创建一个新的分支，所有相关的代码修改都在新分支中进行。开发人员可以自由地提交代码和提交到远程仓库。</p><p>当新分支中的代码全部完成之后，通过Github提交一个新的pull request。团队中的其他人员会对代码进行审查，提出相关的修改意见。由持续集成服务器（如Jenkins）对新分支进行自动化测试。当代码通过自动化测试和代码审查之后，该分支的代码被合并到master分支。再从master分支部署到生产环境。</p><p>Github Flow的好处在于非常简单实用，开发人员需要注意的事项非常少，很容易形成习惯。当需要修改时，只要从master分支创建新分支，完成之后通过pull request和相关的代码审查，合并回master分支就可以了。</p></li><li><p>Gitlab Flow</p></li></ul><table><thead><tr><th>分支模型</th><th>说明</th></tr></thead><tbody><tr><td>带生产分支</td><td>1. 无法控制准确的发布时间，但又要求不停集成的。<br>2. 需要创建一个production分支来放置发布的代码</td></tr><tr><td>带环境分支</td><td>1. 要求所有代码都在逐个环境中测试通过。<br>2. 需要为不同的环境建立不同的分支</td></tr><tr><td>带发布分支</td><td>1. 用于对外界发布软件的项目，同时需要维护多个发布版本<br>2. 尽可能晚地从master拉取发布分支。<br>3. Bug修复应先合并到master，然后cherry pick到release分支。</td></tr></tbody></table><h1><span id="依赖管理">依赖管理</span></h1><h1><span id="代码回滚">代码回滚</span></h1><h2><span id="什么是代码回滚">什么是代码回滚？</span></h2><ol><li>包回滚是指，线上运行的系统，从现在的版本回滚到以前稳定的老版本。</li><li>代码回滚是指，Git分支的指针（游标），从指向当前有问题的版本改为指向一个该分支历史树上没问题的版本，而这个版本可以是曾经的commit，也可以是新建的commit。</li></ol><h2><span id="哪些情况下需要回滚代码">哪些情况下需要回滚代码？</span></h2><ul><li>第一种情况：开发人员独立使用的分支上，如果最近产生的commit都没有价值，应该废弃掉，此时就需要把代码回滚到以前的版本。</li><li>第二种情况：代码集成到团队的集成分支且尚未发布，但在后续测试中发现这部分代码有问题，且一时半会儿解决不掉，为了不把问题传递给下次的集成，此时就需要把有问题的代码从集成分支中回滚掉。</li><li>第三种情况：代码已经发布到线上，线上包回滚后发现是新上线的代码引起的问题，且需要一段时间修复，此时又有其他功能需要上线，那么主干分支必须把代码回滚到正确版本产品包对应的commit</li></ul><h2><span id="哪些情况下包的回滚无需回滚代码">哪些情况下包的回滚无需回滚代码？</span></h2><ul><li>线上回滚后，查出并不是因为源代码有问题。</li><li>下次线上发布，就是用来修复刚才线上运行的问题。</li></ul><h2><span id="代码回滚必须遵循的原则">代码回滚必须遵循的原则</span></h2><p>集成分支上代码回滚坚决不用reset –hard的方式，原因如下：</p><ul><li>集成分支上的commit都是项目阶段性的成果，即使最近的发布不需要某些commit的功能，但仍然需要保留这些commit，以备后需。</li><li>开发人员会基于集成分支上的commit拉取新分支，如果集成分支采用reset的方式消除了该commit，下次开发人员把新分支合并回集成分支时，又会把被清除的commit申请合并，很可能导致不需要的功能再次被引入集成分支。</li></ul><h2><span id="三种典型回滚场景及回滚策略">三种典型回滚场景及回滚策略</span></h2><table><thead><tr><th>场景名称</th><th>特点</th><th>策略</th></tr></thead><tbody><tr><td>个人分支回滚</td><td>不会影响团队其他成员</td><td>可以用git reset –hard</td></tr><tr><td>集成分支上线前回滚</td><td>1. 会影响团队其他成员<br>2. 非线上故障，相对不紧急<br>3. 可以对单独的commit做回滚</td><td>1. 一定不用 git reset –hard<br>2. 可在gitlab上找到对应的Merge Request，点击revert</td></tr><tr><td>集成分支上线后回滚</td><td>1. 会影响团队其他成员<br>2. 线上故障，相对紧急<br>3. 需回滚到包对应的commit</td><td>1. 一定不用 git reset <br>2. 再集成分支的头上增加一个commit，该commit的内容等于包回滚后对应的commit</td></tr></tbody></table><h1><span id="测试环境">测试环境</span></h1><p>在整个持续交付生命周期中，测试环境的易用程度会直接影响软件的交付程度，但因为以下两点，它又是最被容易忽略的一环。</p><ol><li>我们总是把环境理想化，忽略了其管理的难度；</li><li>我们也很少设立专职的环境管理员，导致环境长期处于混乱状态。</li></ol><p>通常，我们在项目初期并不会关注测试环境的问题，然而在回顾时却发现在环境问题上浪费的时间非常惊人：硬件资源申请困难，测试环境配置繁琐，测试应用更新困难，基础设施稳定性差，服务调用异常，多项目并行造成互相干扰等等问题。</p><p>构建一整套好的测试环境的关键点以及具体实施方案</p><ol><li>测试环境的结构一般是怎样的？</li><li>什么才是好的测试环境？</li></ol><h2><span id="互联网公司测试环境的结构">互联网公司测试环境的结构</span></h2><p>当公司规模较小时，测试环境的维护相对容易。开发和测试公用一套数据库缓存等基础设施，因为应用数量不多，开发环境可以是单机的，无论是手动或半自动化的更新测试环境的应用，花费的时间都还在可接受范围内。</p><p>这时，公司环境的结构很简单，分为开发环境，测试环境，生产环境即可。</p><p>但实际上，大多数公司的研发过程及配套环境并没有这么简单，一般都会存在5套以上的大环境以及更多的子环境，每个环境的机器数量可能有数十台甚至更多。</p><p>为什么需要这么多套环境呢？</p><ul><li><p>纵向上看，人员的增多提高了项目的并行度，如果这时还使用一套环境的话，就会发生以下问题：</p><ul><li>开发同学在debug一个问题时，发现下游的应用突然就不可用了；</li><li>测试同学在跑了10多分钟测试脚本后，发现应用已经被开发更新掉了。</li></ul><p>这样的体验是让人崩溃的。</p></li><li><p>横向上看，公司的应用架构逐渐转为微服务化，完整的应用数量很容易就达到了几百甚至几千个的量级，建立一套完整的环境变得越来越复杂，往往是研发团队想要构建一套新的环境却构建不出来。</p></li></ul><p>所以，目前互联网公司常见的环境模型一般分为开发环境，功能测试环境，验收测试环境，预发布环境，生产环境这五套大环境。</p><ul><li><p>开发环境</p><p>微服务架构下，单机已经无法完整地运行业务应用，这就需要开发环境内包含一套完整的业务应用依赖以及相关的基础设施，以保证业务开发同学能在本地完成开发测试。</p></li><li><p>功能测试环境</p><p>在开发环境下，每个下游依赖应用都只有一个可用的stable版本。而在实际的开发过程中，由于项目的并行开发，往往会同时存在多个可依赖的版本。而每个项目组的同学在测试时，都希望测试过程中的关键依赖应用是可以被独占的，版本是固定的，不会被其他项目组干扰。</p><p>所以，一套独立的功能测试环境就很有必要了。<em>通常，互联网企业会通过中间件的方式分割出一块隔离区域，在功能测试环境中创建多个子环境来解决问题。</em></p></li><li><p>验收测试环境</p><p>验收测试环境和功能测试环境是完全隔离的。当功能测试通过后，你可以在验收测试环境进行最终的验收。</p><p>它除了可以用作测试之外，还可以用作产品展示。所以，除了测试和开发人员，产品经理也是验收测试环境的主要使用者。</p></li><li><p>预发布环境</p><p>到预发布阶段，应用已经进入了生产网络，和真实的生产应用共享同一套数据库等基础设施。预发布是正式发布前的最后一次测试，在这个环境中往往可以发现线下环境中发现不了的Bug。这个环境的运维标准等同于生产环境，一般不允许开发人员直接登陆机器。</p><p>根据不同的业务需求和部署策略，不同公司对预发布环境的实现也有所不同：</p><ul><li><p>一种比较常见的方式是，将金丝雀发布作为预发布，从接入真实流量的集群中挑选一台或一小组机器先进行版本更新，通过手工测试以及自动化测试和监控系统验证，降低新版本发布的风险。</p><blockquote><p>金丝雀发布：</p><p>17世纪，英国矿井工人发现，金丝雀对瓦斯这种气体十分敏感。空气中哪怕有极其微量的瓦斯，金丝雀也会停止歌唱；而当瓦斯含量超过一定限度时，虽然鲁钝的人类毫无察觉，金丝雀却早已毒发身亡。当时在采矿设备相对简陋的条件下，工人们每次下井都会带上一只金丝雀作为“瓦斯检测指标”，以便在危险状况下紧急撤离</p><p>金丝雀发布是灰度发布的一种方式。灰度发布是指在黑与白之间，能够平滑过渡的一种发布方式。让一部分用户继续用A，一部分用户开始用B，如果用户对B没有什么反对意见，那么逐步扩大范围，把所有的用户都迁移到B上面来。</p><p>部署步骤：</p><ul><li>准备好部署各个阶段的工件，包括：构建工件、测试脚本、配置文件和部署清单文件。</li><li>从负载均衡列表中移除掉“金丝雀”服务器</li><li>升级“金丝雀”应用（排掉原有流量并进行部署）</li><li>对应用进行自动化测试</li><li>将“金丝雀”服务器重新添加到负载均衡列表中（连通性和健康检查）</li><li>如果“金丝雀”在线使用测试成功，升级剩余的其他服务器，否则就回滚。</li></ul></blockquote></li><li><p>另一种做法是，独立出一组始终不接入真实流量的机器，调用在预发布环境中形成闭环。</p><p>相对于第一种方式，第二张方式对生产环境的影响更小，但需要额外的资源和维护成本。</p></li></ul></li><li><p>生产环境</p><p>生产环境是用户真实使用的环境，对安全性和稳定性的要求最高。</p></li></ul><h2><span id="什么是好的测试环境">什么是好的测试环境？</span></h2><p>开发环境、功能测试环境、验收测试环境、预发布环境这四种测试环境形成的原因是什么？</p><p>搭建测试环境的目的是保证最终交付的软件质量，但每套测试环境的用户并不完全一样：</p><ul><li>开发环境的用户是开发同学；</li><li>功能测试环境的主要用户是测试同学；</li><li>验收测试环境的用户是产品经理和测试同学；</li><li>预发布环境的使用者是测试同学，但受益者却是运维同学。</li></ul><p>而每种角色对于产品研发流程中的需求也是不同的：</p><ul><li>开发同学关注研发效率；</li><li>测试同学关注测试的可靠性；</li><li>产品经理更关注的是真实的用户体验和产品的完整性；</li><li>预发布环境的需求其实来自于运维同学，他们需要保证生产环境的稳定性，减少生产环境的变更，所以需要将预发布环境与线下环境完全隔离。</li></ul><p>当然，不论一套环境用户是测试同学还是开发同学，以下几个需求都是必须被做到的。</p><ul><li>可得性，即在开发一个新项目时，能快速获取构建一个环境需要的机器，基础设施。最好的情况是，能随时可得，随时归还。</li><li>快速部署，即在搭建新环境时，能以最快的速度构建出一整套完整的环境。测试环境的部署很频繁，在代码提交后，能在很短的时间内构建代码，在环境上更新，就能更早开始测试。</li><li>独立性，即一个环境在使用过程中，可以不受其他项目测试人员的干扰。</li><li>稳定性，即不会因为下游服务，基础设施的异常，造成测试中断、等待。</li><li>高仿真，主要分为两个方面：“测试数据真实”，即能在测试环境构建出真实的测试用例；“环境真实”，即基础服务的架构和行为与线上环境保持一致，避免因为环境不一致造成测试结果不一致。</li></ul><p>但是，毕竟各个环境的用户和使用场景不同，它们的需求也是有差别的。比如，相对于开发环境，验收测试环境对测试数据的仿真性要求会更高，而开发环境的灵活性，决定了不会过于严格的维护测试数据的真实性。</p><p>当一个环境可以满足其真正核心用户的需求时，就是一个好用的测试环境。</p><h2><span id="测试环境的成本">测试环境的成本</span></h2><ul><li><p>机器资源的成本</p><p>保证环境的独立性，是你构建更多套环境的一个主要原因。但是，一套独立的、拥有完整链路的环境成本是非常高的。</p><p>以阿里云的价格为例：假设一个只有100个应用的微服务架构环境，选取单应用单机2核4G内存的低配置实例方式进行部署，单实例的年价格在2000元左右，100个实例的话，一年的花费就是20万元左右。</p><p>而这只是最保守的计算，随着服务规模的增加，以及更多环境的需要，整体花费上涨两个数量级也是很正常的。</p><p>这样的问题在开发环境和集成环境的表现是最明显的。为了保证这两套环境的独立性，你必然需要有很高的环境副本数。单无论如何，你都不可能让每一个开发和测试人员都拥有一套完整环境的硬件资源。</p></li><li><p>其次是管理成本</p><p>管理成本，包括维护环境的可用性，配置的管理成本，和测试数据的维护成本三个维度。</p><ul><li><p>维护多套环境的第一要点是，维护环境的可用性。</p><p>与云时代之前相比，容器技术已经解决了很多问题。比如，服务器操作系统级别的依赖的标准化更容易了；当出现硬件故障时，迁移和恢复服务也更加方便了。</p><p>但是容器技术并没有解决故障定位的问题。微服务架构下集群的节点数量多，调用链复杂，你不再能确定到底是环境问题，还是程序本身的Bug，也就导致定位故障更加困难了。</p><p>所以，更多套环境就意味着更大的集群规模，出现故障的几率会随之增加，而解决故障也会占用更长的工作时间。</p></li><li><p>维护多套环境的另一大成本，配置管理成本</p><p>配置是环境管理中最核心的内容，创建一套环境时，为了保证它真正的独立可用，不仅要保证应用可以成功运行，还要保证应用在基础设施的配置是正确的。比如集成测试环境下部署了一个应用的多个平行项目，就需要有办法保证测试人员能访问到正确的应用。</p><p>如果是web应用，你就要考虑把应用绑定到不同的域名，这样就会增加域名管理的成本；如果是一个service应用，就要考虑到这些service不会被其他项目的、无关环境的应用调用到，同时也不会调用到其他错误的服务。</p><p>每多一套环境，就会多一套这样的配置，而且这些配置都需要在各类基础设施中生效。</p></li><li><p>测试数据的维护成本</p><p>测试数据也是环境中极为重要的一个组成部分。当并行环境的数量变多后，数据的维护同样是让人头疼的问题。</p><p>为了保证环境的高仿真，哪些环境公用一套数据库，以及测试数据的更新在多套环境中怎么执行等等，都需要非常高的管理成本。</p></li></ul></li><li><p>最后是流程成本</p><ul><li><p>沟通成本</p><p>每增加一套环境，你都需要考虑团队成员如何在新环境上沟通协作。谁在占用，何时退出这些信息，你都需要第一时间告知团队。当环境的数量变得非常多以后，做好这些事儿的难度就很大了。</p></li><li><p>测试成本</p><p>在开发环境、集成测试环境、验收测试环境、预发布环境、生产环境这样的结构下，核心功能的测试流程就至少会执行五次。每引入一套新的环境，测试流程都会变得更加复杂。</p></li></ul></li></ul><h2><span id="如何调节效率和成本的矛盾">如何调节效率和成本的矛盾？</span></h2><p>增加一套环境带来的成本竟然有那么多，但是为了提高持续交付的效率，隔离的多套环境又是必不可少的。</p><p>那么，应该怎样去规划和设计环境呢？</p><ul><li><p>公共与泳道</p><p>第一个关键点是抽象公共环境，而其中的公共服务基本都属于底层服务，相对比较稳定，这是解耦环境的重中之重。比如我们经常会将中间件、框架类服务，底层业务公共服务（账号、登陆、基本信息）部署在这套公共环境上。</p><p>在公共环境的基础上，可以通过泳道的方式隔离相关测试应用，利用LB和SOA中间件对路由功能的支持，在一个大的公共集成测试环境中隔离出一个个独立的功能测试环境，那么增加的机器成本就仅与被并行的项目多少有关系了。</p><p>具体案例：</p><p>比如，你有一个新的下单流程需要测试。你可以将下单web2.0和下单sevice2.0抽离出来</p></li><li><p>避免产生多套公共环境</p><p>用mock service模拟大多数服务</p></li><li><p>减轻配置的复杂度</p><ul><li>制定一套统一配置的解决方案</li><li>要让环境自己说话，有效减少配置项</li></ul></li></ul><h1><span id="环境自描性">环境自描性</span></h1><blockquote><p>要想把环境配置做好，就是要做到让环境自己能说话。</p></blockquote><p>环境配置可以分为:</p><ul><li><p>以环境中每台服务器为对象的运行时配置</p><p>以一个Java Web应用为例，需要哪些运行时配置呢？</p><ol><li>安装war包运行依赖的基础环境，比如JDK、Tomcat等</li><li>修改Tomcat的配置文件，关注点主要包括：应用的日志目录，日志的输出格式，war包的存放位置。Tomcat的server.xml配置包括：连接数、端口、线程池等参数</li><li>配置Java参数，包括JVM堆内存的最大最小方式、GC方式、参数，JMX监控开启等</li><li>考虑操作系统参数，比较常见的一个配置时Linux的文件句柄数，如果应用对网络环境有一些特殊要求的话，还需要调整系统的TCP参数等配置</li></ol><p>经过上面4步，一个简单的运行时环境的配置就算时完成了，可以开始运行一个程序了。</p><p>但我们不光要考虑单个实例初始化配置，还要考虑每次JDK、Tomcat等基础软件的版本升级引起的运行时配置的变更，而且这些变更都需要清晰的记录下来，从而保证扩容出新的服务器时能取到正确的、最新的配置。</p><p>另外，对于一个集群的服务器组来说，还需要强制保证它们的运行时配置是一致的。</p></li><li><p>以一个环境为整体目标的独立环境配置</p><p>独立环境配置的主要目的是，保证一个环境能够完整运作的同时，又保证足够的隔离性，使其成为一个内聚的整体。</p><p>所以，要让一个环境能够符合需求的正常运作，你需要考虑的内容包括：</p><ol><li>这个环境所依赖的数据库该如何配置，缓存服务器又该如何配置</li><li>如果是分布式系统，或者SOA结构的话，就需要考虑服务中心、配置中心等一系列中间件的配置问题</li></ol><p>其中，最为重要的是配置中心的配置。</p><p>只有先访问到正确的配置中心，才能获取到其他相关的环境配置或者应用配置信息。也就是说，如果配置中心的配置错了，那么环境就会陷入混乱状态。</p><ol><li>要考虑访问入口问题。这套环境的入口在哪里？是一个站点还是一个服务入口？如果是一个站点的话，那这个站点的访问域名就需要被特殊配置。如果这是一个内部环境的话，那么这个内部域名的DNS解析也需要被配置。如果这套环境中有多个Web应用，那么你就要考虑7层路由的配置问题了</li><li>还要配置环境对应的基础服务，比如监控、短信、搜索等</li></ol></li></ul><p>再如果你的环境要承载多种语言栈，各类应用依赖的基础软件也不同，环境和环境之间有各种关联设置，数据库的连接分配，环境中负载均衡的设置等等</p><p>虽然环境配置有这么多的待处理事项，但是环境本身也是一个非常强大的工具，本身包含非常多的信息，如果这些糟心的事情环境能和你一起来解决，那就简单了，也就是说要让环境之间来说话。怎么做到呢？</p><h2><span id="环境一定要标准化">环境一定要标准化</span></h2><p>解决复杂问题的办法，无非是先将其分解，再将其简单化，对环境配置这个难题来说也是同样的道理。想要解决它，首先得要想办法分解、简化它。</p><p>最好的简化方法，莫过于标准化了。</p><p>所谓标准化，就是为了在一定范围内获得最佳秩序，对实际的或潜在的问题制定共同、可重复使用的规则。</p><p>标准化也就是让环境学会了一门统一的语言，是自己说话的前提。</p><p>按照这个思路，我们首先可以实现对语言栈的使用、运行时配置模板、独立环境配置的方法等的标准化：、</p><ul><li>规定公司的主流语言栈</li><li>统一服务器安装镜像</li><li>提供默认的运行时配置模板</li><li>统一基础软件的版本，以及更新方式</li><li>在架构层面统一解决环境路由问题</li><li>自动化环境产生过程</li></ul><p>在实施持续交付的同时，推动形成以下几个方面的规范：</p><ul><li>代码及依赖规范</li><li>命名规范</li><li>开发规范</li><li>配置规范</li><li>部署规范</li><li>安全规范</li><li>测试规范</li></ul><p>其实，不管是持续交付还是架构改造，标准先行都是技术实施的前提条件。</p><h2><span id="约定大于配置">约定大于配置</span></h2><p>像代码的部署路径，每个环境的域名定义，FAT、UAT来表示环境的作用，单机单应用，所有服务端端口是8080等等</p><p>约定大于配置的好处是，除了简化配置工作外，还可以提高沟通效率。</p><p>相当于赋予了环境天生的本能，进一步加强了环境的自我描述能力。</p><h2><span id="让环境自己能开口说话">让环境自己能开口说话</span></h2><p>有了环境标准化，以及约定大于配置的基础，你就可以顺利地让环境自己开口说话了。</p><p>也就是，通过环境的自描述文件，让环境能讲清楚自己的作用、依赖，以及状态，而不是由外部配置来解释这些内容。</p><p>以一台服务器为例，一旦生成，除了不能控制自己的生死外，其他运行过程中的配置，都应该根据它自身的描述来决定。</p><p>那么，如何让服务器自己说话呢？</p><ul><li>首先，需要定义Server Spec：在这个文件中，记录了这台服务器的所有身份信息，包括：IDC、型号、归属环境、作用、所属应用、服务类型、访问路径等</li><li>解决配置中心寻址：中间件根据Server Spec的描述，寻找到它所在环境对应的配置中心，从而进一步获取其他配置，如数据库连接字符串、短信服务地址等</li><li>完成服务自发现：根据服务类型、访问路径等，还可以自动生成对应的路由配置、负载均衡配置等</li></ul><h1><span id="各种配置方法">各种配置方法</span></h1><p>配置管理：是通过技术或行政手段对软件产品及其开发过程和生命周期进行控制、规范的一系列措施。它的目标是记录软件产品的演化过程，确保软件开发者在软件生命周期的各个阶段都能得到精确的产品配置信息。</p><p>配置：是指独立于程序之外，但又对程序产生作用的可配变量。也就是说，同一份代码在不同的配置下，会产生不同的运行结果。</p><h1><span id="分钟级搭建环境">分钟级搭建环境</span></h1><h2><span id="环境构建流水线">环境构建流水线</span></h2><ol><li><p>虚拟机环境准备，根据环境的应用数，每个应用需要的硬件配置，准备号环境的硬件资源</p><ul><li>当物理机接到机架上以后，打开交换机端口，等待机器被发现后，调用Nova进行物理机基本的硬件配置</li><li>物理机环境准备完毕后，从openstack获取虚机所需的镜像、网络等信息，调用Openstack API镜像虚机部署。虚机配置的一个关键点是，如何对网络进行配置</li><li>虚机初始化后，需要在虚机上进行一些基础软件比如JDK，Tomcat的安装和配置。业界一般采用的方式是，通过自动化的配置管理工具来进行操作。</li></ul></li><li><p>应用部署流水线，在标准化的虚拟机上进行应用部署，当出现问题时如何容错。</p><ul><li><p>单应用部署标准化，这是整个环境部署的基础。对一套测试环境而言，每个应用就像是环境上的一个零件，如果单个应用无法自动发布或发布失败率很高，那么整个环境就更难以构建出来。而如何实现一个好的发布系统，提升单应用部署速度呢？</p></li><li><p>应用部署的并行度，为了提高环境的部署速度，需要尽可能得最大化应用部署的并行度。理想的情况下，环境中的所有应用都可以一次性地并行部署。</p><p>然而，做到一次性并行部署并不容易，需要保证：应用都是无状态的，并且可以不依赖别的应用进行启动，或者仅仅依赖于基础环境中的应用就可以启动，且可以随时通过中间件进行调用链的切换。</p></li><li><p>流水线的容错机制。对于环境构建工具，通常的做法是力求做到全面的标准化、代码化。但是因为环境的创建本身是一个非常复杂的工作流，在创建过程总会有一些异常中断整个流程。比如，某个应用启动失败了。</p><p>而对于这些工作流中的异常，我们该如何处理呢？</p><ul><li><p>第一种方法是，错误中断法。创建环境过程中，各种资源申请、应用部署出现问题时，我们将工作流快照下来，然后收集所有的异常信息，返回给用户。由用户判断当前的情况，等用户确认问题已经得到解决后，可以触发一次快照重试，继续被中断的流程。</p></li><li><p>第二种方法是，优先完成法。创建环境过程中发生错误时，先进行几次重试。如果重试依然发生错误的话，就忽略当前错误，先走完剩余的流程，等所有的流程都走完了，再一次性将错误返回给用户。</p><p>从整体速度上来看，第二种优先完成的处理方式是更优的，而且也会更少地打断用户。只是方式二需要保证的关键原则是：所有的部署脚本的操作都是幂等的，即两次操作达成的效果是一致的，并不会带来更多的问题。</p></li></ul></li></ul></li><li><p>环境变更，在SOA或微服务的架构体系下，常常会因为测试的需求，将几套环境合并或拆分，创建环境时，你需要考虑如何高效地完成这些操作。</p><p>一般情况下，研发人员变更环境主要有以下4种场景：</p><ul><li>已经有一套新环境，当有新项目时，开发人员会挑选部分应用，组成一个独立的子环境。这里的重点是，要保证子环境和完整环境的调用是互相隔离的</li><li>当存在多个子环境时，可能在某个时间点需要做多个项目的集成，这时开发人员需要合并多个环境。</li><li>和合并的情况相反，有些情况下，开发人员需要将一个子环境种的应用切分开来，分为两个或者多个环境分别进行隔离测试。</li><li>已经存在一个子环境，当多个并行项目时，开发人员会克隆一套完整的子环境做测试。</li></ul></li></ol><h1><span id="构建提速">构建提速</span></h1><h1><span id="发布">发布</span></h1><h2><span id="发布是持续交付的最后一公里">发布是持续交付的最后一公里</span></h2><h2><span id="任何变更都需要发布">任何变更都需要发布</span></h2><h2><span id="发布系统一定要注意用户体验">发布系统一定要注意用户体验</span></h2><h2><span id="发布系统的核心架构和功能设计">发布系统的核心架构和功能设计</span></h2><p>作为整个持续交付体系中极为重要的一个环节，应用的发布时提升交付效率的关键。高效的发布系统架构应该时清晰的、健壮的、低耦合的，从而达到在最糟糕的情况下也能运作的目的。</p><h1><span id="利用监控保障发布质量">利用监控保障发布质量</span></h1><h1><span id="代码静态检查">代码静态检查</span></h1><h1><span id="破坏性测试">破坏性测试</span></h1><h1><span id="自动化回归">自动化回归</span></h1><p>对于持续交付的测试来说，自动化回归测试是不可或缺的，占了很大的测试比重。</p><p>进行自动化回归测试，就始终会有三个大问题：</p><ul><li>测试数据的准备和清理</li><li>分布式系统的依赖</li><li>测试用例的高度仿真</li></ul><h1><span id="平台化设计持续交付">平台化设计持续交付</span></h1><h1><span id="持续交付中的宝贵数据">持续交付中的宝贵数据</span></h1><h1><span id="移动app的持续交付生命周期">移动APP的持续交付生命周期</span></h1><h1><span id="快速构建持续交付系统">快速构建持续交付系统</span></h1><h2><span id="需求分析">需求分析</span></h2><h3><span id="模拟团队介绍">模拟团队介绍</span></h3><table><thead><tr><th></th><th>团队1</th><th>团队2</th><th>团队3</th></tr></thead><tbody><tr><td>职责</td><td>中间件服务</td><td>业务后台服务</td><td>业务客户端服务</td></tr><tr><td>代码管理</td><td>Git</td><td>Git</td><td>Git</td></tr><tr><td>语言平台</td><td>Java</td><td>Java</td><td>React Native</td></tr><tr><td>交付产物</td><td>服务/Jar</td><td>服务/War</td><td>App</td></tr></tbody></table><p>整个产品的研发，需要由着3个团队合作完成。</p><h3><span id="模拟系统介绍">模拟系统介绍</span></h3><h2><span id="gitlab解决代码管理问题">Gitlab解决代码管理问题</span></h2><h2><span id="jenkins解决集成打包问题">Jenkins解决集成打包问题</span></h2><h2><span id="ansible解决自动部署问题">Ansible解决自动部署问题</span></h2>]]></content>
    
    <summary type="html">
    
      持续交付——如何将一个好点子，以最快的速度交付给用户
    
    </summary>
    
    
      <category term="运维" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>运维体系管理</title>
    <link href="http://yoursite.com/2018/02/21/%E8%BF%90%E7%BB%B4%E4%BD%93%E7%B3%BB%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2018/02/21/运维体系管理/</id>
    <published>2018-02-21T12:51:23.000Z</published>
    <updated>2019-03-01T06:26:46.926Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#微服务架构时代运维体系建设要以应用为核心">微服务架构时代，运维体系建设要以应用为核心。</a><ul><li><a href="#应用的起源">应用的起源</a></li><li><a href="#应用模型及关系模型的建立">应用模型及关系模型的建立</a></li></ul></li><li><a href="#标准化体系建设">标准化体系建设</a><ul><li><a href="#为什么要做标准化">为什么要做标准化？</a></li><li><a href="#基础设施层面的标准化">基础设施层面的标准化</a></li><li><a href="#应用层面的标准化">应用层面的标准化</a></li><li><a href="#基础架构的标准化">基础架构的标准化</a><ul><li><a href="#常见的分布式基础架构组件">常见的分布式基础架构组件</a></li><li><a href="#基础架构组件的选型问题">基础架构组件的选型问题</a></li><li><a href="#其中运维的职责">其中运维的职责</a></li></ul></li><li><a href="#基础架构的服务化">基础架构的服务化</a><ul><li><a href="#为什么要做基础架构的服务化">为什么要做基础架构的服务化</a></li><li><a href="#运维的职责">运维的职责</a></li></ul></li></ul></li><li><a href="#如何从生命周期的视角看待应用运维体系建设">如何从生命周期的视角看待应用运维体系建设</a><ul><li><a href="#应用的生命周期分析">应用的生命周期分析</a></li></ul></li><li><a href="#cmdb">CMDB</a><ul><li><a href="#cmdb缘起">CMDB缘起</a></li><li><a href="#传统运维思路下的cmdb">传统运维思路下的CMDB</a></li><li><a href="#互联网运维体系下的cmdb">互联网运维体系下的CMDB</a></li></ul></li><li><a href="#如何在cmdb中落地应用的概念">如何在CMDB中落地应用的概念？</a><ul><li><a href="#如何有效组织和管理应用">如何有效组织和管理应用</a></li><li><a href="#应用的集群服务分组建设">应用的集群服务分组建设</a></li><li><a href="#cmdb在基础服务体系中的核心位置">CMDB在基础服务体系中的核心位置</a></li></ul></li><li><a href="#持续交付">持续交付</a><ul><li><a href="#什么是持续交付">什么是持续交付？</a></li><li><a href="#持续交付的关键点">持续交付的关键点</a></li><li><a href="#配置管理">配置管理</a><ul><li><a href="#版本控制">版本控制</a></li><li><a href="#依赖管理">依赖管理</a></li><li><a href="#软件配置">软件配置</a></li></ul></li><li><a href="#多环境建设">多环境建设</a></li><li><a href="#线上环境建设">线上环境建设</a></li><li><a href="#持续交付中的流水线模式">持续交付中的流水线模式</a></li></ul></li><li><a href="#混合云">混合云</a><ul><li><a href="#关于混合云">关于混合云</a></li></ul></li><li><a href="#面向应用层的云架构解决方案">面向应用层的云架构解决方案</a></li><li><a href="#cdn和云存储-云生态">CDN和云存储 云生态</a></li><li><a href="#页面静态化架构和二级cdn建设">页面静态化架构和二级CDN建设</a></li><li><a href="#弹性伸缩">弹性伸缩</a><ul><li><a href="#弹性伸缩的主体是谁">弹性伸缩的主体是谁？</a></li></ul></li><li><a href="#稳定性保障">稳定性保障</a></li><li><a href="#容量规划">容量规划</a></li><li><a href="#限流降级">限流降级</a></li><li><a href="#开关预案">开关预案</a></li><li><a href="#全链路跟踪">全链路跟踪</a></li><li><a href="#故障">故障</a></li><li><a href="#安全">安全</a></li></ul><!-- tocstop --><h1><span id="微服务架构时代运维体系建设要以应用为核心">微服务架构时代，运维体系建设要以应用为核心。</span></h1><blockquote><p>在微服务的架构模式下，我们的运维视角一定转到应用这个核心概念上来，一切要以应用的角度分析和看待问题。</p></blockquote><h2><span id="应用的起源">应用的起源</span></h2><p>微服务架构一般都是从单体架构或分层架构演进而来。软件架构服务化的过程，就是我们根据业务模型进行细化的过程，在这个过程中切分出一个个具备不同职责的业务逻辑模块，然后每个微服务模块都会提供相应业务逻辑的服务化接口。</p><p>解释简单点，就一个字，拆！从一个单体工程，拆分出N个独立模块。这些模块都可以独立部署和运行，并提供对应的业务能力。拆分后的模块数量与业务体量和复杂度相关，少则几个、十几个，多则几十、几百个，所以为了统一概念，我们通常称这些模块为应用。</p><p>为了确保每个应用的唯一性，我们给每个应用定义一个唯一的标识符，这个唯一标识符我们称之为应用名。</p><p>这个定义为应用的概念，将成为我们微服务架构管理的核心概念。</p><h2><span id="应用模型及关系模型的建立">应用模型及关系模型的建立</span></h2><p>上面我们定义出来的一个个应用，都是从业务角度入手进行拆分细化出来的业务逻辑单元。它虽然可以独立部署和运行，但是每一个应用都只具备相对单一的业务职能。如果要完成整体的业务流程和目标，就需要和周边其它的服务化应用交互。同时，这个过程中还需要依赖各种与业务无直接关系、相对独立的基础设施和组件，比如机器资源、域名、DB、缓存、消息队列等等</p><p>所以，除了应用这个实体之外，还会存在其他各类基础组件实体。同时。在应用运行过程中，还需要不断地与他们产生和建立各种各样复杂的关联关系，这也为我们后续的运维带来很多困难。</p><p>我们要做的就是应用模型以及各种关系模型的梳理和建立，因为只有模型和关系梳理清楚了，才能为我们后面一系列的运维自动化、持续交付以及稳定性保障打下一个良好基础。</p><ol><li><p>应用业务模型</p><p>应用业务模型，也就是每个应用对外提供的业务服务能力，并以API的方式暴露给外部。<br>这个业务模型通常都是业务架构师在进行业务需求分析和拆解时进行设计，更多的时聚焦在业务逻辑上，所以从运维的角度，我们一般不会关注太多。</p></li><li><p>应用管理模型</p><p>应用管理模型，也就是应用自身的各种属性，如应用名、应用功能信息、责任人、Git地址、部署结构（代码路径、日志路径以及各类配置文件路径等）、启停方式、健康检测方式等待。这其中，应用名时应用的唯一标识，我们用AppName来表示。</p></li><li><p>应用运行时所依赖的基础设施和组件</p><ul><li>资源层面：应用运行所必需的资源载体有物理机、虚拟机或容器等，如果对外提供HTTP服务，及需要VIP和DNS域名服务；</li><li>基础组件：这一部分其实就是我们所说的中间件体系，不如应用运行过程中必然要存储和访问数据，这就需要有数据库和数据库中间件；想要更快访问数据，同时减轻DB的访问压力，就需要缓存；应用之间如果需要数据交互或同步，就需要消息队列；如果进行文件存储和访问，就需要存储系统等等。</li></ul><p>从这里我们可以挖掘出一条规律，那就是这些基础设施和组件都是为上层的一个个业务应用所服务的。也正是因为业务和应用上的需求，才开启了它们各自的生命周期。如果脱离了这些业务应用，它们之间并没有单纯存在的意义。所以，从始至终基础设施和组件都跟应用这个概念保持着紧密的联系。</p><p>理清了这个思路，我们再去梳理它们之间的关系就会顺畅很多，分为两步：</p><ul><li>第一步，建立各个基础设施和组件的数据模型，同时识别出它们的唯一标识。这个套路跟应用管理模型的梳理类似，以典型的缓存为例，每当我们申请一个缓存空间时，通常会以NameSpace来标识唯一命名，同时这个缓存空间会有空间容量和Paritition分区等信息。</li><li>第二步，识别出基础设施及组件可以与应用名AppName建立关联关系的属性，或者在基础组件的数据模型中增加所属应用这样的字段。</li></ul></li></ol><blockquote><p>微服务架构模式下的运维思路一定要转变，一定要将视角转换到应用这个维度，从一开始就要统一规划，从一开始就要将架构、开发和运维的工作拉通了去看，这一点是与传统运维的思路完全不同的。<strong>规划以应用为核心的运维管理体系</strong></p></blockquote><h1><span id="标准化体系建设">标准化体系建设</span></h1><p>标准化工作是运维过程中最基础、最重要的，但也是最容易忽视的一个环节。</p><p><strong>标准先行</strong></p><p>我们运维工作的开展常常不知从何下手，或者上来就冲着工具和自动化去了，却始终不得章法，工具做了一堆，效率却并没有提升。其实绝大多数情况下，问题和原因就是标准化这个基础工作没做扎实。</p><p>为何标准化这个事情如此重要呢？</p><h2><span id="为什么要做标准化">为什么要做标准化？</span></h2><p><strong>标准化的过程实际上就是对运维对象的识别和建模的过程</strong>。形成统一的对象模型后，各方在统一的认识下展开有效协作，然后针对不同的运维对象，再抽取出它们所对应的运维场景，接下来才是运维场景的自动化实现。</p><p>这有点像我们学的面向对象编程的思想，其实我们就是需要遵循这样一个思路，我们面对的就是一个个实体和逻辑运维对象。</p><p>在标准化的过程中，先识别出各个运维对象，然后我们日常做的所有运维工作，都应该是针对这些对象的运维。如果运维操作脱离了对象，那就没有任何意义。同样，没有理清对象，运维自然不得章法。</p><p>比如我们说扩容，那就要先确定这里到底是服务器的扩容，还是应用的扩容，还是其他对象的扩容。你会发现，对象不同，扩容这个场景所实施的动作是完全不一样的。</p><p>Nginx自动扩容，怎么做？</p><p>如果把服务器的扩容套用到应用的扩容上去，必然会导致流程错乱。同时对于对象理解上的不一致，也会徒增无谓的沟通成本，造成效率低下。自然地，这种情况下的运维自动化不但不能提升效率，还会越自动越混乱。</p><p><strong>标准先行</strong>，于纷繁复杂中抽象出标准规范的东西，是我们后续一系列自动化和稳定性保障的基础。</p><p>标准化的套路：</p><ul><li>第一步，识别对象；</li><li>第二步，识别对象属性；</li><li>第三步，识别对象关系；</li><li>第四步，识别对象场景。</li></ul><p>按照这个思路，来分析从基础设施层面和应用层面应该识别出哪些运维对象。</p><h2><span id="基础设施层面的标准化">基础设施层面的标准化</span></h2><ul><li>第一步，识别实体对象，主要有服务器、网络、IDC、机柜、存储、配件等。</li><li>第二步，识别对象的属性，比如服务器就会有SN序列号、IP地址、厂商、硬件配置（如CPU、内存、硬盘、网卡、PCIE、BIOS）、维保信息等；网络设备如交换机也会有厂商、型号、带宽等信息。</li><li>第三步，识别对象之间的关系，比如服务器所在的机柜，虚拟机所在的宿主机、机柜所在的IDC等简单关系；复杂一点就会有核心交换机、汇聚交换机、接入交换机以及机柜和服务器之间的级联关系等，这些相对复杂一些，也就是我们常说的网络拓扑关系。</li></ul><p>把以上信息梳理清楚，通过ER建模工具进行数据建模，再将以上的信息固化到DB中，一个资源层面的信息管理平台就基本成型了。</p><p>但是，信息固化不是目的，也没有价值，只有信息动态流转起来才有价值。接下来，我们需要做的事情，就是识别出针对运维对象所实施的日常运维操作有哪些，也就是识别出运维场景是什么。</p><ul><li>第四步，还是以服务器为例，针对服务器的日常操作有采购、入库、安装、配置、上线、下线、维修等等。另外，可能还会有可视化和查询的场景，如拓扑关系的可视化和动态展示，交换机和服务器之间的级联关系、状态（正常or故障）的展示等，这样可以很直观地关注到资源节点的状态。</li></ul><p>完成了这些工作，接下来才是对上述场景的自动化开发。所以，在真正执行去做工具和自动化平台之前，其实是需要做好大量的基础准备工作的。</p><h2><span id="应用层面的标准化">应用层面的标准化</span></h2><ul><li>第一步，识别对象。<br>这个识别的过程是在做微服务架构设计和拆分的时候就确定下来的。所以严格地讲，它不应该是运维阶段才被识别出来的，而是在之前设计阶段就被识别和确认下来，然后延申到运维这里才对。</li><li><p>第二步，识别对象属性<br>一个应用是业务的抽象逻辑，所以会有业务和运维两个维度的属性。业务属性在业务架构时确定，这主要是需要业务架构师去识别的，但是它的运维属性就应该由运维来识别了。</p><p>一个应用应该具备哪些基本的运维属性呢？</p><ul><li><strong>应用的元数据属性</strong>，也就是简单直接地描述一个应用的信息，如应用名、应用Owner、所属业务、是否核心链路应用以及应用功能说明等，这里关键是应用名；</li><li><strong>应用代码属性</strong>，主要是编程语言及版本（决定了后续的构建方式），GitLab地址；</li><li><strong>应用部署模式</strong>，涉及到基础软件包，如语言包Java、C++、Go等；容器如Tomcat、JBoss等；</li><li><strong>应用目录信息</strong>，如运维脚本目录、日志目录、应用包目录、临时目录等；</li><li><strong>应用运行脚本</strong>，如启停脚本、健康检测脚本；</li><li><strong>应用运行时的参数配置</strong>，如运行端口、Java的JVM参数GC方式、新生代、老生代、永生代的堆内存大小配置等。</li></ul></li><li><p>第三步，识别对象关系</p><ul><li>第一类是应用与基础设施的关系，包括应用与资源、应用与VIP、应用与DNS等等的关系；</li><li>第二类是平行层面的应用与应用之间的关系，这里再细分下去就是应用服务或API与其他应用服务和API的依赖关系。全链路就是这样的工具平台，是用来处理应用间关系管理的。</li><li>第三类是应用与各类基础组件之间的关系，比如应用与缓存、应用与消息、应用与DB等等之间的关系。</li></ul></li><li><p>第四步，识别应用的运维场景。<br>应用创建、持续集成、持续发布、扩容、缩容、监控等；再复杂点的比如容量评估、压测、限流降级等。</p></li></ul><h2><span id="基础架构的标准化">基础架构的标准化</span></h2><h3><span id="常见的分布式基础架构组件">常见的分布式基础架构组件</span></h3><ul><li>分布式服务化框架，业界开源产品比如Dubbo、Spring Cloud这样的框架；</li><li>分布式缓存及框架，业界如Redid、Memcached，框架如Codis和Redis Cluster；</li><li>数据库及分布式数据库框架，这两者密不可分，数据库如Mysql、MariaDB等，中间件如淘宝TDDL、Sharding-JDBC等。当前非常火热的TiDB，就直接实现了分布式数据库的功能，不再额外选择中间件框架；</li><li>分布式的消息中间件，业界如Kafka、RbbitMQ、Active MQ以及RocketMQ等；</li><li>前端接入层部分，如四层负载LVS、七层负载Nginx或Apache，再比如硬件负载F5等</li></ul><h3><span id="基础架构组件的选型问题">基础架构组件的选型问题</span></h3><p>关于基础架构组件，业界可供我们选择的解决方案和产品非常多，选择多了反而不知道从何入手了。这么多的开源产品到底该选哪一个呢？</p><p>按正常的思路，一定是先组织选型调研，然后进行方案验证和对比，最后确认统一的解决方案。</p><p>要对基础架构由统一的规划和建设。原则上，每种基础组件只允许一种选型，至少就能满足90%甚至更多的应用场景。</p><p>比如数据库就只允许使用MySQL，然后版本统一，同时配套的中间件也必须统一，其他的关系型数据库没有特殊情况坚决不允许使用，如果遇到特殊情况具体分析。</p><h3><span id="其中运维的职责">其中运维的职责</span></h3><p>参与制定基础架构标准，并强势约束。</p><p>在这里运维作为线上稳定的Owner，发挥约束作用有可能会比业务架构师的角色更为有效。另外，由于历史原因或者其他种种因素造成的已有架构标准不统一的问题，是需要开发和运维共同合作去改造的。这里面如何保持良好的协作，制定统一的线路图也是非常重要的。所以这里强制约束是一方面，同时也要提供工具化的手段来支持开发的改造。</p><h2><span id="基础架构的服务化">基础架构的服务化</span></h2><h3><span id="为什么要做基础架构的服务化">为什么要做基础架构的服务化</span></h3><p>对基础架构组件做了统一标准之后，下一步要做的就是服务化。因为这些组件都只提供了简单的维护功能，还有很多都是命令行层面的维护，这时我们要做的就是把这些组件提供的维护API进行封装，以提供更加便捷的运维能力。</p><p>这里以Redis缓存为例：</p><ul><li>创建和容量申请；</li><li>容量的扩容和缩容，新增分片的服务发现以及访问路由配置；</li><li>运行指标监控，如QPS、TPS、存储数据数量等等；</li><li>主备切换能力等等。</li></ul><p>以上这些，假设都只是依赖Redis提供的原生能力来做，基本是不可维护的。所以必须要基于这些原生能力进行封装，结合运维场景，讲能力服务化，这样就大大提升了使用方的便利性。</p><p>同时，我们也可以看到，这个服务化的过程其实就是PaaS化的过程。换言之，如果我们能把基础架构组件服务化完成，我们的Paas平台就基本成型了。</p><h3><span id="运维的职责">运维的职责</span></h3><p><strong>基础架构的服务化平台开发，目标是平台自助化，让开发依赖平台的能力自助完成对基础组件的需求，而不是依赖运维的人</strong>。这个事情是驱动运维转型和改进的动力，也是运维能够深入了解架构组件细节的有效途径。</p><h1><span id="如何从生命周期的视角看待应用运维体系建设">如何从生命周期的视角看待应用运维体系建设</span></h1><h2><span id="应用的生命周期分析">应用的生命周期分析</span></h2><p>在一个场景下有多个对象时，就一定要找到那个核心的运维对象，这个核心对象的生命周期就会涵盖其他附属运维对象的子生命周期。在整个运维体系中，或者说软件运行阶段的核心对象，就是应用。</p><p>以应用为本。对应用的生命周期阶段进行分解，大致分为五个部分：</p><ol><li><p>应用的创建阶段</p><p>这个阶段最重要的工作，是确认应用的基础信息和与基础服务的关系，要同时固化下来，从应用创建之初，就讲应用与各类基础服务的生命周期进行挂钩。<br>对于同一类的应用，只需要做一次标准化即可，后续完全可以形成模板固化到工具平台上。<br>同时，另外一个很重要的工作，就是要开启与应用相关的各类基础服务的生命周期。比如这个应用需要用到缓存、消息队列和DB等，也可能需要DNS服务、VIP配置等，这些就要从应用创建这个动作延申出去，启动这些关联基础服务的创建。</p></li><li><p>应用的研发阶段</p><p>主要是业务逻辑实现和验证的阶段。针对业务逻辑层面的场景就是开发代码和质量保证，但是这个过程中就会涉及的代码的提交合并、编译打包以及在不同环境下的发布部署过程。同时，开发和测试在不同的环境下进行各种类型的测试，比如单元测试、集成测试以及系统测试等等，这整个过程就是我们常说的持续集成。</p><p>所以，这个阶段，我们要做的最重要的一个事情，就是为研发团队打造完善的持续集成体系和工具链支持。</p></li><li><p>应用的上线阶段</p><p>这是个过渡阶段，从应用创建过渡到线上运行。创建阶段，应用的基础信息和基础服务都已经到位，接下来就是申请到应用运行的服务器资源，然后将应用软件包发布上线运行，这个动作在下面的运行阶段也会持续迭代。</p></li><li><p>应用的运行阶段</p><p>这是应用生命周期中最重要、最核心的阶段。<br>从运维角度来看，应用在线上运行起来之后就已经变成一个线上运行的进程，那这个进程形态的应用应该有什么样的属性呢？</p><p>这个时候需要应用线上运行的各种指标的输出。这个阶段，应用最重要的属性就是应用本身以及相关联的基础服务的各项运行指标。</p><p>这里，我们需要制定每个运维对象的SLI、SLO和SLA，同时要建设能够对这些指标进行监控和报警的监控体系。</p><p>从业务角度看，应用是线上业务逻辑的执行载体，但是我们的业务需求是在不断变化和迭代的，所以就需要不断地去迭代更新我们的线上应用，这里仍然会依赖到上述应用研发阶段的持续集成过程，并最终与线上发布形成持续交付这样一个闭环体系。</p><p>从运行阶段应用的关系看，除了它跟基础服务之间相对固化的关系外，应用跟应用、以及应用包含的服务之间的调用关系也非常重要，而且这个关系可能随时都在变化。这个时候，我们应用之间依赖管理和链路跟踪的场景就出现了。</p><p>同时，应用线上运行还会面临外部业务量的各种异常变化，以及应用自身所依赖的基础实施、基础服务以及应用服务的各种异常状况。</p></li><li><p>应用的销毁阶段</p><p>如果应用的业务职责不存在了，应用就可以下线销毁了。但是，这里不仅仅是应用自身要销毁，围绕着某个应用所产生出来的基础设施、基础服务以及关联关系都要一并清理，否则将会给系统中造成许多无源的资源浪费。</p></li></ol><p>结合之前所讲的标准化内容，我们就找到了做运维架构的切入点，套路也就有了，总结一下就是：</p><p><strong>从生命周期入手，划分阶段，提炼属性，理清关系，固化基础信息，实现运维场景。</strong></p><p>在思考问题和设计解决方案的时候，一定要从实际出发、从问题出发、从基础出发，理清自己的需求和痛点，然后再去寻求解决方案。</p><p>借鉴业界思路，千万不要一上来就去套用别人的解决方案。因为别人的思路和解决方案往往是建立在一个非常稳固的基础之上的，而这些基础，往往因为太基础而一带而过，甚至是略去不讲的。一旦忽略了这一点，再优秀的解决方案也是无源之水、无本之木，是实现不了的。</p><h1><span id="cmdb">CMDB</span></h1><p>当我们识别出运维对象和对象之间的关系，并形成了统一的标准之后，接下来要做的事情就是将这些标准固化，固化到某个信息管理平台中，也就是我们常说的配置管理，也就是CMDB（Configuration Management DataBase）。</p><h2><span id="cmdb缘起">CMDB缘起</span></h2><p>CMDB并不是一个新概念，它源于ITIL（Information Technology Infrastructure Library）。而ITIL这套理论体系在80年代末就已经成型，并在当时和后来的企业IT建设中作为服务管理的指导理论得到广泛推广和实施。</p><h2><span id="传统运维思路下的cmdb">传统运维思路下的CMDB</span></h2><p>按照ITIL的定义：</p><blockquote><p>CMDB，配置管理数据库，是与IT系统所有组件相关的信息库，它包含IT基础架构配置项的详细信息。</p></blockquote><p>这是一个很宽泛的概念描述，实际上并不具备可落地的指导意义。</p><p>同时，CMDB是与每个企业具体的IT软硬件环境、组织架构和流程强相关的，这就决定了CMDB一定是高度定制化的体系。虽然我们都知道它不仅仅是一个存储信息的数据库那么简单，但是它的具体形态是什么样子的，并没有统一的标准。</p><p>从传统IT运维的角度来看，运维的核心对象是资源层面，所谓的基础架构也就是网络设备和硬件设备这个层面；各种关联和拓扑关系，基本也是从服务器的视角去看。所以更多地，我们是把CMDB建设成为一个以设备为中心的信息管理平台。</p><p>这也是当前绝大多数公司在建设运维平台时最优先的切入点，因为这些运维对象都是实体存在的，是最容易被识别的和管理的；像应用和分布式中间件这种抽象的逻辑对象反而是不容易被识别的。</p><p>这种形态，如果是在软件架构变化不大的情况下，比如单体或分层架构，以服务器为中心去建设是没有问题的。因为无论设备数量也好，还是申请回收这些变更也好，都是很有限的，也就是整个IT基础设施的形态变化不大。</p><p>在早期，并没有太多人提及CMDB，也没有人提出把它作为核心部件去建设，在当时，CMDB这个概念并不具备实践意义，管理的方式方法也就停留在原始的Excel表格中。</p><p>高大上的ITIL体系更多的是被当作流程规范来落地的，真正体现在技术方案和技术产品上的落地并不多。</p><h2><span id="互联网运维体系下的cmdb">互联网运维体系下的CMDB</span></h2><p>进入互联网时代，随着互联网运维力量的崛起，CMDB这个概念也真正得到了落地实践，从理论概念的方法论阶段过渡到了具备具体技术方案的可实施阶段，而且得到了业界的持续分享和传播。</p><p>不过，值得注意的是，“此CMDB”已经非“彼CMDB”。传统运维阶段，我们更多是以设备为核心进行管理，都是到了互联网技术阶段，这个核心就变了，变成了应用这个核心对象。</p><p>至于原因，主要还是互联网技术的快速发展，大大推进了微服务技术架构的落地和实践，这种场景下，应用各维度的管理复杂度、应用的复杂度就逐渐体现出来了，所以我们的很多运维场景就开始围绕着应用来开展。</p><p>与此同时，云计算技术也在蓬勃发展，逐步屏蔽了IDC、网络设备以及硬件服务器这样的底层基础设施的复杂度，有公有云或私有云厂商来专注聚焦这些问题，让我们的运维不必再花过多的精力在这些基础设施上面；同时，单纯以硬件为核心的CMDB形态也被逐步弱化。</p><p>所以，此时的CMDB，仍然可以叫做配置管理数据库，但是这个配置管理的外延已经发生了很大的变化。之前所指的简单的硬件资源配置管理，只能算是狭义的理解；从广义上讲，当前的应用以及以应用为核心的分布式服务化框架、缓存、消息、DB、接入层等基础组件，都应该纳入这个配置管理的范畴。</p><p>所以在这个时期，我们提到的运维自动化，远不是自动化的服务器安装部署交付或网络自动化配置这种单一场景，而是出现了持续交付、DevOps、SRE等更适合这个时代的对运维职责的定义和新的方法论。</p><h1><span id="如何在cmdb中落地应用的概念">如何在CMDB中落地应用的概念？</span></h1><h2><span id="如何有效组织和管理应用">如何有效组织和管理应用</span></h2><p>微服务架构下会有很多应用产生出来，少则十几、几十个，多则上百甚至上千个。这时我们面临的第一个问题就是如何有效地组织和管理这些应用，而不是让它们在各处散乱，命名方式和层次结构可能还不统一。</p><p>用”服务树”，有效组织和管理应用的方式，就是把它组织成一个树形的层次结构。</p><p>基于业务维度的拆分，对应产生了我们的应用拆分原则。比如对于电商公司，大的维度会有电商、支付、广告、流量和搜索等业务领域；进一步，电商业务领域里最典型的会有用户、会员、商品、交易、商家、店铺以及物流等；这里面还可以再进一步细分，比如商品会有详情、SKU、SPU、库存、评价、标签等。</p><p>讲到这里，我们在看一下技术团队的组织架构，基本上是对应着整个业务技术架构的拆分的。<strong>也就是业务架构决定了技术架构</strong>，<strong>而技术架构又决定了一个研发团队的组织架构</strong>，这个组织架构中不同的团队单元分别承担着对应业务的需求开发和实现职责。</p><p>上面这个组织架构建设的逻辑和思路，也是我们在组建团队和职责划分时可以参考的。</p><p>这样一个逻辑讲下来，我们的应用管理思路其实也就明晰了：产品线-业务团队-应用。</p><p>对于应用名定义，要设定规范。</p><p>到了软件运维阶段，运维工作是否可以高效地组织开展，很大程度上，在前面的业务架构拆分阶段就决定了。也就是业务架构拆分得是否合理、职责是否明晰，决定了后续团队组织架构是否合理、团队职责是否明晰。如果这点没做好，到了运维阶段必然就是混乱的。</p><h2><span id="应用的集群服务分组建设">应用的集群服务分组建设</span></h2><p>为什么会有集群服务分组呢？我们来看这么几个需求场景。</p><ul><li><p>场景一：多环境问题</p><p>我们常见的环境会有开发联调环境、集成测试环境、预发环境、线上环境等等。</p></li><li><p>场景二：多IDC问题</p><p>对于大型互联网业务，会做业务单元化，或者有海外业务拓展需求的场景，我们会在多个IDC机房部署应用，应用代码是相同的，但是配置可能会不同。</p></li><li><p>场景三：多服务分组问题</p><p>这个场景就跟具体业务场景相关了。举个例子，比如商品中心IC这样一个核心应用，对外会有商品详情、交易下单、订单、购物车、评价、广告、秒杀活动、会场活动、商家、店铺等一系列应用依赖它，但是这些依赖它的应用优先级是不一样的。</p><ul><li>核心应用和非核心应用：比如交易支付链路上的应用属于核心应用，任何时候都必须要优先保障，但是对于评价、商家和店铺这些应用优先级就低一些。发过来理解就是一个应用出现故障，是不是会影响业务收入，如果影响就属于核心应用，如果不是或者影响非常小，那就属于非核心应用。所以IC这个应用下面，就会有IC的交易分组，IC的广告分组、IC的电商分组，这些分组就会相对固定和静态。</li><li>场景因素决定：这个对于电商就会比较典型，比如大促时的秒杀场景，对于参加秒杀活动的商品，瞬时的访问量就会非常大，而不参加活动的商品就不会有这么大的访问量。所以这时为了隔离较大的流量，就需要有多个不同的秒杀IC分组，从资源层面进行隔离；同时上层秒杀活动的应用在配置中心配置依赖时，就要配置到对应的秒杀IC集群分组上，这样即使秒杀IC出现问题，也不会影响正常的商品IC访问。所以根据场景，不同阶段就会有IC的大促秒杀分组，这种类型的分组就需要根据实际的业务场景来决定，是个动态调整的过程，需要开发和运维一起来讨论和验证。</li></ul></li></ul><h2><span id="cmdb在基础服务体系中的核心位置">CMDB在基础服务体系中的核心位置</span></h2><p>以应用为核心，CMDB中会保存“应用-分组-资源”的对应关系，这个关系对于周边系统来说都是需要的，举例如下：</p><ol><li><p>监控系统</p><p>我们需要以上的对应关系，监控到每个应用、每个集群以及每台机器上的关键信息。</p></li><li><p>发布系统</p><p>我们需要讲每个应用对应的代码进行编译打包，然后发布到对应集群的主机上，也需要这个对应关系。</p></li><li><p>服务化框架</p><p>需要依赖应用和集群分组两个信息，其中主要是对应用名和集群分组名的依赖，对于服务化框架来说，更多的是通过其配置管理中心注册的应用名，来实现应用的服务和API管理，这里要做到与CMDB统一。同样，像LVS和Nginx这样的四七层负载，以及ZK这样的开源分布式配置管理，凡是涉及服务注册、服务发现以及服务上下线的基础服务，都是类似思路。</p></li><li><p>基础服务中</p><p>如分布式DB、分布式缓存和消息等，就需要应用的应用名，以及应用与资源IP的对应关系，或者集群分组与IP的对应关系。</p><ul><li>应用名，是因为要建立应用与分布式服务实例之间的关系。如应用与缓存NamSpace的对应关系，应用与消息Topic的对应关系等，以便于这些基础服务的生命周期管理和自动化开发。</li><li>应用与资源的对应关系，是因为有些核心资源是要做ACL访问控制的。比如对于用户、交易或支付这样非常敏感的数据，它们对应的数据库就不允许随意连接，而应该是仅限于授权过的应用访问。这时就要针对应用对应的IP地址进行白名单配置。一方面，可以通过分布式DB中间件进行配置；另一方面，也可以通过在DB层面进行设置，比如MySQL就可以直接配置白名单策略；同时也可以在机器的iptables上配置，至于如何配置就看具体需求了，但是无论怎样，应用与资源的对应关系是非常重要的。</li></ul></li><li><p>稳定性保障平台，或者叫访问治理平台</p><p>针对系统的稳定性，我们会在应用中做很多的降级限流和开关预案策略，这些都是跟应用直接关联的。而且按照我们前面介绍的，不同的集群分组，策略可能会有不同，所以又会跟集群分组相关。同时，这些策略最终下发到具体服务器上运行的应用实例上，所以这里就会需要应用、集群分组以及对应的资源关系。</p></li></ol><h1><span id="持续交付">持续交付</span></h1><p>前面，我们介绍了非常基础的运维建设环节。如果我们想要这些运维基础建设发挥更大的作用和价值，就需要针对运维场景进行场景化设计和自动化，让效率和稳定性真正提升上来。</p><p>基础的事情做好之后，我们就要进入效率提升的运维场景自动化阶段了。</p><p>这一阶段，首先要把持续交付做好。</p><p>为什么要先做持续交付？如果说我们完成了一些运维职责范围内的自动化工具，提升的是运维效率的话，那么，<strong>做持续交付就是提升整个研发体系效率的关键</strong>。</p><p>做持续交付的价值表现在哪里？</p><p>持续交付覆盖了应用的整个生命周期，涉及产品、开发、测试、运维以及项目管理等相关方面。从生命周期出发，自然就会牵出整个自动化的全貌，就会有从全局着眼的规划设计，这时无论是在开发还是运维过程中存在的问题，都会完完整整地暴露出来。那么，应该以什么样的主线开展？各方应该如何配合？应该以怎样的优先级明确任务？这些问题就都清楚了。同时，也避免了各个环节只把注意力放在各自职责范围内的事情上，而忽略了整体的配合。所以，做好持续交付，对于整个研发体系意义重大。</p><p>我们面临的实际场景是怎样的呢？</p><p>我们知道，随着业务复杂度的升高，不管是分层架构，还是微服务架构，都会带来一个最明显的变化，那就是应用数量增多，有时甚至多达几十个、几百个。不同的应用就有不同的代码、依赖和配置，为了协同多应用之间的在线发布，我们还要做到服务能够平滑地进行上下线切换。同时，为了最大限度地降低发布风险，我们还需要继续多环境下的验证，以及上线后的灰度策略等等。</p><p>应对这一切，如果只是手工维护，或者利用简单的脚本进行维护，都不能保证正常运作。这个时候，我们必须有一系列的流程、机制和工具链来支持和保障。</p><h2><span id="什么是持续交付">什么是持续交付？</span></h2><p><strong>持续交付代表着从业务需求开始到交付上线之后的端到端的过程</strong>。（业务/产品、开发、测试、运维的协作）</p><h2><span id="持续交付的关键点">持续交付的关键点</span></h2><ol><li><p>配置管理</p><p>这一部分会利用到我们前面讲过的标准化和CMDB打下的基础，同时还会有更大的外延，比如环境配置、代码配置以及依赖管理等等。</p><p>配置管理是非常关键的基础工作。有一点值得注意，那就是标准化是一个持续的过程。我们不太可能在一开始就把所有运维对象、属性和关系全部考虑清楚，面面俱到是不太现实的，所以，一定要具备标准化的意识，在开展运维工作的过程中，持续不断地用这个思路去标准化新出现的对象。先标准，再固化，如何自动化。</p></li><li><p>需求拆解</p><p>需求拆解这个工作跟业务需求部门和业务开发有更直接的关系。在这里，运维需要做的是，明确需求拆解的粒度和我们最终发布上线的粒度相匹配。</p></li><li><p>提交管理</p><p>需求拆解完成后，就进入到开发阶段，开发完成后向代码库中提交代码，这个过程中代码分支的合并策略选择就是提交管理。</p></li><li><p>构建打包</p><p>这一部分是指将提交的代码编译成可发布的软件包。</p></li><li><p>自动化测试</p><p>自动化测试包括功能测试和非功能性测试。对于运维来说，会更注重非功能方面的特性。</p></li><li><p>部署发布</p><p>这一部分是指发布到不同的环境，如开发环境、预发环境、线上Beta以及线上全量环境。针对不同的环境，发布策略和注意事项也会不同。</p></li></ol><p>配置管理、提交管理、构建和部署发布是持续交付的重中之重，是关键路径，是从开发代码开始，到发布上线的必经之路。当时，因为这个几个环节出现了问题，不能解决，运维同学经常做手工发布，这样效率就跟不上，还经常出现各种问题。后来，我们就是先从这几个环节入手，把阻塞的问题解决掉，然后在这个主流程上不断增加外围能力，让整个流程的功能更加丰富和全面。整个系统也从原来的只具备持续部署发布功能的平台，逐步演进为具有持续交付能力的平台。</p><p>下面详细展开说明：</p><h2><span id="配置管理">配置管理</span></h2><p>按照持续交付的理念，这里所说的配置管理范围会更广，主要有以下几个部分。</p><ul><li>版本控制</li><li>依赖配置</li><li>软件配置</li><li>环境配置</li></ul><p>讲持续交付，一上来就先讲配置管理，主要还是想强调：配置管理是基础，是关键。勿在浮沙筑高台，我们做工具平台或系统，一定要重视基础的建设。</p><p>同时，这里还有一个前提，就是一定要做到代码和配置的分离。不要让配置写死在代码里，需要依靠严格的规范和约束。同时，对于那些因历史原因遗留在代码中的配置，要多花时间和精力把配置剥离出来，做这项工作没有什么好的方法或经验，只能多上心，多投入些精力。</p><h3><span id="版本控制">版本控制</span></h3><p>版本控制的主要作用是保证团队在交付软件的过程中能够高效协作，版本控制提供了一种保障机制。</p><p>版本控制及其工具是必不可少的，因为这是开发团队协作最基础的工具。</p><h3><span id="依赖管理">依赖管理</span></h3><p>以Java为例，即使运行一个非常简单的Web应用，都会有大量的jar包依赖。如果人工去管理这些依赖，基本上是不可能的，所以就需要有依赖管理的工具。</p><p>对于Java来说，依赖管理工具有Ant、Maven和Gradle。</p><p>以Maven为例，大致用法是建立一个本地Maven源，构建时会优先从本地源中获取依赖包，本地源中没有对应的依赖时，会从公网下载，同时缓存到本地。</p><h3><span id="软件配置">软件配置</span></h3><ol><li><p>代码配置</p><p>代码配置是跟代码运行时的业务逻辑相关的。比如应用的服务接口、并发线程数、超时时间等这些运行时参数；还有类似于业务或技术上的开关，比如商品评论是否开放、优惠时间段设置等。</p></li><li><p>应用配置</p><p>应用配置就是应用这个对象的属性和关系信息。我们把应用配置放到持续交付这个场景中进行分析，对于这个配置可以细分为：</p><ul><li>应用构建时配置，比如它的编程语言、Git地址以及构建方式等；</li><li>应用的部署配置，源代码目录、应用日志目录、Web日志目录、临时目录、脚本目录等；</li><li>应用的运行配置，应用启停、服务上下线方式、健康检测方式等；</li><li>应用运行时与基础组件的关联关系，比如其依赖的DB、缓存、消息以及存储的IP地址、域名、端口、用户名或Token等。</li></ul></li></ol><h2><span id="多环境建设">多环境建设</span></h2><h2><span id="线上环境建设">线上环境建设</span></h2><h2><span id="持续交付中的流水线模式">持续交付中的流水线模式</span></h2><h1><span id="混合云">混合云</span></h1><h2><span id="关于混合云">关于混合云</span></h2><p>随着技术趋势的发展，这个概念的内涵和外延也在不断发生着变化。</p><p>从字面上理解，混合云即公有云和私有云的混合搭配。</p><p>但是随着公有云服务越来越丰富，我们对于公有云的应用也不再仅仅限于资源层面，二更多地体现在云服务层面。</p><p>以CDN为例：</p><p>我们使用CDN服务，其实是云服务最早被应用的典型形态。在很长时间内，我们并没有意识到这就是云服务。但是，这种使用模式，从云的特性来讲，就是混合云模式。</p><p>我们所经历的几个基础设施建设阶段</p><ul><li><p>第一个阶段，完全托管IDC模式。我们选择与电信运营商或者第三方ISP合作，租赁其IDC机房中的机柜。而其他主机硬件和网络设备都是我们自行采购，然后放入机房中进行托管。</p></li><li><p>第二个阶段，资源短期租赁模式。因为电商大促的例行化，以及峰值流量的激增，导致我们短时资源需求量庞大。如果再靠一次性采购模式，付出的成本巨大，且后期成本闲置，造成严重的浪费。</p><p>我们曾跟运营商或第三方ISP谈过一些短期租赁合作。</p><p>这种合作模式，确实帮助我们在资源紧张和成本优化方面，解决了很大的难题。这种模式起到的作用，很大程度上满足了我们对弹性的需求，可以称之为“人肉云”或者“人工云”。</p></li><li><p>第三个阶段，同城混合云模式。这些年运营商和ISP服务商也在做自己的公有云体系，所以随着他们服务的不断完善，后来为了能够提升交付效率，我们也会尝试使用他们的公有云业务。</p><p>同城混合云模式，作为运营商和ISP服务商，他们的云资源可以和我们在同一机房或同城机房。这种模式最大的优势就是可以与我们的IDC网络专线拉通，大大降低网络延时，网络质量相对稳定，同时成本也相对较低。</p><p>如果是跨城甚至是跨省，就会频繁发生网络抖动、丢包这些问题。对于时延敏感的服务，是完全满足不了要求的，且微服务间频繁调用产生的大流量带宽需求，成本也是巨大的。</p><p>所以这种情况下，虽然公有云的各项产品和服务相对完善，但是如果在对应的城市没有公有云节点，或者距离较远，又或者专线质量不高，就基本没法满足我们规模化使用的场景。</p><p>但也不是全部无法满足。通过公有云建设CDN和二级CDN体系，虽然没有专线，但仍然可以满足部分业务场景。</p></li><li><p>公有云体系内混合云模式。从长远角度考虑，为了能够更加全面和深入地利用好云计算的产品技术，我们整体搬迁到了腾讯云。</p><p>这个阶段的初期，我们使用的还是完全独立的物理机资源。这种资源使用模式与之前托管IDC模式相比，除硬件和网络外，操作系统和各项技术栈还完全是由我们自己运维。</p><p>之所以这样做，还是为了保证迁移过程的平稳。因为我们自身的技术体系和架构已经非常庞大，也有较高的复杂度。</p><p>要想在另外一套基础设施上将这套精密的体系部署、测试、运行起来，同时还要保证各项性能指标以及系统容量不出问题 ，项目难度就已经非常高了。而这样做可以很好地防止软件架构发生变化，避免各种复杂因素交织在一起导致的因为稳定性的不可控。</p><p>之前我看到有很多人批评，甚至是贬低这种公有云提供的独立物理机资源的模式，认为这时换汤不换药，或者认为这是技术含量太低、技术水平不足的表现。但是我认为这种理解还是太片面。</p><p>单纯从技术角度来讲，这种模式或许没有体现公有云的特性，但是从实际业务场景和实际客户需求来讲却是必要的。而且对于类似蘑菇街这样有着大规模业务体量和复杂技术架构的产品来说，它还满足了用户的过渡需求。</p><p>所以，我认为腾讯云在这一方面还是体现了“客户第一”的意识的。</p><p>当然，搬迁到腾讯云之后，下一阶段，我们必然会利用更多的云资源和云服务。比如无状态的web服务器或者微服务应用，在大促时完全可以利用云的弹性优势进行快速的资源扩缩容。</p><p>但是对于数据库或大数据这样的存储类业务，因为它们本身又是支持业务运行的核心基础设施，所以短期内我们仍然还是采用独占物理机的模式。主要是基于下面两方面进行考量：</p><ul><li><p>技术架构匹配问题。以数据库为例，我们自研了分布式数据库中间件和大量的工具，比如对分库分表的支持和数据迁移转换等待。还针对具体的业务场景和特性在数据库和操作系统层面做了大量的优化工作，包括但不限于各类参数的调优，以及部分特性定制。</p><p>再者，云上资源也无法规模化地满足我们对硬件的特定需求，所以我们在这种模式下，就很难一下子将云服务利用起来，而其他的分布式组件也会存在类似问题。</p><p>归根结底，这还是云上的技术体系和原有的业务技术体系不匹配的矛盾所导致的，需要二者花更多的时间来磨合。同时，这也决定了在未来很长一段时间内，混合云模式才是最佳实践模式。</p></li><li><p>数据安全问题。一些有政策要求或政策限制的业务，需要慎重考虑这个问题。</p></li></ul></li></ul><p>不管如何选择和使用，我们一定还是要以满足业务场景为出发点，脱离了这一点，单纯准求技术深度和复杂度是没有意义的。</p><h1><span id="面向应用层的云架构解决方案">面向应用层的云架构解决方案</span></h1><p>spring Cloud如何解决应用层的云架构问题。</p><p>Spring Boot可以快速开发单个微服务应用，SpringCloud则提供一系列的服务治理框架，比如服务注册、服务发现、动态路由、负载均衡以及熔断等等能力，可以将一个个独立的微服务作为一个整体，进行很好的管理和维护。</p><p>Spring Cloud框架中云的影子</p><h1><span id="cdn和云存储-云生态">CDN和云存储 云生态</span></h1><h1><span id="页面静态化架构和二级cdn建设">页面静态化架构和二级CDN建设</span></h1><h1><span id="弹性伸缩">弹性伸缩</span></h1><h2><span id="弹性伸缩的主体是谁">弹性伸缩的主体是谁？</span></h2><p>做运维和做架构的思路是相通的，我们碰到问题后，一定要找到问题的主体是什么，通过问题找主体，通过主体的特性制定问题的解决方案。</p><p>对于运维，一定要准确识别出日常运维过程中不同的运维对象，然后再进一步去分析这个对象所对应的运维场景是什么，进而才是针对运维场景的分解和开发。</p><p>弹性伸缩其实是一个运维场景，但是我们并没有定义这个场景的主体是谁。我们来假定以下几种主体：</p><ul><li><p>服务器的弹性伸缩。针对这个场景，假设业务是运行在私有云或公有云上，那我们只要能够通过云平台的API申请和释放资源，申请时初始化我们的操作系统，释放是销毁资源就可以。不过，在私有云资源下，为了能够保障弹性，我们必须自己提取采购、上架、装机、配置然后交付资源，需要大量的准备工作，公有云上就省去这些步骤，可以即拿即用。</p></li><li><p>应用的弹性伸缩。这个场景下其实是默认包含第一步的，就是我们首先必须要拿到应用运行的服务器资源才可以，这一步做到了，下面就是应用的部署、启动以及服务上线接入流量。</p></li><li><p>业务的弹性伸缩。我们可以再进一步思考，通常一个业务可能会包括多个应用，所以为了保障整个业务容量充足，这个时候扩容单个的应用是没有意义的，所以这时要做的就是扩容多个应用，但是这里面就会有一个顺序问题，先扩哪个，后扩哪个，哪些又是可以同时扩容而不会影响业务正常运行的，再进一步，业务承载的服务能力提升了，那网络带宽、缓存、DB等等这些基础设施需不需要也同时扩容呢？</p></li></ul><h1><span id="稳定性保障">稳定性保障</span></h1><h1><span id="容量规划">容量规划</span></h1><h1><span id="限流降级">限流降级</span></h1><h1><span id="开关预案">开关预案</span></h1><h1><span id="全链路跟踪">全链路跟踪</span></h1><h1><span id="故障">故障</span></h1><h1><span id="安全">安全</span></h1>]]></content>
    
    <summary type="html">
    
      在微服务的架构模式下，我们的运维视角一定转到应用这个核心概念上来，一切要以应用的角度分析和看待问题。
    
    </summary>
    
    
      <category term="运维" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Nginx源码分析之内存池管理</title>
    <link href="http://yoursite.com/2017/02/26/Nginx%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%86%85%E5%AD%98%E6%B1%A0%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2017/02/26/Nginx源码分析之内存池管理/</id>
    <published>2017-02-26T03:51:31.000Z</published>
    <updated>2019-02-28T00:47:14.845Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#内存池管理">内存池管理</a><ul><li><a href="#概述">概述</a></li><li><a href="#内存池基本结构">内存池基本结构</a></li><li><a href="#内存池操作">内存池操作</a><ul><li><a href="#创建内存池">创建内存池</a></li><li><a href="#销毁内存池">销毁内存池</a></li><li><a href="#重置内存池">重置内存池</a></li><li><a href="#内存分配">内存分配</a><ul><li><a href="#小块内存分配">小块内存分配</a></li><li><a href="#大块内存分配">大块内存分配</a></li></ul></li><li><a href="#cleanup资源">cleanup资源</a></li></ul></li></ul></li></ul><!-- tocstop --><h1><span id="内存池管理">内存池管理</span></h1><h2><span id="概述">概述</span></h2><p>Nginx使用内存池管理内存，把内存分配归结为大内存分配和小内存分配。</p><ul><li>不会直接在内存池上分配内存来满足大块内存的分配请求，而是直接向系统申请一块内存（直接使用malloc分配），然后将这块内存挂到内存池头部的large字段下。</li><li>小块内存的分配，则是从已有的内存池数据区中去分配。</li></ul><p>内存管理相关文件：</p><ol><li><p><code>src/os/unix/ngx_alloc.h/.c</code></p><ul><li>内存相关操作，封装了最基本的内存分配函数</li><li>如<code>free/malloc/memalign/posix_memalign</code>，分别被封装为<code>ngx_free/ngx_alloc/ngx_calloc/ngx_memalign</code><ul><li>ngx_alloc: 封装malloc分配内存</li><li>ngx_calloc：封装malloc分配内存，并初始化空间内容为0</li><li>ngx_memalign：返回一个基于指定alignment的大小为size的内存空间，且其地址为alignment的整数倍，alignment为2的幂。</li></ul></li></ul></li><li><p><code>src/core/ngx_palloc.h/.c</code></p><p>​    封装创建/销毁内存池，从内存池分配空间等函数</p></li></ol><p>Nginx内存分配流程图如下：（其中size为用户请求分配内存的大小，pool是现有内存池）</p><p><img src="/2017/02/26/Nginx源码分析之内存池管理/1551024279337.png" alt="1551024279337"></p><h2><span id="内存池基本结构">内存池基本结构</span></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 内存池结构 */</span></span><br><span class="line"><span class="comment">/* 文件 core/ngx_palloc.h */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span><span class="comment">/* 内存池数据结构模块 */</span></span><br><span class="line">    u_char               *last; <span class="comment">/* 当前内存分配的结束位置，即下一段可分配内存的起始位置 */</span></span><br><span class="line">    u_char               *end;  <span class="comment">/* 内存池的结束位置 */</span></span><br><span class="line">    <span class="keyword">ngx_pool_t</span>           *next; <span class="comment">/* 指向下一个内存池 */</span></span><br><span class="line">    <span class="keyword">ngx_uint_t</span>            failed;<span class="comment">/* 记录内存池内存分配失败的次数 */</span></span><br><span class="line">&#125; <span class="keyword">ngx_pool_data_t</span>;  <span class="comment">/* 维护内存池的数据块 */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_s</span> &#123;</span><span class="comment">/* 内存池的管理模块，即内存池头部结构 */</span></span><br><span class="line">    <span class="keyword">ngx_pool_data_t</span>       d;    <span class="comment">/* 内存池的数据块 */</span></span><br><span class="line">    <span class="keyword">size_t</span>                max;  <span class="comment">/* 内存池数据块的最大值 */</span></span><br><span class="line">    <span class="keyword">ngx_pool_t</span>           *current;<span class="comment">/* 指向当前内存池 */</span></span><br><span class="line">    <span class="keyword">ngx_chain_t</span>          *chain;<span class="comment">/* 指向一个 ngx_chain_t 结构 */</span></span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>     *large;<span class="comment">/* 大块内存链表，即分配空间超过 max 的内存 */</span></span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span>   *cleanup;<span class="comment">/* 析构函数，释放内存池 */</span></span><br><span class="line">    <span class="keyword">ngx_log_t</span>            *<span class="built_in">log</span>;<span class="comment">/* 内存分配相关的日志信息 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* 文件 core/ngx_core.h */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_s</span>   <span class="title">ngx_pool_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_chain_s</span>  <span class="title">ngx_chain_t</span>;</span></span><br></pre></td></tr></table></figure><p>大块内存分配的数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_large_s</span> <span class="title">ngx_pool_large_t</span>;</span>  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_large_s</span>&#123;</span>  </span><br><span class="line">          <span class="keyword">ngx_pool_large_t</span>  *next;    <span class="comment">//指向下一块大块内存  </span></span><br><span class="line">          <span class="keyword">void</span>    *alloc;             <span class="comment">//指向分配的大块内存  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其他数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*ngx_pool_cleanup_pt)</span><span class="params">(<span class="keyword">void</span> *data)</span></span>;    <span class="comment">//cleanup的callback类型  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_cleanup_s</span> <span class="title">ngx_pool_cleanup_t</span>;</span>  </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_cleanup_s</span>&#123;</span>  </span><br><span class="line">    ngx_pool_cleanup_pt handler;  </span><br><span class="line">    <span class="keyword">void</span>    *data;              <span class="comment">//指向要清除的数据  </span></span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span> *next;   <span class="comment">//下一个cleanup callback  </span></span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>  </span><br><span class="line">    <span class="keyword">ngx_fd_t</span>   fd;  </span><br><span class="line">    u_char    *name;  </span><br><span class="line">    <span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>;  </span><br><span class="line">&#125; <span class="keyword">ngx_pool_cleanup_file_t</span>;</span><br></pre></td></tr></table></figure><p>内存池基本结构之间的关系如下图所示：</p><p><img src="/2017/02/26/Nginx源码分析之内存池管理/1551028372193.png" alt="1551028372193"></p><p><img src="/2017/02/26/Nginx源码分析之内存池管理/1551028537439.png" alt="1551028537439"></p><h2><span id="内存池操作">内存池操作</span></h2><h3><span id="创建内存池">创建内存池</span></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建内存池，该函数定义于 src/core/ngx_palloc.c 文件中 */</span></span><br><span class="line"><span class="keyword">ngx_pool_t</span> *</span><br><span class="line">ngx_create_pool(<span class="keyword">size_t</span> size, <span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">ngx_pool_t</span>  *p; <span class="comment">/* 执行内存池头部 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 分配大小为 size 的内存 */</span></span><br><span class="line">    <span class="comment">/* ngx_memalign 函数实现于 src/os/unix/ngx_alloc.c 文件中 */</span></span><br><span class="line">    p = ngx_memalign(NGX_POOL_ALIGNMENT, size, <span class="built_in">log</span>);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 以下是初始化 ngx_pool_t 结构信息 */</span></span><br><span class="line"></span><br><span class="line">    p-&gt;d.last = (u_char *) p + <span class="keyword">sizeof</span>(<span class="keyword">ngx_pool_t</span>);</span><br><span class="line">    p-&gt;d.end = (u_char *) p + size;</span><br><span class="line">    p-&gt;d.next = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    size = size - <span class="keyword">sizeof</span>(<span class="keyword">ngx_pool_t</span>);   <span class="comment">/* 可供分配的空间大小 */</span></span><br><span class="line">    <span class="comment">/* 不能超过最大的限定值 4096B */</span></span><br><span class="line">    p-&gt;max = (size &lt; NGX_MAX_ALLOC_FROM_POOL) ? size : NGX_MAX_ALLOC_FROM_POOL;</span><br><span class="line"></span><br><span class="line">    p-&gt;current = p; <span class="comment">/* 指向当前的内存池 */</span></span><br><span class="line">    p-&gt;chain = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;large = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;cleanup = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;<span class="built_in">log</span> = <span class="built_in">log</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *  </span><br><span class="line">ngx_memalign(<span class="keyword">size_t</span> alignment, <span class="keyword">size_t</span> size, <span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">void</span>  *p;  </span><br><span class="line">    <span class="keyword">int</span>    err;  </span><br><span class="line">      </span><br><span class="line">    err = posix_memalign(&amp;p, alignment, size);  </span><br><span class="line">    <span class="comment">//该函数分配以alignment为对齐的size字节的内存大小，其中p指向分配的内存块。  </span></span><br><span class="line">      </span><br><span class="line">    <span class="keyword">if</span> (err) &#123;  </span><br><span class="line">        ngx_log_error(NGX_LOG_EMERG, <span class="built_in">log</span>, err,  </span><br><span class="line">            <span class="string">"posix_memalign(%uz, %uz) failed"</span>, alignment, size);  </span><br><span class="line">        p = <span class="literal">NULL</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    ngx_log_debug3(NGX_LOG_DEBUG_ALLOC, <span class="built_in">log</span>, <span class="number">0</span>,  </span><br><span class="line">        <span class="string">"posix_memalign: %p:%uz @%uz"</span>, p, size, alignment);  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> p;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//函数分配以NGX_POOL_ALIGNMENT字节对齐的size字节的内存，在src/core/ngx_palloc.h文件中：  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_POOL_ALIGNMENT       16</span></span><br></pre></td></tr></table></figure><h3><span id="销毁内存池">销毁内存池</span></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 销毁内存池 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">ngx_destroy_pool(<span class="keyword">ngx_pool_t</span> *pool)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">ngx_pool_t</span>          *p, *n;</span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>    *l;</span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span>  *c;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 若注册了cleanup，则遍历该链表结构，依次调用handler函数清理数据 */</span></span><br><span class="line">    <span class="keyword">for</span> (c = pool-&gt;cleanup; c; c = c-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;handler) &#123;</span><br><span class="line">            ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</span><br><span class="line">                           <span class="string">"run cleanup: %p"</span>, c);</span><br><span class="line">            c-&gt;handler(c-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 遍历 large 链表，释放大块内存 */</span></span><br><span class="line">    <span class="keyword">for</span> (l = pool-&gt;large; l; l = l-&gt;next) &#123;</span><br><span class="line"></span><br><span class="line">        ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool-&gt;<span class="built_in">log</span>, <span class="number">0</span>, <span class="string">"free: %p"</span>, l-&gt;alloc);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l-&gt;alloc) &#123;</span><br><span class="line">            ngx_free(l-&gt;alloc); <span class="comment">/* 释放内存 */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 在debug模式下执行 if 和 endif 之间的代码；</span></span><br><span class="line"><span class="comment">     * 主要是用于log记录，跟踪函数销毁时日志信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (NGX_DEBUG)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * we could allocate the pool-&gt;log from this pool</span></span><br><span class="line"><span class="comment">     * so we cannot use this log while free()ing the pool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (p = pool, n = pool-&gt;d.next; <span class="comment">/* void */</span>; p = n, n = n-&gt;d.next) &#123;</span><br><span class="line">        ngx_log_debug2(NGX_LOG_DEBUG_ALLOC, pool-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</span><br><span class="line">                       <span class="string">"free: %p, unused: %uz"</span>, p, p-&gt;d.end - p-&gt;d.last);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 遍历所有分配的内存池，释放内存池结构 */</span></span><br><span class="line">    <span class="keyword">for</span> (p = pool, n = pool-&gt;d.next; <span class="comment">/* void */</span>; p = n, n = n-&gt;d.next) &#123;</span><br><span class="line">        ngx_free(p);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="重置内存池">重置内存池</span></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 重置内存池</span></span><br><span class="line"><span class="comment"> * 定义于 src/core/ngx_palloc.c 文件中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">ngx_reset_pool(<span class="keyword">ngx_pool_t</span> *pool)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">ngx_pool_t</span>        *p;</span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>  *l;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 遍历大块内存链表，释放大块内存 */</span></span><br><span class="line">    <span class="keyword">for</span> (l = pool-&gt;large; l; l = l-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l-&gt;alloc) &#123;</span><br><span class="line">            ngx_free(l-&gt;alloc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (p = pool; p; p = p-&gt;d.next) &#123;</span><br><span class="line">        p-&gt;d.last = (u_char *) p + <span class="keyword">sizeof</span>(<span class="keyword">ngx_pool_t</span>);</span><br><span class="line">        p-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pool-&gt;current = pool;</span><br><span class="line">    pool-&gt;chain = <span class="literal">NULL</span>;</span><br><span class="line">    pool-&gt;large = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="内存分配">内存分配</span></h3><h4><span id="小块内存分配">小块内存分配</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 分配内存 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *</span><br><span class="line">ngx_palloc(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    u_char      *m;</span><br><span class="line">    <span class="keyword">ngx_pool_t</span>  *p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 若请求的内存大小size小于内存池最大内存值max，</span></span><br><span class="line"><span class="comment">     * 则进行小内存分配，从current开始遍历pool链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt;= pool-&gt;max) &#123;</span><br><span class="line"></span><br><span class="line">        p = pool-&gt;current;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">/* 执行对齐操作 */</span></span><br><span class="line">            m = ngx_align_ptr(p-&gt;d.last, NGX_ALIGNMENT);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 检查现有内存池是否有足够的内存空间，</span></span><br><span class="line"><span class="comment">             * 若有足够的内存空间，则移动last指针位置，</span></span><br><span class="line"><span class="comment">             * 并返回所分配的内存地址的起始地址</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">size_t</span>) (p-&gt;d.end - m) &gt;= size) &#123;</span><br><span class="line">                p-&gt;d.last = m + size;   <span class="comment">/* 在该节点指向的内存块中分配size大小的内存 */</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 若不满足，则查找下一个内存池 */</span></span><br><span class="line">            p = p-&gt;d.next;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">while</span> (p);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 若遍历所有现有内存池链表都没有可用的内存空间，</span></span><br><span class="line"><span class="comment">         * 则分配一个新的内存池，并将该内存池连接到现有内存池链表中</span></span><br><span class="line"><span class="comment">         * 同时，返回分配内存的起始地址</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> ngx_palloc_block(pool, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 若所请求的内存大小size大于max则调用大块内存分配函数 */</span></span><br><span class="line">    <span class="keyword">return</span> ngx_palloc_large(pool, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">ngx_palloc_block(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    u_char      *m;</span><br><span class="line">    <span class="keyword">size_t</span>       psize;</span><br><span class="line">    <span class="keyword">ngx_pool_t</span>  *p, *<span class="keyword">new</span>, *current;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 计算pool的大小，即需要分配新的block的大小 */</span></span><br><span class="line">    psize = (<span class="keyword">size_t</span>) (pool-&gt;d.end - (u_char *) pool);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* NGX_POOL_ALIGNMENT对齐操作 */</span></span><br><span class="line">    m = ngx_memalign(NGX_POOL_ALIGNMENT, psize, pool-&gt;<span class="built_in">log</span>);</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 计算需要分配的block的大小 */</span></span><br><span class="line">    <span class="keyword">new</span> = (<span class="keyword">ngx_pool_t</span> *) m;</span><br><span class="line">    <span class="keyword">new</span>-&gt;d.end = m + psize;</span><br><span class="line">    <span class="keyword">new</span>-&gt;d.next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">new</span>-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 初始化新的内存池 */</span></span><br><span class="line">    <span class="comment">/* 让m指向该块内存ngx_pool_data_t结构体之后数据区起始位置 */</span></span><br><span class="line">    m += <span class="keyword">sizeof</span>(<span class="keyword">ngx_pool_data_t</span>);</span><br><span class="line">    <span class="comment">/* 在数据区分配size大小的内存并设置last指针 */</span></span><br><span class="line">    m = ngx_align_ptr(m, NGX_ALIGNMENT);</span><br><span class="line">    <span class="keyword">new</span>-&gt;d.last = m + size;</span><br><span class="line"></span><br><span class="line">    current = pool-&gt;current;</span><br><span class="line">    <span class="keyword">for</span> (p = current; p-&gt;d.next; p = p-&gt;d.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;d.failed++ &gt; <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="comment">/* 失败4次以上移动current指针 */</span></span><br><span class="line">            current = p-&gt;d.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将分配的block连接到现有的内存池  */</span></span><br><span class="line">    p-&gt;d.next = <span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果是第一次为内存池分配block，这current将指向新分配的block */</span></span><br><span class="line">    pool-&gt;current = current ? current : <span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2017/02/26/Nginx源码分析之内存池管理/1551029604394.png" alt="1551029604394"></p><h4><span id="大块内存分配">大块内存分配</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 分配大块内存 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">ngx_palloc_large(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span>              *p;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span>         n;</span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>  *large;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 分配内存 */</span></span><br><span class="line">    p = ngx_alloc(size, pool-&gt;<span class="built_in">log</span>);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 若在该pool之前已经分配了large字段，</span></span><br><span class="line"><span class="comment">     * 则将所分配的大块内存挂载到内存池的large字段中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (large = pool-&gt;large; large; large = large-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (large-&gt;alloc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            large-&gt;alloc = p;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n++ &gt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 若在该pool之前并未分配large字段，</span></span><br><span class="line"><span class="comment">     * 则执行分配ngx_pool_large_t 结构体，分配large字段内存，</span></span><br><span class="line"><span class="comment">     * 再将大块内存挂载到pool的large字段中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    large = ngx_palloc(pool, <span class="keyword">sizeof</span>(<span class="keyword">ngx_pool_large_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (large == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ngx_free(p);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    large-&gt;alloc = p;</span><br><span class="line">    large-&gt;next = pool-&gt;large;</span><br><span class="line">    pool-&gt;large = large;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *</span><br><span class="line">ngx_alloc(<span class="keyword">size_t</span> size, <span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span>  *p;</span><br><span class="line"></span><br><span class="line">    p = <span class="built_in">malloc</span>(size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ngx_log_error(NGX_LOG_EMERG, <span class="built_in">log</span>, ngx_errno,</span><br><span class="line">            <span class="string">"malloc() %uz bytes failed"</span>, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ngx_log_debug2(NGX_LOG_DEBUG_ALLOC, <span class="built_in">log</span>, <span class="number">0</span>, <span class="string">"malloc: %p:%uz"</span>, p, size);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 释放大块内存 */</span></span><br><span class="line"><span class="keyword">ngx_int_t</span></span><br><span class="line">ngx_pfree(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">void</span> *p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>  *l;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (l = pool-&gt;large; l; l = l-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p == l-&gt;alloc) &#123;</span><br><span class="line">            ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</span><br><span class="line">                           <span class="string">"free: %p"</span>, l-&gt;alloc);</span><br><span class="line">            ngx_free(l-&gt;alloc);</span><br><span class="line">            l-&gt;alloc = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> NGX_OK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NGX_DECLINED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2017/02/26/Nginx源码分析之内存池管理/1551029658571.png" alt="1551029658571"></p><h3><span id="cleanup资源">cleanup资源</span></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 注册cleanup；</span></span><br><span class="line"><span class="comment"> * size 是 data 字段所指向的资源的大小；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">ngx_pool_cleanup_t</span> * ngx_pool_cleanup_add(<span class="keyword">ngx_pool_t</span> *p, <span class="keyword">size_t</span> size);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对内存池进行文件清理操作,即执行handler,此时handler==ngx_pool_cleanup_file */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">ngx_pool_run_cleanup_file</span><span class="params">(<span class="keyword">ngx_pool_t</span> *p, <span class="keyword">ngx_fd_t</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 关闭data指定的文件句柄 */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">ngx_pool_cleanup_file</span><span class="params">(<span class="keyword">void</span> *data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 删除data指定的文件 */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">ngx_pool_delete_file</span><span class="params">(<span class="keyword">void</span> *data)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* 注册cleanup */</span></span><br><span class="line"><span class="keyword">ngx_pool_cleanup_t</span> *</span><br><span class="line">ngx_pool_cleanup_add(<span class="keyword">ngx_pool_t</span> *p, <span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span>  *c;</span><br><span class="line"></span><br><span class="line">    c = ngx_palloc(p, <span class="keyword">sizeof</span>(<span class="keyword">ngx_pool_cleanup_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size) &#123;</span><br><span class="line">        c-&gt;data = ngx_palloc(p, size);</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        c-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c-&gt;handler = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;next = p-&gt;cleanup;</span><br><span class="line"></span><br><span class="line">    p-&gt;cleanup = c;</span><br><span class="line"></span><br><span class="line">    ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, p-&gt;<span class="built_in">log</span>, <span class="number">0</span>, <span class="string">"add cleanup: %p"</span>, c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 清理内存池的文件 */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">ngx_pool_run_cleanup_file(<span class="keyword">ngx_pool_t</span> *p, <span class="keyword">ngx_fd_t</span> fd)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span>       *c;</span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_file_t</span>  *cf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 遍历cleanup结构链表，并执行handler */</span></span><br><span class="line">    <span class="keyword">for</span> (c = p-&gt;cleanup; c; c = c-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;handler == ngx_pool_cleanup_file) &#123;</span><br><span class="line"></span><br><span class="line">            cf = c-&gt;data;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cf-&gt;fd == fd) &#123;</span><br><span class="line">                c-&gt;handler(cf);</span><br><span class="line">                c-&gt;handler = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 关闭data指定的文件句柄 */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">ngx_pool_cleanup_file(<span class="keyword">void</span> *data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_file_t</span>  *c = data; <span class="comment">/* 指向data所指向的文件句柄 */</span></span><br><span class="line"></span><br><span class="line">    ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, c-&gt;<span class="built_in">log</span>, <span class="number">0</span>, <span class="string">"file cleanup: fd:%d"</span>,</span><br><span class="line">                   c-&gt;fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 关闭指定文件 */</span></span><br><span class="line">    <span class="keyword">if</span> (ngx_close_file(c-&gt;fd) == NGX_FILE_ERROR) &#123;</span><br><span class="line">        ngx_log_error(NGX_LOG_ALERT, c-&gt;<span class="built_in">log</span>, ngx_errno,</span><br><span class="line">                      ngx_close_file_n <span class="string">" \"%s\" failed"</span>, c-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 删除data所指向的文件 */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">ngx_pool_delete_file(<span class="keyword">void</span> *data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_file_t</span>  *c = data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ngx_err_t</span>  err;</span><br><span class="line"></span><br><span class="line">    ngx_log_debug2(NGX_LOG_DEBUG_ALLOC, c-&gt;<span class="built_in">log</span>, <span class="number">0</span>, <span class="string">"file cleanup: fd:%d %s"</span>,</span><br><span class="line">                   c-&gt;fd, c-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 删除data所指向的文件 */</span></span><br><span class="line">    <span class="keyword">if</span> (ngx_delete_file(c-&gt;name) == NGX_FILE_ERROR) &#123;</span><br><span class="line">        err = ngx_errno;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (err != NGX_ENOENT) &#123;</span><br><span class="line">            ngx_log_error(NGX_LOG_CRIT, c-&gt;<span class="built_in">log</span>, err,</span><br><span class="line">                          ngx_delete_file_n <span class="string">" \"%s\" failed"</span>, c-&gt;name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 关闭文件句柄 */</span></span><br><span class="line">    <span class="keyword">if</span> (ngx_close_file(c-&gt;fd) == NGX_FILE_ERROR) &#123;</span><br><span class="line">        ngx_log_error(NGX_LOG_ALERT, c-&gt;<span class="built_in">log</span>, ngx_errno,</span><br><span class="line">                      ngx_close_file_n <span class="string">" \"%s\" failed"</span>, c-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#内存池管理&quot;&gt;内存池管理&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#概述&quot;&gt;概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#内存池基本结构&quot;&gt;内存池基本结构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#内存池
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>lua进阶学习</title>
    <link href="http://yoursite.com/2017/02/26/lua%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2017/02/26/lua进阶学习/</id>
    <published>2017-02-25T16:54:43.000Z</published>
    <updated>2019-02-28T10:59:10.467Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#lua简介">Lua简介</a><ul><li><a href="#lua是什么">Lua是什么？</a></li><li><a href="#lua和luajit的区别">Lua和LuaJIT的区别</a></li></ul></li><li><a href="#入门">入门</a><ul><li><a href="#基础数据结构">基础数据结构</a><ul><li><a href="#nil">nil</a></li><li><a href="#boolean">boolean</a></li><li><a href="#number">number</a></li><li><a href="#string">string</a></li><li><a href="#table">table</a></li><li><a href="#function">function</a></li></ul></li><li><a href="#表达式">表达式</a><ul><li><a href="#算术运算符">算术运算符</a></li><li><a href="#关系运算符">关系运算符</a></li><li><a href="#逻辑运算符">逻辑运算符</a></li><li><a href="#字符串连接">字符串连接</a></li><li><a href="#优先级">优先级</a></li></ul></li><li><a href="#控制结构">控制结构</a><ul><li><a href="#if-else">if-else</a><ul><li><a href="#单个if分支型">单个if分支型</a></li><li><a href="#两个分支-if-else-型">两个分支 if-else 型</a></li><li><a href="#多个分支-if-elseif-else-型">多个分支 if-elseif-else 型</a><ul><li><a href="#while">while</a></li><li><a href="#repeat">repeat</a></li><li><a href="#for">for</a></li></ul></li><li><a href="#for数字型">for数字型</a></li><li><a href="#for泛型">for泛型</a></li></ul></li></ul></li><li><a href="#函数">函数</a><ul><li><a href="#定义">定义</a></li><li><a href="#参数">参数</a></li><li><a href="#返回值">返回值</a></li><li><a href="#全动态函数调用">全动态函数调用</a></li></ul></li><li><a href="#模块">模块</a><ul><li><a href="#require函数">require函数</a></li></ul></li><li><a href="#string库">String库</a></li><li><a href="#table库">Table库</a></li><li><a href="#日期时间函数">日期时间函数</a></li><li><a href="#数学库函数">数学库函数</a></li><li><a href="#文件操作">文件操作</a></li></ul></li><li><a href="#高阶">高阶</a><ul><li><a href="#元表">元表</a><ul><li><a href="#修改表的操作符行为">修改表的操作符行为</a><ul><li><a href="#__index-元方法">__index 元方法</a></li><li><a href="#__tostring-元方法">__tostring 元方法</a></li><li><a href="#__call-元方法">__call 元方法</a></li><li><a href="#__metatable-元方法">__metatable 元方法</a></li></ul></li></ul></li><li><a href="#面向对象编程">面向对象编程</a><ul><li><a href="#类">类</a></li></ul></li><li><a href="#局部变量">局部变量</a></li><li><a href="#判断数组大小">判断数组大小</a></li><li><a href="#非空判断">非空判断</a></li><li><a href="#正则表达式">正则表达式</a></li><li><a href="#虚变量">虚变量</a></li><li><a href="#ffi">FFI</a></li></ul></li></ul><!-- tocstop --><h1><span id="lua简介">Lua简介</span></h1><h2><span id="lua是什么">Lua是什么？</span></h2><p>Lua于1993年诞生于巴西里约热内卢天主教大学。她浪漫的名字代表的意思是“美丽的月亮”。</p><p>正如她的名字，Lua也极为简洁、优雅且富有乐趣。</p><p>从一开始，Lua就是作为一门方便嵌入到其他应用程序，并可扩展的轻量级脚本语言来设计的，因此她一直遵循着简单、小巧、可移植、快速的原则，官方实现完全采用ANSI C编写，能以C程序库的形式嵌入到宿主程序中。</p><p>Lua广泛应用于游戏开发、机器人控制、分布式应用、图像处理、生物信息学等领域。其中，尤以游戏开发为最，用Lua可以快捷高效地配合游戏引擎完成数据描述、配置管理和逻辑控制等任务。</p><p>Lua是一门过程型动态语言，有如下特性：</p><ul><li>变量名没有类型，值才有类型，变量名在运行时可与任何类型的值绑定；</li><li>只提供唯一一种数据结构，称为表（table），它混合了数组、哈希，可以用任何类型的值作为key和value。一致且富有表达力的表构造语法，使得Lua很适合描述复杂的数据；</li><li>支持匿名函数和正则尾递归；</li><li>支持词法定界和闭包；</li><li>提供thread和coroutine机制，实现协作式多任务；</li><li>运行期能编译字符串形式的程序文本并载入虚拟机执行；</li><li>通过metatable和metamethod提供dynamic metamechanism，从而允许程序运行时根据需要改变或扩充语法设施的内定语义；</li><li>能方便的利用表和dynamic metamechanism实现prototype-based的面向对象模型；</li><li>提供完善的模块机制，从而更好地支持开发大型的应用程序；</li></ul><h2><span id="lua和luajit的区别">Lua和LuaJIT的区别</span></h2><p>Lua非常高效，通过第三方的独立评测也证实，它运行得比Perl、Python、Ruby等其他脚本都快。但是，还不够快。LuaJIT（Lua Just-in Time）则尝试利用即时编译技术把Lua代码编译成本地机器码后交给CPU直接执行，这样又显著的加速了Lua。</p><p>LuaJIT是一个更为高效的Lua实现。支持更多的基本原语和特性，因此功能上也要更为强大。</p><p>以下内容都是基于<a href="http://luajit.org" target="_blank" rel="noopener">LuaJIT</a>进行介绍的。</p><h1><span id="入门">入门</span></h1><h2><span id="基础数据结构">基础数据结构</span></h2><h3><span id="nil">nil</span></h3><p>nil是一种类型，表示“无效值”。一个变量在第一次赋值前的默认值是nil，将nil赋值给一个全局变量就等同于删除它。</p><p>如果一个变量被设置为nil，就等于说该变量未定义，与无穷无尽的其他为定义的变量是一样的。也就是表示该变量不存在。</p><p>OpenResty的lua接口还提供了一种特殊的空值，即ngx.null，用来表示不同于nil的空值。</p><p><a href="https://pureage.info/2013/09/02/125.html" target="_blank" rel="noopener">二者的区别</a>是：</p><p>nil是Lua的一种类型，该类型只有nil一个值，作用只有一个，表示一个变量不存在，未定义。</p><p>ngx.null则是一个userdata类型的值，表示查询为空。</p><h3><span id="boolean">boolean</span></h3><p>Lua中nil和false为“假”，其他所有值均为“真”。</p><p>比如0和空字符串都是“真”。</p><h3><span id="number">number</span></h3><p>表示实数，和C/C++里面的double类型类似。</p><p>可用math.floor(向下取整)和math.ceil(向上取整)进行取整操作。</p><h3><span id="string">string</span></h3><p>有三种方式表示字符串：</p><ul><li><p>单引号</p></li><li><p>双引号</p></li><li><p>长括号（即[[]]）:</p><p>在两个正的方括号之间插入n个等号定义为第n级正长括号。也就是说，[[是0级正长括号，[=[是1级，以此类推。反的长括号也作此类似定义。</p><p>则在n级正反长括号之间的字符串，不受分行限制，不处理任何转义符，忽略掉任何不同级别的长括号，即可以包含除本级别反长括号之外的任何东西。</p><p>例如：[=[abc\nbca]=]，里面的“\n”不会被转义。</p></li></ul><p>Lua的字符串是不可改变的值，不能像在C语言中那样直接修改字符串的某个字符，而是根据修改要求来创建一个新的字符串。</p><p>Lua也不能通过下标来访问字符串的某个字符。</p><p>Lua字符串一般都会经历一个内化的过程，即两个完全一样的Lua字符串在Lua虚拟机中只会存储一份。每一个Lua字符串在创建时都会插入到Lua虚拟机内部的一个全局的哈希表中。这意味着：</p><ul><li>创建相同的Lua字符串并不会引入新的动态内存分配操作，所以相对节省开销（但仍有全局哈希表查询的开销）</li><li>内容相同的Lua字符串不会占用多份存储空间</li><li>已经创建好的Lua字符串之间进行相等性比较时是<code>O(1)</code>时间度的开销，而不是通常所见的<code>O(n)</code></li></ul><h3><span id="table">table</span></h3><p>一种抽象的关联数组。是一种具有特殊索引方式的数组，索引通常是字符串或number类型，也可以是除nil以外的任意类型的值。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> corp = &#123;</span><br><span class="line">    web = <span class="string">"www.google.com"</span>,   <span class="comment">--索引为字符串，key = "web",</span></span><br><span class="line">                              <span class="comment">--            value = "www.google.com"</span></span><br><span class="line">    telephone = <span class="string">"12345678"</span>,   <span class="comment">--索引为字符串</span></span><br><span class="line">    staff = &#123;<span class="string">"Jack"</span>, <span class="string">"Scott"</span>, <span class="string">"Gary"</span>&#125;, <span class="comment">--索引为字符串，值也是一个表</span></span><br><span class="line">    <span class="number">100876</span>,              <span class="comment">--相当于 [1] = 100876，此时索引为数字</span></span><br><span class="line">                         <span class="comment">--      key = 1, value = 100876</span></span><br><span class="line">    <span class="number">100191</span>,              <span class="comment">--相当于 [2] = 100191，此时索引为数字</span></span><br><span class="line">    [<span class="number">10</span>] = <span class="number">360</span>,          <span class="comment">--直接把数字索引给出</span></span><br><span class="line">    [<span class="string">"city"</span>] = <span class="string">"Beijing"</span> <span class="comment">--索引为字符串</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(corp.web)               <span class="comment">--&gt;output:www.google.com</span></span><br><span class="line"><span class="built_in">print</span>(corp[<span class="string">"telephone"</span>])      <span class="comment">--&gt;output:12345678</span></span><br><span class="line"><span class="built_in">print</span>(corp[<span class="number">2</span>])                <span class="comment">--&gt;output:100191</span></span><br><span class="line"><span class="built_in">print</span>(corp[<span class="string">"city"</span>])           <span class="comment">--&gt;output:"Beijing"</span></span><br><span class="line"><span class="built_in">print</span>(corp.staff[<span class="number">1</span>])          <span class="comment">--&gt;output:Jack</span></span><br><span class="line"><span class="built_in">print</span>(corp[<span class="number">10</span>])               <span class="comment">--&gt;output:360</span></span><br></pre></td></tr></table></figure><p>在内部实现上，table通常实现为一个哈希表、一个数组或者两者的混合。</p><h3><span id="function">function</span></h3><p>Lua的函数也是一种数据类型，函数可以存储在变量中，可以通过参数传递给其他函数，还可以作为其他函数的返回值。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"in the function"</span>)</span><br><span class="line">    <span class="comment">--dosomething()</span></span><br><span class="line">    <span class="keyword">local</span> x = <span class="number">10</span></span><br><span class="line">    <span class="keyword">local</span> y = <span class="number">20</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> a = foo    <span class="comment">--把函数赋给变量</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a())</span><br><span class="line"></span><br><span class="line"><span class="comment">--output:</span></span><br><span class="line"><span class="keyword">in</span> the <span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="function">30</span></span><br></pre></td></tr></table></figure><p>有名函数的定义实质上是匿名函数对变量的赋值。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo = <span class="function"><span class="keyword">function</span> <span class="params">()</span></span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2><span id="表达式">表达式</span></h2><h3><span id="算术运算符">算术运算符</span></h3><table><thead><tr><th>算术运算符</th><th>说明</th></tr></thead><tbody><tr><td>+</td><td>加法</td></tr><tr><td>-</td><td>减法</td></tr><tr><td>*</td><td>乘法</td></tr><tr><td>/</td><td>除法</td></tr><tr><td>^</td><td>指数</td></tr><tr><td>%</td><td>取模</td></tr></tbody></table><h3><span id="关系运算符">关系运算符</span></h3><table><thead><tr><th>关系运算符</th><th>说明</th></tr></thead><tbody><tr><td>&lt;</td><td>小于</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&lt;=</td><td>小于等于</td></tr><tr><td>&gt;=</td><td>大于等于</td></tr><tr><td>==</td><td>等于</td></tr><tr><td>~=</td><td>不等于</td></tr></tbody></table><p>在使用“==”做等于判断时，要注意对于 table, userdate 和函数， Lua 是作引用比较的。也就是说，只有当两个变量引用同一个对象时，才认为它们相等。</p><h3><span id="逻辑运算符">逻辑运算符</span></h3><table><thead><tr><th>逻辑运算符</th><th>说明</th></tr></thead><tbody><tr><td>and</td><td>逻辑与</td></tr><tr><td>or</td><td>逻辑或</td></tr><tr><td>not</td><td>逻辑非</td></tr></tbody></table><ul><li><code>a and b</code> 如果 a 为 nil，则返回 a，否则返回 b;</li><li><code>a or b</code> 如果 a 为 nil，则返回 b，否则返回 a。</li></ul><h3><span id="字符串连接">字符串连接</span></h3><p>使用“..”来连接两个字符串。数字会转换为字符串，然后做连接。</p><p>连接只会创建一个新字符串，而不会改变原操作数。</p><p>也可以使用string.format连接字符串。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"Hello "</span> .. <span class="string">"World"</span>)    <span class="comment">--&gt;打印 Hello World</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">0</span> .. <span class="number">1</span>)                 <span class="comment">--&gt;打印 01</span></span><br><span class="line"></span><br><span class="line">str1 = <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">"%s-%s"</span>,<span class="string">"hello"</span>,<span class="string">"world"</span>)</span><br><span class="line"><span class="built_in">print</span>(str1)              <span class="comment">--&gt;打印 hello-world</span></span><br><span class="line"></span><br><span class="line">str2 = <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">"%d-%s-%.2f"</span>,<span class="number">123</span>,<span class="string">"world"</span>,<span class="number">1.21</span>)</span><br><span class="line"><span class="built_in">print</span>(str2)              <span class="comment">--&gt;打印 123-world-1.21</span></span><br></pre></td></tr></table></figure><p>table和table.concat()可进行很多字符串的拼接，又能避免用“..”做连接时不断的创建新的字符串而导致的巨大性能开销。</p><h3><span id="优先级">优先级</span></h3><table><thead><tr><th style="text-align:center">优先级(从高到低)</th></tr></thead><tbody><tr><td style="text-align:center">^</td></tr><tr><td style="text-align:center">not   # -</td></tr><tr><td style="text-align:center">*   /   %</td></tr><tr><td style="text-align:center">+   -</td></tr><tr><td style="text-align:center">..</td></tr><tr><td style="text-align:center">&lt; &gt; &lt;=  &gt;=  ==  ~=</td></tr><tr><td style="text-align:center">and</td></tr><tr><td style="text-align:center">or</td></tr></tbody></table><h2><span id="控制结构">控制结构</span></h2><h3><span id="if-else">if-else</span></h3><h5><span id="单个if分支型">单个if分支型</span></h5><h5><span id="两个分支-if-else-型">两个分支 if-else 型</span></h5><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br><span class="line"><span class="keyword">if</span> x &gt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"x is a positive number"</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"x is a non-positive number"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h5><span id="多个分支-if-elseif-else-型">多个分支 if-elseif-else 型</span></h5><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">score = <span class="number">90</span></span><br><span class="line"><span class="keyword">if</span> score == <span class="number">100</span> <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Very good!Your score is 100"</span>)</span><br><span class="line"><span class="keyword">elseif</span> score &gt;= <span class="number">60</span> <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Congratulations, you have passed it,your score greater or equal to 60"</span>)</span><br><span class="line"><span class="comment">--此处可以添加多个elseif</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Sorry, you do not pass the exam! "</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h4><span id="while">while</span></h4><p>while 型控制结构语法如下，当表达式值为假（即 false 或 nil）时结束循环。也可以使用 break 语言提前跳出循环。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> 表达式 <span class="keyword">do</span></span><br><span class="line"><span class="comment">--body</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>break可以跳出当前循环。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> t = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">18</span>, <span class="number">21</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> i</span><br><span class="line"><span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">ipairs</span>(t) <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> <span class="number">11</span> == v <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"index["</span> .. i .. <span class="string">"] have right value[11]"</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h4><span id="repeat">repeat</span></h4><p>类似于do-while，但控制方式刚好相反：</p><p>执行repeat循环体时，直到until条件为真时才结束。</p><p>以下代码将会形成死循环：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br><span class="line"><span class="keyword">repeat</span></span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"><span class="keyword">until</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h4><span id="for">for</span></h4><h5><span id="for数字型">for数字型</span></h5><p>语法如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var = begin, finish, step <span class="keyword">do</span></span><br><span class="line">    <span class="comment">--body</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>step是可选的，默认为1。</p><p>如果不想给循环设置上限的话，可以使用常量math.huge：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, <span class="built_in">math</span>.<span class="built_in">huge</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0.3</span>*i^<span class="number">3</span> - <span class="number">20</span>*i^<span class="number">2</span> - <span class="number">500</span> &gt;=<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">print</span>(i)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h5><span id="for泛型">for泛型</span></h5><p>泛型for循环通过一个迭代器函数来遍历所有值：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 打印数组a的所有值</span></span><br><span class="line"><span class="keyword">local</span> a = &#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">ipairs</span>(a) <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"index:"</span>, i, <span class="string">" value:"</span>, v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- output:</span></span><br><span class="line">index:  <span class="number">1</span>  value: a</span><br><span class="line">index:  <span class="number">2</span>  value: b</span><br><span class="line">index:  <span class="number">3</span>  value: c</span><br><span class="line">index:  <span class="number">4</span>  value: d</span><br></pre></td></tr></table></figure><p>ipairs是一个用于遍历数组的迭代器函数。在每次循环中，i是索引值，v是对应于该索引的数组元素值。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 打印table t中所有的key</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">pairs</span>(t) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(k)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>泛型for非常强大。通过不同的迭代器，几乎可以遍历所有东西。</p><p>标准库通过了几种迭代器，包括用于迭代文件中的每行的io.lines、迭代table元素的pairs、迭代数组元素的ipairs、迭代字符串中单词的string.gmatch等。</p><h2><span id="函数">函数</span></h2><h3><span id="定义">定义</span></h3><p>使用关键字function定义函数：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">function_name</span> <span class="params">(arc)</span></span>  <span class="comment">-- arc 表示参数列表，函数的参数列表可以为空</span></span><br><span class="line">   <span class="comment">-- body</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>上面的语法定义了一个全局函数。</p><p>由于全局函数一般会污染全局名字空间，特殊也有性能损耗（即查询全局环境表的开销），因此我们应当尽量使用“局部函数”，记法类似，只是开通加上local修饰符：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">function_name</span> <span class="params">(arc)</span></span></span><br><span class="line">  <span class="comment">-- body</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>由于函数定义本质上是变量赋值，而变量的定义总是应放在变量使用之前，所有函数的定义也需要放置在函数调用之前。</p><p>由于函数定义等价于变量赋值，我们可以把函数名替换为某个Lua表的某个字段：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo.bar</span><span class="params">(a, b, c)</span></span></span><br><span class="line">    <span class="comment">-- body ...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo.bar = <span class="function"><span class="keyword">function</span> <span class="params">(a, b, c)</span></span></span><br><span class="line">    <span class="built_in">print</span>(a, b, c)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3><span id="参数">参数</span></h3><ul><li><p>按值传递</p><p>实参通过它在参数表中的位置与形参匹配起来，把自己的值赋值传递给形参，之后二者就没有关系了。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">swap</span><span class="params">(a, b)</span></span> <span class="comment">--定义函数swap,函数内部进行交换两个变量的值</span></span><br><span class="line">   <span class="keyword">local</span> temp = a</span><br><span class="line">   a = b</span><br><span class="line">   b = temp</span><br><span class="line">   <span class="built_in">print</span>(a, b)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> x = <span class="string">"hello"</span></span><br><span class="line"><span class="keyword">local</span> y = <span class="number">20</span></span><br><span class="line"><span class="built_in">print</span>(x, y)</span><br><span class="line">swap(x, y)    <span class="comment">--调用swap函数</span></span><br><span class="line"><span class="built_in">print</span>(x, y)   <span class="comment">--调用swap函数后，x和y的值并没有交换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--&gt;output</span></span><br><span class="line">hello <span class="number">20</span></span><br><span class="line"><span class="number">20</span>  hello</span><br><span class="line">hello <span class="number">20</span></span><br></pre></td></tr></table></figure><p>在调用函数的时候，若形参个数和实参个数不相同时，Lua会自动调整实参个数。调整规则为：</p><p>若实参个数大于形参个数，从左到右，多余的实参被忽略；</p><p>若实参个数小于形参个数，从左到右，没有被实参初始化的形参会被初始化为nil</p></li><li><p>变长参数</p><p>若形参为…，表示该函数可以接收不同长度的参数，访问参数的时候也要使用…。</p><p>LuaJIT2尚不能实时编译这种变长参数的用法，只能解释执行，所以对性能敏感的代码，应当避免使用这种形式。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">func</span><span class="params">( ... )</span></span>                <span class="comment">-- 形参为 ... ,表示函数采用变长参数</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">local</span> temp = &#123;...&#125;                     <span class="comment">-- 访问的时候也要使用 ...</span></span><br><span class="line">   <span class="keyword">local</span> ans = <span class="built_in">table</span>.<span class="built_in">concat</span>(temp, <span class="string">" "</span>)    <span class="comment">-- 使用 table.concat 库函数对数</span></span><br><span class="line">                                          <span class="comment">-- 组内容使用 " " 拼接成字符串。</span></span><br><span class="line">   <span class="built_in">print</span>(ans)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>)        <span class="comment">-- 传递了两个参数</span></span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)  <span class="comment">-- 传递了四个参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--&gt;output</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure></li><li><p>具名参数</p><p>Lua支持通过名称来指定实参，这时候要把所有的实参组织到一个table中，并将这个table作为唯一的实参传给函数。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">change</span><span class="params">(arg)</span></span> <span class="comment">-- change 函数，改变长方形的长和宽，使其各增长一倍</span></span><br><span class="line">  <span class="built_in">arg</span>.width = <span class="built_in">arg</span>.width * <span class="number">2</span></span><br><span class="line">  <span class="built_in">arg</span>.height = <span class="built_in">arg</span>.height * <span class="number">2</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">arg</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> rectangle = &#123; width = <span class="number">20</span>, height = <span class="number">15</span> &#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"before change:"</span>, <span class="string">"width  ="</span>, rectangle.width,</span><br><span class="line">                        <span class="string">"height ="</span>, rectangle.height)</span><br><span class="line">rectangle = change(rectangle)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"after  change:"</span>, <span class="string">"width  ="</span>, rectangle.width,</span><br><span class="line">                        <span class="string">"height ="</span>, rectangle.height)</span><br><span class="line"></span><br><span class="line"><span class="comment">--&gt;output</span></span><br><span class="line">before change: width = <span class="number">20</span>  height =  <span class="number">15</span></span><br><span class="line">after  change: width = <span class="number">40</span>  height =  <span class="number">30</span></span><br></pre></td></tr></table></figure></li><li><p>按引用传递</p><p>当函数参数是table类型时，传递进来的是实际参数的引用，此时在函数内部对该table所做的修改，会直接对所传递的实际参数生效，而无需自己返回结果。</p></li></ul><h3><span id="返回值">返回值</span></h3><p>Lua允许函数返回多个值。</p><p>当函数返回值的个数和接收返回值的变量的个数不一致时，Lua也会自动调整参数个数。</p><p>调整规则：</p><ul><li><p>若返回值个数大于接收变量的个数，多余的返回值会被忽略掉；</p></li><li><p>若返回值的个数小于参数的个数，从左到右，没有被返回值初始化的变量会被初始化为nil</p></li></ul><p>如果一个函数有一个以上的返回值，当在列表表达式上对该函数进行调用时，若该函数调用不是列表的最后一项，那么，该函数调用只返回第一个返回值。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">init</span><span class="params">()</span></span>       <span class="comment">-- init 函数 返回两个值 1 和 "lua"</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>, <span class="string">"lua"</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> x, y, z = init(), <span class="number">2</span>   <span class="comment">-- init 函数的位置不在最后，此时只返回 1</span></span><br><span class="line"><span class="built_in">print</span>(x, y, z)              <span class="comment">--&gt;output  1  2  nil</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> a, b, c = <span class="number">2</span>, init()   <span class="comment">-- init 函数的位置在最后，此时返回 1 和 "lua"</span></span><br><span class="line"><span class="built_in">print</span>(a, b, c)              <span class="comment">--&gt;output  2  1  lu</span></span><br></pre></td></tr></table></figure><p>函数调用的实参列表也是一个列表表达式，也同样遵循以上规则。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>, <span class="string">"lua"</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(init(), <span class="number">2</span>)   <span class="comment">--&gt;output  1  2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span>, init())   <span class="comment">--&gt;output  2  1  lua</span></span><br></pre></td></tr></table></figure><p>如果你想确保只取函数返回值的第一个值，可以使用括号运算符：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>, <span class="string">"lua"</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>((init()), <span class="number">2</span>)   <span class="comment">--&gt;output  1  2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span>, (init()))   <span class="comment">--&gt;output  2  1</span></span><br></pre></td></tr></table></figure><h3><span id="全动态函数调用">全动态函数调用</span></h3><p>将函数作为参数和一个变长参数一起传递给另一个函数，实现全动态的函数调用。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">(x, y)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'run'</span>, x, y)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">attack</span><span class="params">(targetId)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'targetId'</span>, targetId)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">do_action</span><span class="params">(method, ...)</span></span></span><br><span class="line">    <span class="keyword">local</span> args = &#123;...&#125; <span class="keyword">or</span> &#123;&#125;</span><br><span class="line">    <span class="comment">-- 如果你的实参table中确定没有nil，则可以简化为：</span></span><br><span class="line">    <span class="comment">-- method_name(unpack(args))</span></span><br><span class="line">    method(<span class="built_in">unpack</span>(args, <span class="number">1</span>, <span class="built_in">table</span>.<span class="built_in">maxn</span>(args)))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">do_action(run, <span class="number">1</span>, <span class="number">2</span>)         <span class="comment">-- output: run 1 2</span></span><br><span class="line">do_action(attack, <span class="number">1111</span>)      <span class="comment">-- output: targetId    1111</span></span><br></pre></td></tr></table></figure><h2><span id="模块">模块</span></h2><h3><span id="require函数">require函数</span></h3><p>Lua提供一个名为require的函数来加载模块。</p><p>用require “file”就可以加载一个模块。（file指模块所在的文件名）</p><p>这个调用会返回一个由模块函数组成的table，并且还会定义一个包含该table的全局变量。</p><p>怎么在Lua中创建一个模块呢？</p><p>创建一个table，并将所有需要导出的函数放入其中，最后返回这个table就可以了。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 下面的代码保存在my.lua中</span></span><br><span class="line"><span class="keyword">local</span> foo=&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">getname</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Lucy"</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo.greeting</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"hello "</span> .. getname())</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> foo</span><br></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 下面的代码保存在main.lua中，然后执行main.lua，调用上述模块</span></span><br><span class="line"><span class="keyword">local</span> fp = <span class="built_in">require</span>(<span class="string">"my"</span>)</span><br><span class="line">fp.greeting()     <span class="comment">--&gt;output: hello Lucy</span></span><br></pre></td></tr></table></figure><h2><span id="string库">String库</span></h2><p>string.bytes(s[,i[,j]])</p><p>string.char(…)</p><p>string.upper(s)</p><p>string.lower(s)</p><p>string.len(s)</p><p>string.find(s, p, [, init [, plain]])</p><p>string.format(formatstring, …)</p><p>string.match(s, p, [,init])</p><p>在字符串 s 中匹配（模式）字符串 p，若匹配成功，则返回目标字符串中与模式匹配的子串；否则返回 nil。第三个参数 init 默认为 1，并且可以为负整数，当 init 为负数时，表示从 s 字符串的 string.len(s) + init 索引处开始向后匹配字符串 p。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">match</span>(<span class="string">"hello lua"</span>, <span class="string">"lua"</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">match</span>(<span class="string">"lua lua"</span>, <span class="string">"lua"</span>, <span class="number">2</span>))  <span class="comment">--匹配后面那个lua</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">match</span>(<span class="string">"lua lua"</span>, <span class="string">"hello"</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">match</span>(<span class="string">"today is 27/7/2015"</span>, <span class="string">"%d+/%d+/%d+"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">--&gt;output</span></span><br><span class="line">lua</span><br><span class="line">lua</span><br><span class="line"><span class="literal">nil</span></span><br><span class="line"><span class="number">27</span>/<span class="number">7</span>/<span class="number">2015</span></span><br></pre></td></tr></table></figure><p><code>string.match</code> 目前并不能被 JIT 编译，应 <strong>尽量</strong> 使用 ngx_lua 模块提供的 <code>ngx.re.match</code> 等接口。</p><p>string.gmatch(s, p)</p><p>返回一个迭代器函数，通过这个迭代器函数可以遍历到在字符串 s 中出现模式串 p 的所有地方。</p><p>此函数目前并不能被 LuaJIT 所 JIT 编译，而只能被解释执行。应 <strong>尽量</strong> 使用 ngx_lua 模块提供的 <code>ngx.re.gmatch</code> 等接口。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">"hello world from Lua"</span></span><br><span class="line"><span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">string</span>.<span class="built_in">gmatch</span>(s, <span class="string">"%a+"</span>) <span class="keyword">do</span>  <span class="comment">--匹配最长连续且只含字母的字符串</span></span><br><span class="line">    <span class="built_in">print</span>(w)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--&gt;output</span></span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">from</span><br><span class="line">Lua</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t = &#123;&#125;</span><br><span class="line">s = <span class="string">"from=world, to=Lua"</span></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">string</span>.<span class="built_in">gmatch</span>(s, <span class="string">"(%a+)=(%a+)"</span>) <span class="keyword">do</span>  <span class="comment">--匹配两个最长连续且只含字母的</span></span><br><span class="line">    t[k] = v                                    <span class="comment">--字符串，它们之间用等号连接</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(t) <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span> (k,v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--&gt;output</span></span><br><span class="line">to      Lua</span><br><span class="line">from    world</span><br></pre></td></tr></table></figure><p>string.rep(s, n)</p><p>string.sub(s, i [,j])</p><p>返回字符串 s 中，索引 i 到索引 j 之间的子字符串。</p><p>当 j 缺省时，默认为 -1，也就是字符串 s 的最后位置。i 可以为负数。当索引 i 在字符串 s 的位置在索引 j 的后面时，将返回一个空字符串。</p><p>string.gsub(s, p, r [,n])</p><p>将目标字符串 s 中所有的子串 p 替换成字符串 r。</p><p>可选参数 n，表示限制替换次数。返回值有两个，第一个是被替换后的字符串，第二个是替换了多少次。</p><p>此函数不能为 LuaJIT 所 JIT 编译，而只能被解释执行。一般我们推荐使用 ngx_lua 模块提供的 <code>ngx.re.gsub</code> 函数。</p><p>string.reverse(s)</p><h2><span id="table库">Table库</span></h2><h2><span id="日期时间函数">日期时间函数</span></h2><h2><span id="数学库函数">数学库函数</span></h2><h2><span id="文件操作">文件操作</span></h2><h1><span id="高阶">高阶</span></h1><h2><span id="元表">元表</span></h2><p>类似于C++中的操作符重载。</p><p>例如，我们可以重载“<strong>____</strong>add”元方法，来计算两个Lua数组的并集；或者重载“____index”方法，来定义我们自己的Hash函数。</p><p>Lua提供两个用来处理元表的方法，如下：</p><ul><li>setmetatable(table, metatable)：此方法用于为一个表设置元表。</li><li>getmetatable(table)：此方法用于获取表的元表对象。</li></ul><p>设置元表的方法，如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> mytable = &#123;&#125;</span><br><span class="line"><span class="keyword">local</span> mymetatable = &#123;&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(mytable, mymetatable)</span><br></pre></td></tr></table></figure><p>可以简写成如下一行：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> mytable = <span class="built_in">setmetatable</span>(&#123;&#125;, &#123;&#125;)</span><br></pre></td></tr></table></figure><h3><span id="修改表的操作符行为">修改表的操作符行为</span></h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> set1 = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;   <span class="comment">-- 集合</span></span><br><span class="line"><span class="keyword">local</span> set2 = &#123;<span class="number">20</span>, <span class="number">40</span>, <span class="number">50</span>&#125;   <span class="comment">-- 集合</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将用于重载__add的函数，注意第一个参数是self</span></span><br><span class="line"><span class="keyword">local</span> union = <span class="function"><span class="keyword">function</span> <span class="params">(self, another)</span></span></span><br><span class="line">    <span class="keyword">local</span> set = &#123;&#125;</span><br><span class="line">    <span class="keyword">local</span> result = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 利用数组来确保集合的互异性</span></span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">pairs</span>(self) <span class="keyword">do</span> set[j] = <span class="literal">true</span> <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">pairs</span>(another) <span class="keyword">do</span> set[j] = <span class="literal">true</span> <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 加入结果集合</span></span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">pairs</span>(set) <span class="keyword">do</span> <span class="built_in">table</span>.<span class="built_in">insert</span>(result, i) <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">setmetatable</span>(set1, &#123;<span class="built_in">__add</span> = union&#125;) <span class="comment">-- 重载 set1 表的 __add 元方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> set3 = set1 + set2</span><br><span class="line"><span class="keyword">for</span> _, j <span class="keyword">in</span> <span class="built_in">pairs</span>(set3) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">io</span>.<span class="built_in">write</span>(j..<span class="string">" "</span>)               <span class="comment">--&gt;output：30 50 20 40 10</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>Lua提供的所有操作符都可以被重载：</p><table><thead><tr><th>元方法</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td>“__add”</td><td style="text-align:center">+ 操作</td></tr><tr><td>“__sub”</td><td style="text-align:center">- 操作 其行为类似于 “add” 操作</td></tr><tr><td>“__mul”</td><td style="text-align:center">* 操作 其行为类似于 “add” 操作</td></tr><tr><td>“__div”</td><td style="text-align:center">/ 操作 其行为类似于 “add” 操作</td></tr><tr><td>“__mod”</td><td style="text-align:center">% 操作 其行为类似于 “add” 操作</td></tr><tr><td>“__pow”</td><td style="text-align:center">^ （幂）操作 其行为类似于 “add” 操作</td></tr><tr><td>“__unm”</td><td style="text-align:center">一元 - 操作</td></tr><tr><td>“__concat”</td><td style="text-align:center">.. （字符串连接）操作</td></tr><tr><td>“__len”</td><td style="text-align:center"># 操作</td></tr><tr><td>“__eq”</td><td style="text-align:center">== 操作 函数 getcomphandler 定义了 Lua 怎样选择一个处理器来作比较操作 仅在两个对象类型相同且有对应操作相同的元方法时才起效</td></tr><tr><td>“__lt”</td><td style="text-align:center">&lt; 操作</td></tr><tr><td>“__le”</td><td style="text-align:center">&lt;= 操作</td></tr></tbody></table><p>除了操作符之外，如下元方法也可以被重载，下面依次解释使用方法：</p><table><thead><tr><th>元方法</th><th>含义</th></tr></thead><tbody><tr><td>“__index”</td><td>取下标操作用于访问 table[key]</td></tr><tr><td>“__newindex”</td><td>赋值给指定下标 table[key] = value</td></tr><tr><td>“__tostring”</td><td>转换成字符串</td></tr><tr><td>“__call”</td><td>当 Lua 调用一个值时调用</td></tr><tr><td>“__mode”</td><td>用于弱表(<em>week table</em>)</td></tr><tr><td>“__metatable”</td><td>用于保护metatable不被访问</td></tr></tbody></table><h4><span id="__index-元方法">__index 元方法</span></h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 在表中查找不到某键时，转而在元表中查找该键</span></span><br><span class="line">mytable = <span class="built_in">setmetatable</span>(&#123;key1 = <span class="string">"value1"</span>&#125;,   <span class="comment">--原始表</span></span><br><span class="line">  &#123;<span class="built_in">__index</span> = <span class="function"><span class="keyword">function</span><span class="params">(self, key)</span></span>            <span class="comment">--重载函数</span></span><br><span class="line">    <span class="keyword">if</span> key == <span class="string">"key2"</span> <span class="keyword">then</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">"metatablevalue"</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(mytable.key1,mytable.key2)  <span class="comment">--&gt; output：value1 metatablevalue</span></span><br></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- __index 的元方法不需要非是一个函数，它也可以是一个表</span></span><br><span class="line">t = <span class="built_in">setmetatable</span>(&#123;[<span class="number">1</span>] = <span class="string">"hello"</span>&#125;, &#123;<span class="built_in">__index</span> = &#123;[<span class="number">2</span>] = <span class="string">"world"</span>&#125;&#125;)</span><br><span class="line"><span class="built_in">print</span>(t[<span class="number">1</span>], t[<span class="number">2</span>])   <span class="comment">--&gt;hello world</span></span><br></pre></td></tr></table></figure><h4><span id="__tostring-元方法">__tostring 元方法</span></h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">arr = <span class="built_in">setmetatable</span>(arr, &#123;<span class="built_in">__tostring</span> = <span class="function"><span class="keyword">function</span> <span class="params">(self)</span></span></span><br><span class="line">    <span class="keyword">local</span> result = <span class="string">'&#123;'</span></span><br><span class="line">    <span class="keyword">local</span> sep = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> _, i <span class="keyword">in</span> <span class="built_in">pairs</span>(self) <span class="keyword">do</span></span><br><span class="line">        result = result ..sep .. i</span><br><span class="line">        sep = <span class="string">', '</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    result = result .. <span class="string">'&#125;'</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"><span class="keyword">end</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(arr)  <span class="comment">--&gt; &#123;1, 2, 3, 4&#125;</span></span><br></pre></td></tr></table></figure><h4><span id="__call-元方法">__call 元方法</span></h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- __call 元方法的功能类似于 C++ 中的仿函数，使得普通的表也可以被调用。</span></span><br><span class="line">functor = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span><span class="params">(self, arg)</span></span></span><br><span class="line">  <span class="built_in">print</span> (<span class="string">"called from"</span>, <span class="built_in">arg</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setmetatable</span>(functor, &#123;<span class="built_in">__call</span> = func1&#125;)</span><br><span class="line"></span><br><span class="line">functor(<span class="string">"functor"</span>)  <span class="comment">--&gt; called from functor</span></span><br><span class="line"><span class="built_in">print</span>(functor)      <span class="comment">--&gt; output：0x00076fc8 （后面这串数字可能不一样）</span></span><br></pre></td></tr></table></figure><h4><span id="__metatable-元方法">__metatable 元方法</span></h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 假如我们想保护我们的对象使其使用者既看不到也不能修改，</span></span><br><span class="line"><span class="comment">-- 我们可以对 metatable 设置 __metatable 的值，</span></span><br><span class="line"><span class="comment">-- getmetatable 将返回这个域的值，而调用 setmetatable 将会出错</span></span><br><span class="line">Object = <span class="built_in">setmetatable</span>(&#123;&#125;, &#123;<span class="built_in">__metatable</span> = <span class="string">"You cannot access here"</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getmetatable</span>(Object)) <span class="comment">--&gt; You cannot access here</span></span><br><span class="line"><span class="built_in">setmetatable</span>(Object, &#123;&#125;)    <span class="comment">--&gt; 引发编译器报错</span></span><br></pre></td></tr></table></figure><h2><span id="面向对象编程">面向对象编程</span></h2><h3><span id="类">类</span></h3><p>将函数和相关的数据放置于同一个表中就形成了一个对象。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- account.lua</span></span><br><span class="line"><span class="keyword">local</span> _M = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> mt = &#123; <span class="built_in">__index</span> = _M &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> _M.deposit <span class="params">(self, v)</span></span></span><br><span class="line">    self.balance = self.balance + v</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> _M.withdraw <span class="params">(self, v)</span></span></span><br><span class="line">    <span class="keyword">if</span> self.balance &gt; v <span class="keyword">then</span></span><br><span class="line">        self.balance = self.balance - v</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">error</span>(<span class="string">"insufficient funds"</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> _M.new <span class="params">(self, balance)</span></span></span><br><span class="line">    balance = balance <span class="keyword">or</span> <span class="number">0</span></span><br><span class="line">    <span class="comment">-- 将_M作为新建表的原型，在自己的表中找不到'deposit'、'withdraw'时，</span></span><br><span class="line">    <span class="comment">-- 便会到__index所指定的_M类型中去寻找</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">setmetatable</span>(&#123;balance = balance&#125;, mt)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> _M</span><br></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 引用代码</span></span><br><span class="line"><span class="keyword">local</span> account = <span class="built_in">require</span>(<span class="string">"account"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> a = account:new()</span><br><span class="line">a:deposit(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> b = account:new()</span><br><span class="line">b:deposit(<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a.balance)  <span class="comment">--&gt; output: 100</span></span><br><span class="line"><span class="built_in">print</span>(b.balance)  <span class="comment">--&gt; output: 50</span></span><br></pre></td></tr></table></figure><h2><span id="局部变量">局部变量</span></h2><p>局部变量的生命周期是有限的，它的作用域仅限于声明它的块（block）。一个块是一个控制结构的执行体、或者是一个函数的执行体再或是一个程序块（chunk）。</p><p>以下代码展示各种作用域中的局部变量：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br><span class="line"><span class="keyword">local</span> i = <span class="number">1</span>         <span class="comment">-- 程序块中的局部变量 i</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> i &lt;=x <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">local</span> x = i * <span class="number">2</span>   <span class="comment">-- while 循环体中的局部变量 x</span></span><br><span class="line">  <span class="built_in">print</span>(x)          <span class="comment">-- output： 2, 4, 6, 8, ...</span></span><br><span class="line">  i = i + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> i &gt; <span class="number">20</span> <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">local</span> x           <span class="comment">-- then 中的局部变量 x</span></span><br><span class="line">  x = <span class="number">20</span></span><br><span class="line">  <span class="built_in">print</span>(x + <span class="number">2</span>)      <span class="comment">-- 如果i &gt; 20 将会打印 22，此处的 x 是局部变量</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">print</span>(x)          <span class="comment">-- 打印 10，这里 x 是全局变量</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x)            <span class="comment">-- 打印 10</span></span><br></pre></td></tr></table></figure><p>使用局部变量的好处：</p><ol><li>局部变量可以避免因为命名问题污染了全局环境</li><li>local 变量的访问比全局变量更快</li><li>由于局部变量出了作用域之后生命周期结束，这样可以被垃圾回收器及时释放</li></ol><h2><span id="判断数组大小">判断数组大小</span></h2><p>table.getn(t) 等价于 #t 但计算的是数组元素，不包括 hash 键值。而且数组是以第一个 nil 元素来判断数组结束。<code>#</code> 只计算 array 的元素个数，它实际上调用了对象的 metatable 的 <code>__len</code> 函数。对于有 <code>__len</code> 方法的函数返回函数返回值，不然就返回数组成员数目。</p><p>Lua 中，数组的实现方式其实类似于 C++ 中的 map，对于数组中所有的值，都是以键值对的形式来存储（无论是显式还是隐式），<em>Lua</em> 内部实际采用哈希表和数组分别保存键值对、普通值，所以不推荐混合使用这两种赋值方式。</p><p>尤其需要注意的一点是：Lua 数组中允许 nil 值的存在，但是数组默认结束标志却是 nil。这类似于 C 语言中的字符串，字符串中允许 ‘\0’ 存在，但当读到 ‘\0’ 时，就认为字符串已经结束了的情况。</p><p>初始化是例外，在 Lua 相关源码中，初始化数组时首先判断数组的长度，若长度大于 0 ，并且最后一个值不为 nil，返回包括 nil 的长度；若最后一个值为 nil，则返回截至第一个非 nil 值的长度。</p><p>注意：一定不要使用 <code>#</code> 操作符或 <code>table.getn</code> 来计算包含 nil 的数组长度，这是一个未定义的操作，不一定报错，但不能保证结果如你所想。如果你要删除一个数组中的元素，请使用 remove 函数，而不是用 nil 赋值。</p><h2><span id="非空判断">非空判断</span></h2><h2><span id="正则表达式">正则表达式</span></h2><h2><span id="虚变量">虚变量</span></h2><h2><span id="ffi">FFI</span></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#lua简介&quot;&gt;Lua简介&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#lua是什么&quot;&gt;Lua是什么？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#lua和luajit的区别&quot;&gt;Lua和LuaJIT的区别&lt;/a&gt;&lt;/
      
    
    </summary>
    
    
      <category term="lua" scheme="http://yoursite.com/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>Nginx modules</title>
    <link href="http://yoursite.com/2017/02/17/Nginx-modules/"/>
    <id>http://yoursite.com/2017/02/17/Nginx-modules/</id>
    <published>2017-02-17T09:06:52.000Z</published>
    <updated>2019-02-28T00:47:22.672Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="http-处理请求的11个阶段">HTTP 处理请求的11个阶段</span></h2><table><thead><tr><th style="text-align:center">阶段</th><th style="text-align:right">模块</th></tr></thead><tbody><tr><td style="text-align:center">post_read</td><td style="text-align:right">realip</td></tr><tr><td style="text-align:center">server_rewrite</td><td style="text-align:right">rewrite</td></tr><tr><td style="text-align:center">find_config</td><td style="text-align:right"></td></tr><tr><td style="text-align:center">rewrite</td><td style="text-align:right">rewrite</td></tr><tr><td style="text-align:center">post_rewrite</td><td style="text-align:right"></td></tr><tr><td style="text-align:center">pre access</td><td style="text-align:right">limit_conn,limit_req</td></tr><tr><td style="text-align:center">access</td><td style="text-align:right">auth_basic,access,auth_request</td></tr><tr><td style="text-align:center">post_access</td><td style="text-align:right"></td></tr><tr><td style="text-align:center">pre content</td><td style="text-align:right">try_files</td></tr><tr><td style="text-align:center">content</td><td style="text-align:right">index,autoindex,concat</td></tr><tr><td style="text-align:center">log</td><td style="text-align:right">access_log</td></tr></tbody></table><p>使用模块的前提：模块需要先编译进Nginx的二进制文件。<br>对于每个模块，我们需要了解：</p><ul><li>该模块提供哪些配置项</li><li>模块何时被使用</li><li>该模块提供了哪些变量</li></ul><p>Nginx能够实现类似于iptables的功能</p>]]></content>
    
    <summary type="html">
    
      关于Nginx的模块的详细分析
    
    </summary>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>如何追踪函数的完整调用过程</title>
    <link href="http://yoursite.com/2016/02/27/%E5%A6%82%E4%BD%95%E8%BF%BD%E8%B8%AA%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%8C%E6%95%B4%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2016/02/27/如何追踪函数的完整调用过程/</id>
    <published>2016-02-26T22:05:32.000Z</published>
    <updated>2019-02-28T00:50:11.914Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="如何追踪函数的完整调用过程">如何追踪函数的完整调用过程</span></h1><h2><span id="环境和示例程序说明">环境和示例程序说明</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@geek ~]# uname -r</span><br><span class="line">3.10.0-957.5.1.el7.x86_64</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@geek ~]<span class="meta"># cat test.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">triple</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span> * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, triple(<span class="number">10</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@geek ~]# gcc test.c -o test</span><br></pre></td></tr></table></figure><h2><span id="使用strace-amp-ltrace">使用strace &amp; ltrace</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@geek ~]# ltrace ./test</span><br><span class="line">__libc_start_main(0x40053f, 1, 0x7ffd0a4f01e8, 0x400570 &lt;unfinished ...&gt;</span><br><span class="line">printf(&quot;%d\n&quot;, 3030</span><br><span class="line">)                          = 3</span><br><span class="line">+++ exited (status 0) +++</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[root@geek ~]# strace ./test</span><br><span class="line">execve(&quot;./test&quot;, [&quot;./test&quot;], [/* 23 vars */]) = 0</span><br><span class="line">brk(NULL)                               = 0xec5000</span><br><span class="line">mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7ff98b65e000</span><br><span class="line">access(&quot;/etc/ld.so.preload&quot;, R_OK)      = -1 ENOENT (No such file or directory)</span><br><span class="line">open(&quot;/etc/ld.so.cache&quot;, O_RDONLY|O_CLOEXEC) = 3</span><br><span class="line">fstat(3, &#123;st_mode=S_IFREG|0644, st_size=76002, ...&#125;) = 0</span><br><span class="line">mmap(NULL, 76002, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7ff98b64b000</span><br><span class="line">close(3)                                = 0</span><br><span class="line">open(&quot;/lib64/libc.so.6&quot;, O_RDONLY|O_CLOEXEC) = 3</span><br><span class="line">read(3, &quot;\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0\340$\2\0\0\0\0\0&quot;..., 832) = 832</span><br><span class="line">fstat(3, &#123;st_mode=S_IFREG|0755, st_size=2151672, ...&#125;) = 0</span><br><span class="line">mmap(NULL, 3981792, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7ff98b071000</span><br><span class="line">mprotect(0x7ff98b233000, 2097152, PROT_NONE) = 0</span><br><span class="line">mmap(0x7ff98b433000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1c2000) = 0x7ff98b433000</span><br><span class="line">mmap(0x7ff98b439000, 16864, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7ff98b439000</span><br><span class="line">close(3)                                = 0</span><br><span class="line">mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7ff98b64a000</span><br><span class="line">mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7ff98b648000</span><br><span class="line">arch_prctl(ARCH_SET_FS, 0x7ff98b648740) = 0</span><br><span class="line">mprotect(0x7ff98b433000, 16384, PROT_READ) = 0</span><br><span class="line">mprotect(0x600000, 4096, PROT_READ)     = 0</span><br><span class="line">mprotect(0x7ff98b65f000, 4096, PROT_READ) = 0</span><br><span class="line">munmap(0x7ff98b64b000, 76002)           = 0</span><br><span class="line">fstat(1, &#123;st_mode=S_IFCHR|0620, st_rdev=makedev(136, 1), ...&#125;) = 0</span><br><span class="line">mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7ff98b65d000</span><br><span class="line">write(1, &quot;30\n&quot;, 330</span><br><span class="line">)                     = 3</span><br><span class="line">exit_group(0)                           = ?</span><br><span class="line">+++ exited with 0 +++</span><br></pre></td></tr></table></figure><p>ltrace只追踪到动态库函数printf的调用，而strace追踪到所有的系统调用、函数调用。注意，printf只是一个库函数，其内使用了系统调用函数write。</p><p>严格来说，ltrace和strace不算是追踪到函数的完整调用过程。</p><h2><span id="使用gdb">使用gdb</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@geek ~]# readelf -s ./test | gawk &apos; &#123;    </span><br><span class="line">if($4 == &quot;FUNC&quot; &amp;&amp; $2 != 0) &#123; </span><br><span class="line">  print &quot;# code for &quot; $NF;</span><br><span class="line">  print &quot;b *0x&quot; $2;</span><br><span class="line">  print &quot;commands&quot;;</span><br><span class="line">  print &quot;silent&quot;;   </span><br><span class="line">  print &quot;bt 1&quot;;</span><br><span class="line">  print &quot;c&quot;;</span><br><span class="line">  print &quot;end&quot;;     </span><br><span class="line">  print &quot;&quot;;    </span><br><span class="line">&#125;  </span><br><span class="line">&#125;&apos; &gt; sym;</span><br></pre></td></tr></table></figure><p>如上，先利用gawk生成对应的gdb命令，它在每一个函数符号处下一个断点，一旦函数执行到这里就被断下来，并执行对应的commands命令内容，其中silent表示强制gdb不要打印额外的提示信息，“bt 1”（backtrace 1）表示只显示当前函数名，c继续。生成的gdb命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[root@geek ~]# cat sym</span><br><span class="line"># code for deregister_tm_clones</span><br><span class="line">b *0x0000000000400470</span><br><span class="line">command</span><br><span class="line">silent</span><br><span class="line">bt 1</span><br><span class="line">c</span><br><span class="line">end</span><br><span class="line"># code for register_tm_clones</span><br><span class="line">b *0x00000000004004a0</span><br><span class="line">command</span><br><span class="line">silent</span><br><span class="line">bt 1</span><br><span class="line">c</span><br><span class="line">end</span><br><span class="line"># code for __do_global_dtors_aux</span><br><span class="line">b *0x00000000004004e0</span><br><span class="line">command</span><br><span class="line">silent</span><br><span class="line">bt 1</span><br><span class="line">c</span><br><span class="line">end</span><br><span class="line"># code for frame_dummy</span><br><span class="line">b *0x0000000000400500</span><br><span class="line">command</span><br><span class="line">silent</span><br><span class="line">bt 1</span><br><span class="line">c</span><br><span class="line">end</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>接着，执行gdb，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[root@geek ~]# gdb --command=sym ./test -q</span><br><span class="line">Reading symbols from /root/test...(no debugging symbols found)...done.</span><br><span class="line">Breakpoint 1 at 0x400470</span><br><span class="line">Breakpoint 2 at 0x4004a0</span><br><span class="line">Breakpoint 3 at 0x4004e0</span><br><span class="line">Breakpoint 4 at 0x400500</span><br><span class="line">Breakpoint 5 at 0x4005e0</span><br><span class="line">Breakpoint 6 at 0x4005e4</span><br><span class="line">Breakpoint 7 at 0x400570</span><br><span class="line">Breakpoint 8 at 0x400440</span><br><span class="line">Breakpoint 9 at 0x40053f</span><br><span class="line">Breakpoint 10 at 0x40052d</span><br><span class="line">Breakpoint 11 at 0x4003e0</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /root/./test</span><br><span class="line">#0  0x0000000000400440 in _start ()</span><br><span class="line">#0  0x0000000000400570 in __libc_csu_init ()</span><br><span class="line">#0  0x00000000004003e0 in _init ()</span><br><span class="line">#0  0x0000000000400500 in frame_dummy ()</span><br><span class="line">#0  0x00000000004004a0 in register_tm_clones ()</span><br><span class="line">#0  0x000000000040053f in main ()</span><br><span class="line">#0  0x000000000040052d in triple ()</span><br><span class="line">30</span><br><span class="line">#0  0x00000000004004e0 in __do_global_dtors_aux ()</span><br><span class="line">#0  0x0000000000400470 in deregister_tm_clones ()</span><br><span class="line">#0  0x00000000004005e4 in _fini ()</span><br><span class="line">[Inferior 1 (process 13325) exited normally]</span><br><span class="line">Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>上面追踪出了所有的函数调用过程。</p><h2><span id="使用systemtab">使用systemtab</span></h2><p>systemtab很强大，因此利用systemtab追踪函数的完整调用过程很简单，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@geek ~]# cat lsprob.stp</span><br><span class="line">probe process(&quot;/root/test&quot;).function(&quot;*&quot;)</span><br><span class="line">&#123;</span><br><span class="line">        printf(&quot;%s(%s)\n&quot;, probefunc(), $$parms)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@geek ~]# stap lsprob.stp -c /root/test</span><br><span class="line">30</span><br><span class="line">_start()</span><br><span class="line">__libc_csu_init()</span><br><span class="line">_init()</span><br><span class="line">frame_dummy()</span><br><span class="line">register_tm_clones()</span><br><span class="line">main()</span><br><span class="line">triple()</span><br><span class="line">__do_global_dtors_aux()</span><br><span class="line">deregister_tm_clones()</span><br><span class="line">_fini()</span><br></pre></td></tr></table></figure><p>参考资料：</p><p><a href="http://www.lenky.info/archives/2013/02/2202" target="_blank" rel="noopener">如何追踪函数的完整调用过程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;如何追踪函数的完整调用过程&quot;&gt;如何追踪函数的完整调用过程&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span id=&quot;环境和示例程序说明&quot;&gt;环境和示例程序说明&lt;/span&gt;&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux内核设计03-安装文件系统</title>
    <link href="http://yoursite.com/2016/02/26/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A103-%E5%AE%89%E8%A3%85%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2016/02/26/Linux内核设计03-安装文件系统/</id>
    <published>2016-02-26T03:20:14.000Z</published>
    <updated>2019-02-28T00:47:04.218Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#安装文件系统">安装文件系统</a><ul><li><a href="#获取硬盘设备号">获取硬盘设备号</a></li><li><a href="#获取虚拟盘上的挂接点">获取虚拟盘上的挂接点</a></li><li><a href="#得到hd1设备文件的超级块">得到hd1设备文件的超级块</a></li><li><a href="#将hd1设备文件与mnt目录文件的i节点挂接">将hd1设备文件与mnt目录文件的i节点挂接</a></li></ul></li></ul><!-- tocstop --><h1><span id="安装文件系统">安装文件系统</span></h1><h2><span id="获取硬盘设备号">获取硬盘设备号</span></h2><h2><span id="获取虚拟盘上的挂接点">获取虚拟盘上的挂接点</span></h2><h2><span id="得到hd1设备文件的超级块">得到hd1设备文件的超级块</span></h2><h2><span id="将hd1设备文件与mnt目录文件的i节点挂接">将hd1设备文件与mnt目录文件的i节点挂接</span></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#安装文件系统&quot;&gt;安装文件系统&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#获取硬盘设备号&quot;&gt;获取硬盘设备号&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#获取虚拟盘上的挂接点&quot;&gt;获取虚拟盘上的挂接点&lt;/a&gt;&lt;/li&gt;
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核设计02-从main到怠速</title>
    <link href="http://yoursite.com/2016/02/26/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A102-%E4%BB%8Emain%E5%88%B0%E6%80%A0%E9%80%9F/"/>
    <id>http://yoursite.com/2016/02/26/Linux内核设计02-从main到怠速/</id>
    <published>2016-02-25T16:35:35.000Z</published>
    <updated>2019-02-26T08:30:13.584Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#从main到怠速">从main到怠速</a><ul><li><a href="#开中断之前的准备工作">开中断之前的准备工作</a><ul><li><a href="#复制根设备号和硬盘参数表">复制根设备号和硬盘参数表</a></li><li><a href="#物理内存规划格局">物理内存规划格局</a></li><li><a href="#虚拟盘设置与初始化">虚拟盘设置与初始化</a></li><li><a href="#内存管理结构mem_map初始化">内存管理结构mem_map初始化</a></li><li><a href="#异常处理类中断服务程序挂接">异常处理类中断服务程序挂接</a></li><li><a href="#初始化块设备请求项结构">初始化块设备请求项结构</a></li><li><a href="#与建立人机交互界面相关的外设的中断服务程序挂接">与建立人机交互界面相关的外设的中断服务程序挂接</a></li><li><a href="#开机启动时间设置">开机启动时间设置</a></li><li><a href="#系统开始激活进程0">系统开始激活进程0</a></li><li><a href="#初始化缓冲区管理结构">初始化缓冲区管理结构</a></li><li><a href="#初始化硬盘">初始化硬盘</a></li><li><a href="#初始化软盘">初始化软盘</a></li><li><a href="#开中断">开中断</a></li></ul></li><li><a href="#进程创建的最基本动作">进程创建的最基本动作</a><ul><li><a href="#操作系统为进程0创建进程1做准备">操作系统为进程0创建进程1做准备</a></li><li><a href="#在进程槽中为进程1申请一个空闲位置并获取进程号">在进程槽中为进程1申请一个空闲位置并获取进程号</a></li><li><a href="#复制进程信息之前先将以下数据压栈">复制进程信息之前，先将以下数据压栈</a></li><li><a href="#初步设置进程1管理结构">初步设置进程1管理结构</a></li><li><a href="#进程0创建进程1的过程中发生时钟中断">进程0创建进程1的过程中发生时钟中断</a></li><li><a href="#从时钟中断返回">从时钟中断返回</a></li><li><a href="#调整进程1管理结构">调整进程1管理结构</a></li><li><a href="#设置进程1的线性地址空间及物理页面">设置进程1的线性地址空间及物理页面</a></li><li><a href="#继续调整进程1管理结构">继续调整进程1管理结构</a></li></ul></li><li><a href="#加载根文件系统">加载根文件系统</a><ul><li><a href="#进程1如何开始执行">进程1如何开始执行</a></li><li><a href="#进程1开始执行">进程1开始执行</a></li><li><a href="#进程1开始以数据块的形式操作硬盘">进程1开始以数据块的形式操作硬盘</a></li><li><a href="#将找到的缓冲块与请求项挂接">将找到的缓冲块与请求项挂接</a></li><li><a href="#将请求项与硬盘处理函数挂接">将请求项与硬盘处理函数挂接</a></li><li><a href="#进行硬盘读盘前的准备工作">进行硬盘读盘前的准备工作</a></li><li><a href="#给硬盘下达读盘指令">给硬盘下达读盘指令</a></li><li><a href="#进程1由于等待读盘操作挂起">进程1由于等待读盘操作挂起</a></li><li><a href="#系统切换到进程0执行">系统切换到进程0执行</a></li><li><a href="#进程0的执行过程">进程0的执行过程</a></li><li><a href="#进程0执行过程中发生硬盘中断">进程0执行过程中发生硬盘中断</a></li><li><a href="#硬盘中断服务程序响应后进程0继续执行">硬盘中断服务程序响应后，进程0继续执行</a></li><li><a href="#再次响应硬盘中断并唤醒进程1">再次响应硬盘中断并唤醒进程1</a></li><li><a href="#读盘操作完成后进程1继续执行">读盘操作完成后，进程1继续执行</a></li><li><a href="#进程1继续设置硬盘管理结构">进程1继续设置硬盘管理结构</a></li><li><a href="#进程1获取软盘超级块为加载根文件系统做准备">进程1获取软盘超级块，为加载根文件系统做准备</a></li><li><a href="#进程1备份超级块数据">进程1备份超级块数据</a></li><li><a href="#进程1将根文件系统从软盘拷贝到虚拟盘">进程1将根文件系统从软盘拷贝到虚拟盘</a></li><li><a href="#进程1开始加载根文件系统">进程1开始加载根文件系统</a></li><li><a href="#进程1准备加载根文件系统超级块">进程1准备加载根文件系统超级块</a></li><li><a href="#进程1加载根文件系统超级块">进程1加载根文件系统超级块</a></li><li><a href="#进程1继续加载根文件系统">进程1继续加载根文件系统</a></li><li><a href="#进程1准备读取根目录i节点">进程1准备读取根目录i节点</a></li><li><a href="#进程1加载根目录i节点">进程1加载根目录i节点</a></li><li><a href="#进程1结束加载根文件系统的过程">进程1结束加载根文件系统的过程</a></li></ul></li><li><a href="#打开终端设备文件及复制文件句柄">打开终端设备文件及复制文件句柄</a><ul><li><a href="#进程1与内核文件表挂接为打开文件做准备">进程1与内核文件表挂接，为打开文件做准备</a></li><li><a href="#确定打开操作的起点">确定打开操作的起点</a></li><li><a href="#获得枝梢i节点-dev目录文件的i节点">获得枝梢i节点-dev目录文件的i节点</a></li><li><a href="#确定dev目录文件i节点为枝梢i节点">确定dev目录文件i节点为枝梢i节点</a></li><li><a href="#继续返回枝梢i节点">继续返回枝梢i节点</a></li><li><a href="#查找tty0文件的i节点">查找tty0文件的i节点</a></li><li><a href="#将tty0设备文件的i节点返回给sys_open系统调用">将tty0设备文件的i节点返回给sys_open系统调用</a></li><li><a href="#分析tty0文件i节点">分析tty0文件i节点</a></li><li><a href="#设置文件管理结构并返回给用户进程">设置文件管理结构并返回给用户进程</a></li><li><a href="#进程1复制tty0文件句柄">进程1复制tty0文件句柄</a></li><li><a href="#进程1继续复制tty0文件句柄">进程1继续复制tty0文件句柄</a></li></ul></li><li><a href="#创建进程2">创建进程2</a><ul><li><a href="#进程1准备创建进程2">进程1准备创建进程2</a></li><li><a href="#复制进程2管理结构并继续调整">复制进程2管理结构并继续调整</a></li><li><a href="#设置进程2的页目录项并复制进程2的页表">设置进程2的页目录项并复制进程2的页表</a></li><li><a href="#调整进程2管理结构中与文件有关的内容">调整进程2管理结构中与文件有关的内容</a></li><li><a href="#进程1执行过程中发生时钟中断">进程1执行过程中发生时钟中断</a></li><li><a href="#进程1从时钟中断返回准备切换到进程2">进程1从时钟中断返回，准备切换到进程2</a></li></ul></li><li><a href="#进程1等待进程2退出">进程1等待进程2退出</a></li><li><a href="#shell程序的加载">shell程序的加载</a></li><li><a href="#系统实现怠速">系统实现怠速</a></li></ul></li></ul><!-- tocstop --><h1><span id="从main到怠速">从main到怠速</span></h1><h2><span id="开中断之前的准备工作">开中断之前的准备工作</span></h2><h3><span id="复制根设备号和硬盘参数表">复制根设备号和硬盘参数表</span></h3><p>在对各个硬件设备进行设置和规划前，系统会对“根设备号”和“硬盘参数表”进行备份。</p><p>这是因为启动部分的初始化设置是逐步完成的，“根设备号”和“硬盘参数表”现在所占用的内存空间会在以后进行缓冲区的初始化设置时被重新规划。因此，这时候要事先备份，以免将来被干扰。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXT_MEM_K (*(unsigned short *)0x90002)<span class="comment">// 1M 以后的扩展内存大小（KB）。</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRIVE_INFO (*(struct drive_info *)0x90080)<span class="comment">// 硬盘参数表基址。</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ORIG_ROOT_DEV (*(unsigned short *)0x901FC)<span class="comment">// 根文件系统所在设备号。</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">drive_info</span> &#123;</span> <span class="keyword">char</span> dummy[<span class="number">32</span>]; &#125; drive_info;<span class="comment">// 用于存放硬盘参数表信息。</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ROOT_DEV = ORIG_ROOT_DEV;</span><br><span class="line">drive_info = DRIVE_INFO;</span><br></pre></td></tr></table></figure><p><img src="/2016/02/26/Linux内核设计02-从main到怠速/1551155801810.png" alt="1551155801810"></p><h3><span id="物理内存规划格局">物理内存规划格局</span></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">memory_end = (<span class="number">1</span>&lt;&lt;<span class="number">20</span>) + (EXT_MEM_K&lt;&lt;<span class="number">10</span>);<span class="comment">// 内存大小=1Mb 字节+扩展内存(k)*1024 字节。</span></span><br><span class="line">memory_end &amp;= <span class="number">0xfffff000</span>;<span class="comment">// 忽略不到4Kb（1 页）的内存数。</span></span><br><span class="line"><span class="keyword">if</span> (memory_end &gt; <span class="number">16</span>*<span class="number">1024</span>*<span class="number">1024</span>)<span class="comment">// 如果内存超过16Mb，则按16Mb 计。</span></span><br><span class="line">memory_end = <span class="number">16</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"><span class="keyword">if</span> (memory_end &gt; <span class="number">12</span>*<span class="number">1024</span>*<span class="number">1024</span>)<span class="comment">// 如果内存&gt;12Mb，则设置缓冲区末端=4Mb</span></span><br><span class="line">buffer_memory_end = <span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (memory_end &gt; <span class="number">6</span>*<span class="number">1024</span>*<span class="number">1024</span>)<span class="comment">// 否则如果内存&gt;6Mb，则设置缓冲区末端=2Mb</span></span><br><span class="line">buffer_memory_end = <span class="number">2</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">buffer_memory_end = <span class="number">1</span>*<span class="number">1024</span>*<span class="number">1024</span>;<span class="comment">// 否则则设置缓冲区末端=1Mb</span></span><br><span class="line">main_memory_start = buffer_memory_end;<span class="comment">// 主内存起始位置=缓冲区末端；</span></span><br></pre></td></tr></table></figure><p>除1MB以内的内核区之外，其余物理内存要完成的工作是不同的：</p><ul><li>主内存区主要用来承载进程的相关信息，包括进程管理结构、进程对应的程序等；</li><li>缓冲区主要作为主机与外设进行数据交互的中转站；</li><li>虚拟盘区是一个可选的区域，如果选择使用虚拟盘，就可以将外设上的数据先复制到虚拟盘区，然后再使用。由于从内存中操作数据的速度远高于外设，因此这样可以提高系统执行效率。</li></ul><p><img src="/2016/02/26/Linux内核设计02-从main到怠速/1551156541548.png" alt="1551156541548"></p><h3><span id="虚拟盘设置与初始化">虚拟盘设置与初始化</span></h3><p>以makefile中“虚拟盘使用标志”来确定本系统是否使用了虚拟盘。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RAMDISK<span class="comment">// 如果定义了虚拟盘，则主内存将减少。</span></span></span><br><span class="line">main_memory_start += rd_init(main_memory_start, RAMDISK*<span class="number">1024</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/blk_drv/ramdisk.c</span></span><br><span class="line"><span class="comment">/* 返回内存虚拟盘ramdisk 所需的内存量 */</span></span><br><span class="line"><span class="comment">// 虚拟盘初始化函数。确定虚拟盘在内存中的起始地址，长度。并对整个虚拟盘区清零。</span></span><br><span class="line"><span class="keyword">long</span></span><br><span class="line">rd_init (<span class="keyword">long</span> mem_start, <span class="keyword">int</span> length)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">char</span> *cp;</span><br><span class="line"></span><br><span class="line">blk_dev[MAJOR_NR].request_fn = DEVICE_REQUEST;<span class="comment">// do_rd_request()。</span></span><br><span class="line">rd_start = (<span class="keyword">char</span> *) mem_start;</span><br><span class="line">rd_length = length;</span><br><span class="line">cp = rd_start;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">*cp++ = <span class="string">'\0'</span>;</span><br><span class="line"><span class="keyword">return</span> (length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_REQUEST do_rd_request<span class="comment">// 设备请求函数do_rd_request()。</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行虚拟盘(ramdisk)读写操作。程序结构与do_hd_request()类似(kernel/blk_drv/hd.c,294)。</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">do_rd_request (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">char</span> *addr;</span><br><span class="line"></span><br><span class="line">INIT_REQUEST;<span class="comment">// 检测请求的合法性(参见kernel/blk_drv/blk.h,127)。</span></span><br><span class="line"><span class="comment">// 下面语句取得ramdisk 的起始扇区对应的内存起始位置和内存长度。</span></span><br><span class="line"><span class="comment">// 其中sector &lt;&lt; 9 表示sector * 512，CURRENT 定义为(blk_dev[MAJOR_NR].current_request)。</span></span><br><span class="line">addr = rd_start + (CURRENT-&gt;sector &lt;&lt; <span class="number">9</span>);</span><br><span class="line">len = CURRENT-&gt;nr_sectors &lt;&lt; <span class="number">9</span>;</span><br><span class="line"><span class="comment">// 如果子设备号不为1 或者对应内存起始位置&gt;虚拟盘末尾，则结束该请求，并跳转到repeat 处</span></span><br><span class="line"><span class="comment">// （定义在28 行的INIT_REQUEST 内开始处）。</span></span><br><span class="line"><span class="keyword">if</span> ((MINOR (CURRENT-&gt;dev) != <span class="number">1</span>) || (addr + len &gt; rd_start + rd_length))</span><br><span class="line">&#123;</span><br><span class="line">end_request (<span class="number">0</span>);</span><br><span class="line"><span class="keyword">goto</span> repeat;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果是写命令(WRITE)，则将请求项中缓冲区的内容复制到addr 处，长度为len 字节。</span></span><br><span class="line"><span class="keyword">if</span> (CURRENT-&gt;cmd == WRITE)</span><br><span class="line">&#123;</span><br><span class="line">(<span class="keyword">void</span>) <span class="built_in">memcpy</span> (addr, CURRENT-&gt;buffer, len);</span><br><span class="line"><span class="comment">// 如果是读命令(READ)，则将addr 开始的内容复制到请求项中缓冲区中，长度为len 字节。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (CURRENT-&gt;cmd == READ)</span><br><span class="line">&#123;</span><br><span class="line">(<span class="keyword">void</span>) <span class="built_in">memcpy</span> (CURRENT-&gt;buffer, addr, len);</span><br><span class="line"><span class="comment">// 否则显示命令不存在，死机。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">panic (<span class="string">"unknown ramdisk-command"</span>);</span><br><span class="line"><span class="comment">// 请求项成功后处理，置更新标志。并继续处理本设备的下一请求项。</span></span><br><span class="line">end_request (<span class="number">1</span>);</span><br><span class="line"><span class="keyword">goto</span> repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* blk_dev_struct is:</span></span><br><span class="line"><span class="comment">* do_request-address</span></span><br><span class="line"><span class="comment">* next-request</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/* blk_dev_struct 块设备结构是：(kernel/blk_drv/blk.h,23)</span></span><br><span class="line"><span class="comment">* do_request-address //对应主设备号的请求处理程序指针。</span></span><br><span class="line"><span class="comment">* current-request // 该设备的下一个请求。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 该数组使用主设备号作为索引（下标）。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">blk_dev_struct</span> <span class="title">blk_dev</span>[<span class="title">NR_BLK_DEV</span>] = &#123;</span></span><br><span class="line">&#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;,<span class="comment">/* no_dev */</span><span class="comment">// 0 - 无设备。</span></span><br><span class="line">&#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;,<span class="comment">/* dev mem */</span><span class="comment">// 1 - 内存。</span></span><br><span class="line">&#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;,<span class="comment">/* dev fd */</span><span class="comment">// 2 - 软驱设备。</span></span><br><span class="line">&#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;,<span class="comment">/* dev hd */</span><span class="comment">// 3 - 硬盘设备。</span></span><br><span class="line">&#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;,<span class="comment">/* dev ttyx */</span><span class="comment">// 4 - ttyx 设备。</span></span><br><span class="line">&#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;,<span class="comment">/* dev tty */</span><span class="comment">// 5 - tty 设备。</span></span><br><span class="line">&#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;<span class="comment">/* dev lp */</span><span class="comment">// 6 - lp 打印机设备。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/blk_drv/blk.h</span></span><br><span class="line"><span class="comment">// 块设备结构。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">blk_dev_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">void</span> (*request_fn) (<span class="keyword">void</span>);<span class="comment">// 请求操作的函数指针。</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">request</span> *<span class="title">current_request</span>;</span><span class="comment">// 请求信息结构。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* OK，下面是request 结构的一个扩展形式，因而当实现以后，我们就可以在分页请求中</span></span><br><span class="line"><span class="comment">* 使用同样的request 结构。在分页处理中，'bh'是NULL，而'waiting'则用于等待读/写的完成。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 下面是请求队列中项的结构。其中如果dev=-1，则表示该项没有被使用。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> dev;<span class="comment">/* -1 if no request */</span><span class="comment">// 使用的设备号。</span></span><br><span class="line">  <span class="keyword">int</span> cmd;<span class="comment">/* READ or WRITE */</span><span class="comment">// 命令(READ 或WRITE)。</span></span><br><span class="line">  <span class="keyword">int</span> errors;<span class="comment">//操作时产生的错误次数。</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> sector;<span class="comment">// 起始扇区。(1 块=2 扇区)</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_sectors;<span class="comment">// 读/写扇区数。</span></span><br><span class="line">  <span class="keyword">char</span> *buffer;<span class="comment">// 数据缓冲区。</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">waiting</span>;</span><span class="comment">// 任务等待操作执行完成的地方。</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh</span>;</span><span class="comment">// 缓冲区头指针(include/linux/fs.h,68)。</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">request</span> *<span class="title">next</span>;</span><span class="comment">// 指向下一请求项。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/2016/02/26/Linux内核设计02-从main到怠速/1551156694617.png" alt="1551156694617"></p><h3><span id="内存管理结构mem_map初始化">内存管理结构mem_map初始化</span></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init/main.c</span></span><br><span class="line"><span class="comment">// 以下是内核进行所有方面的初始化工作。阅读时最好跟着调用的程序深入进去看，实在看</span></span><br><span class="line"><span class="comment">// 不下去了，就先放一放，看下一个初始化调用-- 这是经验之谈:)</span></span><br><span class="line">mem_init(main_memory_start,memory_end);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mm/memery.c</span></span><br><span class="line"><span class="comment">//// 物理内存初始化。</span></span><br><span class="line"><span class="comment">// 参数：start_mem - 可用作分页处理的物理内存起始位置（已去除RAMDISK 所占内存空间等）。</span></span><br><span class="line"><span class="comment">// end_mem - 实际物理内存最大地址。</span></span><br><span class="line"><span class="comment">// 在该版的linux 内核中，最多能使用16Mb 的内存，大于16Mb 的内存将不于考虑，弃置不用。</span></span><br><span class="line"><span class="comment">// 0 - 1Mb 内存空间用于内核系统（其实是0-640Kb）。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mem_init</span><span class="params">(<span class="keyword">long</span> start_mem, <span class="keyword">long</span> end_mem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">HIGH_MEMORY = end_mem;<span class="comment">// 设置内存最高端。</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;PAGING_PAGES ; i++)<span class="comment">// 首先置所有页面为已占用(USED=100)状态，</span></span><br><span class="line">mem_map[i] = USED;<span class="comment">// 即将页面映射数组全置成USED。</span></span><br><span class="line">i = MAP_NR(start_mem);<span class="comment">// 然后计算可使用起始内存的页面号。</span></span><br><span class="line">end_mem -= start_mem;<span class="comment">// 再计算可分页处理的内存块大小。</span></span><br><span class="line">end_mem &gt;&gt;= <span class="number">12</span>;<span class="comment">// 从而计算出可用于分页处理的页面数。</span></span><br><span class="line"><span class="keyword">while</span> (end_mem--&gt;<span class="number">0</span>)<span class="comment">// 最后将这些可用页面对应的页面映射数组清零。</span></span><br><span class="line">mem_map[i++]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USED 100<span class="comment">// 页面被占用标志。</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGING_MEMORY (15*1024*1024)<span class="comment">// 分页内存15MB。主内存区最多15M。</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGING_PAGES (PAGING_MEMORY&gt;&gt;12)<span class="comment">// 分页后的物理内存页数。</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAP_NR(addr) (((addr)-LOW_MEM)&gt;&gt;12)<span class="comment">// 指定物理内存地址映射为页号。</span></span></span><br></pre></td></tr></table></figure><p><img src="/2016/02/26/Linux内核设计02-从main到怠速/1551159102486.png" alt="1551159102486"></p><p>系统对1MB以上的内存都是分页管理的，于是系统就通过一个叫做mem_map的数组记录每一个页面的使用次数。</p><p>先将所有的内存页面使用次数均设置成100，然后再依据主内存的起始位置和终止位置将位于主内存中的所有页面的使用次数全部清零，系统以后只把使用次数为0的页面视为空闲页面。</p><h3><span id="异常处理类中断服务程序挂接">异常处理类中断服务程序挂接</span></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init/main.c</span></span><br><span class="line">trap_init();<span class="comment">// 陷阱门（硬件中断向量）初始化。（kernel/traps.c）</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kenel/traps.c</span></span><br><span class="line"><span class="comment">// 下面是异常（陷阱）中断程序初始化子程序。设置它们的中断调用门（中断向量）。</span></span><br><span class="line"><span class="comment">// set_trap_gate()与set_system_gate()的主要区别在于前者设置的特权级为0，后者是3。因此</span></span><br><span class="line"><span class="comment">// 断点陷阱中断int3、溢出中断overflow 和边界出错中断bounds 可以由任何程序产生。</span></span><br><span class="line"><span class="comment">// 这两个函数均是嵌入式汇编宏程序(include/asm/system.h,第36 行、39 行)。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trap_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">set_trap_gate(<span class="number">0</span>,&amp;divide_error);<span class="comment">// 设置除操作出错的中断向量值。以下雷同。</span></span><br><span class="line">set_trap_gate(<span class="number">1</span>,&amp;debug);</span><br><span class="line">set_trap_gate(<span class="number">2</span>,&amp;nmi);</span><br><span class="line">set_system_gate(<span class="number">3</span>,&amp;int3);<span class="comment">/* int3-5 can be called from all */</span></span><br><span class="line">set_system_gate(<span class="number">4</span>,&amp;overflow);</span><br><span class="line">set_system_gate(<span class="number">5</span>,&amp;bounds);</span><br><span class="line">set_trap_gate(<span class="number">6</span>,&amp;invalid_op);</span><br><span class="line">set_trap_gate(<span class="number">7</span>,&amp;device_not_available);</span><br><span class="line">set_trap_gate(<span class="number">8</span>,&amp;double_fault);</span><br><span class="line">set_trap_gate(<span class="number">9</span>,&amp;coprocessor_segment_overrun);</span><br><span class="line">set_trap_gate(<span class="number">10</span>,&amp;invalid_TSS);</span><br><span class="line">set_trap_gate(<span class="number">11</span>,&amp;segment_not_present);</span><br><span class="line">set_trap_gate(<span class="number">12</span>,&amp;stack_segment);</span><br><span class="line">set_trap_gate(<span class="number">13</span>,&amp;general_protection);</span><br><span class="line">set_trap_gate(<span class="number">14</span>,&amp;page_fault);</span><br><span class="line">set_trap_gate(<span class="number">15</span>,&amp;reserved);</span><br><span class="line">set_trap_gate(<span class="number">16</span>,&amp;coprocessor_error);</span><br><span class="line"><span class="comment">// 下面将int17-48 的陷阱门先均设置为reserved，以后每个硬件初始化时会重新设置自己的陷阱门。</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">17</span>;i&lt;<span class="number">48</span>;i++)</span><br><span class="line">set_trap_gate(i,&amp;reserved);</span><br><span class="line">set_trap_gate(<span class="number">45</span>,&amp;irq13);<span class="comment">// 设置协处理器的陷阱门。</span></span><br><span class="line">outb_p(inb_p(<span class="number">0x21</span>)&amp;<span class="number">0xfb</span>,<span class="number">0x21</span>);<span class="comment">// 允许主8259A 芯片的IRQ2 中断请求。</span></span><br><span class="line">outb(inb_p(<span class="number">0xA1</span>)&amp;<span class="number">0xdf</span>,<span class="number">0xA1</span>);<span class="comment">// 允许从8259A 芯片的IRQ13 中断请求。</span></span><br><span class="line">set_trap_gate(<span class="number">39</span>,&amp;parallel_interrupt);<span class="comment">// 设置并行口的陷阱门。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/asm/system.h</span></span><br><span class="line"><span class="comment">//// 设置陷阱门函数。</span></span><br><span class="line"><span class="comment">// 参数：n - 中断号；addr - 中断程序偏移地址。</span></span><br><span class="line"><span class="comment">// &amp;idt[n]对应中断号在中断描述符表中的偏移值；中断描述符的类型是15，特权级是0。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_trap_gate(n,addr) \</span></span><br><span class="line">_set_gate((<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(&amp;(idt[n])),<span class="number">15</span>,<span class="number">0</span>,(<span class="keyword">unsigned</span> <span class="keyword">long</span>)addr)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//// 设置门描述符宏函数。</span></span><br><span class="line"><span class="comment">// 参数：gate_addr -描述符地址；type -描述符中类型域值；dpl -描述符特权层值；addr -偏移地址。</span></span><br><span class="line"><span class="comment">// %0 - (由dpl,type 组合成的类型标志字)；%1 - (描述符低4 字节地址)；</span></span><br><span class="line"><span class="comment">// %2 - (描述符高4 字节地址)；%3 - edx(程序偏移地址addr)；%4 - eax(高字中含有段选择符)。</span></span><br><span class="line"><span class="keyword">void</span> _inline _set_gate(<span class="keyword">unsigned</span> <span class="keyword">long</span> *gate_addr, \</span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">short</span> type, \</span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">short</span> dpl, \</span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">long</span> addr) </span><br><span class="line">&#123;<span class="comment">// c语句和汇编语句都可以通过</span></span><br><span class="line">gate_addr[<span class="number">0</span>] = <span class="number">0x00080000</span> + (addr &amp; <span class="number">0xffff</span>);</span><br><span class="line">gate_addr[<span class="number">1</span>] = <span class="number">0x8000</span> + (dpl &lt;&lt; <span class="number">13</span>) + (type &lt;&lt; <span class="number">8</span>) + (addr &amp; <span class="number">0xffff0000</span>);</span><br><span class="line"><span class="comment">/*unsigned short tmp = 0x8000 + (dpl &lt;&lt; 13) + (type &lt;&lt; 8);</span></span><br><span class="line"><span class="comment">_asm mov eax,00080000h ;</span></span><br><span class="line"><span class="comment">_asm mov edx,addr ;</span></span><br><span class="line"><span class="comment">_asm mov ax,dx ;// 将偏移地址低字与段选择符组合成描述符低4 字节(eax)。</span></span><br><span class="line"><span class="comment">_asm mov dx,tmp ;// 将类型标志字与偏移高字组合成描述符高4 字节(edx)。</span></span><br><span class="line"><span class="comment">_asm mov ebx,gate_addr</span></span><br><span class="line"><span class="comment">_asm mov [ebx],eax ;// 分别设置门描述符的低4 字节和高4 字节。</span></span><br><span class="line"><span class="comment">_asm mov [ebx+4],edx ;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2016/02/26/Linux内核设计02-从main到怠速/1551159347271.png" alt="1551159347271"></p><h3><span id="初始化块设备请求项结构">初始化块设备请求项结构</span></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blk_dev_init();<span class="comment">// 块设备初始化。（kernel/blk_dev/ll_rw_blk.c）</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//// 块设备初始化函数，由初始化程序main.c 调用（init/main.c,128）。</span></span><br><span class="line"><span class="comment">// 初始化请求数组，将所有请求项置为空闲项(dev = -1)。有32 项(NR_REQUEST = 32)。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">blk_dev_init</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NR_REQUEST; i++)</span><br><span class="line">&#123;</span><br><span class="line">request[i].dev = <span class="number">-1</span>;</span><br><span class="line">request[i].next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 下面定义的NR_REQUEST 是请求队列中所包含的项数。</span></span><br><span class="line"><span class="comment">* 注意，读操作仅使用这些项低端的2/3；读操作优先处理。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 32 项好象是一个合理的数字：已经足够从电梯算法中获得好处，</span></span><br><span class="line"><span class="comment">* 但当缓冲区在队列中而锁住时又不显得是很大的数。64 就看上</span></span><br><span class="line"><span class="comment">* 去太大了（当大量的写/同步操作运行时很容易引起长时间的暂停）。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NR_REQUEST 32</span></span><br></pre></td></tr></table></figure><p><img src="/2016/02/26/Linux内核设计02-从main到怠速/1551163458818.png" alt="1551163458818"></p><h3><span id="与建立人机交互界面相关的外设的中断服务程序挂接">与建立人机交互界面相关的外设的中断服务程序挂接</span></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//// tty 终端初始化函数。</span></span><br><span class="line"><span class="comment">// 初始化串口终端和控制台终端。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tty_init</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">rs_init ();<span class="comment">// 初始化串行中断程序和串行接口1 和2。(serial.c, 37)</span></span><br><span class="line">con_init ();<span class="comment">// 初始化控制台终端。(console.c, 617)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//// 初始化串行中断程序和串行接口。</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">rs_init (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">set_intr_gate (<span class="number">0x24</span>, rs1_interrupt);<span class="comment">// 设置串行口1 的中断门向量(硬件IRQ4 信号)。</span></span><br><span class="line">set_intr_gate (<span class="number">0x23</span>, rs2_interrupt);<span class="comment">// 设置串行口2 的中断门向量(硬件IRQ3 信号)。</span></span><br><span class="line">init (tty_table[<span class="number">1</span>].read_q.data);<span class="comment">// 初始化串行口1(.data 是端口号)。</span></span><br><span class="line">init (tty_table[<span class="number">2</span>].read_q.data);<span class="comment">// 初始化串行口2。</span></span><br><span class="line">outb (inb_p (<span class="number">0x21</span>) &amp; <span class="number">0xE7</span>, <span class="number">0x21</span>);<span class="comment">// 允许主8259A 芯片的IRQ3，IRQ4 中断信号请求。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* void con_init(void);</span></span><br><span class="line"><span class="comment">* 这个子程序初始化控制台中断，其它什么都不做。如果你想让屏幕干净的话，就使用</span></span><br><span class="line"><span class="comment">* 适当的转义字符序列调用tty_write()函数。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 读取setup.s 程序保存的信息，用以确定当前显示器类型，并且设置所有相关参数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">con_init (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> a;</span><br><span class="line"><span class="keyword">char</span> *display_desc = <span class="string">"????"</span>;</span><br><span class="line"><span class="keyword">char</span> *display_ptr;</span><br><span class="line"></span><br><span class="line">video_num_columns = ORIG_VIDEO_COLS;<span class="comment">// 显示器显示字符列数。</span></span><br><span class="line">video_size_row = video_num_columns * <span class="number">2</span>;<span class="comment">// 每行需使用字节数。</span></span><br><span class="line">video_num_lines = ORIG_VIDEO_LINES;<span class="comment">// 显示器显示字符行数。</span></span><br><span class="line">video_page = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)ORIG_VIDEO_PAGE;<span class="comment">// 当前显示页面。</span></span><br><span class="line">video_erase_char = <span class="number">0x0720</span>;<span class="comment">// 擦除字符(0x20 显示字符， 0x07 是属性)。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果原始显示模式等于7，则表示是单色显示器。</span></span><br><span class="line"><span class="keyword">if</span> (ORIG_VIDEO_MODE == <span class="number">7</span>)<span class="comment">/* Is this a monochrome display? */</span></span><br><span class="line">&#123;</span><br><span class="line">video_mem_start = <span class="number">0xb0000</span>;<span class="comment">// 设置单显映象内存起始地址。</span></span><br><span class="line">video_port_reg = <span class="number">0x3b4</span>;<span class="comment">// 设置单显索引寄存器端口。</span></span><br><span class="line">video_port_val = <span class="number">0x3b5</span>;<span class="comment">// 设置单显数据寄存器端口。</span></span><br><span class="line"><span class="comment">// 根据BIOS 中断int 0x10 功能0x12 获得的显示模式信息，判断显示卡单色显示卡还是彩色显示卡。</span></span><br><span class="line"><span class="comment">// 如果使用上述中断功能所得到的BX 寄存器返回值不等于0x10，则说明是EGA 卡。因此初始</span></span><br><span class="line"><span class="comment">// 显示类型为EGA 单色；所使用映象内存末端地址为0xb8000；并置显示器描述字符串为'EGAm'。</span></span><br><span class="line"><span class="comment">// 在系统初始化期间显示器描述字符串将显示在屏幕的右上角。</span></span><br><span class="line"><span class="keyword">if</span> ((ORIG_VIDEO_EGA_BX &amp; <span class="number">0xff</span>) != <span class="number">0x10</span>)</span><br><span class="line">&#123;</span><br><span class="line">video_type = VIDEO_TYPE_EGAM;<span class="comment">// 设置显示类型(EGA 单色)。</span></span><br><span class="line">video_mem_end = <span class="number">0xb8000</span>;<span class="comment">// 设置显示内存末端地址。</span></span><br><span class="line">display_desc = <span class="string">"EGAm"</span>;<span class="comment">// 设置显示描述字符串。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果BX 寄存器的值等于0x10，则说明是单色显示卡MDA。则设置相应参数。</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">video_type = VIDEO_TYPE_MDA;<span class="comment">// 设置显示类型(MDA 单色)。</span></span><br><span class="line">video_mem_end = <span class="number">0xb2000</span>;<span class="comment">// 设置显示内存末端地址。</span></span><br><span class="line">display_desc = <span class="string">"*MDA"</span>;<span class="comment">// 设置显示描述字符串。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果显示模式不为7，则为彩色模式。此时所用的显示内存起始地址为0xb800；显示控制索引寄存</span></span><br><span class="line"><span class="comment">// 器端口地址为0x3d4；数据寄存器端口地址为0x3d5。</span></span><br><span class="line"><span class="keyword">else</span><span class="comment">/* If not, it is color. */</span></span><br><span class="line">&#123;</span><br><span class="line">video_mem_start = <span class="number">0xb8000</span>;<span class="comment">// 显示内存起始地址。</span></span><br><span class="line">video_port_reg = <span class="number">0x3d4</span>;<span class="comment">// 设置彩色显示索引寄存器端口。</span></span><br><span class="line">video_port_val = <span class="number">0x3d5</span>;<span class="comment">// 设置彩色显示数据寄存器端口。</span></span><br><span class="line"><span class="comment">// 再判断显示卡类别。如果BX 不等于0x10，则说明是EGA 显示卡。</span></span><br><span class="line"><span class="keyword">if</span> ((ORIG_VIDEO_EGA_BX &amp; <span class="number">0xff</span>) != <span class="number">0x10</span>)</span><br><span class="line">&#123;</span><br><span class="line">video_type = VIDEO_TYPE_EGAC;<span class="comment">// 设置显示类型(EGA 彩色)。</span></span><br><span class="line">video_mem_end = <span class="number">0xbc000</span>;<span class="comment">// 设置显示内存末端地址。</span></span><br><span class="line">display_desc = <span class="string">"EGAc"</span>;<span class="comment">// 设置显示描述字符串。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果BX 寄存器的值等于0x10，则说明是CGA 显示卡。则设置相应参数。</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">video_type = VIDEO_TYPE_CGA;<span class="comment">// 设置显示类型(CGA)。</span></span><br><span class="line">video_mem_end = <span class="number">0xba000</span>;<span class="comment">// 设置显示内存末端地址。</span></span><br><span class="line">display_desc = <span class="string">"*CGA"</span>;<span class="comment">// 设置显示描述字符串。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Let the user known what kind of display driver we are using */</span></span><br><span class="line"><span class="comment">/* 让用户知道我们正在使用哪一类显示驱动程序 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在屏幕的右上角显示显示描述字符串。采用的方法是直接将字符串写到显示内存的相应位置处。</span></span><br><span class="line"><span class="comment">// 首先将显示指针display_ptr 指到屏幕第一行右端差4 个字符处(每个字符需2 个字节，因此减8)。</span></span><br><span class="line">display_ptr = ((<span class="keyword">char</span> *) video_mem_start) + video_size_row - <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 然后循环复制字符串中的字符，并且每复制一个字符都空开一个属性字节。</span></span><br><span class="line"><span class="keyword">while</span> (*display_desc)</span><br><span class="line">&#123;</span><br><span class="line">*display_ptr++ = *display_desc++;<span class="comment">// 复制字符。</span></span><br><span class="line">display_ptr++;<span class="comment">// 空开属性字节位置。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化用于滚屏的变量(主要用于EGA/VGA) */</span></span><br><span class="line"></span><br><span class="line">origin = video_mem_start;<span class="comment">// 滚屏起始显示内存地址。</span></span><br><span class="line">scr_end = video_mem_start + video_num_lines * video_size_row;<span class="comment">// 滚屏结束内存地址。</span></span><br><span class="line">top = <span class="number">0</span>;<span class="comment">// 最顶行号。</span></span><br><span class="line">bottom = video_num_lines;<span class="comment">// 最底行号。</span></span><br><span class="line"></span><br><span class="line">gotoxy (ORIG_X, ORIG_Y);<span class="comment">// 初始化光标位置x,y 和对应的内存位置pos。</span></span><br><span class="line">set_trap_gate (<span class="number">0x21</span>, &amp;keyboard_interrupt);<span class="comment">// 设置键盘中断陷阱门。</span></span><br><span class="line">outb_p ((<span class="keyword">unsigned</span> <span class="keyword">char</span>)(inb_p (<span class="number">0x21</span>) &amp; <span class="number">0xfd</span>), <span class="number">0x21</span>);<span class="comment">// 取消8259A 中对键盘中断的屏蔽，允许IRQ1。</span></span><br><span class="line">a = inb_p (<span class="number">0x61</span>);<span class="comment">// 延迟读取键盘端口0x61(8255A 端口PB)。</span></span><br><span class="line">outb_p ((<span class="keyword">unsigned</span> <span class="keyword">char</span>)(a | <span class="number">0x80</span>), <span class="number">0x61</span>);<span class="comment">// 设置禁止键盘工作(位7 置位)，</span></span><br><span class="line">outb (a, <span class="number">0x61</span>);<span class="comment">// 再允许键盘工作，用以复位键盘操作。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2016/02/26/Linux内核设计02-从main到怠速/1551163804007.png" alt="1551163804007"></p><p><img src="/2016/02/26/Linux内核设计02-从main到怠速/1551163850692.png" alt="1551163850692"></p><p><img src="/2016/02/26/Linux内核设计02-从main到怠速/1551163891858.png" alt="1551163891858"></p><h3><span id="开机启动时间设置">开机启动时间设置</span></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time_init();<span class="comment">// 设置开机启动时间 -&gt; startup_time。</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 该子程序取CMOS 时钟，并设置开机时间 startup_time(为从1970-1-1-0 时起到开机时的秒数)。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">time_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">time</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;<span class="comment">// 参见后面CMOS 内存列表。</span></span><br><span class="line">time.tm_sec = CMOS_READ(<span class="number">0</span>);</span><br><span class="line">time.tm_min = CMOS_READ(<span class="number">2</span>);</span><br><span class="line">time.tm_hour = CMOS_READ(<span class="number">4</span>);</span><br><span class="line">time.tm_mday = CMOS_READ(<span class="number">7</span>);</span><br><span class="line">time.tm_mon = CMOS_READ(<span class="number">8</span>);</span><br><span class="line">time.tm_year = CMOS_READ(<span class="number">9</span>);</span><br><span class="line">&#125; <span class="keyword">while</span> (time.tm_sec != CMOS_READ(<span class="number">0</span>));</span><br><span class="line">BCD_TO_BIN(time.tm_sec);</span><br><span class="line">BCD_TO_BIN(time.tm_min);</span><br><span class="line">BCD_TO_BIN(time.tm_hour);</span><br><span class="line">BCD_TO_BIN(time.tm_mday);</span><br><span class="line">BCD_TO_BIN(time.tm_mon);</span><br><span class="line">BCD_TO_BIN(time.tm_year);</span><br><span class="line">time.tm_mon--;</span><br><span class="line">startup_time = kernel_mktime(&amp;time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2016/02/26/Linux内核设计02-从main到怠速/1551164025849.png" alt="1551164025849"></p><h3><span id="系统开始激活进程0">系统开始激活进程0</span></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sched_init();<span class="comment">// 调度程序初始化(加载了任务0 的tr, ldtr) （kernel/sched.c）</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调度程序的初始化子程序。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sched_init</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> *<span class="title">p</span>;</span><span class="comment">// 描述符表结构指针。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">sizeof</span> (struct sigaction) != <span class="number">16</span>)<span class="comment">// sigaction 是存放有关信号状态的结构。</span></span><br><span class="line">panic (<span class="string">"Struct sigaction MUST be 16 bytes"</span>);</span><br><span class="line"><span class="comment">// 设置初始任务（任务0）的任务状态段描述符和局部数据表描述符(include/asm/system.h,65)。</span></span><br><span class="line">set_tss_desc (gdt + FIRST_TSS_ENTRY, &amp;(init_task.task.tss));</span><br><span class="line">set_ldt_desc (gdt + FIRST_LDT_ENTRY, &amp;(init_task.task.ldt));</span><br><span class="line"><span class="comment">// 清任务数组和描述符表项（注意i=1 开始，所以初始任务的描述符还在）。</span></span><br><span class="line">p = gdt + <span class="number">2</span> + FIRST_TSS_ENTRY;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; NR_TASKS; i++)</span><br><span class="line">&#123;</span><br><span class="line">task[i] = <span class="literal">NULL</span>;</span><br><span class="line">p-&gt;a = p-&gt;b = <span class="number">0</span>;</span><br><span class="line">p++;</span><br><span class="line">p-&gt;a = p-&gt;b = <span class="number">0</span>;</span><br><span class="line">p++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 清除标志寄存器中的位NT，这样以后就不会有麻烦 */</span></span><br><span class="line"><span class="comment">// NT 标志用于控制程序的递归调用(Nested Task)。当NT 置位时，那么当前中断任务执行</span></span><br><span class="line"><span class="comment">// iret 指令时就会引起任务切换。NT 指出TSS 中的back_link 字段是否有效。</span></span><br><span class="line"><span class="comment">//  __asm__ ("pushfl ; andl $0xffffbfff,(%esp) ; popfl");// 复位NT 标志。</span></span><br><span class="line">_asm pushfd; _asm <span class="keyword">and</span> dword ptr ss:[esp],<span class="number">0xffffbfff</span>; _asm popfd;</span><br><span class="line">ltr (<span class="number">0</span>);<span class="comment">// 将任务0 的TSS 加载到任务寄存器tr。</span></span><br><span class="line">lldt (<span class="number">0</span>);<span class="comment">// 将局部描述符表加载到局部描述符表寄存器。</span></span><br><span class="line"><span class="comment">// 注意！！是将GDT 中相应LDT 描述符的选择符加载到ldtr。只明确加载这一次，以后新任务</span></span><br><span class="line"><span class="comment">// LDT 的加载，是CPU 根据TSS 中的LDT 项自动加载。</span></span><br><span class="line"><span class="comment">// 下面代码用于初始化8253 定时器。</span></span><br><span class="line">outb_p (<span class="number">0x36</span>, <span class="number">0x43</span>);<span class="comment">/* binary, mode 3, LSB/MSB, ch 0 */</span></span><br><span class="line">outb_p (LATCH &amp; <span class="number">0xff</span>, <span class="number">0x40</span>);<span class="comment">/* LSB */</span><span class="comment">// 定时值低字节。</span></span><br><span class="line">outb (LATCH &gt;&gt; <span class="number">8</span>, <span class="number">0x40</span>);<span class="comment">/* MSB */</span><span class="comment">// 定时值高字节。</span></span><br><span class="line">  <span class="comment">// 设置时钟中断处理程序句柄（设置时钟中断门）。</span></span><br><span class="line">set_intr_gate (<span class="number">0x20</span>, &amp;timer_interrupt);</span><br><span class="line">  <span class="comment">// 修改中断控制器屏蔽码，允许时钟中断。</span></span><br><span class="line">outb (inb_p (<span class="number">0x21</span>) &amp; ~<span class="number">0x01</span>, <span class="number">0x21</span>);</span><br><span class="line">  <span class="comment">// 设置系统调用中断门。</span></span><br><span class="line">set_system_gate (<span class="number">0x80</span>, &amp;system_call);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>进程相关事务初始化设置</p><p><img src="/2016/02/26/Linux内核设计02-从main到怠速/1551164154217.png" alt="1551164154217"></p></li><li><p>时钟中断设置</p><p><img src="/2016/02/26/Linux内核设计02-从main到怠速/1551164206310.png" alt="1551164206310"></p></li><li><p>系统调用服务程序挂接</p></li></ul><p><img src="/2016/02/26/Linux内核设计02-从main到怠速/1551164294583.png" alt="1551164294583"></p><h3><span id="初始化缓冲区管理结构">初始化缓冲区管理结构</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buffer_init(buffer_memory_end);<span class="comment">// 缓冲管理初始化，建内存链表等。（fs/buffer.c）</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//// 缓冲区初始化函数。</span></span><br><span class="line"><span class="comment">// 参数buffer_end 是指定的缓冲区内存的末端。对于系统有16MB 内存，则缓冲区末端设置为4MB。</span></span><br><span class="line"><span class="comment">// 对于系统有8MB 内存，缓冲区末端设置为2MB。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buffer_init</span><span class="params">(<span class="keyword">long</span> buffer_end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">h</span> = <span class="title">start_buffer</span>;</span></span><br><span class="line"><span class="keyword">void</span> * b;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果缓冲区高端等于1Mb，则由于从640KB-1MB 被显示内存和BIOS 占用，因此实际可用缓冲区内存</span></span><br><span class="line"><span class="comment">// 高端应该是640KB。否则内存高端一定大于1MB。</span></span><br><span class="line"><span class="keyword">if</span> (buffer_end == <span class="number">1</span>&lt;&lt;<span class="number">20</span>)</span><br><span class="line">b = (<span class="keyword">void</span> *) (<span class="number">640</span>*<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">b = (<span class="keyword">void</span> *) buffer_end;</span><br><span class="line"><span class="comment">// 这段代码用于初始化缓冲区，建立空闲缓冲区环链表，并获取系统中缓冲块的数目。</span></span><br><span class="line"><span class="comment">// 操作的过程是从缓冲区高端开始划分1K 大小的缓冲块，与此同时在缓冲区低端建立描述该缓冲块</span></span><br><span class="line"><span class="comment">// 的结构buffer_head，并将这些buffer_head 组成双向链表。</span></span><br><span class="line"><span class="comment">// h 是指向缓冲头结构的指针，而h+1 是指向内存地址连续的下一个缓冲头地址，也可以说是指向h</span></span><br><span class="line"><span class="comment">// 缓冲头的末端外。为了保证有足够长度的内存来存储一个缓冲头结构，需要b 所指向的内存块</span></span><br><span class="line"><span class="comment">// 地址&gt;= h 缓冲头的末端，也即要&gt;=h+1。</span></span><br><span class="line"><span class="keyword">while</span> ( (b = (<span class="keyword">char</span>*)b - BLOCK_SIZE) &gt;= ((<span class="keyword">void</span> *) (h+<span class="number">1</span>)) ) &#123;</span><br><span class="line">h-&gt;b_dev = <span class="number">0</span>;<span class="comment">// 使用该缓冲区的设备号。</span></span><br><span class="line">h-&gt;b_dirt = <span class="number">0</span>;<span class="comment">// 脏标志，也即缓冲区修改标志。</span></span><br><span class="line">h-&gt;b_count = <span class="number">0</span>;<span class="comment">// 该缓冲区引用计数。</span></span><br><span class="line">h-&gt;b_lock = <span class="number">0</span>;<span class="comment">// 缓冲区锁定标志。</span></span><br><span class="line">h-&gt;b_uptodate = <span class="number">0</span>;<span class="comment">// 缓冲区更新标志（或称数据有效标志）。</span></span><br><span class="line">h-&gt;b_wait = <span class="literal">NULL</span>;<span class="comment">// 指向等待该缓冲区解锁的进程。</span></span><br><span class="line">h-&gt;b_next = <span class="literal">NULL</span>;<span class="comment">// 指向具有相同hash 值的下一个缓冲头。</span></span><br><span class="line">h-&gt;b_prev = <span class="literal">NULL</span>;<span class="comment">// 指向具有相同hash 值的前一个缓冲头。</span></span><br><span class="line">h-&gt;b_data = (<span class="keyword">char</span> *) b;<span class="comment">// 指向对应缓冲区数据块（1024 字节）。</span></span><br><span class="line">h-&gt;b_prev_free = h<span class="number">-1</span>;<span class="comment">// 指向链表中前一项。</span></span><br><span class="line">h-&gt;b_next_free = h+<span class="number">1</span>;<span class="comment">// 指向链表中下一项。</span></span><br><span class="line">h++;<span class="comment">// h 指向下一新缓冲头位置。</span></span><br><span class="line">NR_BUFFERS++;<span class="comment">// 缓冲区块数累加。</span></span><br><span class="line"><span class="keyword">if</span> (b == (<span class="keyword">void</span> *) <span class="number">0x100000</span>)<span class="comment">// 如果地址b 递减到等于1MB，则跳过384KB，</span></span><br><span class="line">b = (<span class="keyword">void</span> *) <span class="number">0xA0000</span>;<span class="comment">// 让b 指向地址0xA0000(640KB)处。</span></span><br><span class="line">&#125;</span><br><span class="line">h--;<span class="comment">// 让h 指向最后一个有效缓冲头。</span></span><br><span class="line">free_list = start_buffer;<span class="comment">// 让空闲链表头指向头一个缓冲区头。</span></span><br><span class="line">free_list-&gt;b_prev_free = h;<span class="comment">// 链表头的b_prev_free 指向前一项（即最后一项）。</span></span><br><span class="line">h-&gt;b_next_free = free_list;<span class="comment">// h 的下一项指针指向第一项，形成一个环链。</span></span><br><span class="line"><span class="comment">// 初始化hash 表（哈希表、散列表），置表中所有的指针为NULL。</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;NR_HASH;i++)</span><br><span class="line">hash_table[i]=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2016/02/26/Linux内核设计02-从main到怠速/1551164581529.png" alt="1551164581529"></p><h3><span id="初始化硬盘">初始化硬盘</span></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hd_init();<span class="comment">// 硬盘初始化。（kernel/blk_dev/hd.c）</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 硬盘系统初始化。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hd_init</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">blk_dev[MAJOR_NR].request_fn = DEVICE_REQUEST;<span class="comment">// do_hd_request()。</span></span><br><span class="line">set_intr_gate (<span class="number">0x2E</span>, &amp;hd_interrupt);<span class="comment">// 设置硬盘中断门向量 int 0x2E(46)。</span></span><br><span class="line"><span class="comment">// hd_interrupt 在(kernel/system_call.s,221)。</span></span><br><span class="line">outb_p (inb_p (<span class="number">0x21</span>) &amp; <span class="number">0xfb</span>, <span class="number">0x21</span>);<span class="comment">// 复位接联的主8259A int2 的屏蔽位，允许从片</span></span><br><span class="line"><span class="comment">// 发出中断请求信号。</span></span><br><span class="line">outb (inb_p (<span class="number">0xA1</span>) &amp; <span class="number">0xbf</span>, <span class="number">0xA1</span>);<span class="comment">// 复位硬盘的中断请求屏蔽位（在从片上），允许</span></span><br><span class="line"><span class="comment">// 硬盘控制器发送中断请求信号。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/blk_drv/hd.c</span></span><br><span class="line"><span class="comment">// 执行硬盘读写请求操作。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_hd_request</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, r;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> block, dev;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> sec, head, cyl;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> nsect;</span><br><span class="line"></span><br><span class="line">INIT_REQUEST;<span class="comment">// 检测请求项的合法性(参见kernel/blk_drv/blk.h,127)。</span></span><br><span class="line"><span class="comment">// 取设备号中的子设备号(见列表后对硬盘设备号的说明)。子设备号即是硬盘上的分区号。</span></span><br><span class="line">dev = MINOR (CURRENT-&gt;dev);<span class="comment">// CURRENT 定义为(blk_dev[MAJOR_NR].current_request)。</span></span><br><span class="line">block = CURRENT-&gt;sector;<span class="comment">// 请求的起始扇区。</span></span><br><span class="line"><span class="comment">// 如果子设备号不存在或者起始扇区大于该分区扇区数-2，则结束该请求，并跳转到标号repeat 处</span></span><br><span class="line"><span class="comment">// （定义在INIT_REQUEST 开始处）。因为一次要求读写2 个扇区（512*2 字节），所以请求的扇区号</span></span><br><span class="line"><span class="comment">// 不能大于分区中最后倒数第二个扇区号。</span></span><br><span class="line"><span class="keyword">if</span> (dev &gt;= <span class="number">5</span> * NR_HD || block + <span class="number">2</span> &gt; hd[dev].nr_sects)</span><br><span class="line">&#123;</span><br><span class="line">end_request (<span class="number">0</span>);</span><br><span class="line"><span class="keyword">goto</span> repeat;<span class="comment">// 该标号在blk.h 最后面。</span></span><br><span class="line">&#125;</span><br><span class="line">block += hd[dev].start_sect;<span class="comment">// 将所需读的块对应到整个硬盘上的绝对扇区号。</span></span><br><span class="line">dev /= <span class="number">5</span>;<span class="comment">// 此时dev 代表硬盘号（0 或1）。</span></span><br><span class="line"><span class="comment">// 下面嵌入汇编代码用来从硬盘信息结构中根据起始扇区号和每磁道扇区数计算在磁道中的</span></span><br><span class="line"><span class="comment">// 扇区号(sec)、所在柱面号(cyl)和磁头号(head)。</span></span><br><span class="line">sec = hd_info[dev].sect;</span><br><span class="line">_asm &#123;</span><br><span class="line">mov eax,block</span><br><span class="line">xor edx,edx</span><br><span class="line">mov ebx,sec</span><br><span class="line">div ebx</span><br><span class="line">mov block,eax</span><br><span class="line">mov sec,edx</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//__asm__ ("divl %4": "=a" (block), "=d" (sec):"" (block), "1" (0),</span></span><br><span class="line"><span class="comment">//   "r" (hd_info[dev].</span></span><br><span class="line"><span class="comment">//sect));</span></span><br><span class="line">head = hd_info[dev].head;</span><br><span class="line">_asm &#123;</span><br><span class="line">mov eax,block</span><br><span class="line">xor edx,edx</span><br><span class="line">mov ebx,head</span><br><span class="line">div ebx</span><br><span class="line">mov cyl,eax</span><br><span class="line">mov head,edx</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//__asm__ ("divl %4": "=a" (cyl), "=d" (head):"" (block), "1" (0),</span></span><br><span class="line"><span class="comment">//   "r" (hd_info[dev].</span></span><br><span class="line"><span class="comment">//head));</span></span><br><span class="line">sec++;</span><br><span class="line">nsect = CURRENT-&gt;nr_sectors;<span class="comment">// 欲读/写的扇区数。</span></span><br><span class="line"><span class="comment">// 如果reset 置1，则执行复位操作。复位硬盘和控制器，并置需要重新校正标志，返回。</span></span><br><span class="line"><span class="keyword">if</span> (reset)</span><br><span class="line">&#123;</span><br><span class="line">reset = <span class="number">0</span>;</span><br><span class="line">recalibrate = <span class="number">1</span>;</span><br><span class="line">reset_hd (CURRENT_DEV);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果重新校正标志(recalibrate)置位，则首先复位该标志，然后向硬盘控制器发送重新校正命令。</span></span><br><span class="line"><span class="keyword">if</span> (recalibrate)</span><br><span class="line">&#123;</span><br><span class="line">recalibrate = <span class="number">0</span>;</span><br><span class="line">hd_out (dev, hd_info[CURRENT_DEV].sect, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">  WIN_RESTORE, &amp;recal_intr);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果当前请求是写扇区操作，则发送写命令，循环读取状态寄存器信息并判断请求服务标志</span></span><br><span class="line"><span class="comment">// DRQ_STAT 是否置位。DRQ_STAT 是硬盘状态寄存器的请求服务位（include/linux/hdreg.h，27）。</span></span><br><span class="line"><span class="keyword">if</span> (CURRENT-&gt;cmd == WRITE)</span><br><span class="line">&#123;</span><br><span class="line">hd_out (dev, nsect, sec, head, cyl, WIN_WRITE, &amp;write_intr);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3000</span> &amp;&amp; !(r = inb_p (HD_STATUS) &amp; DRQ_STAT); i++)</span><br><span class="line"><span class="comment">// 如果请求服务位置位则退出循环。若等到循环结束也没有置位，则此次写硬盘操作失败，去处理</span></span><br><span class="line"><span class="comment">// 下一个硬盘请求。否则向硬盘控制器数据寄存器端口HD_DATA 写入1 个扇区的数据。</span></span><br><span class="line"><span class="keyword">if</span> (!r)</span><br><span class="line">&#123;</span><br><span class="line">bad_rw_intr ();</span><br><span class="line"><span class="keyword">goto</span> repeat;<span class="comment">// 该标号在blk.h 最后面，也即跳到301 行。</span></span><br><span class="line">&#125;</span><br><span class="line">port_write (HD_DATA, CURRENT-&gt;buffer, <span class="number">256</span>);</span><br><span class="line"><span class="comment">// 如果当前请求是读硬盘扇区，则向硬盘控制器发送读扇区命令。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (CURRENT-&gt;cmd == READ)</span><br><span class="line">&#123;</span><br><span class="line">hd_out (dev, nsect, sec, head, cyl, WIN_READ, &amp;read_intr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">panic (<span class="string">"unknown hd-command"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2016/02/26/Linux内核设计02-从main到怠速/1551164769475.png" alt="1551164769475"></p><h3><span id="初始化软盘">初始化软盘</span></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//// 软盘系统初始化。</span></span><br><span class="line"><span class="comment">// 设置软盘块设备的请求处理函数(do_fd_request())，并设置软盘中断门(int 0x26，对应硬件</span></span><br><span class="line"><span class="comment">// 中断请求信号IRQ6），然后取消对该中断信号的屏蔽，允许软盘控制器FDC 发送中断请求信号。</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">floppy_init (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">blk_dev[MAJOR_NR].request_fn = DEVICE_REQUEST;<span class="comment">// = do_fd_request()。</span></span><br><span class="line">set_trap_gate (<span class="number">0x26</span>, &amp;floppy_interrupt);<span class="comment">//设置软盘中断门 int 0x26(38)。</span></span><br><span class="line">outb (inb_p (<span class="number">0x21</span>) &amp; ~<span class="number">0x40</span>, <span class="number">0x21</span>);<span class="comment">// 复位软盘的中断请求屏蔽位，允许</span></span><br><span class="line"><span class="comment">// 软盘控制器发送中断请求信号。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2016/02/26/Linux内核设计02-从main到怠速/1551164843770.png" alt="1551164843770"></p><h3><span id="开中断">开中断</span></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sti();<span class="comment">// 所有初始化工作都做完了，开启中断。</span></span><br></pre></td></tr></table></figure><p><img src="/2016/02/26/Linux内核设计02-从main到怠速/1551164931203.png" alt="1551164931203"></p><h2><span id="进程创建的最基本动作">进程创建的最基本动作</span></h2><h3><span id="操作系统为进程0创建进程1做准备">操作系统为进程0创建进程1做准备</span></h3><p>在Linux 0.11中，除进程0外，所有进程都是由一个已有进程在用户态下完成创建的。</p><p>为了遵守这个规则，在进程0正式创建进程1之前，要将进程0由内核态转变为用户态，方法是调用move_to_user_mode函数，模仿中断返回动作，实现进程0的特权级从内核态转变为用户态。</p><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面过程通过在堆栈中设置的参数，利用中断返回指令切换到任务0。</span></span><br><span class="line">move_to_user_mode();<span class="comment">// 移到用户模式。（include/asm/system.h）</span></span><br><span class="line"><span class="keyword">if</span> (!fork()) &#123;<span class="comment">/* we count on this going ok */</span></span><br><span class="line">init();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//// 切换到用户模式运行。</span></span><br><span class="line"><span class="comment">// 该函数利用iret 指令实现从内核模式切换到用户模式（初始任务0）。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> move_to_user_mode() \</span></span><br><span class="line">_asm &#123; \</span><br><span class="line">_asm mov eax,esp <span class="comment">/* 保存堆栈指针esp 到eax 寄存器中。*/</span>\</span><br><span class="line">_asm push <span class="number">00000017</span>h <span class="comment">/* 首先将堆栈段选择符(SS)入栈。*/</span>\</span><br><span class="line">_asm push eax <span class="comment">/* 然后将保存的堆栈指针值(esp)入栈。*/</span>\</span><br><span class="line">_asm pushfd <span class="comment">/* 将标志寄存器(eflags)内容入栈。*/</span>\</span><br><span class="line">_asm push <span class="number">0000000f</span>h <span class="comment">/* 将内核代码段选择符(cs)入栈。*/</span>\</span><br><span class="line">_asm push offset l1 <span class="comment">/* 将下面标号l1 的偏移地址(eip)入栈。*/</span>\</span><br><span class="line">_asm iretd <span class="comment">/* 执行中断返回指令，则会跳转到下面标号1 处。*/</span>\</span><br><span class="line">_asm l1: mov eax,<span class="number">17</span>h <span class="comment">/* 此时开始执行任务0，*/</span>\</span><br><span class="line">_asm mov ds,ax <span class="comment">/* 初始化段寄存器指向本局部表的数据段。*/</span>\</span><br><span class="line">_asm mov es,ax \</span><br><span class="line">_asm mov fs,ax \</span><br><span class="line">_asm mov gs,ax \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行iretd时，硬件会将从上至下的5个push压栈的数据分别出栈，给ss、esp、eflags、cs、eip。</p><p>压栈顺序与通常中断时硬件的压栈动作一样，只是iret前面并没有一个真正的中断引起的压栈动作，所以说是模仿，等到执行iret时，返回的效果却是一样的。</p><p><img src="/2016/02/26/Linux内核设计02-从main到怠速/1551167170538.png" alt="1551167170538"></p><h3><span id="在进程槽中为进程1申请一个空闲位置并获取进程号">在进程槽中为进程1申请一个空闲位置并获取进程号</span></h3><h3><span id="复制进程信息之前先将以下数据压栈">复制进程信息之前，先将以下数据压栈</span></h3><h3><span id="初步设置进程1管理结构">初步设置进程1管理结构</span></h3><h3><span id="进程0创建进程1的过程中发生时钟中断">进程0创建进程1的过程中发生时钟中断</span></h3><h3><span id="从时钟中断返回">从时钟中断返回</span></h3><h3><span id="调整进程1管理结构">调整进程1管理结构</span></h3><h3><span id="设置进程1的线性地址空间及物理页面">设置进程1的线性地址空间及物理页面</span></h3><h3><span id="继续调整进程1管理结构">继续调整进程1管理结构</span></h3><h2><span id="加载根文件系统">加载根文件系统</span></h2><h3><span id="进程1如何开始执行">进程1如何开始执行</span></h3><h3><span id="进程1开始执行">进程1开始执行</span></h3><h3><span id="进程1开始以数据块的形式操作硬盘">进程1开始以数据块的形式操作硬盘</span></h3><h3><span id="将找到的缓冲块与请求项挂接">将找到的缓冲块与请求项挂接</span></h3><h3><span id="将请求项与硬盘处理函数挂接">将请求项与硬盘处理函数挂接</span></h3><h3><span id="进行硬盘读盘前的准备工作">进行硬盘读盘前的准备工作</span></h3><h3><span id="给硬盘下达读盘指令">给硬盘下达读盘指令</span></h3><h3><span id="进程1由于等待读盘操作挂起">进程1由于等待读盘操作挂起</span></h3><h3><span id="系统切换到进程0执行">系统切换到进程0执行</span></h3><h3><span id="进程0的执行过程">进程0的执行过程</span></h3><h3><span id="进程0执行过程中发生硬盘中断">进程0执行过程中发生硬盘中断</span></h3><h3><span id="硬盘中断服务程序响应后进程0继续执行">硬盘中断服务程序响应后，进程0继续执行</span></h3><h3><span id="再次响应硬盘中断并唤醒进程1">再次响应硬盘中断并唤醒进程1</span></h3><h3><span id="读盘操作完成后进程1继续执行">读盘操作完成后，进程1继续执行</span></h3><h3><span id="进程1继续设置硬盘管理结构">进程1继续设置硬盘管理结构</span></h3><h3><span id="进程1获取软盘超级块为加载根文件系统做准备">进程1获取软盘超级块，为加载根文件系统做准备</span></h3><h3><span id="进程1备份超级块数据">进程1备份超级块数据</span></h3><h3><span id="进程1将根文件系统从软盘拷贝到虚拟盘">进程1将根文件系统从软盘拷贝到虚拟盘</span></h3><h3><span id="进程1开始加载根文件系统">进程1开始加载根文件系统</span></h3><h3><span id="进程1准备加载根文件系统超级块">进程1准备加载根文件系统超级块</span></h3><h3><span id="进程1加载根文件系统超级块">进程1加载根文件系统超级块</span></h3><h3><span id="进程1继续加载根文件系统">进程1继续加载根文件系统</span></h3><h3><span id="进程1准备读取根目录i节点">进程1准备读取根目录i节点</span></h3><h3><span id="进程1加载根目录i节点">进程1加载根目录i节点</span></h3><h3><span id="进程1结束加载根文件系统的过程">进程1结束加载根文件系统的过程</span></h3><h2><span id="打开终端设备文件及复制文件句柄">打开终端设备文件及复制文件句柄</span></h2><h3><span id="进程1与内核文件表挂接为打开文件做准备">进程1与内核文件表挂接，为打开文件做准备</span></h3><h3><span id="确定打开操作的起点">确定打开操作的起点</span></h3><h3><span id="获得枝梢i节点-dev目录文件的i节点">获得枝梢i节点-dev目录文件的i节点</span></h3><h3><span id="确定dev目录文件i节点为枝梢i节点">确定dev目录文件i节点为枝梢i节点</span></h3><h3><span id="继续返回枝梢i节点">继续返回枝梢i节点</span></h3><h3><span id="查找tty0文件的i节点">查找tty0文件的i节点</span></h3><h3><span id="将tty0设备文件的i节点返回给sys_open系统调用">将tty0设备文件的i节点返回给sys_open系统调用</span></h3><h3><span id="分析tty0文件i节点">分析tty0文件i节点</span></h3><h3><span id="设置文件管理结构并返回给用户进程">设置文件管理结构并返回给用户进程</span></h3><h3><span id="进程1复制tty0文件句柄">进程1复制tty0文件句柄</span></h3><h3><span id="进程1继续复制tty0文件句柄">进程1继续复制tty0文件句柄</span></h3><h2><span id="创建进程2">创建进程2</span></h2><h3><span id="进程1准备创建进程2">进程1准备创建进程2</span></h3><h3><span id="复制进程2管理结构并继续调整">复制进程2管理结构并继续调整</span></h3><h3><span id="设置进程2的页目录项并复制进程2的页表">设置进程2的页目录项并复制进程2的页表</span></h3><h3><span id="调整进程2管理结构中与文件有关的内容">调整进程2管理结构中与文件有关的内容</span></h3><h3><span id="进程1执行过程中发生时钟中断">进程1执行过程中发生时钟中断</span></h3><h3><span id="进程1从时钟中断返回准备切换到进程2">进程1从时钟中断返回，准备切换到进程2</span></h3><h2><span id="进程1等待进程2退出">进程1等待进程2退出</span></h2><h2><span id="shell程序的加载">shell程序的加载</span></h2><h2><span id="系统实现怠速">系统实现怠速</span></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#从main到怠速&quot;&gt;从main到怠速&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#开中断之前的准备工作&quot;&gt;开中断之前的准备工作&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#复制根设备号和硬盘参数表&quot;&gt;复制根设备号和硬
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
</feed>
