<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>javfa&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-02-26T03:21:09.869Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Javfa</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux内核设计03-安装文件系统</title>
    <link href="http://yoursite.com/2019/02/26/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A103-%E5%AE%89%E8%A3%85%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2019/02/26/Linux内核设计03-安装文件系统/</id>
    <published>2019-02-26T03:20:14.000Z</published>
    <updated>2019-02-26T03:21:09.869Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#安装文件系统">安装文件系统</a><ul><li><a href="#获取硬盘设备号">获取硬盘设备号</a></li><li><a href="#获取虚拟盘上的挂接点">获取虚拟盘上的挂接点</a></li><li><a href="#得到hd1设备文件的超级块">得到hd1设备文件的超级块</a></li><li><a href="#将hd1设备文件与mnt目录文件的i节点挂接">将hd1设备文件与mnt目录文件的i节点挂接</a></li></ul></li></ul><!-- tocstop --><h1><span id="安装文件系统">安装文件系统</span></h1><h2><span id="获取硬盘设备号">获取硬盘设备号</span></h2><h2><span id="获取虚拟盘上的挂接点">获取虚拟盘上的挂接点</span></h2><h2><span id="得到hd1设备文件的超级块">得到hd1设备文件的超级块</span></h2><h2><span id="将hd1设备文件与mnt目录文件的i节点挂接">将hd1设备文件与mnt目录文件的i节点挂接</span></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#安装文件系统&quot;&gt;安装文件系统&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#获取硬盘设备号&quot;&gt;获取硬盘设备号&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#获取虚拟盘上的挂接点&quot;&gt;获取虚拟盘上的挂接点&lt;/a&gt;&lt;/li&gt;
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript In A Nutshell</title>
    <link href="http://yoursite.com/2019/02/26/JavaScript-In-A-Nutshell/"/>
    <id>http://yoursite.com/2019/02/26/JavaScript-In-A-Nutshell/</id>
    <published>2019-02-25T17:49:28.000Z</published>
    <updated>2019-02-26T03:18:30.621Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="javascript基础">JavaScript基础</span></h1><h2><span id="javascript组成">JavaScript组成</span></h2><ul><li>ECMAScript：</li><li>DOM</li><li>BOM</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;javascript基础&quot;&gt;JavaScript基础&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span id=&quot;javascript组成&quot;&gt;JavaScript组成&lt;/span&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;ECMAScript：&lt;/li&gt;
&lt;li&gt;DOM&lt;/l
      
    
    </summary>
    
    
      <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>lua进阶学习</title>
    <link href="http://yoursite.com/2019/02/26/lua%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/02/26/lua进阶学习/</id>
    <published>2019-02-25T16:54:43.000Z</published>
    <updated>2019-02-25T17:26:29.608Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="lua" scheme="http://yoursite.com/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>亿级流量详情页开发</title>
    <link href="http://yoursite.com/2019/02/25/%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F%E8%AF%A6%E6%83%85%E9%A1%B5%E5%BC%80%E5%8F%91/"/>
    <id>http://yoursite.com/2019/02/25/亿级流量详情页开发/</id>
    <published>2019-02-25T05:28:39.000Z</published>
    <updated>2019-02-25T05:44:25.852Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx源码分析</title>
    <link href="http://yoursite.com/2019/02/24/Nginx%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/02/24/Nginx源码分析/</id>
    <published>2019-02-24T14:06:15.000Z</published>
    <updated>2019-02-25T11:00:03.948Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#内存池管理">内存池管理</a><ul><li><a href="#概述">概述</a></li><li><a href="#内存池基本结构">内存池基本结构</a></li><li><a href="#内存池操作">内存池操作</a><ul><li><a href="#创建内存池">创建内存池</a></li><li><a href="#销毁内存池">销毁内存池</a></li><li><a href="#重置内存池">重置内存池</a></li><li><a href="#内存分配">内存分配</a><ul><li><a href="#小块内存分配">小块内存分配</a></li><li><a href="#大块内存分配">大块内存分配</a></li></ul></li><li><a href="#cleanup资源">cleanup资源</a></li></ul></li></ul></li><li><a href="#理解event模块的实现">理解Event模块的实现</a><ul><li><a href="#事件驱动">事件驱动</a></li></ul></li></ul><!-- tocstop --><h1><span id="内存池管理">内存池管理</span></h1><h2><span id="概述">概述</span></h2><p>Nginx使用内存池管理内存，把内存分配归结为大内存分配和小内存分配。</p><ul><li>不会直接在内存池上分配内存来满足大块内存的分配请求，而是直接向系统申请一块内存（直接使用malloc分配），然后将这块内存挂到内存池头部的large字段下。</li><li>小块内存的分配，则是从已有的内存池数据区中去分配。</li></ul><p>内存管理相关文件：</p><ol><li><p><code>src/os/unix/ngx_alloc.h/.c</code></p><ul><li>内存相关操作，封装了最基本的内存分配函数</li><li>如<code>free/malloc/memalign/posix_memalign</code>，分别被封装为<code>ngx_free/ngx_alloc/ngx_calloc/ngx_memalign</code><ul><li>ngx_alloc: 封装malloc分配内存</li><li>ngx_calloc：封装malloc分配内存，并初始化空间内容为0</li><li>ngx_memalign：返回一个基于指定alignment的大小为size的内存空间，且其地址为alignment的整数倍，alignment为2的幂。</li></ul></li></ul></li><li><p><code>src/core/ngx_palloc.h/.c</code></p><p>​    封装创建/销毁内存池，从内存池分配空间等函数</p></li></ol><p>Nginx内存分配流程图如下：（其中size为用户请求分配内存的大小，pool是现有内存池）</p><p><img src="assets/1551024279337.png" alt="1551024279337"></p><h2><span id="内存池基本结构">内存池基本结构</span></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 内存池结构 */</span></span><br><span class="line"><span class="comment">/* 文件 core/ngx_palloc.h */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span><span class="comment">/* 内存池数据结构模块 */</span></span><br><span class="line">    u_char               *last; <span class="comment">/* 当前内存分配的结束位置，即下一段可分配内存的起始位置 */</span></span><br><span class="line">    u_char               *end;  <span class="comment">/* 内存池的结束位置 */</span></span><br><span class="line">    <span class="keyword">ngx_pool_t</span>           *next; <span class="comment">/* 指向下一个内存池 */</span></span><br><span class="line">    <span class="keyword">ngx_uint_t</span>            failed;<span class="comment">/* 记录内存池内存分配失败的次数 */</span></span><br><span class="line">&#125; <span class="keyword">ngx_pool_data_t</span>;  <span class="comment">/* 维护内存池的数据块 */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_s</span> &#123;</span><span class="comment">/* 内存池的管理模块，即内存池头部结构 */</span></span><br><span class="line">    <span class="keyword">ngx_pool_data_t</span>       d;    <span class="comment">/* 内存池的数据块 */</span></span><br><span class="line">    <span class="keyword">size_t</span>                max;  <span class="comment">/* 内存池数据块的最大值 */</span></span><br><span class="line">    <span class="keyword">ngx_pool_t</span>           *current;<span class="comment">/* 指向当前内存池 */</span></span><br><span class="line">    <span class="keyword">ngx_chain_t</span>          *chain;<span class="comment">/* 指向一个 ngx_chain_t 结构 */</span></span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>     *large;<span class="comment">/* 大块内存链表，即分配空间超过 max 的内存 */</span></span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span>   *cleanup;<span class="comment">/* 析构函数，释放内存池 */</span></span><br><span class="line">    <span class="keyword">ngx_log_t</span>            *<span class="built_in">log</span>;<span class="comment">/* 内存分配相关的日志信息 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* 文件 core/ngx_core.h */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_s</span>   <span class="title">ngx_pool_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_chain_s</span>  <span class="title">ngx_chain_t</span>;</span></span><br></pre></td></tr></table></figure><p>大块内存分配的数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_large_s</span> <span class="title">ngx_pool_large_t</span>;</span>  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_large_s</span>&#123;</span>  </span><br><span class="line">          <span class="keyword">ngx_pool_large_t</span>  *next;    <span class="comment">//指向下一块大块内存  </span></span><br><span class="line">          <span class="keyword">void</span>    *alloc;             <span class="comment">//指向分配的大块内存  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其他数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*ngx_pool_cleanup_pt)</span><span class="params">(<span class="keyword">void</span> *data)</span></span>;    <span class="comment">//cleanup的callback类型  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_cleanup_s</span> <span class="title">ngx_pool_cleanup_t</span>;</span>  </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_cleanup_s</span>&#123;</span>  </span><br><span class="line">    ngx_pool_cleanup_pt handler;  </span><br><span class="line">    <span class="keyword">void</span>    *data;              <span class="comment">//指向要清除的数据  </span></span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span> *next;   <span class="comment">//下一个cleanup callback  </span></span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>  </span><br><span class="line">    <span class="keyword">ngx_fd_t</span>   fd;  </span><br><span class="line">    u_char    *name;  </span><br><span class="line">    <span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>;  </span><br><span class="line">&#125; <span class="keyword">ngx_pool_cleanup_file_t</span>;</span><br></pre></td></tr></table></figure><p>内存池基本结构之间的关系如下图所示：</p><p><img src="assets/1551028372193.png" alt="1551028372193"></p><p><img src="assets/1551028537439.png" alt="1551028537439"></p><h2><span id="内存池操作">内存池操作</span></h2><h3><span id="创建内存池">创建内存池</span></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建内存池，该函数定义于 src/core/ngx_palloc.c 文件中 */</span></span><br><span class="line"><span class="keyword">ngx_pool_t</span> *</span><br><span class="line">ngx_create_pool(<span class="keyword">size_t</span> size, <span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">ngx_pool_t</span>  *p; <span class="comment">/* 执行内存池头部 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 分配大小为 size 的内存 */</span></span><br><span class="line">    <span class="comment">/* ngx_memalign 函数实现于 src/os/unix/ngx_alloc.c 文件中 */</span></span><br><span class="line">    p = ngx_memalign(NGX_POOL_ALIGNMENT, size, <span class="built_in">log</span>);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 以下是初始化 ngx_pool_t 结构信息 */</span></span><br><span class="line"></span><br><span class="line">    p-&gt;d.last = (u_char *) p + <span class="keyword">sizeof</span>(<span class="keyword">ngx_pool_t</span>);</span><br><span class="line">    p-&gt;d.end = (u_char *) p + size;</span><br><span class="line">    p-&gt;d.next = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    size = size - <span class="keyword">sizeof</span>(<span class="keyword">ngx_pool_t</span>);   <span class="comment">/* 可供分配的空间大小 */</span></span><br><span class="line">    <span class="comment">/* 不能超过最大的限定值 4096B */</span></span><br><span class="line">    p-&gt;max = (size &lt; NGX_MAX_ALLOC_FROM_POOL) ? size : NGX_MAX_ALLOC_FROM_POOL;</span><br><span class="line"></span><br><span class="line">    p-&gt;current = p; <span class="comment">/* 指向当前的内存池 */</span></span><br><span class="line">    p-&gt;chain = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;large = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;cleanup = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;<span class="built_in">log</span> = <span class="built_in">log</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *  </span><br><span class="line">ngx_memalign(<span class="keyword">size_t</span> alignment, <span class="keyword">size_t</span> size, <span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">void</span>  *p;  </span><br><span class="line">    <span class="keyword">int</span>    err;  </span><br><span class="line">      </span><br><span class="line">    err = posix_memalign(&amp;p, alignment, size);  </span><br><span class="line">    <span class="comment">//该函数分配以alignment为对齐的size字节的内存大小，其中p指向分配的内存块。  </span></span><br><span class="line">      </span><br><span class="line">    <span class="keyword">if</span> (err) &#123;  </span><br><span class="line">        ngx_log_error(NGX_LOG_EMERG, <span class="built_in">log</span>, err,  </span><br><span class="line">            <span class="string">"posix_memalign(%uz, %uz) failed"</span>, alignment, size);  </span><br><span class="line">        p = <span class="literal">NULL</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    ngx_log_debug3(NGX_LOG_DEBUG_ALLOC, <span class="built_in">log</span>, <span class="number">0</span>,  </span><br><span class="line">        <span class="string">"posix_memalign: %p:%uz @%uz"</span>, p, size, alignment);  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> p;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//函数分配以NGX_POOL_ALIGNMENT字节对齐的size字节的内存，在src/core/ngx_palloc.h文件中：  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_POOL_ALIGNMENT       16</span></span><br></pre></td></tr></table></figure><h3><span id="销毁内存池">销毁内存池</span></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 销毁内存池 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">ngx_destroy_pool(<span class="keyword">ngx_pool_t</span> *pool)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">ngx_pool_t</span>          *p, *n;</span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>    *l;</span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span>  *c;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 若注册了cleanup，则遍历该链表结构，依次调用handler函数清理数据 */</span></span><br><span class="line">    <span class="keyword">for</span> (c = pool-&gt;cleanup; c; c = c-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;handler) &#123;</span><br><span class="line">            ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</span><br><span class="line">                           <span class="string">"run cleanup: %p"</span>, c);</span><br><span class="line">            c-&gt;handler(c-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 遍历 large 链表，释放大块内存 */</span></span><br><span class="line">    <span class="keyword">for</span> (l = pool-&gt;large; l; l = l-&gt;next) &#123;</span><br><span class="line"></span><br><span class="line">        ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool-&gt;<span class="built_in">log</span>, <span class="number">0</span>, <span class="string">"free: %p"</span>, l-&gt;alloc);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l-&gt;alloc) &#123;</span><br><span class="line">            ngx_free(l-&gt;alloc); <span class="comment">/* 释放内存 */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 在debug模式下执行 if 和 endif 之间的代码；</span></span><br><span class="line"><span class="comment">     * 主要是用于log记录，跟踪函数销毁时日志信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (NGX_DEBUG)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * we could allocate the pool-&gt;log from this pool</span></span><br><span class="line"><span class="comment">     * so we cannot use this log while free()ing the pool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (p = pool, n = pool-&gt;d.next; <span class="comment">/* void */</span>; p = n, n = n-&gt;d.next) &#123;</span><br><span class="line">        ngx_log_debug2(NGX_LOG_DEBUG_ALLOC, pool-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</span><br><span class="line">                       <span class="string">"free: %p, unused: %uz"</span>, p, p-&gt;d.end - p-&gt;d.last);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 遍历所有分配的内存池，释放内存池结构 */</span></span><br><span class="line">    <span class="keyword">for</span> (p = pool, n = pool-&gt;d.next; <span class="comment">/* void */</span>; p = n, n = n-&gt;d.next) &#123;</span><br><span class="line">        ngx_free(p);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="重置内存池">重置内存池</span></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 重置内存池</span></span><br><span class="line"><span class="comment"> * 定义于 src/core/ngx_palloc.c 文件中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">ngx_reset_pool(<span class="keyword">ngx_pool_t</span> *pool)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">ngx_pool_t</span>        *p;</span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>  *l;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 遍历大块内存链表，释放大块内存 */</span></span><br><span class="line">    <span class="keyword">for</span> (l = pool-&gt;large; l; l = l-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l-&gt;alloc) &#123;</span><br><span class="line">            ngx_free(l-&gt;alloc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (p = pool; p; p = p-&gt;d.next) &#123;</span><br><span class="line">        p-&gt;d.last = (u_char *) p + <span class="keyword">sizeof</span>(<span class="keyword">ngx_pool_t</span>);</span><br><span class="line">        p-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pool-&gt;current = pool;</span><br><span class="line">    pool-&gt;chain = <span class="literal">NULL</span>;</span><br><span class="line">    pool-&gt;large = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="内存分配">内存分配</span></h3><h4><span id="小块内存分配">小块内存分配</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 分配内存 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *</span><br><span class="line">ngx_palloc(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    u_char      *m;</span><br><span class="line">    <span class="keyword">ngx_pool_t</span>  *p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 若请求的内存大小size小于内存池最大内存值max，</span></span><br><span class="line"><span class="comment">     * 则进行小内存分配，从current开始遍历pool链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt;= pool-&gt;max) &#123;</span><br><span class="line"></span><br><span class="line">        p = pool-&gt;current;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">/* 执行对齐操作 */</span></span><br><span class="line">            m = ngx_align_ptr(p-&gt;d.last, NGX_ALIGNMENT);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 检查现有内存池是否有足够的内存空间，</span></span><br><span class="line"><span class="comment">             * 若有足够的内存空间，则移动last指针位置，</span></span><br><span class="line"><span class="comment">             * 并返回所分配的内存地址的起始地址</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">size_t</span>) (p-&gt;d.end - m) &gt;= size) &#123;</span><br><span class="line">                p-&gt;d.last = m + size;   <span class="comment">/* 在该节点指向的内存块中分配size大小的内存 */</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 若不满足，则查找下一个内存池 */</span></span><br><span class="line">            p = p-&gt;d.next;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">while</span> (p);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 若遍历所有现有内存池链表都没有可用的内存空间，</span></span><br><span class="line"><span class="comment">         * 则分配一个新的内存池，并将该内存池连接到现有内存池链表中</span></span><br><span class="line"><span class="comment">         * 同时，返回分配内存的起始地址</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> ngx_palloc_block(pool, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 若所请求的内存大小size大于max则调用大块内存分配函数 */</span></span><br><span class="line">    <span class="keyword">return</span> ngx_palloc_large(pool, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">ngx_palloc_block(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    u_char      *m;</span><br><span class="line">    <span class="keyword">size_t</span>       psize;</span><br><span class="line">    <span class="keyword">ngx_pool_t</span>  *p, *<span class="keyword">new</span>, *current;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 计算pool的大小，即需要分配新的block的大小 */</span></span><br><span class="line">    psize = (<span class="keyword">size_t</span>) (pool-&gt;d.end - (u_char *) pool);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* NGX_POOL_ALIGNMENT对齐操作 */</span></span><br><span class="line">    m = ngx_memalign(NGX_POOL_ALIGNMENT, psize, pool-&gt;<span class="built_in">log</span>);</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 计算需要分配的block的大小 */</span></span><br><span class="line">    <span class="keyword">new</span> = (<span class="keyword">ngx_pool_t</span> *) m;</span><br><span class="line">    <span class="keyword">new</span>-&gt;d.end = m + psize;</span><br><span class="line">    <span class="keyword">new</span>-&gt;d.next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">new</span>-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 初始化新的内存池 */</span></span><br><span class="line">    <span class="comment">/* 让m指向该块内存ngx_pool_data_t结构体之后数据区起始位置 */</span></span><br><span class="line">    m += <span class="keyword">sizeof</span>(<span class="keyword">ngx_pool_data_t</span>);</span><br><span class="line">    <span class="comment">/* 在数据区分配size大小的内存并设置last指针 */</span></span><br><span class="line">    m = ngx_align_ptr(m, NGX_ALIGNMENT);</span><br><span class="line">    <span class="keyword">new</span>-&gt;d.last = m + size;</span><br><span class="line"></span><br><span class="line">    current = pool-&gt;current;</span><br><span class="line">    <span class="keyword">for</span> (p = current; p-&gt;d.next; p = p-&gt;d.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;d.failed++ &gt; <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="comment">/* 失败4次以上移动current指针 */</span></span><br><span class="line">            current = p-&gt;d.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将分配的block连接到现有的内存池  */</span></span><br><span class="line">    p-&gt;d.next = <span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果是第一次为内存池分配block，这current将指向新分配的block */</span></span><br><span class="line">    pool-&gt;current = current ? current : <span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="assets/1551029604394.png" alt="1551029604394"></p><h4><span id="大块内存分配">大块内存分配</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 分配大块内存 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">ngx_palloc_large(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span>              *p;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span>         n;</span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>  *large;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 分配内存 */</span></span><br><span class="line">    p = ngx_alloc(size, pool-&gt;<span class="built_in">log</span>);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 若在该pool之前已经分配了large字段，</span></span><br><span class="line"><span class="comment">     * 则将所分配的大块内存挂载到内存池的large字段中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (large = pool-&gt;large; large; large = large-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (large-&gt;alloc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            large-&gt;alloc = p;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n++ &gt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 若在该pool之前并未分配large字段，</span></span><br><span class="line"><span class="comment">     * 则执行分配ngx_pool_large_t 结构体，分配large字段内存，</span></span><br><span class="line"><span class="comment">     * 再将大块内存挂载到pool的large字段中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    large = ngx_palloc(pool, <span class="keyword">sizeof</span>(<span class="keyword">ngx_pool_large_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (large == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ngx_free(p);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    large-&gt;alloc = p;</span><br><span class="line">    large-&gt;next = pool-&gt;large;</span><br><span class="line">    pool-&gt;large = large;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *</span><br><span class="line">ngx_alloc(<span class="keyword">size_t</span> size, <span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span>  *p;</span><br><span class="line"></span><br><span class="line">    p = <span class="built_in">malloc</span>(size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ngx_log_error(NGX_LOG_EMERG, <span class="built_in">log</span>, ngx_errno,</span><br><span class="line">            <span class="string">"malloc() %uz bytes failed"</span>, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ngx_log_debug2(NGX_LOG_DEBUG_ALLOC, <span class="built_in">log</span>, <span class="number">0</span>, <span class="string">"malloc: %p:%uz"</span>, p, size);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 释放大块内存 */</span></span><br><span class="line"><span class="keyword">ngx_int_t</span></span><br><span class="line">ngx_pfree(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">void</span> *p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>  *l;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (l = pool-&gt;large; l; l = l-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p == l-&gt;alloc) &#123;</span><br><span class="line">            ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</span><br><span class="line">                           <span class="string">"free: %p"</span>, l-&gt;alloc);</span><br><span class="line">            ngx_free(l-&gt;alloc);</span><br><span class="line">            l-&gt;alloc = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> NGX_OK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NGX_DECLINED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="assets/1551029658571.png" alt="1551029658571"></p><h3><span id="cleanup资源">cleanup资源</span></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 注册cleanup；</span></span><br><span class="line"><span class="comment"> * size 是 data 字段所指向的资源的大小；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">ngx_pool_cleanup_t</span> * ngx_pool_cleanup_add(<span class="keyword">ngx_pool_t</span> *p, <span class="keyword">size_t</span> size);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对内存池进行文件清理操作,即执行handler,此时handler==ngx_pool_cleanup_file */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">ngx_pool_run_cleanup_file</span><span class="params">(<span class="keyword">ngx_pool_t</span> *p, <span class="keyword">ngx_fd_t</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 关闭data指定的文件句柄 */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">ngx_pool_cleanup_file</span><span class="params">(<span class="keyword">void</span> *data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 删除data指定的文件 */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">ngx_pool_delete_file</span><span class="params">(<span class="keyword">void</span> *data)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* 注册cleanup */</span></span><br><span class="line"><span class="keyword">ngx_pool_cleanup_t</span> *</span><br><span class="line">ngx_pool_cleanup_add(<span class="keyword">ngx_pool_t</span> *p, <span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span>  *c;</span><br><span class="line"></span><br><span class="line">    c = ngx_palloc(p, <span class="keyword">sizeof</span>(<span class="keyword">ngx_pool_cleanup_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size) &#123;</span><br><span class="line">        c-&gt;data = ngx_palloc(p, size);</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        c-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c-&gt;handler = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;next = p-&gt;cleanup;</span><br><span class="line"></span><br><span class="line">    p-&gt;cleanup = c;</span><br><span class="line"></span><br><span class="line">    ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, p-&gt;<span class="built_in">log</span>, <span class="number">0</span>, <span class="string">"add cleanup: %p"</span>, c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 清理内存池的文件 */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">ngx_pool_run_cleanup_file(<span class="keyword">ngx_pool_t</span> *p, <span class="keyword">ngx_fd_t</span> fd)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span>       *c;</span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_file_t</span>  *cf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 遍历cleanup结构链表，并执行handler */</span></span><br><span class="line">    <span class="keyword">for</span> (c = p-&gt;cleanup; c; c = c-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;handler == ngx_pool_cleanup_file) &#123;</span><br><span class="line"></span><br><span class="line">            cf = c-&gt;data;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cf-&gt;fd == fd) &#123;</span><br><span class="line">                c-&gt;handler(cf);</span><br><span class="line">                c-&gt;handler = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 关闭data指定的文件句柄 */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">ngx_pool_cleanup_file(<span class="keyword">void</span> *data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_file_t</span>  *c = data; <span class="comment">/* 指向data所指向的文件句柄 */</span></span><br><span class="line"></span><br><span class="line">    ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, c-&gt;<span class="built_in">log</span>, <span class="number">0</span>, <span class="string">"file cleanup: fd:%d"</span>,</span><br><span class="line">                   c-&gt;fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 关闭指定文件 */</span></span><br><span class="line">    <span class="keyword">if</span> (ngx_close_file(c-&gt;fd) == NGX_FILE_ERROR) &#123;</span><br><span class="line">        ngx_log_error(NGX_LOG_ALERT, c-&gt;<span class="built_in">log</span>, ngx_errno,</span><br><span class="line">                      ngx_close_file_n <span class="string">" \"%s\" failed"</span>, c-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 删除data所指向的文件 */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">ngx_pool_delete_file(<span class="keyword">void</span> *data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_file_t</span>  *c = data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ngx_err_t</span>  err;</span><br><span class="line"></span><br><span class="line">    ngx_log_debug2(NGX_LOG_DEBUG_ALLOC, c-&gt;<span class="built_in">log</span>, <span class="number">0</span>, <span class="string">"file cleanup: fd:%d %s"</span>,</span><br><span class="line">                   c-&gt;fd, c-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 删除data所指向的文件 */</span></span><br><span class="line">    <span class="keyword">if</span> (ngx_delete_file(c-&gt;name) == NGX_FILE_ERROR) &#123;</span><br><span class="line">        err = ngx_errno;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (err != NGX_ENOENT) &#123;</span><br><span class="line">            ngx_log_error(NGX_LOG_CRIT, c-&gt;<span class="built_in">log</span>, err,</span><br><span class="line">                          ngx_delete_file_n <span class="string">" \"%s\" failed"</span>, c-&gt;name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 关闭文件句柄 */</span></span><br><span class="line">    <span class="keyword">if</span> (ngx_close_file(c-&gt;fd) == NGX_FILE_ERROR) &#123;</span><br><span class="line">        ngx_log_error(NGX_LOG_ALERT, c-&gt;<span class="built_in">log</span>, ngx_errno,</span><br><span class="line">                      ngx_close_file_n <span class="string">" \"%s\" failed"</span>, c-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="理解event模块的实现">理解Event模块的实现</span></h1><h2><span id="事件驱动">事件驱动</span></h2>]]></content>
    
    <summary type="html">
    
      Nginx源码的全方位分析
    
    </summary>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx的配置</title>
    <link href="http://yoursite.com/2019/02/21/Nginx%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/02/21/Nginx的配置/</id>
    <published>2019-02-21T15:21:21.000Z</published>
    <updated>2019-02-24T12:50:13.731Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="运行中的nginx进程间的关系">运行中的Nginx进程间的关系</span></h1><p>在正式提供服务的产品环境中，部署Nginx时都是使用一个master进程来管理多个worker进程，一般情况下，worker进程的数量与服务器上的CPU核心数相等。每一个worker进程都时繁忙的，它们在真正地提供互联网服务，master进程则很“清闲”，只负责监控管理worker进程。worker之间通过共享内存、原子操作等一些进程间通信机制来实现负载均衡等功能。</p><p>Nginx是支持单进程（master进程）提供服务的，那么为什么产品环境下要按照master、worker方式配置同时启动多个进程呢？这样做的好处主要有一下两点：</p><ul><li>由于master进程不会对用户请求提供服务，只用于管理真正提供服务的worker进程，所以master进程可以是唯一的，它仅专注于自己的纯管理工作，为管理员提供命令行服务，包括诸如启动服务、停止服务、重新配置文件、平滑升级程序等。master进程需要拥有较大的权限，例如，通常会使用root用户启动master进程。worker进程的权限要小于或者等于master进程，这样master进程才可以完全地管理worker进程。当任意一个worker进程出现错误从而导致coredump时，master进程会立刻启动新的worker进程继续服务。</li><li>多个worker进程处理互联网请求不但可以提高服务的健壮性，最重要的是，这样可以充分利用现在常见的SMP多核架构，从而实现微观上真正的多核并发处理。为什么要把worker进程数量设置得跟CPU核心数量一致呢？对于Nginx，一个worker进程可以同时处理的请求数只受限于内存大小，而且在架构上，<strong>不同的worker进程之间处理并发请求时几乎没有同步锁的限制</strong>，worker进程通常不会进入睡眠状态，因此，当Nginx上的进程数与CPU核心数相等时（最好每一个worker进程都绑定特定的CPU核心【使用taskset命令来设置进程的CPU亲和性（affinity），将进程绑定到某个或某组CPU核心上】），进程间的切换的代价是最小的。</li></ul><h1><span id="nginx服务的基本配置">Nginx服务的基本配置</span></h1><h2><span id="用于调试进程和定位问题的配置项">用于调试进程和定位问题的配置项</span></h2><ol><li><p>是否以守护进程方式运行Nginx</p><p>语法：daemon on|off;</p><p>默认：daemon on;</p><p>关闭守护进程的模式，方便使用gdb跟踪调试Nginx，在研究Nginx架构时很有用。</p></li><li><p>是否以master/worker方式工作</p><p>语法：master_process on | off;</p><p>默认：master_process on;</p><p>如果用off关闭了master_process方式，就不会fork出worker子进程来处理请求，而是用master进程自身来处理请求。</p></li><li><p>error日志的位置</p><p>语法：error_log /path/file level;</p><p>默认：error_log logs/error.log error;</p><p>error日志是定位Nginx问题的最佳工具，我们可以根据自己的需求妥善设置error日志的路径和级别。<br>/path/file可以是：</p><ul><li>一个具体的文件，例如，默认情况下是logs/error.log文件，最好将它放到一个磁盘空间足够大的位置；</li><li>也可以是/dev/null，这也是关闭error日志的唯一方法；</li><li><p>也可以是stderr，将日志输出到标准错误文件中；</p><p>level是日志的输出级别，取值范围是debug、info、notice、warn、error、crit、alert、emerg，从左到右级别依次增大。当设定一个级别时，大于或者等于该级别的日志都会输出到/path/file文件中，小于该级别的日志则不会输出。</p><p>如果日志级别设定到debug，必须在configure时加入–with-debug配置项。</p></li></ul></li><li><p>是否处理几个特殊的调试点</p><p>语法：debug_points [stop|abort]</p><p>这个配置项也是用来帮助用户跟踪调试Nginx的。Nginx在一些关键的错误逻辑中设置了调试点。如果设置了debug_points为stop，那么Nginx的代码执行到这些调试点时就会发出SIGSTOP信号以用于调试。如果设置为abort，则会产生一个coredump文件，可以使用gdb来查看Nginx当时的各种信息。</p></li><li><p>仅对指定的客户端输出debug级别的日志</p><p>语法：debug_connection [IP|CIDR]</p><p>这个配置项实际上属于事件类配置，因此，它必须放在events {…}中才有效。</p><p>对来自于指定IP地址的请求才会输出debug级别的日志，其他请求仍然沿用error_log中配置的日志级别。</p></li><li><p>限制coredump核心转储文件的大小</p><p>语法：worker_rlimit_core size;</p><p>在Linux系统中，当进程发生错误或收到信号而终止时，系统会将进程执行时的内存内容写入一个文件，以作为调试只用，这就是所谓的核心转储（core dumps）.</p></li><li><p>指定coredump文件生成目录</p><p>语法：working_directory path;</p></li></ol><h2><span id="正常运行的配置项">正常运行的配置项</span></h2><ol><li><p>定义环境变量</p><p>语法：env VAR|VAR=VALUE;</p><p>这个配置项可以让用户直接设置操作系统上的环境变量。</p></li><li><p>嵌入其他配置文件</p><p>语法：include /path/file;</p></li><li><p>pid文件的路径</p><p>语法：pid /path/file;</p><p>默认：pid logs/nginx.pid;</p></li><li><p>Nginx worker进程运行的用户和用户组</p><p>语法：user username [groupname];</p><p>默认：user nobody nodoby;</p></li><li><p>指定Nginx worker进程可以打开的最大句柄描述符个数</p><p>语法：worker_rlimit_nofile limit;</p></li><li><p>限制信号队列</p><p>语法：worker_rlimit_sigpending limit;</p><p>设置每个用户发往Nginx的信号队列的大小。也就是说，当某个用户的信号队列满了，这个用户再发送的信号量就会被丢掉。</p></li></ol><h2><span id="优化性能的配置项">优化性能的配置项</span></h2><ol><li><p>Nginx worker进程个数</p><p>语法：worker_processes number;</p><p>默认：worker_processes 1;</p></li><li><p>绑定Nginx worker进程到指定的CPU内核</p><p>语法：worker_cpu_affinity cpumask [cpumask…]</p><p>例如，如果有4个CPU内核，可以进行如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">worker_processes 4;</span><br><span class="line">worker_cpu_affinity 1000 0100 0010 0001;</span><br></pre></td></tr></table></figure></li><li><p>SSL硬件加速</p><p>语法：ssl_engine device;</p><p>如果服务器上有ssl硬件加速设备，那么就可以进行配置以加快SSL协议的处理速度。</p></li><li><p>系统调用gettimeofday的执行频率</p><p>语法：timer_resolution t;</p><p>默认情况下，每次内核的事件调用（如epoll、select、poll、kqueue等）返回时，都会执行一次gettimeofday，实现用内核的时钟来更新Nginx中的缓存时钟。</p><p>在早期的内核中，gettimeofday的执行代价不小，因为中间有一次内核态到用户态的内存复制。需要降低gettimeofday的调用频率时，可以使用该配置项，表示至少每t秒才调用一次。</p><p>但在目前的大多数内核中，gettimeofday只是一次vsyscall，仅仅是对共享内存页中的数据做访问，并不是通常的系统调用，代价不大，一般不必使用这个配置。</p></li><li><p>Nginx worker进程优先级设置</p><p>语法：worker_priority nice;</p><p>默认：worker_pricrity 0;</p><p>当有多个进程处于可执行状态时，系统将按照所有进程的优先级来决定本次内核选择哪一个进程执行。</p><p>进程所分配的时间片大小也与进程优先级相关，优先级越高，进程分配到的时间片也就越大。</p><p>（在默认配置下，最小的时间片时5ms，最大的时间片则有800ms。）</p><p>这样，优先级高的进程会占有更多的系统资源。</p></li></ol><h2><span id="事件类配置项">事件类配置项</span></h2><ol><li><p>是否打开accept锁</p><p>语法：accept_mutex [on|off];</p><p>默认：accept_mutex on;</p><p>accept_mutex是Nginx的负载均衡锁。</p><p>这把锁可以让多个worker进程轮流地、序列化地与新的客户端建立TCP连接。</p><p>当某个worker进程建立的连接数量达到worker_connections配置的最大连接数的7/8时，会大大地减小该worker进程试图建立新TCP连接的机会，以此实现所有的worker进程之上处理的客户端请求数尽量接近。</p><p>如果关闭它，那么建立TCP连接的耗时会更短，但worker进程之间的负载会非常不均衡。不建议关闭它。</p></li><li><p>lock文件的路径</p><p>语法：lock_file path/file;</p><p>默认：lock_file logs/nginx.lock;</p><p>accept_mutex为off时，此配置完全不生效。</p><p>accept_mutex为on是，若由于编译程序、操作系统导致Nginx不支持原子锁，这时会用文件锁来实现accecpt锁，此时lock_file所指定的lock文件才会生效。</p><blockquote><p><strong>文件锁</strong>：在多任务操作系统中，如果一个进程尝试对正在被其他进程读取的文件进行写操作，可能会导致正在进行读操作的进程读取到一些被破坏或者不完整的数据；如果两个进程并发对同一个文件进行写操作，可能会导致该文件遭到破坏。因此，为了避免发生这种问题，必须要采用某种机制来<strong>解决多个进程并发访问同一个文件时所面临的同步问题</strong>，由此而产生了文件加锁方面的技术。</p><p>Linux支持的文件锁主要包括劝告锁（advisory lock）和强制锁（mandatory lock）这两种。此外，Linux中还引入了两种强制锁的变种形式：共享模式强制锁（share-mode mandatory lock）和租借锁（lease）。</p></blockquote></li><li><p>使用accept锁后到真正建立连接之间的延迟时间</p><p>语法：accept_mutex_delay Nms;</p><p>默认：accept_mutex_delay 500ms;</p><p>在使用accept锁后，同一时间只有一个worker进程能够取到accept锁。这个锁不是阻塞锁，如果取不到会立刻返回。如果有一个worker进程试图取锁而未得，它至少要等该配置项所定义的时间间隔后才能再次试图取锁。</p></li><li><p>批量建立新连接</p><p>语法：multi_accept [on|off];</p><p>默认：multi_accept off;</p><p>当事件模型通知有新连接时，尽可能地对本次调度中客户端发起的所有TCP请求都建立连接。</p></li><li><p>选择事件模型</p><p>语法：use [kqueue|rtsig|epoll|/dev/poll|select|poll|eventport];</p><p>默认：Nginx会自动使用最合适的事件模型。</p><p>在Linux系统中，epoll性能是最高的。</p></li><li><p>每个worker的最大连接数</p><p>语法：worker_connections number;</p><p>定义每个worker进程可以同时处理的最大连接数。</p></li></ol><h1><span id="使用http核心模块配置一个静态web服务器">使用HTTP核心模块配置一个静态Web服务器</span></h1>]]></content>
    
    <summary type="html">
    
      Nginx的配置详解
    
    </summary>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Web性能基础</title>
    <link href="http://yoursite.com/2019/02/21/Web%E6%80%A7%E8%83%BD%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/02/21/Web性能基础/</id>
    <published>2019-02-21T02:54:57.000Z</published>
    <updated>2019-02-24T12:48:20.377Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="网络技术概览">网络技术概览</span></h1><h2><span id="延迟与带宽">延迟与带宽</span></h2><p>速度是关键</p><p>WPO（Web Performance Optimization）产业从无到有，快速增长，充分说明用户越来越重视速度方面的用户体验。</p><p>业绩证实：</p><ul><li>网站越快，用户的黏性越高</li><li>网站越快，用户忠诚度更高</li><li>网站越快，用户转化率越高</li></ul><p>延迟和带宽：</p><ul><li><p>延迟：分组从信息源发送到目的地所需的时间</p></li><li><p>带宽：逻辑或物理通信路径最大的吞吐量</p></li></ul><p>延迟的构成：</p><ul><li>传播延迟<br>消息从发送端到接收端需要的时间，是信号传播距离和速度的函数</li><li>传输延迟<br>把消息中的所有比特转移到链路中需要的时间，是消息长度和链路速率的函数</li><li>处理延迟<br>处理分组首部、检查位错误及确定分组目标所需的时间</li><li>排队延迟<br>到来的分组排队等待处理的时间</li></ul><blockquote><p>在软件交互中，哪怕100-200ms左右的延迟，大多数人都会感觉到‘拖拉’；如果超过了300ms的门槛，就会说“反应迟钝”。</p></blockquote><blockquote><p>光速与分组在介质中传播速度之比，叫做该介质的折射率。我们大都假定光纤的折射率约为1.5，即光通过光纤的速度约为每秒200，000，000米。</p></blockquote><h2><span id="tcp">TCP</span></h2><h2><span id="udp">UDP</span></h2><h2><span id="tls">TLS</span></h2><h1><span id="无线网络性能">无线网络性能</span></h1><h2><span id="wifi">WIFI</span></h2><h2><span id="移动网络">移动网络</span></h2><h1><span id="http">HTTP</span></h1><h2><span id="http-1x">HTTP 1.x</span></h2><h2><span id="http-20">HTTP 2.0</span></h2><h2><span id="优化应用的交付">优化应用的交付</span></h2><h1><span id="浏览器api与协议">浏览器API与协议</span></h1><h2><span id="xmlhttprequest">XMLHttpRequest</span></h2><h2><span id="服务器发送事件">服务器发送事件</span></h2><h2><span id="websocket">websocket</span></h2><p>WebSocket可以实现客户端与服务器间同时双向、基于消息的文本或二进制数据传输。<br>WebSocket使得浏览器具备了实时、双向通信的能力，是由HTML5开始提供的一种浏览器与服务器进行全双工通讯的网络技术，属于应用层协议。基于TCP传输协议，并复用HTTP的握手通道。</p><ul><li>优点：<ul><li>支持双向通信，实时性更强</li><li>更好的支持二进制</li><li>较少的控制开销。连接创建后，ws客户端、服务的进行数据交换时，协议控制的数据包头部较小。</li><li>支持扩展。可以扩展协议，实现自定义的自协议（如自定义压缩算法等）</li></ul></li></ul><h3><span id="1-入门例子">1. 入门例子：</span></h3><ul><li>1.1 <strong>服务端</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="built_in">require</span>(<span class="string">'express'</span>)();</span><br><span class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">'http'</span>).Server(app);</span><br><span class="line"><span class="keyword">var</span> WebSocket = <span class="built_in">require</span>(<span class="string">'ws'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wss = <span class="keyword">new</span> WebSocket.Server(&#123; <span class="attr">port</span>: <span class="number">8080</span> &#125;);</span><br><span class="line"></span><br><span class="line">wss.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> <span class="title">connection</span>(<span class="params">ws</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'server: receive connection.'</span>);</span><br><span class="line">    </span><br><span class="line">    ws.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> <span class="title">incoming</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'server: received %s'</span>, message);</span><br><span class="line">        ws.send(<span class="string">'server: reply'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    ws.on(<span class="string">'pong'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'server: received pong from client'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    ws.send(<span class="string">'world'</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// setInterval(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//     ws.ping('', false, true);</span></span><br><span class="line">    <span class="comment">// &#125;, 2000);</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.sendfile(__dirname + <span class="string">'/index.html'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><ul><li>1.2 <strong>客户端</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:8080'</span>);</span><br><span class="line">  ws.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'ws onopen'</span>);</span><br><span class="line">    ws.send(<span class="string">'from client: hello'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  ws.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'ws onmessage'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'from server: '</span> + e.data);</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><ul><li>1.3 <strong>运行结果</strong></li></ul><p><em>服务端输出</em>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server: receive connection.</span><br><span class="line">server: received hello</span><br></pre></td></tr></table></figure></p><p><em>客户端输出</em>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">client: ws connection is open</span><br><span class="line">client: received world</span><br></pre></td></tr></table></figure></p><h3><span id="2-如何建立连接">2. 如何建立连接</span></h3><p>WebSocket复用了HTTP的握手通道。具体是指，客户端通过HTTP请求与WebSocket服务器协商升级协议。</p><ul><li><p>2.1. 客户端：申请协议升级</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: localhost:8080</span><br><span class="line">Origin: http://127.0.0.1:3000</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Sec-WebSocket-Key: w4v7O6xFTi36lq3RNcgctw==</span><br></pre></td></tr></table></figure></li><li><p>2.2. 服务端：响应协议升级</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Connection:Upgrade</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Sec-WebSocket-Accept: Oy4NRAQ13jhfONC7bP8dTKb4PTU=</span><br></pre></td></tr></table></figure></li><li><p>2.3. Sec-WebSocket-Accept的计算</p></li></ul><p>伪代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;toBase64( sha1( Sec-WebSocket-Key +258EAFA5-E914-47DA-95CA-C5AB0DC85B11 )  )</span><br></pre></td></tr></table></figure></p><h3><span id="3-数据帧格式">3. 数据帧格式</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-------+-+-------------+-------------------------------+</span><br><span class="line">|F|R|R|R| opcode|M| Payload len |    Extended payload length    |</span><br><span class="line">|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |</span><br><span class="line">|N|V|V|V|       |S|             |   (if payload len==126/127)   |</span><br><span class="line">| |1|2|3|       |K|             |                               |</span><br><span class="line">+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</span><br><span class="line">|     Extended payload length continued, if payload len == 127  |</span><br><span class="line">+ - - - - - - - - - - - - - - - +-------------------------------+</span><br><span class="line">|                               |Masking-key, if MASK set to 1  |</span><br><span class="line">+-------------------------------+-------------------------------+</span><br><span class="line">| Masking-key (continued)       |          Payload Data         |</span><br><span class="line">+-------------------------------- - - - - - - - - - - - - - - - +</span><br><span class="line">:                     Payload Data continued ...                :</span><br><span class="line">+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</span><br><span class="line">|                     Payload Data continued ...                |</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure><h3><span id="4-数据传递">4. 数据传递</span></h3><p>使用场景及性能</p><h2><span id="webrtc">WebRTC</span></h2>]]></content>
    
    <summary type="html">
    
      有关于Web性能的基础知识
    
    </summary>
    
    
      <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Linux性能优化</title>
    <link href="http://yoursite.com/2019/02/20/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/02/20/Linux性能优化/</id>
    <published>2019-02-20T13:18:11.000Z</published>
    <updated>2019-02-24T12:40:15.781Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="性能优化的目标">性能优化的目标</span></h1><ul><li>减少延时</li><li>增加吞吐量<h1><span id="性能等级约定">性能等级约定</span></h1></li><li>基于业务需求<h1><span id="监控-信息采集-绘图-分析">监控 信息采集 绘图 分析</span></h1><h2><span id="监控">监控</span></h2><h2><span id="信息采集">信息采集</span></h2><h2><span id="绘图">绘图</span></h2><h2><span id="分析">分析</span></h2><h1><span id="系统调度算法">系统调度算法</span></h1><h2><span id="io调度算法">IO调度算法</span></h2><h2><span id="cpu调度算法">CPU调度算法</span></h2><h1><span id="systemtap">systemtap</span></h1></li></ul><h1><span id="实例">实例</span></h1>]]></content>
    
    <summary type="html">
    
      如何做Linux的性能优化
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux Kernel</title>
    <link href="http://yoursite.com/2019/02/20/Linux-Kernel/"/>
    <id>http://yoursite.com/2019/02/20/Linux-Kernel/</id>
    <published>2019-02-20T08:47:55.000Z</published>
    <updated>2019-02-24T12:46:35.562Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="如何学习内核">如何学习内核：</span></h1><ul><li>以应用为目的来学习，边学边用，学以致用</li><li>以培养内核的阅读能力为主要目标</li><li>阅读和修改真实的代码，而非只是阅读书籍</li><li>需要不断的更新和学习，因为内核的策略和方法一直在不断的变化着</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">勿贪大求全，聚焦关键应用</span><br><span class="line">奠定基础，循序渐进</span><br><span class="line">兴趣是第一驱动力</span><br></pre></td></tr></table></figure><h2><span id="内核基础层">内核基础层</span></h2><blockquote><p>内核中提供基础服务的部分</p></blockquote><ul><li>代码总量很少，但难度高</li><li>提供基本稳定的API</li><li>数据结构 </li><li>内核同步机制</li><li>内存管理和任务调度</li><li>学习方法：<ul><li>以API接口学习为主要内容，不细究实现</li><li>日后应该加强基础层的研读</li></ul></li></ul><h2><span id="内核应用层">内核应用层</span></h2><blockquote><p>建立在基础层之上，提供应用服务的部分</p></blockquote><ul><li>占代码的90%以上，数量多，重复性强</li><li>接口经常变化</li><li>文件系统 </li><li>设备和驱动</li><li>网络</li><li>学习方法：<ul><li>文件系统是应用层的基础和灵魂</li><li>从文件系统入手，驻步扩展</li><li>以架构为核心，举一反三</li><li>设备和驱动不依赖具体设备，以通用架构为主</li></ul></li></ul><h2><span id="最终目的">最终目的：</span></h2><ul><li>独立思考，独立学习，成为在该领域有影响力的专家</li><li>在代码中寻找答案</li><li>这个课程就是要形成一个起点，从这个起点出发，不断的学习、思考、实践、分享</li></ul><h2><span id="内核编译">内核编译：</span></h2><ul><li>编译的实质：<ul><li>基于头文件和c文件产生对象文件</li><li>将所有的对象文件链接起来，生成可执行文件</li></ul></li><li>内核编译的核心问题：make文件和配置文件</li></ul>]]></content>
    
    <summary type="html">
    
      以应用为目的来学习Linux内核，通过阅读和修改代码，培养内核的阅读能力
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Nginx modules</title>
    <link href="http://yoursite.com/2019/02/17/Nginx-modules/"/>
    <id>http://yoursite.com/2019/02/17/Nginx-modules/</id>
    <published>2019-02-17T09:06:52.000Z</published>
    <updated>2019-02-24T12:46:53.381Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="http-处理请求的11个阶段">HTTP 处理请求的11个阶段</span></h2><table><thead><tr><th style="text-align:center">阶段</th><th style="text-align:right">模块</th></tr></thead><tbody><tr><td style="text-align:center">post_read</td><td style="text-align:right">realip</td></tr><tr><td style="text-align:center">server_rewrite</td><td style="text-align:right">rewrite</td></tr><tr><td style="text-align:center">find_config</td><td style="text-align:right"></td></tr><tr><td style="text-align:center">rewrite</td><td style="text-align:right">rewrite</td></tr><tr><td style="text-align:center">post_rewrite</td><td style="text-align:right"></td></tr><tr><td style="text-align:center">pre access</td><td style="text-align:right">limit_conn,limit_req</td></tr><tr><td style="text-align:center">access</td><td style="text-align:right">auth_basic,access,auth_request</td></tr><tr><td style="text-align:center">post_access</td><td style="text-align:right"></td></tr><tr><td style="text-align:center">pre content</td><td style="text-align:right">try_files</td></tr><tr><td style="text-align:center">content</td><td style="text-align:right">index,autoindex,concat</td></tr><tr><td style="text-align:center">log</td><td style="text-align:right">access_log</td></tr></tbody></table><p>使用模块的前提：模块需要先编译进Nginx的二进制文件。<br>对于每个模块，我们需要了解：</p><ul><li>该模块提供哪些配置项</li><li>模块何时被使用</li><li>该模块提供了哪些变量</li></ul><p>Nginx能够实现类似于iptables的功能</p>]]></content>
    
    <summary type="html">
    
      关于Nginx的模块的详细分析
    
    </summary>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>持续交付</title>
    <link href="http://yoursite.com/2017/02/23/%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98/"/>
    <id>http://yoursite.com/2017/02/23/持续交付/</id>
    <published>2017-02-23T07:46:12.000Z</published>
    <updated>2019-02-25T12:43:15.644Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#持续交付的价值">持续交付的价值</a><ul><li><a href="#持续交付的定义">持续交付的定义</a></li><li><a href="#持续集成-持续交付和持续部署的关系">持续集成、持续交付和持续部署的关系</a></li><li><a href="#持续交付的显性价值">持续交付的显性价值</a></li><li><a href="#持续交付的隐性价值">持续交付的隐性价值</a></li><li><a href="#如何评估持续交付的价值">如何评估持续交付的价值</a></li></ul></li><li><a href="#影响持续交付的因素">影响持续交付的因素</a><ul><li><a href="#组织和文化因素">组织和文化因素</a></li><li><a href="#代码分支策略的选择">代码分支策略的选择</a><ul><li><a href="#主干开发tbd">主干开发（TBD）</a></li><li><a href="#特性分支开发">特性分支开发</a></li></ul></li></ul></li><li><a href="#依赖管理">依赖管理</a></li><li><a href="#代码回滚">代码回滚</a><ul><li><a href="#什么是代码回滚">什么是代码回滚？</a></li><li><a href="#哪些情况下需要回滚代码">哪些情况下需要回滚代码？</a></li><li><a href="#哪些情况下包的回滚无需回滚代码">哪些情况下包的回滚无需回滚代码？</a></li><li><a href="#代码回滚必须遵循的原则">代码回滚必须遵循的原则</a></li><li><a href="#三种典型回滚场景及回滚策略">三种典型回滚场景及回滚策略</a></li></ul></li><li><a href="#测试环境">测试环境</a><ul><li><a href="#互联网公司测试环境的结构">互联网公司测试环境的结构</a></li><li><a href="#什么是好的测试环境">什么是好的测试环境？</a></li><li><a href="#测试环境的成本">测试环境的成本</a></li><li><a href="#如何调节效率和成本的矛盾">如何调节效率和成本的矛盾？</a></li></ul></li><li><a href="#环境自描性">环境自描性</a><ul><li><a href="#环境一定要标准化">环境一定要标准化</a></li><li><a href="#约定大于配置">约定大于配置</a></li><li><a href="#让环境自己能开口说话">让环境自己能开口说话</a></li></ul></li><li><a href="#各种配置方法">各种配置方法</a></li><li><a href="#分钟级搭建环境">分钟级搭建环境</a><ul><li><a href="#环境构建流水线">环境构建流水线</a></li></ul></li><li><a href="#构建提速">构建提速</a></li><li><a href="#发布">发布</a><ul><li><a href="#发布是持续交付的最后一公里">发布是持续交付的最后一公里</a></li><li><a href="#任何变更都需要发布">任何变更都需要发布</a></li><li><a href="#发布系统一定要注意用户体验">发布系统一定要注意用户体验</a></li><li><a href="#发布系统的核心架构和功能设计">发布系统的核心架构和功能设计</a></li></ul></li><li><a href="#利用监控保障发布质量">利用监控保障发布质量</a></li><li><a href="#代码静态检查">代码静态检查</a></li><li><a href="#破坏性测试">破坏性测试</a></li><li><a href="#自动化回归">自动化回归</a></li><li><a href="#平台化设计持续交付">平台化设计持续交付</a></li><li><a href="#持续交付中的宝贵数据">持续交付中的宝贵数据</a></li><li><a href="#移动app的持续交付生命周期">移动APP的持续交付生命周期</a></li><li><a href="#快速构建持续交付系统">快速构建持续交付系统</a><ul><li><a href="#需求分析">需求分析</a><ul><li><a href="#模拟团队介绍">模拟团队介绍</a></li><li><a href="#模拟系统介绍">模拟系统介绍</a></li></ul></li><li><a href="#gitlab解决代码管理问题">Gitlab解决代码管理问题</a></li><li><a href="#jenkins解决集成打包问题">Jenkins解决集成打包问题</a></li><li><a href="#ansible解决自动部署问题">Ansible解决自动部署问题</a></li></ul></li></ul><!-- tocstop --><h1><span id="持续交付的价值">持续交付的价值</span></h1><h2><span id="持续交付的定义">持续交付的定义</span></h2><blockquote><p>持续交付是软件研发人员，如何将一个好点子，以最快的速度交付给用户的方法。</p><p>From 《持续交付：发布可靠软件的系统方法》</p></blockquote><h2><span id="持续集成-持续交付和持续部署的关系">持续集成、持续交付和持续部署的关系</span></h2><p>我们通常会把软件研发工作拆解，拆分成不同模块或不同团队后进行编码，编码完成后，进行集成构建和测试。这个从编码到构建再到测试的反复持续的过程，就叫做“持续集成”。</p><p>“持续集成”一旦完成，则代表产品处于一个可交付的状态，但并不代表这是最优状态，还需要根据外部使用者的反馈逐步优化。当然这里的使用者并不一定是真正的用户，还可能是测试人员、产品人员、用户体验工程师、安全工程师、企业领导等等。</p><p>这个“持续集成”之后，获取外部对软件的反馈再通过“持续集成”进行优化的过程就叫做“持续交付”，它是“持续集成”的自然延续。</p><p>传统安装型软件，要现场调试，要用户购买等等，其难度可想而知。即使是可达度最高的互联网应用，由于生成环境的多样性、架构的复杂性、影响的广泛性（需要灰度发布）等等，就算产品已是待交付的状态，要真正达到用户可用的标准，还有大量的问题需要解决。</p><p>而“持续部署”就是将可交付产品，快速且安全地交付用户使用的一套方法和系统，它是“持续交付”的最后“一公里”。</p><h2><span id="持续交付的显性价值">持续交付的显性价值</span></h2><p>持续交付也通常以“发布流水线”的方式来解释，即研发团队从开发，到测试，再到部署，最终将产品交付给最终用户使用的过程。</p><p>虽然持续交付着重打造的是发布流水线的部分，但它索要达到的目标是在“最终用户”和“研发团队”之间建立紧密的反馈环：通过持续交付新的软件版本，以验证新想法和软件改动的正确性，并衡量这些改动对软件价值的影响。</p><p>这里所说的“软件价值”，就是收入、日活、GMV等KPI指标了。</p><p>通常我们在实施持续交付后，都能够做到在保证交付质量的前提下，加快交付速度，从而更快地得到市场反馈，引领产品的方向，最终达到扩大收益的目的。</p><p>速度为王的今天，持续交付的能力，正成为评定一家互联网公司研发能力的重要指标。</p><h2><span id="持续交付的隐性价值">持续交付的隐性价值</span></h2><p>无论是什么企业，无论你的职位高低，都可以或者应该尝试持续交付，它一定会让你觉得物超所值。</p><p>它可以实现的能力：</p><ul><li><p>解决技术选型的难题</p><p>技术选型最大的难点在于影响大，又难以验证（或者验证效率低下）。而造成这些困境的绝大多数原因是没有合适的测试环境，比如环境差异造成测试数据缺乏说服力，又比如缺少隔离环境造成服务冲突等等。而这正是持续交付的用武之地。</p><p>持续交付的实施，将全面改善企业对测试环境的关联方法，使得环境管理更合理、更自由。</p></li><li><p>让制定的标准更好落地：</p><p>标准、规范、流程的落地，都需要载体，而最好的载体就是平台工具。而持续交付是一整套平台工具的落地，几乎涵盖了研发的整个生命周期，是天然的、最佳的载体。</p><p>另外，持续交付的落地本身伴随着各类标准、规范、流程的制定和实施，可以说两者相互依存，是非常好的管理思想落地方案。</p></li><li><p>提高跨部门协作的效率</p><p>每一个持续交付的实施团队，都可以说是最厉害的“拆墙大队”，拆的就是各个研发协作部门间的“隔离墙”。</p><p>持续交付能够向各个协作部门输出统一的标准、流程和工具，提升沟通效率；并且通过大量的自动化，进一步提升各部门工作效率；还可以快速集成，把各个分散的团队，无论是横向的业务研发团队，还是纵向的技术框架团队，紧紧地联系在一起，共同进退。</p></li><li><p>从容面对故障</p><p>任何故障都有一个天敌，叫做：快速恢复。</p><p>假设，所有的故障都可以在3分钟内恢复，你是不是觉得天下无敌了。那恢复故障最快、最有效的手段又是什么呢？当然就是回滚（或者重新部署）了，而这正是持续交付所包含和着力打造的能力之一。</p></li><li><p>让知识能够传承</p><p>互联网公司的人才流动之频繁已经远远超过了你我的想象。人来人往，如何将知识传承下来？</p><p>持续交付将团队赖以生存的工作流程进行固化；</p><p>利用代码静态检查等工具，能够很好地传承团队多年来的代码规范，并作为检查项进行自动化校验；</p><p>自动化测试脚本，同样是团队经验的产物。</p></li><li><p>让团队专注于业务而非工程</p><p>持续交付体系也如同中间件一样，能够从日常的业务研发工作中抽象出来，其不同只在于中间件解决架构问题，而持续交付解决工程问题。</p><p>这样研发团队能够全力应付业务的需求，而不用总是重复奔波于一些烦人且耗时的工程问题，比如按照测试机、准备编译服务器等等。</p></li><li><p>让产品经理成为产品真正的第一个用户</p><p>持续交付不仅仅是可以保证每一个变化都能及时得到测试以及反馈，更多的是解决测试与实际发布时存在差异的问题。</p><p>产品人员将真正成为第一个用户，而不再是最后一个QA。</p></li><li><p>让产品经理能够完全知悉当前进度和质量</p><p>持续交付能够实时地反应当前的开发情况，从而帮助产品人员决策和调整。</p></li><li><p>产品随时能发布</p><p>计划永远赶不上变化，如何产品人员都希望自己的产品能够随时处于可发布状态。这样就灵活地交付已完成的功能，迎合市场或业务的需要。</p><p>本质上，<strong>做到代码上线和业务上线的解耦分离</strong>，这也正是交付方法论强调的一个重点。</p></li><li><p>可以让程序员进一步加强对整个软件工程的认识</p><p>持续交付涵盖了软件交付端到端的整个周期，其覆盖面不仅仅包括编码，还包括：设计、测试、部署、运维、运营等等。</p><p>研发效率的提高往往不是个人能力的提高，而是集体协同效率的提高。</p></li><li><p>提高个人的工作效率和质量</p><p>随着持续交付的流行，其配套的实践和工具也层出不穷。ping-pong式结对编程（A写测试，B写实现，然后B写下一个测试，A写重构和实现），让编程充满乐趣，也很好的保证了代码质量。</p></li></ul><h2><span id="如何评估持续交付的价值">如何评估持续交付的价值</span></h2><p>量化？</p><p>产品的交付速度是否变快了。但是，实际情况下影响产品交付速度的因素实在太多，持续交付又积极作用，但到底占比多少呢？难以回答。</p><p>各个自动化过程的速度是否变快了？如：编译速度、发布速度、回滚速度、自动化测试速度等等。这些指标确实很好地反应了持续交付的价值，但总觉得这些并不是全部，持续交付的标准化、推行的新流程、改革的环境治理结构，好像都没有体现出来。</p><p>如果很难量化，也可以具象化。在整个工程生命周期中有多少被开发人员诟病，或者阻碍开发人员自主处理的问题点，即‘不可持续点’：</p><blockquote><p>开发不能按需产生隔离的测试环境；</p><p>生成代码回滚后，要手工处理代码分支；</p><p>预发布流量要能自动分离，以便预发布测试。</p></blockquote><p>以消灭这些不可持续点作为目标，拆解出来的可行动点，作为关键结果，来完成绩效考评。</p><h1><span id="影响持续交付的因素">影响持续交付的因素</span></h1><h2><span id="组织和文化因素">组织和文化因素</span></h2><p>持续交付一定是整个组织层面的事情，是跨部门合作的产物，所以组织和文化因素，是要首先考虑的问题。</p><p>紧密配合</p><p>集思广益</p><p>自我驱动</p><p>组织的问题，还是需要通过组织变更来解决。通常我们会采用以下三种方案：</p><ul><li>成立项目管理办公室</li><li>独立建立工程效能部门</li><li>使用敏捷形式，如Scrum，打破职能部门之间的隔离墙，以产品的形式组织团队</li></ul><h2><span id="代码分支策略的选择">代码分支策略的选择</span></h2><h3><span id="主干开发tbd">主干开发（TBD）</span></h3><p>主干开发是一个源代码控制的分支模型，开发者在一个称为“trunck”的分支（Git称master）中对代码进行协作，除了发布分支外没有其他开发分支。</p><p>Google和Facebook都是采用“主干开发”的方式，代码一般直接提交到主干的头部，这样可以保证所有用户看到的都是同一份代码的最新版本。</p><p>“主干开发”确实避免了合并分支时的麻烦，因此像Google这样的公司一般就不采用分支开发，分支只用来发布。</p><p>大多数时候，发布分支是主干某个时点的快照。以后的改Bug和功能增强，都是提交到主干，必要时cherry-pick（选择部分变更集合并到其他分支）到发布分支。与主干长期并行的特性分支极为少见。</p><p>由于不采用“特性分支开发”，所有提交的代码都被集成到了主干，为了保证主干上线后的有效性，一般会使用特性切换（feature toggle）。特性切换就像一个开关可以在运行期间隐藏、启用或禁用特定功能，项目团队可以借助这种方式加速开发过程。</p><p>特性切换在大型项目持续交付中变得越来越重要，因为它有助于将部署从发布中解耦除了。但是，特性切换也会导致代码更为脆弱、更难测试、更难理解和维护、更难提供技术支持，而且更不安全。（From Jim Bird）</p><p>特性切换需要健壮的工程过程、可靠的技术设计和成熟的特性切换生命周期管理，如果不具备这三个关键的条件，使用特性切换反而会降低生产力。</p><p>根据上面的分析，主干开发的分支策略虽然有利于开展持续交付，但是它对开发团队的能力要求也更高。</p><h3><span id="特性分支开发">特性分支开发</span></h3><p>和主干开发行对的时“特性分支开发”。在这个大类里面，我们来分析Git Flow、Github Flow和Gitlab Flow：</p><ul><li><p>Git Flow</p></li><li><p>Github Flow</p><p>是Github所使用的一种简单流程。该流程只使用master和特性分支，并借助Github的pull request功能。</p><p>在Github Flow中，master分支中包含稳定的代码，它已经或即将部署到生产环境。任何开发人员都不允许把未测试或未审查的代码直接提交到master分支。对代码的任何修改，不可Bug修复、热修复、新功能开发等都在单独的分支中进行。不管是一行代码的小改动，还是需要几个星期开发的新功能，都采用同样的方式来管理。</p><p>当需要修改时，从master分支创建一个新的分支，所有相关的代码修改都在新分支中进行。开发人员可以自由地提交代码和提交到远程仓库。</p><p>当新分支中的代码全部完成之后，通过Github提交一个新的pull request。团队中的其他人员会对代码进行审查，提出相关的修改意见。由持续集成服务器（如Jenkins）对新分支进行自动化测试。当代码通过自动化测试和代码审查之后，该分支的代码被合并到master分支。再从master分支部署到生产环境。</p><p>Github Flow的好处在于非常简单实用，开发人员需要注意的事项非常少，很容易形成习惯。当需要修改时，只要从master分支创建新分支，完成之后通过pull request和相关的代码审查，合并回master分支就可以了。</p></li><li><p>Gitlab Flow</p></li></ul><table><thead><tr><th>分支模型</th><th>说明</th></tr></thead><tbody><tr><td>带生产分支</td><td>1. 无法控制准确的发布时间，但又要求不停集成的。<br>2. 需要创建一个production分支来放置发布的代码</td></tr><tr><td>带环境分支</td><td>1. 要求所有代码都在逐个环境中测试通过。<br>2. 需要为不同的环境建立不同的分支</td></tr><tr><td>带发布分支</td><td>1. 用于对外界发布软件的项目，同时需要维护多个发布版本<br>2. 尽可能晚地从master拉取发布分支。<br>3. Bug修复应先合并到master，然后cherry pick到release分支。</td></tr></tbody></table><h1><span id="依赖管理">依赖管理</span></h1><h1><span id="代码回滚">代码回滚</span></h1><h2><span id="什么是代码回滚">什么是代码回滚？</span></h2><ol><li>包回滚是指，线上运行的系统，从现在的版本回滚到以前稳定的老版本。</li><li>代码回滚是指，Git分支的指针（游标），从指向当前有问题的版本改为指向一个该分支历史树上没问题的版本，而这个版本可以是曾经的commit，也可以是新建的commit。</li></ol><h2><span id="哪些情况下需要回滚代码">哪些情况下需要回滚代码？</span></h2><ul><li>第一种情况：开发人员独立使用的分支上，如果最近产生的commit都没有价值，应该废弃掉，此时就需要把代码回滚到以前的版本。</li><li>第二种情况：代码集成到团队的集成分支且尚未发布，但在后续测试中发现这部分代码有问题，且一时半会儿解决不掉，为了不把问题传递给下次的集成，此时就需要把有问题的代码从集成分支中回滚掉。</li><li>第三种情况：代码已经发布到线上，线上包回滚后发现是新上线的代码引起的问题，且需要一段时间修复，此时又有其他功能需要上线，那么主干分支必须把代码回滚到正确版本产品包对应的commit</li></ul><h2><span id="哪些情况下包的回滚无需回滚代码">哪些情况下包的回滚无需回滚代码？</span></h2><ul><li>线上回滚后，查出并不是因为源代码有问题。</li><li>下次线上发布，就是用来修复刚才线上运行的问题。</li></ul><h2><span id="代码回滚必须遵循的原则">代码回滚必须遵循的原则</span></h2><p>集成分支上代码回滚坚决不用reset –hard的方式，原因如下：</p><ul><li>集成分支上的commit都是项目阶段性的成果，即使最近的发布不需要某些commit的功能，但仍然需要保留这些commit，以备后需。</li><li>开发人员会基于集成分支上的commit拉取新分支，如果集成分支采用reset的方式消除了该commit，下次开发人员把新分支合并回集成分支时，又会把被清除的commit申请合并，很可能导致不需要的功能再次被引入集成分支。</li></ul><h2><span id="三种典型回滚场景及回滚策略">三种典型回滚场景及回滚策略</span></h2><table><thead><tr><th>场景名称</th><th>特点</th><th>策略</th></tr></thead><tbody><tr><td>个人分支回滚</td><td>不会影响团队其他成员</td><td>可以用git reset –hard</td></tr><tr><td>集成分支上线前回滚</td><td>1. 会影响团队其他成员<br>2. 非线上故障，相对不紧急<br>3. 可以对单独的commit做回滚</td><td>1. 一定不用 git reset –hard<br>2. 可在gitlab上找到对应的Merge Request，点击revert</td></tr><tr><td>集成分支上线后回滚</td><td>1. 会影响团队其他成员<br>2. 线上故障，相对紧急<br>3. 需回滚到包对应的commit</td><td>1. 一定不用 git reset <br>2. 再集成分支的头上增加一个commit，该commit的内容等于包回滚后对应的commit</td></tr></tbody></table><h1><span id="测试环境">测试环境</span></h1><p>在整个持续交付生命周期中，测试环境的易用程度会直接影响软件的交付程度，但因为以下两点，它又是最被容易忽略的一环。</p><ol><li>我们总是把环境理想化，忽略了其管理的难度；</li><li>我们也很少设立专职的环境管理员，导致环境长期处于混乱状态。</li></ol><p>通常，我们在项目初期并不会关注测试环境的问题，然而在回顾时却发现在环境问题上浪费的时间非常惊人：硬件资源申请困难，测试环境配置繁琐，测试应用更新困难，基础设施稳定性差，服务调用异常，多项目并行造成互相干扰等等问题。</p><p>构建一整套好的测试环境的关键点以及具体实施方案</p><ol><li>测试环境的结构一般是怎样的？</li><li>什么才是好的测试环境？</li></ol><h2><span id="互联网公司测试环境的结构">互联网公司测试环境的结构</span></h2><p>当公司规模较小时，测试环境的维护相对容易。开发和测试公用一套数据库缓存等基础设施，因为应用数量不多，开发环境可以是单机的，无论是手动或半自动化的更新测试环境的应用，花费的时间都还在可接受范围内。</p><p>这时，公司环境的结构很简单，分为开发环境，测试环境，生产环境即可。</p><p>但实际上，大多数公司的研发过程及配套环境并没有这么简单，一般都会存在5套以上的大环境以及更多的子环境，每个环境的机器数量可能有数十台甚至更多。</p><p>为什么需要这么多套环境呢？</p><ul><li><p>纵向上看，人员的增多提高了项目的并行度，如果这时还使用一套环境的话，就会发生以下问题：</p><ul><li>开发同学在debug一个问题时，发现下游的应用突然就不可用了；</li><li>测试同学在跑了10多分钟测试脚本后，发现应用已经被开发更新掉了。</li></ul><p>这样的体验是让人崩溃的。</p></li><li><p>横向上看，公司的应用架构逐渐转为微服务化，完整的应用数量很容易就达到了几百甚至几千个的量级，建立一套完整的环境变得越来越复杂，往往是研发团队想要构建一套新的环境却构建不出来。</p></li></ul><p>所以，目前互联网公司常见的环境模型一般分为开发环境，功能测试环境，验收测试环境，预发布环境，生产环境这五套大环境。</p><ul><li><p>开发环境</p><p>微服务架构下，单机已经无法完整地运行业务应用，这就需要开发环境内包含一套完整的业务应用依赖以及相关的基础设施，以保证业务开发同学能在本地完成开发测试。</p></li><li><p>功能测试环境</p><p>在开发环境下，每个下游依赖应用都只有一个可用的stable版本。而在实际的开发过程中，由于项目的并行开发，往往会同时存在多个可依赖的版本。而每个项目组的同学在测试时，都希望测试过程中的关键依赖应用是可以被独占的，版本是固定的，不会被其他项目组干扰。</p><p>所以，一套独立的功能测试环境就很有必要了。<em>通常，互联网企业会通过中间件的方式分割出一块隔离区域，在功能测试环境中创建多个子环境来解决问题。</em></p></li><li><p>验收测试环境</p><p>验收测试环境和功能测试环境是完全隔离的。当功能测试通过后，你可以在验收测试环境进行最终的验收。</p><p>它除了可以用作测试之外，还可以用作产品展示。所以，除了测试和开发人员，产品经理也是验收测试环境的主要使用者。</p></li><li><p>预发布环境</p><p>到预发布阶段，应用已经进入了生产网络，和真实的生产应用共享同一套数据库等基础设施。预发布是正式发布前的最后一次测试，在这个环境中往往可以发现线下环境中发现不了的Bug。这个环境的运维标准等同于生产环境，一般不允许开发人员直接登陆机器。</p><p>根据不同的业务需求和部署策略，不同公司对预发布环境的实现也有所不同：</p><ul><li><p>一种比较常见的方式是，将金丝雀发布作为预发布，从接入真实流量的集群中挑选一台或一小组机器先进行版本更新，通过手工测试以及自动化测试和监控系统验证，降低新版本发布的风险。</p><blockquote><p>金丝雀发布：</p><p>17世纪，英国矿井工人发现，金丝雀对瓦斯这种气体十分敏感。空气中哪怕有极其微量的瓦斯，金丝雀也会停止歌唱；而当瓦斯含量超过一定限度时，虽然鲁钝的人类毫无察觉，金丝雀却早已毒发身亡。当时在采矿设备相对简陋的条件下，工人们每次下井都会带上一只金丝雀作为“瓦斯检测指标”，以便在危险状况下紧急撤离</p><p>金丝雀发布是灰度发布的一种方式。灰度发布是指在黑与白之间，能够平滑过渡的一种发布方式。让一部分用户继续用A，一部分用户开始用B，如果用户对B没有什么反对意见，那么逐步扩大范围，把所有的用户都迁移到B上面来。</p><p>部署步骤：</p><ul><li>准备好部署各个阶段的工件，包括：构建工件、测试脚本、配置文件和部署清单文件。</li><li>从负载均衡列表中移除掉“金丝雀”服务器</li><li>升级“金丝雀”应用（排掉原有流量并进行部署）</li><li>对应用进行自动化测试</li><li>将“金丝雀”服务器重新添加到负载均衡列表中（连通性和健康检查）</li><li>如果“金丝雀”在线使用测试成功，升级剩余的其他服务器，否则就回滚。</li></ul></blockquote></li><li><p>另一种做法是，独立出一组始终不接入真实流量的机器，调用在预发布环境中形成闭环。</p><p>相对于第一种方式，第二张方式对生产环境的影响更小，但需要额外的资源和维护成本。</p></li></ul></li><li><p>生产环境</p><p>生产环境是用户真实使用的环境，对安全性和稳定性的要求最高。</p></li></ul><h2><span id="什么是好的测试环境">什么是好的测试环境？</span></h2><p>开发环境、功能测试环境、验收测试环境、预发布环境这四种测试环境形成的原因是什么？</p><p>搭建测试环境的目的是保证最终交付的软件质量，但每套测试环境的用户并不完全一样：</p><ul><li>开发环境的用户是开发同学；</li><li>功能测试环境的主要用户是测试同学；</li><li>验收测试环境的用户是产品经理和测试同学；</li><li>预发布环境的使用者是测试同学，但受益者却是运维同学。</li></ul><p>而每种角色对于产品研发流程中的需求也是不同的：</p><ul><li>开发同学关注研发效率；</li><li>测试同学关注测试的可靠性；</li><li>产品经理更关注的是真实的用户体验和产品的完整性；</li><li>预发布环境的需求其实来自于运维同学，他们需要保证生产环境的稳定性，减少生产环境的变更，所以需要将预发布环境与线下环境完全隔离。</li></ul><p>当然，不论一套环境用户是测试同学还是开发同学，以下几个需求都是必须被做到的。</p><ul><li>可得性，即在开发一个新项目时，能快速获取构建一个环境需要的机器，基础设施。最好的情况是，能随时可得，随时归还。</li><li>快速部署，即在搭建新环境时，能以最快的速度构建出一整套完整的环境。测试环境的部署很频繁，在代码提交后，能在很短的时间内构建代码，在环境上更新，就能更早开始测试。</li><li>独立性，即一个环境在使用过程中，可以不受其他项目测试人员的干扰。</li><li>稳定性，即不会因为下游服务，基础设施的异常，造成测试中断、等待。</li><li>高仿真，主要分为两个方面：“测试数据真实”，即能在测试环境构建出真实的测试用例；“环境真实”，即基础服务的架构和行为与线上环境保持一致，避免因为环境不一致造成测试结果不一致。</li></ul><p>但是，毕竟各个环境的用户和使用场景不同，它们的需求也是有差别的。比如，相对于开发环境，验收测试环境对测试数据的仿真性要求会更高，而开发环境的灵活性，决定了不会过于严格的维护测试数据的真实性。</p><p>当一个环境可以满足其真正核心用户的需求时，就是一个好用的测试环境。</p><h2><span id="测试环境的成本">测试环境的成本</span></h2><ul><li><p>机器资源的成本</p><p>保证环境的独立性，是你构建更多套环境的一个主要原因。但是，一套独立的、拥有完整链路的环境成本是非常高的。</p><p>以阿里云的价格为例：假设一个只有100个应用的微服务架构环境，选取单应用单机2核4G内存的低配置实例方式进行部署，单实例的年价格在2000元左右，100个实例的话，一年的花费就是20万元左右。</p><p>而这只是最保守的计算，随着服务规模的增加，以及更多环境的需要，整体花费上涨两个数量级也是很正常的。</p><p>这样的问题在开发环境和集成环境的表现是最明显的。为了保证这两套环境的独立性，你必然需要有很高的环境副本数。单无论如何，你都不可能让每一个开发和测试人员都拥有一套完整环境的硬件资源。</p></li><li><p>其次是管理成本</p><p>管理成本，包括维护环境的可用性，配置的管理成本，和测试数据的维护成本三个维度。</p><ul><li><p>维护多套环境的第一要点是，维护环境的可用性。</p><p>与云时代之前相比，容器技术已经解决了很多问题。比如，服务器操作系统级别的依赖的标准化更容易了；当出现硬件故障时，迁移和恢复服务也更加方便了。</p><p>但是容器技术并没有解决故障定位的问题。微服务架构下集群的节点数量多，调用链复杂，你不再能确定到底是环境问题，还是程序本身的Bug，也就导致定位故障更加困难了。</p><p>所以，更多套环境就意味着更大的集群规模，出现故障的几率会随之增加，而解决故障也会占用更长的工作时间。</p></li><li><p>维护多套环境的另一大成本，配置管理成本</p><p>配置是环境管理中最核心的内容，创建一套环境时，为了保证它真正的独立可用，不仅要保证应用可以成功运行，还要保证应用在基础设施的配置是正确的。比如集成测试环境下部署了一个应用的多个平行项目，就需要有办法保证测试人员能访问到正确的应用。</p><p>如果是web应用，你就要考虑把应用绑定到不同的域名，这样就会增加域名管理的成本；如果是一个service应用，就要考虑到这些service不会被其他项目的、无关环境的应用调用到，同时也不会调用到其他错误的服务。</p><p>每多一套环境，就会多一套这样的配置，而且这些配置都需要在各类基础设施中生效。</p></li><li><p>测试数据的维护成本</p><p>测试数据也是环境中极为重要的一个组成部分。当并行环境的数量变多后，数据的维护同样是让人头疼的问题。</p><p>为了保证环境的高仿真，哪些环境公用一套数据库，以及测试数据的更新在多套环境中怎么执行等等，都需要非常高的管理成本。</p></li></ul></li><li><p>最后是流程成本</p><ul><li><p>沟通成本</p><p>每增加一套环境，你都需要考虑团队成员如何在新环境上沟通协作。谁在占用，何时退出这些信息，你都需要第一时间告知团队。当环境的数量变得非常多以后，做好这些事儿的难度就很大了。</p></li><li><p>测试成本</p><p>在开发环境、集成测试环境、验收测试环境、预发布环境、生产环境这样的结构下，核心功能的测试流程就至少会执行五次。每引入一套新的环境，测试流程都会变得更加复杂。</p></li></ul></li></ul><h2><span id="如何调节效率和成本的矛盾">如何调节效率和成本的矛盾？</span></h2><p>增加一套环境带来的成本竟然有那么多，但是为了提高持续交付的效率，隔离的多套环境又是必不可少的。</p><p>那么，应该怎样去规划和设计环境呢？</p><ul><li><p>公共与泳道</p><p>第一个关键点是抽象公共环境，而其中的公共服务基本都属于底层服务，相对比较稳定，这是解耦环境的重中之重。比如我们经常会将中间件、框架类服务，底层业务公共服务（账号、登陆、基本信息）部署在这套公共环境上。</p><p>在公共环境的基础上，可以通过泳道的方式隔离相关测试应用，利用LB和SOA中间件对路由功能的支持，在一个大的公共集成测试环境中隔离出一个个独立的功能测试环境，那么增加的机器成本就仅与被并行的项目多少有关系了。</p><p>具体案例：</p><p>比如，你有一个新的下单流程需要测试。你可以将下单web2.0和下单sevice2.0抽离出来</p></li><li><p>避免产生多套公共环境</p><p>用mock service模拟大多数服务</p></li><li><p>减轻配置的复杂度</p><ul><li>制定一套统一配置的解决方案</li><li>要让环境自己说话，有效减少配置项</li></ul></li></ul><h1><span id="环境自描性">环境自描性</span></h1><blockquote><p>要想把环境配置做好，就是要做到让环境自己能说话。</p></blockquote><p>环境配置可以分为:</p><ul><li><p>以环境中每台服务器为对象的运行时配置</p><p>以一个Java Web应用为例，需要哪些运行时配置呢？</p><ol><li>安装war包运行依赖的基础环境，比如JDK、Tomcat等</li><li>修改Tomcat的配置文件，关注点主要包括：应用的日志目录，日志的输出格式，war包的存放位置。Tomcat的server.xml配置包括：连接数、端口、线程池等参数</li><li>配置Java参数，包括JVM堆内存的最大最小方式、GC方式、参数，JMX监控开启等</li><li>考虑操作系统参数，比较常见的一个配置时Linux的文件句柄数，如果应用对网络环境有一些特殊要求的话，还需要调整系统的TCP参数等配置</li></ol><p>经过上面4步，一个简单的运行时环境的配置就算时完成了，可以开始运行一个程序了。</p><p>但我们不光要考虑单个实例初始化配置，还要考虑每次JDK、Tomcat等基础软件的版本升级引起的运行时配置的变更，而且这些变更都需要清晰的记录下来，从而保证扩容出新的服务器时能取到正确的、最新的配置。</p><p>另外，对于一个集群的服务器组来说，还需要强制保证它们的运行时配置是一致的。</p></li><li><p>以一个环境为整体目标的独立环境配置</p><p>独立环境配置的主要目的是，保证一个环境能够完整运作的同时，又保证足够的隔离性，使其成为一个内聚的整体。</p><p>所以，要让一个环境能够符合需求的正常运作，你需要考虑的内容包括：</p><ol><li>这个环境所依赖的数据库该如何配置，缓存服务器又该如何配置</li><li>如果是分布式系统，或者SOA结构的话，就需要考虑服务中心、配置中心等一系列中间件的配置问题</li></ol><p>其中，最为重要的是配置中心的配置。</p><p>只有先访问到正确的配置中心，才能获取到其他相关的环境配置或者应用配置信息。也就是说，如果配置中心的配置错了，那么环境就会陷入混乱状态。</p><ol><li>要考虑访问入口问题。这套环境的入口在哪里？是一个站点还是一个服务入口？如果是一个站点的话，那这个站点的访问域名就需要被特殊配置。如果这是一个内部环境的话，那么这个内部域名的DNS解析也需要被配置。如果这套环境中有多个Web应用，那么你就要考虑7层路由的配置问题了</li><li>还要配置环境对应的基础服务，比如监控、短信、搜索等</li></ol></li></ul><p>再如果你的环境要承载多种语言栈，各类应用依赖的基础软件也不同，环境和环境之间有各种关联设置，数据库的连接分配，环境中负载均衡的设置等等</p><p>虽然环境配置有这么多的待处理事项，但是环境本身也是一个非常强大的工具，本身包含非常多的信息，如果这些糟心的事情环境能和你一起来解决，那就简单了，也就是说要让环境之间来说话。怎么做到呢？</p><h2><span id="环境一定要标准化">环境一定要标准化</span></h2><p>解决复杂问题的办法，无非是先将其分解，再将其简单化，对环境配置这个难题来说也是同样的道理。想要解决它，首先得要想办法分解、简化它。</p><p>最好的简化方法，莫过于标准化了。</p><p>所谓标准化，就是为了在一定范围内获得最佳秩序，对实际的或潜在的问题制定共同、可重复使用的规则。</p><p>标准化也就是让环境学会了一门统一的语言，是自己说话的前提。</p><p>按照这个思路，我们首先可以实现对语言栈的使用、运行时配置模板、独立环境配置的方法等的标准化：、</p><ul><li>规定公司的主流语言栈</li><li>统一服务器安装镜像</li><li>提供默认的运行时配置模板</li><li>统一基础软件的版本，以及更新方式</li><li>在架构层面统一解决环境路由问题</li><li>自动化环境产生过程</li></ul><p>在实施持续交付的同时，推动形成以下几个方面的规范：</p><ul><li>代码及依赖规范</li><li>命名规范</li><li>开发规范</li><li>配置规范</li><li>部署规范</li><li>安全规范</li><li>测试规范</li></ul><p>其实，不管是持续交付还是架构改造，标准先行都是技术实施的前提条件。</p><h2><span id="约定大于配置">约定大于配置</span></h2><p>像代码的部署路径，每个环境的域名定义，FAT、UAT来表示环境的作用，单机单应用，所有服务端端口是8080等等</p><p>约定大于配置的好处是，除了简化配置工作外，还可以提高沟通效率。</p><p>相当于赋予了环境天生的本能，进一步加强了环境的自我描述能力。</p><h2><span id="让环境自己能开口说话">让环境自己能开口说话</span></h2><p>有了环境标准化，以及约定大于配置的基础，你就可以顺利地让环境自己开口说话了。</p><p>也就是，通过环境的自描述文件，让环境能讲清楚自己的作用、依赖，以及状态，而不是由外部配置来解释这些内容。</p><p>以一台服务器为例，一旦生成，除了不能控制自己的生死外，其他运行过程中的配置，都应该根据它自身的描述来决定。</p><p>那么，如何让服务器自己说话呢？</p><ul><li>首先，需要定义Server Spec：在这个文件中，记录了这台服务器的所有身份信息，包括：IDC、型号、归属环境、作用、所属应用、服务类型、访问路径等</li><li>解决配置中心寻址：中间件根据Server Spec的描述，寻找到它所在环境对应的配置中心，从而进一步获取其他配置，如数据库连接字符串、短信服务地址等</li><li>完成服务自发现：根据服务类型、访问路径等，还可以自动生成对应的路由配置、负载均衡配置等</li></ul><h1><span id="各种配置方法">各种配置方法</span></h1><p>配置管理：是通过技术或行政手段对软件产品及其开发过程和生命周期进行控制、规范的一系列措施。它的目标是记录软件产品的演化过程，确保软件开发者在软件生命周期的各个阶段都能得到精确的产品配置信息。</p><p>配置：是指独立于程序之外，但又对程序产生作用的可配变量。也就是说，同一份代码在不同的配置下，会产生不同的运行结果。</p><h1><span id="分钟级搭建环境">分钟级搭建环境</span></h1><h2><span id="环境构建流水线">环境构建流水线</span></h2><ol><li><p>虚拟机环境准备，根据环境的应用数，每个应用需要的硬件配置，准备号环境的硬件资源</p><ul><li>当物理机接到机架上以后，打开交换机端口，等待机器被发现后，调用Nova进行物理机基本的硬件配置</li><li>物理机环境准备完毕后，从openstack获取虚机所需的镜像、网络等信息，调用Openstack API镜像虚机部署。虚机配置的一个关键点是，如何对网络进行配置</li><li>虚机初始化后，需要在虚机上进行一些基础软件比如JDK，Tomcat的安装和配置。业界一般采用的方式是，通过自动化的配置管理工具来进行操作。</li></ul></li><li><p>应用部署流水线，在标准化的虚拟机上进行应用部署，当出现问题时如何容错。</p><ul><li><p>单应用部署标准化，这是整个环境部署的基础。对一套测试环境而言，每个应用就像是环境上的一个零件，如果单个应用无法自动发布或发布失败率很高，那么整个环境就更难以构建出来。而如何实现一个好的发布系统，提升单应用部署速度呢？</p></li><li><p>应用部署的并行度，为了提高环境的部署速度，需要尽可能得最大化应用部署的并行度。理想的情况下，环境中的所有应用都可以一次性地并行部署。</p><p>然而，做到一次性并行部署并不容易，需要保证：应用都是无状态的，并且可以不依赖别的应用进行启动，或者仅仅依赖于基础环境中的应用就可以启动，且可以随时通过中间件进行调用链的切换。</p></li><li><p>流水线的容错机制。对于环境构建工具，通常的做法是力求做到全面的标准化、代码化。但是因为环境的创建本身是一个非常复杂的工作流，在创建过程总会有一些异常中断整个流程。比如，某个应用启动失败了。</p><p>而对于这些工作流中的异常，我们该如何处理呢？</p><ul><li><p>第一种方法是，错误中断法。创建环境过程中，各种资源申请、应用部署出现问题时，我们将工作流快照下来，然后收集所有的异常信息，返回给用户。由用户判断当前的情况，等用户确认问题已经得到解决后，可以触发一次快照重试，继续被中断的流程。</p></li><li><p>第二种方法是，优先完成法。创建环境过程中发生错误时，先进行几次重试。如果重试依然发生错误的话，就忽略当前错误，先走完剩余的流程，等所有的流程都走完了，再一次性将错误返回给用户。</p><p>从整体速度上来看，第二种优先完成的处理方式是更优的，而且也会更少地打断用户。只是方式二需要保证的关键原则是：所有的部署脚本的操作都是幂等的，即两次操作达成的效果是一致的，并不会带来更多的问题。</p></li></ul></li></ul></li><li><p>环境变更，在SOA或微服务的架构体系下，常常会因为测试的需求，将几套环境合并或拆分，创建环境时，你需要考虑如何高效地完成这些操作。</p><p>一般情况下，研发人员变更环境主要有以下4种场景：</p><ul><li>已经有一套新环境，当有新项目时，开发人员会挑选部分应用，组成一个独立的子环境。这里的重点是，要保证子环境和完整环境的调用是互相隔离的</li><li>当存在多个子环境时，可能在某个时间点需要做多个项目的集成，这时开发人员需要合并多个环境。</li><li>和合并的情况相反，有些情况下，开发人员需要将一个子环境种的应用切分开来，分为两个或者多个环境分别进行隔离测试。</li><li>已经存在一个子环境，当多个并行项目时，开发人员会克隆一套完整的子环境做测试。</li></ul></li></ol><h1><span id="构建提速">构建提速</span></h1><h1><span id="发布">发布</span></h1><h2><span id="发布是持续交付的最后一公里">发布是持续交付的最后一公里</span></h2><h2><span id="任何变更都需要发布">任何变更都需要发布</span></h2><h2><span id="发布系统一定要注意用户体验">发布系统一定要注意用户体验</span></h2><h2><span id="发布系统的核心架构和功能设计">发布系统的核心架构和功能设计</span></h2><p>作为整个持续交付体系中极为重要的一个环节，应用的发布时提升交付效率的关键。高效的发布系统架构应该时清晰的、健壮的、低耦合的，从而达到在最糟糕的情况下也能运作的目的。</p><h1><span id="利用监控保障发布质量">利用监控保障发布质量</span></h1><h1><span id="代码静态检查">代码静态检查</span></h1><h1><span id="破坏性测试">破坏性测试</span></h1><h1><span id="自动化回归">自动化回归</span></h1><p>对于持续交付的测试来说，自动化回归测试是不可或缺的，占了很大的测试比重。</p><p>进行自动化回归测试，就始终会有三个大问题：</p><ul><li>测试数据的准备和清理</li><li>分布式系统的依赖</li><li>测试用例的高度仿真</li></ul><h1><span id="平台化设计持续交付">平台化设计持续交付</span></h1><h1><span id="持续交付中的宝贵数据">持续交付中的宝贵数据</span></h1><h1><span id="移动app的持续交付生命周期">移动APP的持续交付生命周期</span></h1><h1><span id="快速构建持续交付系统">快速构建持续交付系统</span></h1><h2><span id="需求分析">需求分析</span></h2><h3><span id="模拟团队介绍">模拟团队介绍</span></h3><table><thead><tr><th></th><th>团队1</th><th>团队2</th><th>团队3</th></tr></thead><tbody><tr><td>职责</td><td>中间件服务</td><td>业务后台服务</td><td>业务客户端服务</td></tr><tr><td>代码管理</td><td>Git</td><td>Git</td><td>Git</td></tr><tr><td>语言平台</td><td>Java</td><td>Java</td><td>React Native</td></tr><tr><td>交付产物</td><td>服务/Jar</td><td>服务/War</td><td>App</td></tr></tbody></table><p>整个产品的研发，需要由着3个团队合作完成。</p><h3><span id="模拟系统介绍">模拟系统介绍</span></h3><h2><span id="gitlab解决代码管理问题">Gitlab解决代码管理问题</span></h2><h2><span id="jenkins解决集成打包问题">Jenkins解决集成打包问题</span></h2><h2><span id="ansible解决自动部署问题">Ansible解决自动部署问题</span></h2>]]></content>
    
    <summary type="html">
    
      持续交付——如何将一个好点子，以最快的速度交付给用户
    
    </summary>
    
    
      <category term="运维" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>运维体系管理</title>
    <link href="http://yoursite.com/2017/02/21/%E8%BF%90%E7%BB%B4%E4%BD%93%E7%B3%BB%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2017/02/21/运维体系管理/</id>
    <published>2017-02-21T12:51:23.000Z</published>
    <updated>2019-02-25T14:53:18.813Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#微服务架构时代运维体系建设要以应用为核心">微服务架构时代，运维体系建设要以应用为核心。</a><ul><li><a href="#应用的起源">应用的起源</a></li><li><a href="#应用模型及关系模型的建立">应用模型及关系模型的建立</a></li></ul></li><li><a href="#标准化体系建设">标准化体系建设</a><ul><li><a href="#为什么要做标准化">为什么要做标准化？</a></li><li><a href="#基础设施层面的标准化">基础设施层面的标准化</a></li><li><a href="#应用层面的标准化">应用层面的标准化</a></li><li><a href="#基础架构的标准化">基础架构的标准化</a><ul><li><a href="#常见的分布式基础架构组件">常见的分布式基础架构组件</a></li><li><a href="#基础架构组件的选型问题">基础架构组件的选型问题</a></li><li><a href="#其中运维的职责">其中运维的职责</a></li></ul></li><li><a href="#基础架构的服务化">基础架构的服务化</a><ul><li><a href="#为什么要做基础架构的服务化">为什么要做基础架构的服务化</a></li><li><a href="#运维的职责">运维的职责</a></li></ul></li></ul></li><li><a href="#如何从生命周期的视角看待应用运维体系建设">如何从生命周期的视角看待应用运维体系建设</a><ul><li><a href="#应用的生命周期分析">应用的生命周期分析</a></li></ul></li><li><a href="#cmdb">CMDB</a><ul><li><a href="#cmdb缘起">CMDB缘起</a></li><li><a href="#传统运维思路下的cmdb">传统运维思路下的CMDB</a></li><li><a href="#互联网运维体系下的cmdb">互联网运维体系下的CMDB</a></li></ul></li><li><a href="#如何在cmdb中落地应用的概念">如何在CMDB中落地应用的概念？</a><ul><li><a href="#如何有效组织和管理应用">如何有效组织和管理应用</a></li><li><a href="#应用的集群服务分组建设">应用的集群服务分组建设</a></li><li><a href="#cmdb在基础服务体系中的核心位置">CMDB在基础服务体系中的核心位置</a></li></ul></li><li><a href="#持续交付">持续交付</a><ul><li><a href="#什么是持续交付">什么是持续交付？</a></li><li><a href="#持续交付的关键点">持续交付的关键点</a></li><li><a href="#配置管理">配置管理</a><ul><li><a href="#版本控制">版本控制</a></li><li><a href="#依赖管理">依赖管理</a></li><li><a href="#软件配置">软件配置</a></li></ul></li><li><a href="#多环境建设">多环境建设</a></li><li><a href="#线上环境建设">线上环境建设</a></li><li><a href="#持续交付中的流水线模式">持续交付中的流水线模式</a></li></ul></li><li><a href="#混合云">混合云</a><ul><li><a href="#关于混合云">关于混合云</a></li></ul></li><li><a href="#面向应用层的云架构解决方案">面向应用层的云架构解决方案</a></li><li><a href="#cdn和云存储-云生态">CDN和云存储 云生态</a></li><li><a href="#页面静态化架构和二级cdn建设">页面静态化架构和二级CDN建设</a></li><li><a href="#弹性伸缩">弹性伸缩</a></li><li><a href="#稳定性保障">稳定性保障</a></li><li><a href="#容量规划">容量规划</a></li><li><a href="#限流降级">限流降级</a></li><li><a href="#开关预案">开关预案</a></li><li><a href="#全链路跟踪">全链路跟踪</a></li><li><a href="#故障">故障</a></li><li><a href="#安全">安全</a></li></ul><!-- tocstop --><h1><span id="微服务架构时代运维体系建设要以应用为核心">微服务架构时代，运维体系建设要以应用为核心。</span></h1><blockquote><p>在微服务的架构模式下，我们的运维视角一定转到应用这个核心概念上来，一切要以应用的角度分析和看待问题。</p></blockquote><h2><span id="应用的起源">应用的起源</span></h2><p>微服务架构一般都是从单体架构或分层架构演进而来。软件架构服务化的过程，就是我们根据业务模型进行细化的过程，在这个过程中切分出一个个具备不同职责的业务逻辑模块，然后每个微服务模块都会提供相应业务逻辑的服务化接口。</p><p>解释简单点，就一个字，拆！从一个单体工程，拆分出N个独立模块。这些模块都可以独立部署和运行，并提供对应的业务能力。拆分后的模块数量与业务体量和复杂度相关，少则几个、十几个，多则几十、几百个，所以为了统一概念，我们通常称这些模块为应用。</p><p>为了确保每个应用的唯一性，我们给每个应用定义一个唯一的标识符，这个唯一标识符我们称之为应用名。</p><p>这个定义为应用的概念，将成为我们微服务架构管理的核心概念。</p><h2><span id="应用模型及关系模型的建立">应用模型及关系模型的建立</span></h2><p>上面我们定义出来的一个个应用，都是从业务角度入手进行拆分细化出来的业务逻辑单元。它虽然可以独立部署和运行，但是每一个应用都只具备相对单一的业务职能。如果要完成整体的业务流程和目标，就需要和周边其它的服务化应用交互。同时，这个过程中还需要依赖各种与业务无直接关系、相对独立的基础设施和组件，比如机器资源、域名、DB、缓存、消息队列等等</p><p>所以，除了应用这个实体之外，还会存在其他各类基础组件实体。同时。在应用运行过程中，还需要不断地与他们产生和建立各种各样复杂的关联关系，这也为我们后续的运维带来很多困难。</p><p>我们要做的就是应用模型以及各种关系模型的梳理和建立，因为只有模型和关系梳理清楚了，才能为我们后面一系列的运维自动化、持续交付以及稳定性保障打下一个良好基础。</p><ol><li><p>应用业务模型</p><p>应用业务模型，也就是每个应用对外提供的业务服务能力，并以API的方式暴露给外部。<br>这个业务模型通常都是业务架构师在进行业务需求分析和拆解时进行设计，更多的时聚焦在业务逻辑上，所以从运维的角度，我们一般不会关注太多。</p></li><li><p>应用管理模型</p><p>应用管理模型，也就是应用自身的各种属性，如应用名、应用功能信息、责任人、Git地址、部署结构（代码路径、日志路径以及各类配置文件路径等）、启停方式、健康检测方式等待。这其中，应用名时应用的唯一标识，我们用AppName来表示。</p></li><li><p>应用运行时所依赖的基础设施和组件</p><ul><li>资源层面：应用运行所必需的资源载体有物理机、虚拟机或容器等，如果对外提供HTTP服务，及需要VIP和DNS域名服务；</li><li>基础组件：这一部分其实就是我们所说的中间件体系，不如应用运行过程中必然要存储和访问数据，这就需要有数据库和数据库中间件；想要更快访问数据，同时减轻DB的访问压力，就需要缓存；应用之间如果需要数据交互或同步，就需要消息队列；如果进行文件存储和访问，就需要存储系统等等。</li></ul><p>从这里我们可以挖掘出一条规律，那就是这些基础设施和组件都是为上层的一个个业务应用所服务的。也正是因为业务和应用上的需求，才开启了它们各自的生命周期。如果脱离了这些业务应用，它们之间并没有单纯存在的意义。所以，从始至终基础设施和组件都跟应用这个概念保持着紧密的联系。</p><p>理清了这个思路，我们再去梳理它们之间的关系就会顺畅很多，分为两步：</p><ul><li>第一步，建立各个基础设施和组件的数据模型，同时识别出它们的唯一标识。这个套路跟应用管理模型的梳理类似，以典型的缓存为例，每当我们申请一个缓存空间时，通常会以NameSpace来标识唯一命名，同时这个缓存空间会有空间容量和Paritition分区等信息。</li><li>第二步，识别出基础设施及组件可以与应用名AppName建立关联关系的属性，或者在基础组件的数据模型中增加所属应用这样的字段。</li></ul></li></ol><blockquote><p>微服务架构模式下的运维思路一定要转变，一定要将视角转换到应用这个维度，从一开始就要统一规划，从一开始就要将架构、开发和运维的工作拉通了去看，这一点是与传统运维的思路完全不同的。<strong>规划以应用为核心的运维管理体系</strong></p></blockquote><h1><span id="标准化体系建设">标准化体系建设</span></h1><p>标准化工作是运维过程中最基础、最重要的，但也是最容易忽视的一个环节。</p><p><strong>标准先行</strong></p><p>我们运维工作的开展常常不知从何下手，或者上来就冲着工具和自动化去了，却始终不得章法，工具做了一堆，效率却并没有提升。其实绝大多数情况下，问题和原因就是标准化这个基础工作没做扎实。</p><p>为何标准化这个事情如此重要呢？</p><h2><span id="为什么要做标准化">为什么要做标准化？</span></h2><p><strong>标准化的过程实际上就是对运维对象的识别和建模的过程</strong>。形成统一的对象模型后，各方在统一的认识下展开有效协作，然后针对不同的运维对象，再抽取出它们所对应的运维场景，接下来才是运维场景的自动化实现。</p><p>这有点像我们学的面向对象编程的思想，其实我们就是需要遵循这样一个思路，我们面对的就是一个个实体和逻辑运维对象。</p><p>在标准化的过程中，先识别出各个运维对象，然后我们日常做的所有运维工作，都应该是针对这些对象的运维。如果运维操作脱离了对象，那就没有任何意义。同样，没有理清对象，运维自然不得章法。</p><p>比如我们说扩容，那就要先确定这里到底是服务器的扩容，还是应用的扩容，还是其他对象的扩容。你会发现，对象不同，扩容这个场景所实施的动作是完全不一样的。</p><p>Nginx自动扩容，怎么做？</p><p>如果把服务器的扩容套用到应用的扩容上去，必然会导致流程错乱。同时对于对象理解上的不一致，也会徒增无谓的沟通成本，造成效率低下。自然地，这种情况下的运维自动化不但不能提升效率，还会越自动越混乱。</p><p><strong>标准先行</strong>，于纷繁复杂中抽象出标准规范的东西，是我们后续一系列自动化和稳定性保障的基础。</p><p>标准化的套路：</p><ul><li>第一步，识别对象；</li><li>第二步，识别对象属性；</li><li>第三步，识别对象关系；</li><li>第四步，识别对象场景。</li></ul><p>按照这个思路，来分析从基础设施层面和应用层面应该识别出哪些运维对象。</p><h2><span id="基础设施层面的标准化">基础设施层面的标准化</span></h2><ul><li>第一步，识别实体对象，主要有服务器、网络、IDC、机柜、存储、配件等。</li><li>第二步，识别对象的属性，比如服务器就会有SN序列号、IP地址、厂商、硬件配置（如CPU、内存、硬盘、网卡、PCIE、BIOS）、维保信息等；网络设备如交换机也会有厂商、型号、带宽等信息。</li><li>第三步，识别对象之间的关系，比如服务器所在的机柜，虚拟机所在的宿主机、机柜所在的IDC等简单关系；复杂一点就会有核心交换机、汇聚交换机、接入交换机以及机柜和服务器之间的级联关系等，这些相对复杂一些，也就是我们常说的网络拓扑关系。</li></ul><p>把以上信息梳理清楚，通过ER建模工具进行数据建模，再将以上的信息固化到DB中，一个资源层面的信息管理平台就基本成型了。</p><p>但是，信息固化不是目的，也没有价值，只有信息动态流转起来才有价值。接下来，我们需要做的事情，就是识别出针对运维对象所实施的日常运维操作有哪些，也就是识别出运维场景是什么。</p><ul><li>第四步，还是以服务器为例，针对服务器的日常操作有采购、入库、安装、配置、上线、下线、维修等等。另外，可能还会有可视化和查询的场景，如拓扑关系的可视化和动态展示，交换机和服务器之间的级联关系、状态（正常or故障）的展示等，这样可以很直观地关注到资源节点的状态。</li></ul><p>完成了这些工作，接下来才是对上述场景的自动化开发。所以，在真正执行去做工具和自动化平台之前，其实是需要做好大量的基础准备工作的。</p><h2><span id="应用层面的标准化">应用层面的标准化</span></h2><ul><li>第一步，识别对象。<br>这个识别的过程是在做微服务架构设计和拆分的时候就确定下来的。所以严格地讲，它不应该是运维阶段才被识别出来的，而是在之前设计阶段就被识别和确认下来，然后延申到运维这里才对。</li><li><p>第二步，识别对象属性<br>一个应用是业务的抽象逻辑，所以会有业务和运维两个维度的属性。业务属性在业务架构时确定，这主要是需要业务架构师去识别的，但是它的运维属性就应该由运维来识别了。</p><p>一个应用应该具备哪些基本的运维属性呢？</p><ul><li><strong>应用的元数据属性</strong>，也就是简单直接地描述一个应用的信息，如应用名、应用Owner、所属业务、是否核心链路应用以及应用功能说明等，这里关键是应用名；</li><li><strong>应用代码属性</strong>，主要是编程语言及版本（决定了后续的构建方式），GitLab地址；</li><li><strong>应用部署模式</strong>，涉及到基础软件包，如语言包Java、C++、Go等；容器如Tomcat、JBoss等；</li><li><strong>应用目录信息</strong>，如运维脚本目录、日志目录、应用包目录、临时目录等；</li><li><strong>应用运行脚本</strong>，如启停脚本、健康检测脚本；</li><li><strong>应用运行时的参数配置</strong>，如运行端口、Java的JVM参数GC方式、新生代、老生代、永生代的堆内存大小配置等。</li></ul></li><li><p>第三步，识别对象关系</p><ul><li>第一类是应用与基础设施的关系，包括应用与资源、应用与VIP、应用与DNS等等的关系；</li><li>第二类是平行层面的应用与应用之间的关系，这里再细分下去就是应用服务或API与其他应用服务和API的依赖关系。全链路就是这样的工具平台，是用来处理应用间关系管理的。</li><li>第三类是应用与各类基础组件之间的关系，比如应用与缓存、应用与消息、应用与DB等等之间的关系。</li></ul></li><li><p>第四步，识别应用的运维场景。<br>应用创建、持续集成、持续发布、扩容、缩容、监控等；再复杂点的比如容量评估、压测、限流降级等。</p></li></ul><h2><span id="基础架构的标准化">基础架构的标准化</span></h2><h3><span id="常见的分布式基础架构组件">常见的分布式基础架构组件</span></h3><ul><li>分布式服务化框架，业界开源产品比如Dubbo、Spring Cloud这样的框架；</li><li>分布式缓存及框架，业界如Redid、Memcached，框架如Codis和Redis Cluster；</li><li>数据库及分布式数据库框架，这两者密不可分，数据库如Mysql、MariaDB等，中间件如淘宝TDDL、Sharding-JDBC等。当前非常火热的TiDB，就直接实现了分布式数据库的功能，不再额外选择中间件框架；</li><li>分布式的消息中间件，业界如Kafka、RbbitMQ、Active MQ以及RocketMQ等；</li><li>前端接入层部分，如四层负载LVS、七层负载Nginx或Apache，再比如硬件负载F5等</li></ul><h3><span id="基础架构组件的选型问题">基础架构组件的选型问题</span></h3><p>关于基础架构组件，业界可供我们选择的解决方案和产品非常多，选择多了反而不知道从何入手了。这么多的开源产品到底该选哪一个呢？</p><p>按正常的思路，一定是先组织选型调研，然后进行方案验证和对比，最后确认统一的解决方案。</p><p>要对基础架构由统一的规划和建设。原则上，每种基础组件只允许一种选型，至少就能满足90%甚至更多的应用场景。</p><p>比如数据库就只允许使用MySQL，然后版本统一，同时配套的中间件也必须统一，其他的关系型数据库没有特殊情况坚决不允许使用，如果遇到特殊情况具体分析。</p><h3><span id="其中运维的职责">其中运维的职责</span></h3><p>参与制定基础架构标准，并强势约束。</p><p>在这里运维作为线上稳定的Owner，发挥约束作用有可能会比业务架构师的角色更为有效。另外，由于历史原因或者其他种种因素造成的已有架构标准不统一的问题，是需要开发和运维共同合作去改造的。这里面如何保持良好的协作，制定统一的线路图也是非常重要的。所以这里强制约束是一方面，同时也要提供工具化的手段来支持开发的改造。</p><h2><span id="基础架构的服务化">基础架构的服务化</span></h2><h3><span id="为什么要做基础架构的服务化">为什么要做基础架构的服务化</span></h3><p>对基础架构组件做了统一标准之后，下一步要做的就是服务化。因为这些组件都只提供了简单的维护功能，还有很多都是命令行层面的维护，这时我们要做的就是把这些组件提供的维护API进行封装，以提供更加便捷的运维能力。</p><p>这里以Redis缓存为例：</p><ul><li>创建和容量申请；</li><li>容量的扩容和缩容，新增分片的服务发现以及访问路由配置；</li><li>运行指标监控，如QPS、TPS、存储数据数量等等；</li><li>主备切换能力等等。</li></ul><p>以上这些，假设都只是依赖Redis提供的原生能力来做，基本是不可维护的。所以必须要基于这些原生能力进行封装，结合运维场景，讲能力服务化，这样就大大提升了使用方的便利性。</p><p>同时，我们也可以看到，这个服务化的过程其实就是PaaS化的过程。换言之，如果我们能把基础架构组件服务化完成，我们的Paas平台就基本成型了。</p><h3><span id="运维的职责">运维的职责</span></h3><p><strong>基础架构的服务化平台开发，目标是平台自助化，让开发依赖平台的能力自助完成对基础组件的需求，而不是依赖运维的人</strong>。这个事情是驱动运维转型和改进的动力，也是运维能够深入了解架构组件细节的有效途径。</p><h1><span id="如何从生命周期的视角看待应用运维体系建设">如何从生命周期的视角看待应用运维体系建设</span></h1><h2><span id="应用的生命周期分析">应用的生命周期分析</span></h2><p>在一个场景下有多个对象时，就一定要找到那个核心的运维对象，这个核心对象的生命周期就会涵盖其他附属运维对象的子生命周期。在整个运维体系中，或者说软件运行阶段的核心对象，就是应用。</p><p>以应用为本。对应用的生命周期阶段进行分解，大致分为五个部分：</p><ol><li><p>应用的创建阶段</p><p>这个阶段最重要的工作，是确认应用的基础信息和与基础服务的关系，要同时固化下来，从应用创建之初，就讲应用与各类基础服务的生命周期进行挂钩。<br>对于同一类的应用，只需要做一次标准化即可，后续完全可以形成模板固化到工具平台上。<br>同时，另外一个很重要的工作，就是要开启与应用相关的各类基础服务的生命周期。比如这个应用需要用到缓存、消息队列和DB等，也可能需要DNS服务、VIP配置等，这些就要从应用创建这个动作延申出去，启动这些关联基础服务的创建。</p></li><li><p>应用的研发阶段</p><p>主要是业务逻辑实现和验证的阶段。针对业务逻辑层面的场景就是开发代码和质量保证，但是这个过程中就会涉及的代码的提交合并、编译打包以及在不同环境下的发布部署过程。同时，开发和测试在不同的环境下进行各种类型的测试，比如单元测试、集成测试以及系统测试等等，这整个过程就是我们常说的持续集成。</p><p>所以，这个阶段，我们要做的最重要的一个事情，就是为研发团队打造完善的持续集成体系和工具链支持。</p></li><li><p>应用的上线阶段</p><p>这是个过渡阶段，从应用创建过渡到线上运行。创建阶段，应用的基础信息和基础服务都已经到位，接下来就是申请到应用运行的服务器资源，然后将应用软件包发布上线运行，这个动作在下面的运行阶段也会持续迭代。</p></li><li><p>应用的运行阶段</p><p>这是应用生命周期中最重要、最核心的阶段。<br>从运维角度来看，应用在线上运行起来之后就已经变成一个线上运行的进程，那这个进程形态的应用应该有什么样的属性呢？</p><p>这个时候需要应用线上运行的各种指标的输出。这个阶段，应用最重要的属性就是应用本身以及相关联的基础服务的各项运行指标。</p><p>这里，我们需要制定每个运维对象的SLI、SLO和SLA，同时要建设能够对这些指标进行监控和报警的监控体系。</p><p>从业务角度看，应用是线上业务逻辑的执行载体，但是我们的业务需求是在不断变化和迭代的，所以就需要不断地去迭代更新我们的线上应用，这里仍然会依赖到上述应用研发阶段的持续集成过程，并最终与线上发布形成持续交付这样一个闭环体系。</p><p>从运行阶段应用的关系看，除了它跟基础服务之间相对固化的关系外，应用跟应用、以及应用包含的服务之间的调用关系也非常重要，而且这个关系可能随时都在变化。这个时候，我们应用之间依赖管理和链路跟踪的场景就出现了。</p><p>同时，应用线上运行还会面临外部业务量的各种异常变化，以及应用自身所依赖的基础实施、基础服务以及应用服务的各种异常状况。</p></li><li><p>应用的销毁阶段</p><p>如果应用的业务职责不存在了，应用就可以下线销毁了。但是，这里不仅仅是应用自身要销毁，围绕着某个应用所产生出来的基础设施、基础服务以及关联关系都要一并清理，否则将会给系统中造成许多无源的资源浪费。</p></li></ol><p>结合之前所讲的标准化内容，我们就找到了做运维架构的切入点，套路也就有了，总结一下就是：</p><p><strong>从生命周期入手，划分阶段，提炼属性，理清关系，固化基础信息，实现运维场景。</strong></p><p>在思考问题和设计解决方案的时候，一定要从实际出发、从问题出发、从基础出发，理清自己的需求和痛点，然后再去寻求解决方案。</p><p>借鉴业界思路，千万不要一上来就去套用别人的解决方案。因为别人的思路和解决方案往往是建立在一个非常稳固的基础之上的，而这些基础，往往因为太基础而一带而过，甚至是略去不讲的。一旦忽略了这一点，再优秀的解决方案也是无源之水、无本之木，是实现不了的。</p><h1><span id="cmdb">CMDB</span></h1><p>当我们识别出运维对象和对象之间的关系，并形成了统一的标准之后，接下来要做的事情就是将这些标准固化，固化到某个信息管理平台中，也就是我们常说的配置管理，也就是CMDB（Configuration Management DataBase）。</p><h2><span id="cmdb缘起">CMDB缘起</span></h2><p>CMDB并不是一个新概念，它源于ITIL（Information Technology Infrastructure Library）。而ITIL这套理论体系在80年代末就已经成型，并在当时和后来的企业IT建设中作为服务管理的指导理论得到广泛推广和实施。</p><h2><span id="传统运维思路下的cmdb">传统运维思路下的CMDB</span></h2><p>按照ITIL的定义：</p><blockquote><p>CMDB，配置管理数据库，是与IT系统所有组件相关的信息库，它包含IT基础架构配置项的详细信息。</p></blockquote><p>这是一个很宽泛的概念描述，实际上并不具备可落地的指导意义。</p><p>同时，CMDB是与每个企业具体的IT软硬件环境、组织架构和流程强相关的，这就决定了CMDB一定是高度定制化的体系。虽然我们都知道它不仅仅是一个存储信息的数据库那么简单，但是它的具体形态是什么样子的，并没有统一的标准。</p><p>从传统IT运维的角度来看，运维的核心对象是资源层面，所谓的基础架构也就是网络设备和硬件设备这个层面；各种关联和拓扑关系，基本也是从服务器的视角去看。所以更多地，我们是把CMDB建设成为一个以设备为中心的信息管理平台。</p><p>这也是当前绝大多数公司在建设运维平台时最优先的切入点，因为这些运维对象都是实体存在的，是最容易被识别的和管理的；像应用和分布式中间件这种抽象的逻辑对象反而是不容易被识别的。</p><p>这种形态，如果是在软件架构变化不大的情况下，比如单体或分层架构，以服务器为中心去建设是没有问题的。因为无论设备数量也好，还是申请回收这些变更也好，都是很有限的，也就是整个IT基础设施的形态变化不大。</p><p>在早期，并没有太多人提及CMDB，也没有人提出把它作为核心部件去建设，在当时，CMDB这个概念并不具备实践意义，管理的方式方法也就停留在原始的Excel表格中。</p><p>高大上的ITIL体系更多的是被当作流程规范来落地的，真正体现在技术方案和技术产品上的落地并不多。</p><h2><span id="互联网运维体系下的cmdb">互联网运维体系下的CMDB</span></h2><p>进入互联网时代，随着互联网运维力量的崛起，CMDB这个概念也真正得到了落地实践，从理论概念的方法论阶段过渡到了具备具体技术方案的可实施阶段，而且得到了业界的持续分享和传播。</p><p>不过，值得注意的是，“此CMDB”已经非“彼CMDB”。传统运维阶段，我们更多是以设备为核心进行管理，都是到了互联网技术阶段，这个核心就变了，变成了应用这个核心对象。</p><p>至于原因，主要还是互联网技术的快速发展，大大推进了微服务技术架构的落地和实践，这种场景下，应用各维度的管理复杂度、应用的复杂度就逐渐体现出来了，所以我们的很多运维场景就开始围绕着应用来开展。</p><p>与此同时，云计算技术也在蓬勃发展，逐步屏蔽了IDC、网络设备以及硬件服务器这样的底层基础设施的复杂度，有公有云或私有云厂商来专注聚焦这些问题，让我们的运维不必再花过多的精力在这些基础设施上面；同时，单纯以硬件为核心的CMDB形态也被逐步弱化。</p><p>所以，此时的CMDB，仍然可以叫做配置管理数据库，但是这个配置管理的外延已经发生了很大的变化。之前所指的简单的硬件资源配置管理，只能算是狭义的理解；从广义上讲，当前的应用以及以应用为核心的分布式服务化框架、缓存、消息、DB、接入层等基础组件，都应该纳入这个配置管理的范畴。</p><p>所以在这个时期，我们提到的运维自动化，远不是自动化的服务器安装部署交付或网络自动化配置这种单一场景，而是出现了持续交付、DevOps、SRE等更适合这个时代的对运维职责的定义和新的方法论。</p><h1><span id="如何在cmdb中落地应用的概念">如何在CMDB中落地应用的概念？</span></h1><h2><span id="如何有效组织和管理应用">如何有效组织和管理应用</span></h2><p>微服务架构下会有很多应用产生出来，少则十几、几十个，多则上百甚至上千个。这时我们面临的第一个问题就是如何有效地组织和管理这些应用，而不是让它们在各处散乱，命名方式和层次结构可能还不统一。</p><p>用”服务树”，有效组织和管理应用的方式，就是把它组织成一个树形的层次结构。</p><p>基于业务维度的拆分，对应产生了我们的应用拆分原则。比如对于电商公司，大的维度会有电商、支付、广告、流量和搜索等业务领域；进一步，电商业务领域里最典型的会有用户、会员、商品、交易、商家、店铺以及物流等；这里面还可以再进一步细分，比如商品会有详情、SKU、SPU、库存、评价、标签等。</p><p>讲到这里，我们在看一下技术团队的组织架构，基本上是对应着整个业务技术架构的拆分的。<strong>也就是业务架构决定了技术架构</strong>，<strong>而技术架构又决定了一个研发团队的组织架构</strong>，这个组织架构中不同的团队单元分别承担着对应业务的需求开发和实现职责。</p><p>上面这个组织架构建设的逻辑和思路，也是我们在组建团队和职责划分时可以参考的。</p><p>这样一个逻辑讲下来，我们的应用管理思路其实也就明晰了：产品线-业务团队-应用。</p><p>对于应用名定义，要设定规范。</p><p>到了软件运维阶段，运维工作是否可以高效地组织开展，很大程度上，在前面的业务架构拆分阶段就决定了。也就是业务架构拆分得是否合理、职责是否明晰，决定了后续团队组织架构是否合理、团队职责是否明晰。如果这点没做好，到了运维阶段必然就是混乱的。</p><h2><span id="应用的集群服务分组建设">应用的集群服务分组建设</span></h2><p>为什么会有集群服务分组呢？我们来看这么几个需求场景。</p><ul><li><p>场景一：多环境问题</p><p>我们常见的环境会有开发联调环境、集成测试环境、预发环境、线上环境等等。</p></li><li><p>场景二：多IDC问题</p><p>对于大型互联网业务，会做业务单元化，或者有海外业务拓展需求的场景，我们会在多个IDC机房部署应用，应用代码是相同的，但是配置可能会不同。</p></li><li><p>场景三：多服务分组问题</p><p>这个场景就跟具体业务场景相关了。举个例子，比如商品中心IC这样一个核心应用，对外会有商品详情、交易下单、订单、购物车、评价、广告、秒杀活动、会场活动、商家、店铺等一系列应用依赖它，但是这些依赖它的应用优先级是不一样的。</p><ul><li>核心应用和非核心应用：比如交易支付链路上的应用属于核心应用，任何时候都必须要优先保障，但是对于评价、商家和店铺这些应用优先级就低一些。发过来理解就是一个应用出现故障，是不是会影响业务收入，如果影响就属于核心应用，如果不是或者影响非常小，那就属于非核心应用。所以IC这个应用下面，就会有IC的交易分组，IC的广告分组、IC的电商分组，这些分组就会相对固定和静态。</li><li>场景因素决定：这个对于电商就会比较典型，比如大促时的秒杀场景，对于参加秒杀活动的商品，瞬时的访问量就会非常大，而不参加活动的商品就不会有这么大的访问量。所以这时为了隔离较大的流量，就需要有多个不同的秒杀IC分组，从资源层面进行隔离；同时上层秒杀活动的应用在配置中心配置依赖时，就要配置到对应的秒杀IC集群分组上，这样即使秒杀IC出现问题，也不会影响正常的商品IC访问。所以根据场景，不同阶段就会有IC的大促秒杀分组，这种类型的分组就需要根据实际的业务场景来决定，是个动态调整的过程，需要开发和运维一起来讨论和验证。</li></ul></li></ul><h2><span id="cmdb在基础服务体系中的核心位置">CMDB在基础服务体系中的核心位置</span></h2><p>以应用为核心，CMDB中会保存“应用-分组-资源”的对应关系，这个关系对于周边系统来说都是需要的，举例如下：</p><ol><li><p>监控系统</p><p>我们需要以上的对应关系，监控到每个应用、每个集群以及每台机器上的关键信息。</p></li><li><p>发布系统</p><p>我们需要讲每个应用对应的代码进行编译打包，然后发布到对应集群的主机上，也需要这个对应关系。</p></li><li><p>服务化框架</p><p>需要依赖应用和集群分组两个信息，其中主要是对应用名和集群分组名的依赖，对于服务化框架来说，更多的是通过其配置管理中心注册的应用名，来实现应用的服务和API管理，这里要做到与CMDB统一。同样，像LVS和Nginx这样的四七层负载，以及ZK这样的开源分布式配置管理，凡是涉及服务注册、服务发现以及服务上下线的基础服务，都是类似思路。</p></li><li><p>基础服务中</p><p>如分布式DB、分布式缓存和消息等，就需要应用的应用名，以及应用与资源IP的对应关系，或者集群分组与IP的对应关系。</p><ul><li>应用名，是因为要建立应用与分布式服务实例之间的关系。如应用与缓存NamSpace的对应关系，应用与消息Topic的对应关系等，以便于这些基础服务的生命周期管理和自动化开发。</li><li>应用与资源的对应关系，是因为有些核心资源是要做ACL访问控制的。比如对于用户、交易或支付这样非常敏感的数据，它们对应的数据库就不允许随意连接，而应该是仅限于授权过的应用访问。这时就要针对应用对应的IP地址进行白名单配置。一方面，可以通过分布式DB中间件进行配置；另一方面，也可以通过在DB层面进行设置，比如MySQL就可以直接配置白名单策略；同时也可以在机器的iptables上配置，至于如何配置就看具体需求了，但是无论怎样，应用与资源的对应关系是非常重要的。</li></ul></li><li><p>稳定性保障平台，或者叫访问治理平台</p><p>针对系统的稳定性，我们会在应用中做很多的降级限流和开关预案策略，这些都是跟应用直接关联的。而且按照我们前面介绍的，不同的集群分组，策略可能会有不同，所以又会跟集群分组相关。同时，这些策略最终下发到具体服务器上运行的应用实例上，所以这里就会需要应用、集群分组以及对应的资源关系。</p></li></ol><h1><span id="持续交付">持续交付</span></h1><p>前面，我们介绍了非常基础的运维建设环节。如果我们想要这些运维基础建设发挥更大的作用和价值，就需要针对运维场景进行场景化设计和自动化，让效率和稳定性真正提升上来。</p><p>基础的事情做好之后，我们就要进入效率提升的运维场景自动化阶段了。</p><p>这一阶段，首先要把持续交付做好。</p><p>为什么要先做持续交付？如果说我们完成了一些运维职责范围内的自动化工具，提升的是运维效率的话，那么，<strong>做持续交付就是提升整个研发体系效率的关键</strong>。</p><p>做持续交付的价值表现在哪里？</p><p>持续交付覆盖了应用的整个生命周期，涉及产品、开发、测试、运维以及项目管理等相关方面。从生命周期出发，自然就会牵出整个自动化的全貌，就会有从全局着眼的规划设计，这时无论是在开发还是运维过程中存在的问题，都会完完整整地暴露出来。那么，应该以什么样的主线开展？各方应该如何配合？应该以怎样的优先级明确任务？这些问题就都清楚了。同时，也避免了各个环节只把注意力放在各自职责范围内的事情上，而忽略了整体的配合。所以，做好持续交付，对于整个研发体系意义重大。</p><p>我们面临的实际场景是怎样的呢？</p><p>我们知道，随着业务复杂度的升高，不管是分层架构，还是微服务架构，都会带来一个最明显的变化，那就是应用数量增多，有时甚至多达几十个、几百个。不同的应用就有不同的代码、依赖和配置，为了协同多应用之间的在线发布，我们还要做到服务能够平滑地进行上下线切换。同时，为了最大限度地降低发布风险，我们还需要继续多环境下的验证，以及上线后的灰度策略等等。</p><p>应对这一切，如果只是手工维护，或者利用简单的脚本进行维护，都不能保证正常运作。这个时候，我们必须有一系列的流程、机制和工具链来支持和保障。</p><h2><span id="什么是持续交付">什么是持续交付？</span></h2><p><strong>持续交付代表着从业务需求开始到交付上线之后的端到端的过程</strong>。（业务/产品、开发、测试、运维的协作）</p><h2><span id="持续交付的关键点">持续交付的关键点</span></h2><ol><li><p>配置管理</p><p>这一部分会利用到我们前面讲过的标准化和CMDB打下的基础，同时还会有更大的外延，比如环境配置、代码配置以及依赖管理等等。</p><p>配置管理是非常关键的基础工作。有一点值得注意，那就是标准化是一个持续的过程。我们不太可能在一开始就把所有运维对象、属性和关系全部考虑清楚，面面俱到是不太现实的，所以，一定要具备标准化的意识，在开展运维工作的过程中，持续不断地用这个思路去标准化新出现的对象。先标准，再固化，如何自动化。</p></li><li><p>需求拆解</p><p>需求拆解这个工作跟业务需求部门和业务开发有更直接的关系。在这里，运维需要做的是，明确需求拆解的粒度和我们最终发布上线的粒度相匹配。</p></li><li><p>提交管理</p><p>需求拆解完成后，就进入到开发阶段，开发完成后向代码库中提交代码，这个过程中代码分支的合并策略选择就是提交管理。</p></li><li><p>构建打包</p><p>这一部分是指将提交的代码编译成可发布的软件包。</p></li><li><p>自动化测试</p><p>自动化测试包括功能测试和非功能性测试。对于运维来说，会更注重非功能方面的特性。</p></li><li><p>部署发布</p><p>这一部分是指发布到不同的环境，如开发环境、预发环境、线上Beta以及线上全量环境。针对不同的环境，发布策略和注意事项也会不同。</p></li></ol><p>配置管理、提交管理、构建和部署发布是持续交付的重中之重，是关键路径，是从开发代码开始，到发布上线的必经之路。当时，因为这个几个环节出现了问题，不能解决，运维同学经常做手工发布，这样效率就跟不上，还经常出现各种问题。后来，我们就是先从这几个环节入手，把阻塞的问题解决掉，然后在这个主流程上不断增加外围能力，让整个流程的功能更加丰富和全面。整个系统也从原来的只具备持续部署发布功能的平台，逐步演进为具有持续交付能力的平台。</p><p>下面详细展开说明：</p><h2><span id="配置管理">配置管理</span></h2><p>按照持续交付的理念，这里所说的配置管理范围会更广，主要有以下几个部分。</p><ul><li>版本控制</li><li>依赖配置</li><li>软件配置</li><li>环境配置</li></ul><p>讲持续交付，一上来就先讲配置管理，主要还是想强调：配置管理是基础，是关键。勿在浮沙筑高台，我们做工具平台或系统，一定要重视基础的建设。</p><p>同时，这里还有一个前提，就是一定要做到代码和配置的分离。不要让配置写死在代码里，需要依靠严格的规范和约束。同时，对于那些因历史原因遗留在代码中的配置，要多花时间和精力把配置剥离出来，做这项工作没有什么好的方法或经验，只能多上心，多投入些精力。</p><h3><span id="版本控制">版本控制</span></h3><p>版本控制的主要作用是保证团队在交付软件的过程中能够高效协作，版本控制提供了一种保障机制。</p><p>版本控制及其工具是必不可少的，因为这是开发团队协作最基础的工具。</p><h3><span id="依赖管理">依赖管理</span></h3><p>以Java为例，即使运行一个非常简单的Web应用，都会有大量的jar包依赖。如果人工去管理这些依赖，基本上是不可能的，所以就需要有依赖管理的工具。</p><p>对于Java来说，依赖管理工具有Ant、Maven和Gradle。</p><p>以Maven为例，大致用法是建立一个本地Maven源，构建时会优先从本地源中获取依赖包，本地源中没有对应的依赖时，会从公网下载，同时缓存到本地。</p><h3><span id="软件配置">软件配置</span></h3><ol><li><p>代码配置</p><p>代码配置是跟代码运行时的业务逻辑相关的。比如应用的服务接口、并发线程数、超时时间等这些运行时参数；还有类似于业务或技术上的开关，比如商品评论是否开放、优惠时间段设置等。</p></li><li><p>应用配置</p><p>应用配置就是应用这个对象的属性和关系信息。我们把应用配置放到持续交付这个场景中进行分析，对于这个配置可以细分为：</p><ul><li>应用构建时配置，比如它的编程语言、Git地址以及构建方式等；</li><li>应用的部署配置，源代码目录、应用日志目录、Web日志目录、临时目录、脚本目录等；</li><li>应用的运行配置，应用启停、服务上下线方式、健康检测方式等；</li><li>应用运行时与基础组件的关联关系，比如其依赖的DB、缓存、消息以及存储的IP地址、域名、端口、用户名或Token等。</li></ul></li></ol><h2><span id="多环境建设">多环境建设</span></h2><h2><span id="线上环境建设">线上环境建设</span></h2><h2><span id="持续交付中的流水线模式">持续交付中的流水线模式</span></h2><h1><span id="混合云">混合云</span></h1><h2><span id="关于混合云">关于混合云</span></h2><p>随着技术趋势的发展，这个概念的内涵和外延也在不断发生着变化。</p><p>从字面上理解，混合云即公有云和私有云的混合搭配。</p><p>但是随着公有云服务越来越丰富，我们对于公有云的应用也不再仅仅限于资源层面，二更多地体现在云服务层面。</p><p>以CDN为例：</p><p>我们使用CDN服务，其实是云服务最早被应用的典型形态。在很长时间内，我们并没有意识到这就是云服务。但是，这种使用模式，从云的特性来讲，就是混合云模式。</p><p>我们所经历的几个基础设施建设阶段</p><ul><li><p>第一个阶段，完全托管IDC模式。我们选择与电信运营商或者第三方ISP合作，租赁其IDC机房中的机柜。而其他主机硬件和网络设备都是我们自行采购，然后放入机房中进行托管。</p></li><li><p>第二个阶段，资源短期租赁模式。因为电商大促的例行化，以及峰值流量的激增，导致我们短时资源需求量庞大。如果再靠一次性采购模式，付出的成本巨大，且后期成本闲置，造成严重的浪费。</p><p>我们曾跟运营商或第三方ISP谈过一些短期租赁合作。</p><p>这种合作模式，确实帮助我们在资源紧张和成本优化方面，解决了很大的难题。这种模式起到的作用，很大程度上满足了我们对弹性的需求，可以称之为“人肉云”或者“人工云”。</p></li><li><p>第三个阶段，同城混合云模式。这些年运营商和ISP服务商也在做自己的公有云体系，所以随着他们服务的不断完善，后来为了能够提升交付效率，我们也会尝试使用他们的公有云业务。</p><p>同城混合云模式，作为运营商和ISP服务商，他们的云资源可以和我们在同一机房或同城机房。这种模式最大的优势就是可以与我们的IDC网络专线拉通，大大降低网络延时，网络质量相对稳定，同时成本也相对较低。</p><p>如果是跨城甚至是跨省，就会频繁发生网络抖动、丢包这些问题。对于时延敏感的服务，是完全满足不了要求的，且微服务间频繁调用产生的大流量带宽需求，成本也是巨大的。</p><p>所以这种情况下，虽然公有云的各项产品和服务相对完善，但是如果在对应的城市没有公有云节点，或者距离较远，又或者专线质量不高，就基本没法满足我们规模化使用的场景。</p><p>但也不是全部无法满足。通过公有云建设CDN和二级CDN体系，虽然没有专线，但仍然可以满足部分业务场景。</p></li><li><p>公有云体系内混合云模式。从长远角度考虑，为了能够更加全面和深入地利用好云计算的产品技术，我们整体搬迁到了腾讯云。</p><p>这个阶段的初期，我们使用的还是完全独立的物理机资源。这种资源使用模式与之前托管IDC模式相比，除硬件和网络外，操作系统和各项技术栈还完全是由我们自己运维。</p><p>之所以这样做，还是为了保证迁移过程的平稳。因为我们自身的技术体系和架构已经非常庞大，也有较高的复杂度。</p><p>要想在另外一套基础设施上将这套精密的体系部署、测试、运行起来，同时还要保证各项性能指标以及系统容量不出问题 ，项目难度就已经非常高了。而这样做可以很好地防止软件架构发生变化，避免各种复杂因素交织在一起导致的因为稳定性的不可控。</p><p>之前我看到有很多人批评，甚至是贬低这种公有云提供的独立物理机资源的模式，认为这时换汤不换药，或者认为这是技术含量太低、技术水平不足的表现。但是我认为这种理解还是太片面。</p><p>单纯从技术角度来讲，这种模式或许没有体现公有云的特性，但是从实际业务场景和实际客户需求来讲却是必要的。而且对于类似蘑菇街这样有着大规模业务体量和复杂技术架构的产品来说，它还满足了用户的过渡需求。</p><p>所以，我认为腾讯云在这一方面还是体现了“客户第一”的意识的。</p><p>当然，搬迁到腾讯云之后，下一阶段，我们必然会利用更多的云资源和云服务。比如无状态的web服务器或者微服务应用，在大促时完全可以利用云的弹性优势进行快速的资源扩缩容。</p><p>但是对于数据库或大数据这样的存储类业务，因为它们本身又是支持业务运行的核心基础设施，所以短期内我们仍然还是采用独占物理机的模式。主要是基于下面两方面进行考量：</p><ul><li><p>技术架构匹配问题。以数据库为例，我们自研了分布式数据库中间件和大量的工具，比如对分库分表的支持和数据迁移转换等待。还针对具体的业务场景和特性在数据库和操作系统层面做了大量的优化工作，包括但不限于各类参数的调优，以及部分特性定制。</p><p>再者，云上资源也无法规模化地满足我们对硬件的特定需求，所以我们在这种模式下，就很难一下子将云服务利用起来，而其他的分布式组件也会存在类似问题。</p><p>归根结底，这还是云上的技术体系和原有的业务技术体系不匹配的矛盾所导致的，需要二者花更多的时间来磨合。同时，这也决定了在未来很长一段时间内，混合云模式才是最佳实践模式。</p></li><li><p>数据安全问题。一些有政策要求或政策限制的业务，需要慎重考虑这个问题。</p></li></ul></li></ul><p>不管如何选择和使用，我们一定还是要以满足业务场景为出发点，脱离了这一点，单纯准求技术深度和复杂度是没有意义的。</p><h1><span id="面向应用层的云架构解决方案">面向应用层的云架构解决方案</span></h1><p>spring Cloud如何解决应用层的云架构问题。</p><p>Spring Boot可以快速开发单个微服务应用，SpringCloud则提供一系列的服务治理框架，比如服务注册、服务发现、动态路由、负载均衡以及熔断等等能力，可以将一个个独立的微服务作为一个整体，进行很好的管理和维护。</p><p>Spring Cloud框架中云的影子</p><h1><span id="cdn和云存储-云生态">CDN和云存储 云生态</span></h1><h1><span id="页面静态化架构和二级cdn建设">页面静态化架构和二级CDN建设</span></h1><h1><span id="弹性伸缩">弹性伸缩</span></h1><h1><span id="稳定性保障">稳定性保障</span></h1><h1><span id="容量规划">容量规划</span></h1><h1><span id="限流降级">限流降级</span></h1><h1><span id="开关预案">开关预案</span></h1><h1><span id="全链路跟踪">全链路跟踪</span></h1><h1><span id="故障">故障</span></h1><h1><span id="安全">安全</span></h1>]]></content>
    
    <summary type="html">
    
      在微服务的架构模式下，我们的运维视角一定转到应用这个核心概念上来，一切要以应用的角度分析和看待问题。
    
    </summary>
    
    
      <category term="运维" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核设计02-从main到怠速</title>
    <link href="http://yoursite.com/2016/02/26/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A102-%E4%BB%8Emain%E5%88%B0%E6%80%A0%E9%80%9F/"/>
    <id>http://yoursite.com/2016/02/26/Linux内核设计02-从main到怠速/</id>
    <published>2016-02-25T16:35:35.000Z</published>
    <updated>2019-02-25T16:40:37.912Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#从main到怠速">从main到怠速</a><ul><li><a href="#开中断之前的准备工作">开中断之前的准备工作</a><ul><li><a href="#复制根设备号和硬盘参数表">复制根设备号和硬盘参数表</a></li><li><a href="#物理内存规划格局">物理内存规划格局</a></li><li><a href="#虚拟盘设置与初始化">虚拟盘设置与初始化</a></li><li><a href="#内存管理结构mem_map初始化">内存管理结构mem_map初始化</a></li><li><a href="#异常处理类中断服务程序挂接">异常处理类中断服务程序挂接</a></li><li><a href="#初始化块设备请求项结构">初始化块设备请求项结构</a></li><li><a href="#与建立人机交互界面相关的外设的中断服务程序挂接">与建立人机交互界面相关的外设的中断服务程序挂接</a></li><li><a href="#开机启动时间设置">开机启动时间设置</a></li><li><a href="#系统开始激活进程0">系统开始激活进程0</a></li><li><a href="#进程相关事务初始化设置">进程相关事务初始化设置</a></li><li><a href="#时钟中断设置">时钟中断设置</a></li><li><a href="#系统调用服务程序挂接">系统调用服务程序挂接</a></li><li><a href="#初始化缓冲区管理结构">初始化缓冲区管理结构</a></li><li><a href="#初始化硬盘">初始化硬盘</a></li><li><a href="#初始化软盘">初始化软盘</a></li><li><a href="#开中断">开中断</a></li></ul></li><li><a href="#进程创建的最基本动作">进程创建的最基本动作</a><ul><li><a href="#操作系统为进程0创建进程1做准备">操作系统为进程0创建进程1做准备</a></li><li><a href="#在进程槽中为进程1申请一个空闲位置并获取进程号">在进程槽中为进程1申请一个空闲位置并获取进程号</a></li><li><a href="#复制进程信息之前先将以下数据压栈">复制进程信息之前，先将以下数据压栈</a></li><li><a href="#初步设置进程1管理结构">初步设置进程1管理结构</a></li><li><a href="#进程0创建进程1的过程中发生时钟中断">进程0创建进程1的过程中发生时钟中断</a></li><li><a href="#从时钟中断返回">从时钟中断返回</a></li><li><a href="#调整进程1管理结构">调整进程1管理结构</a></li><li><a href="#设置进程1的线性地址空间及物理页面">设置进程1的线性地址空间及物理页面</a></li><li><a href="#继续调整进程1管理结构">继续调整进程1管理结构</a></li></ul></li><li><a href="#加载根文件系统">加载根文件系统</a><ul><li><a href="#进程1如何开始执行">进程1如何开始执行</a></li><li><a href="#进程1开始执行">进程1开始执行</a></li><li><a href="#进程1开始以数据块的形式操作硬盘">进程1开始以数据块的形式操作硬盘</a></li><li><a href="#将找到的缓冲块与请求项挂接">将找到的缓冲块与请求项挂接</a></li><li><a href="#将请求项与硬盘处理函数挂接">将请求项与硬盘处理函数挂接</a></li><li><a href="#进行硬盘读盘前的准备工作">进行硬盘读盘前的准备工作</a></li><li><a href="#给硬盘下达读盘指令">给硬盘下达读盘指令</a></li><li><a href="#进程1由于等待读盘操作挂起">进程1由于等待读盘操作挂起</a></li><li><a href="#系统切换到进程0执行">系统切换到进程0执行</a></li><li><a href="#进程0的执行过程">进程0的执行过程</a></li><li><a href="#进程0执行过程中发生硬盘中断">进程0执行过程中发生硬盘中断</a></li><li><a href="#硬盘中断服务程序响应后进程0继续执行">硬盘中断服务程序响应后，进程0继续执行</a></li><li><a href="#再次响应硬盘中断并唤醒进程1">再次响应硬盘中断并唤醒进程1</a></li><li><a href="#读盘操作完成后进程1继续执行">读盘操作完成后，进程1继续执行</a></li><li><a href="#进程1继续设置硬盘管理结构">进程1继续设置硬盘管理结构</a></li><li><a href="#进程1获取软盘超级块为加载根文件系统做准备">进程1获取软盘超级块，为加载根文件系统做准备</a></li><li><a href="#进程1备份超级块数据">进程1备份超级块数据</a></li><li><a href="#进程1将根文件系统从软盘拷贝到虚拟盘">进程1将根文件系统从软盘拷贝到虚拟盘</a></li><li><a href="#进程1开始加载根文件系统">进程1开始加载根文件系统</a></li><li><a href="#进程1准备加载根文件系统超级块">进程1准备加载根文件系统超级块</a></li><li><a href="#进程1加载根文件系统超级块">进程1加载根文件系统超级块</a></li><li><a href="#进程1继续加载根文件系统">进程1继续加载根文件系统</a></li><li><a href="#进程1准备读取根目录i节点">进程1准备读取根目录i节点</a></li><li><a href="#进程1加载根目录i节点">进程1加载根目录i节点</a></li><li><a href="#进程1结束加载根文件系统的过程">进程1结束加载根文件系统的过程</a></li></ul></li><li><a href="#打开终端设备文件及复制文件句柄">打开终端设备文件及复制文件句柄</a><ul><li><a href="#进程1与内核文件表挂接为打开文件做准备">进程1与内核文件表挂接，为打开文件做准备</a></li><li><a href="#确定打开操作的起点">确定打开操作的起点</a></li><li><a href="#获得枝梢i节点-dev目录文件的i节点">获得枝梢i节点-dev目录文件的i节点</a></li><li><a href="#确定dev目录文件i节点为枝梢i节点">确定dev目录文件i节点为枝梢i节点</a></li><li><a href="#继续返回枝梢i节点">继续返回枝梢i节点</a></li><li><a href="#查找tty0文件的i节点">查找tty0文件的i节点</a></li><li><a href="#将tty0设备文件的i节点返回给sys_open系统调用">将tty0设备文件的i节点返回给sys_open系统调用</a></li><li><a href="#分析tty0文件i节点">分析tty0文件i节点</a></li><li><a href="#设置文件管理结构并返回给用户进程">设置文件管理结构并返回给用户进程</a></li><li><a href="#进程1复制tty0文件句柄">进程1复制tty0文件句柄</a></li><li><a href="#进程1继续复制tty0文件句柄">进程1继续复制tty0文件句柄</a></li></ul></li><li><a href="#创建进程2">创建进程2</a></li><li><a href="#进程1等待进程2退出">进程1等待进程2退出</a></li><li><a href="#shell程序的加载">shell程序的加载</a></li><li><a href="#系统实现怠速">系统实现怠速</a></li></ul></li></ul><!-- tocstop --><h1><span id="从main到怠速">从main到怠速</span></h1><h2><span id="开中断之前的准备工作">开中断之前的准备工作</span></h2><h3><span id="复制根设备号和硬盘参数表">复制根设备号和硬盘参数表</span></h3><h3><span id="物理内存规划格局">物理内存规划格局</span></h3><h3><span id="虚拟盘设置与初始化">虚拟盘设置与初始化</span></h3><h3><span id="内存管理结构mem_map初始化">内存管理结构mem_map初始化</span></h3><h3><span id="异常处理类中断服务程序挂接">异常处理类中断服务程序挂接</span></h3><h3><span id="初始化块设备请求项结构">初始化块设备请求项结构</span></h3><h3><span id="与建立人机交互界面相关的外设的中断服务程序挂接">与建立人机交互界面相关的外设的中断服务程序挂接</span></h3><h3><span id="开机启动时间设置">开机启动时间设置</span></h3><h3><span id="系统开始激活进程0">系统开始激活进程0</span></h3><h3><span id="进程相关事务初始化设置">进程相关事务初始化设置</span></h3><h3><span id="时钟中断设置">时钟中断设置</span></h3><h3><span id="系统调用服务程序挂接">系统调用服务程序挂接</span></h3><h3><span id="初始化缓冲区管理结构">初始化缓冲区管理结构</span></h3><h3><span id="初始化硬盘">初始化硬盘</span></h3><h3><span id="初始化软盘">初始化软盘</span></h3><h3><span id="开中断">开中断</span></h3><h2><span id="进程创建的最基本动作">进程创建的最基本动作</span></h2><h3><span id="操作系统为进程0创建进程1做准备">操作系统为进程0创建进程1做准备</span></h3><h3><span id="在进程槽中为进程1申请一个空闲位置并获取进程号">在进程槽中为进程1申请一个空闲位置并获取进程号</span></h3><h3><span id="复制进程信息之前先将以下数据压栈">复制进程信息之前，先将以下数据压栈</span></h3><h3><span id="初步设置进程1管理结构">初步设置进程1管理结构</span></h3><h3><span id="进程0创建进程1的过程中发生时钟中断">进程0创建进程1的过程中发生时钟中断</span></h3><h3><span id="从时钟中断返回">从时钟中断返回</span></h3><h3><span id="调整进程1管理结构">调整进程1管理结构</span></h3><h3><span id="设置进程1的线性地址空间及物理页面">设置进程1的线性地址空间及物理页面</span></h3><h3><span id="继续调整进程1管理结构">继续调整进程1管理结构</span></h3><h2><span id="加载根文件系统">加载根文件系统</span></h2><h3><span id="进程1如何开始执行">进程1如何开始执行</span></h3><h3><span id="进程1开始执行">进程1开始执行</span></h3><h3><span id="进程1开始以数据块的形式操作硬盘">进程1开始以数据块的形式操作硬盘</span></h3><h3><span id="将找到的缓冲块与请求项挂接">将找到的缓冲块与请求项挂接</span></h3><h3><span id="将请求项与硬盘处理函数挂接">将请求项与硬盘处理函数挂接</span></h3><h3><span id="进行硬盘读盘前的准备工作">进行硬盘读盘前的准备工作</span></h3><h3><span id="给硬盘下达读盘指令">给硬盘下达读盘指令</span></h3><h3><span id="进程1由于等待读盘操作挂起">进程1由于等待读盘操作挂起</span></h3><h3><span id="系统切换到进程0执行">系统切换到进程0执行</span></h3><h3><span id="进程0的执行过程">进程0的执行过程</span></h3><h3><span id="进程0执行过程中发生硬盘中断">进程0执行过程中发生硬盘中断</span></h3><h3><span id="硬盘中断服务程序响应后进程0继续执行">硬盘中断服务程序响应后，进程0继续执行</span></h3><h3><span id="再次响应硬盘中断并唤醒进程1">再次响应硬盘中断并唤醒进程1</span></h3><h3><span id="读盘操作完成后进程1继续执行">读盘操作完成后，进程1继续执行</span></h3><h3><span id="进程1继续设置硬盘管理结构">进程1继续设置硬盘管理结构</span></h3><h3><span id="进程1获取软盘超级块为加载根文件系统做准备">进程1获取软盘超级块，为加载根文件系统做准备</span></h3><h3><span id="进程1备份超级块数据">进程1备份超级块数据</span></h3><h3><span id="进程1将根文件系统从软盘拷贝到虚拟盘">进程1将根文件系统从软盘拷贝到虚拟盘</span></h3><h3><span id="进程1开始加载根文件系统">进程1开始加载根文件系统</span></h3><h3><span id="进程1准备加载根文件系统超级块">进程1准备加载根文件系统超级块</span></h3><h3><span id="进程1加载根文件系统超级块">进程1加载根文件系统超级块</span></h3><h3><span id="进程1继续加载根文件系统">进程1继续加载根文件系统</span></h3><h3><span id="进程1准备读取根目录i节点">进程1准备读取根目录i节点</span></h3><h3><span id="进程1加载根目录i节点">进程1加载根目录i节点</span></h3><h3><span id="进程1结束加载根文件系统的过程">进程1结束加载根文件系统的过程</span></h3><h2><span id="打开终端设备文件及复制文件句柄">打开终端设备文件及复制文件句柄</span></h2><h3><span id="进程1与内核文件表挂接为打开文件做准备">进程1与内核文件表挂接，为打开文件做准备</span></h3><h3><span id="确定打开操作的起点">确定打开操作的起点</span></h3><h3><span id="获得枝梢i节点-dev目录文件的i节点">获得枝梢i节点-dev目录文件的i节点</span></h3><h3><span id="确定dev目录文件i节点为枝梢i节点">确定dev目录文件i节点为枝梢i节点</span></h3><h3><span id="继续返回枝梢i节点">继续返回枝梢i节点</span></h3><h3><span id="查找tty0文件的i节点">查找tty0文件的i节点</span></h3><h3><span id="将tty0设备文件的i节点返回给sys_open系统调用">将tty0设备文件的i节点返回给sys_open系统调用</span></h3><h3><span id="分析tty0文件i节点">分析tty0文件i节点</span></h3><h3><span id="设置文件管理结构并返回给用户进程">设置文件管理结构并返回给用户进程</span></h3><h3><span id="进程1复制tty0文件句柄">进程1复制tty0文件句柄</span></h3><h3><span id="进程1继续复制tty0文件句柄">进程1继续复制tty0文件句柄</span></h3><h2><span id="创建进程2">创建进程2</span></h2><p>进程1准备创建进程2</p><p>复制进程2管理结构并继续调整</p><p>设置进程2的页目录项并复制进程2的页表</p><p>调整进程2管理结构中与文件有关的内容</p><p>进程1执行过程中发生时钟中断</p><p>进程1从时钟中断返回，准备切换到进程2</p><h2><span id="进程1等待进程2退出">进程1等待进程2退出</span></h2><h2><span id="shell程序的加载">shell程序的加载</span></h2><h2><span id="系统实现怠速">系统实现怠速</span></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#从main到怠速&quot;&gt;从main到怠速&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#开中断之前的准备工作&quot;&gt;开中断之前的准备工作&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#复制根设备号和硬盘参数表&quot;&gt;复制根设备号和硬
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核设计01-从加电到main</title>
    <link href="http://yoursite.com/2016/02/24/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A101-%E4%BB%8E%E5%8A%A0%E7%94%B5%E5%88%B0main/"/>
    <id>http://yoursite.com/2016/02/24/Linux内核设计01-从加电到main/</id>
    <published>2016-02-24T00:49:09.000Z</published>
    <updated>2019-02-26T03:20:26.096Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#从开机加电到执行main函数之前的过程">从开机加电到执行main函数之前的过程</a><ul><li><a href="#第一步启动bios准备实模式下的中断向量表和中断服务程序">第一步，启动BIOS，准备<em>实模式</em>下的中断向量表和中断服务程序</a><ul><li><a href="#bios启动原理">BIOS启动原理</a></li><li><a href="#bios在内存中加载中断向量表和中断服务程序">BIOS在内存中加载中断向量表和中断服务程序</a></li></ul></li><li><a href="#第二步利用第一步中准备的中断服务程序来实现从启动盘加载操作系统程序到内存">第二步，利用第一步中准备的中断服务程序来实现：从启动盘加载操作系统程序到内存</a></li><li><a href="#第三步为执行32位的main函数做过渡工作">第三步，为执行32位的main函数做过渡工作</a><ul><li><a href="#关中断并将system移动到内存地址起始位置0x00000">关中断，并将system移动到内存地址起始位置0x00000</a></li><li><a href="#设置中断描述符表和全局描述符表">设置中断描述符表和全局描述符表</a></li><li><a href="#打开a20实现32位寻址">打开A20，实现32位寻址</a></li><li><a href="#为在保护模式下执行heads做准备">为在保护模式下执行head.s做准备</a></li><li><a href="#heads开始执行">head.s开始执行</a></li></ul></li></ul></li><li><a href="#文件操作">文件操作</a><ul><li><a href="#打开文件">打开文件</a></li><li><a href="#读文件">读文件</a></li><li><a href="#新建文件">新建文件</a></li><li><a href="#写文件">写文件</a></li><li><a href="#修改文件">修改文件</a></li><li><a href="#关闭文件">关闭文件</a></li><li><a href="#删除文件">删除文件</a></li></ul></li><li><a href="#用户进程与内存管理">用户进程与内存管理</a><ul><li><a href="#用户进程的创建">用户进程的创建</a></li><li><a href="#为用户进程str1的加载做准备">为用户进程str1的加载做准备</a></li><li><a href="#对缺页中断的处理">对缺页中断的处理</a></li><li><a href="#str1用户进程的退出">str1用户进程的退出</a></li><li><a href="#多个用户进程同时运行">多个用户进程同时运行</a></li><li><a href="#进程的调度与切换">进程的调度与切换</a></li><li><a href="#内核的分页">内核的分页</a></li><li><a href="#页写保护">页写保护</a></li></ul></li><li><a href="#多个进程同时操作一个文件">多个进程同时操作一个文件</a><ul><li><a href="#三个进程操作同一个文件">三个进程操作同一个文件</a></li><li><a href="#缓冲区与外设的数据同步">缓冲区与外设的数据同步</a></li></ul></li><li><a href="#ipc问题">IPC问题</a><ul><li><a href="#管道机制">管道机制</a></li><li><a href="#信号机制">信号机制</a></li></ul></li></ul><!-- tocstop --><h1><span id="从开机加电到执行main函数之前的过程">从开机加电到执行main函数之前的过程</span></h1><p>从开机到main函数的执行分三步完成，其目的是实现从启动盘加载操作系统程序，完成执行main函数所需要的准备工作。</p><h2><span id="第一步启动bios准备实模式下的中断向量表和中断服务程序">第一步，启动BIOS，准备<em>实模式</em>下的中断向量表和中断服务程序</span></h2><p>加电的一瞬间，计算机的RAM中，空空如也，什么程序也没有。而CPU的逻辑电路被设计为只能运行内存中的程序。如果要运行软盘中的操作系统，必须将软盘中操作系统程序加载到RAM中。<br>在RAM中什么程序都没有的时候，要由BIOS来完成加载软盘中操作系统到RAM中的任务。</p><h3><span id="bios启动原理">BIOS启动原理</span></h3><p>此时RAM中无程序，所以通过软件方法不可能执行BIOS，只能靠<strong>硬件方法</strong>完成。<br>从硬件角度看，Intel 80x86系列的cpu可以分别在16位实模式和32位保护模式下运行。</p><p>所有80x86系列CPU的硬件都设计为加电即进入16位实模式状态运行。且在加电瞬间强行将CS置为0xFFFF，IP置为0x0000，如此CS：IP就指向0xFFFF0这个地址位置。</p><blockquote><p>实模式（Real mode）的特性是一个20位的存储器地址空间，可以直接通过软件的方式访问BIOS以及周边硬件。</p><blockquote><p>$$<br>2^{20} =1048576​<br>$$</p><p>即1M的存储器可被寻</p></blockquote></blockquote><p>0xFFFF0指向了BIOS的地址范围。<br>这是一个纯硬件完成的动作。</p><p>BIOS程序的入口地址就是0xFFFF0.</p><h3><span id="bios在内存中加载中断向量表和中断服务程序">BIOS在内存中加载中断向量表和中断服务程序</span></h3><p>BIOS程序被固化在计算机主板之上的一块很小的ROM芯片里。不同的主板所用的BIOS也有所不同，就启动部分，各种类型的BIOS的基本原理大致相似。</p><p>在此，我们选用8KB的BIOS来说明此问题，此时BIOS所占地址段为0xFE000-0xFFFFF。</p><p>而此时，在实模式下内存寻址空间为：0x00000-0xFFFFF</p><p>CS：IP指向0xFFFF0，意味着BIOS开始启动了。<br>随着BIOS程序的执行，屏幕上显示显卡的信息、内存的信息……<br>在这期间，BIOS在内存中建立了中断向量表和中断服务程序：<br><strong>BIOS在内存最开始的位置（0x00000）用1K的内存空间构建中断向量表，并在紧挨它的位置用256字节的内存空间构建BIOS数据区，在大约56K以后的位置加载了8KB左右的与中断向量表相应的若干中断服务程序</strong>。<br>中断向量表中有256个中断向量，每个中断向量占4个字节，其中两个字节是CS值，两个为IP值，每个中断向量都指向一个具体的中断服务程序。</p><blockquote><p><em>中断</em>，可以理解为函数调用。</p></blockquote><h2><span id="第二步利用第一步中准备的中断服务程序来实现从启动盘加载操作系统程序到内存">第二步，利用第一步中准备的中断服务程序来实现：从启动盘加载操作系统程序到内存</span></h2><p>从现在开始就要执行真正的boot操作了，即把软盘中的操作系统加载至内存。</p><p>分三批逐次加载操作系统的内核代码：</p><ul><li><p>第一批由BIOS中断int 0x19h把第一扇区bootsect的内容加载到内存。</p><p>CPU接收到int 19h中断，立即在中断向量表中找到int 19h中断向量-&gt;这个中断向量把CPU指向0x0E6F2，这个位置就是int 19h相对应的中断服务程序的入口地址。</p><p>这个中断服务程序的作用就是把软盘的第一个扇区中的程序（512B）加载到内存中的指定位置（0x07C00）。</p><p><strong>这个中断服务程序的功能是BIOS事先设计好的，代码是固定的，与Linux操作系统无关</strong>。</p><p>这个扇区里的内容就是Linux 0.11操作系统的引导程序，也就是bootsect，其作用就是陆续把软盘中的操作系统程序载入内存。</p><p>bootsect的载入，标志着操作系统中的代码即将发挥作用了。</p></li><li><p>加载第二部分代码-setup</p><p>现在BIOS已经把bootsect（如上所示）载入内存了，它的作用就是把第二批和第三批程序陆续加载到内存中。为了把第二批和第三批程序加载到内存中的适当位置，bootsect首先做的工作就是规划内存。</p><ol><li>bootsect对内存的规划</li></ol><p>在实模式下，寻址的最大范围是1MB，为了规划内存，bootsect首先设计了如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SETUPLEN, 4     # nr of setup-sectors</span><br><span class="line"></span><br><span class="line">BOOTSEG, 0x07c0 # original address of boot-sector</span><br><span class="line"></span><br><span class="line">INITSEG, 0x9000 # we move boot here - out of the way</span><br><span class="line"></span><br><span class="line">SETUPSEG, 0x9020    # setup starts here</span><br><span class="line"></span><br><span class="line">SYSSEG, 0x1000      # system loaded at 0x10000 (65536).</span><br><span class="line"></span><br><span class="line">ENDSEG, SYSSEG + SYSSIZE    # where to stop loading</span><br></pre></td></tr></table></figure></li></ul><p>  这些源代码的作用就是对后续操作所涉及的内存位置进行设置，包括将要加载的setup程序的扇区数和被加载到的位置、启动扇区被BIOS加载的位置和将要移动到的新位置、内核被加载的位置、内核末尾位置和根文件系统设备号。</p><p>  要时刻牢记这样一个概念：<strong>操作系统的设计者要全面</strong>、<strong>整体地考虑内存的规划</strong>。</p><ol start="2"><li><p>复制bootsect</p><p>接下来，bootsect启动程序将它自身从内存0x07C00处复制至内存0x90000处</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">start:;// 以下10行作用是将自身(bootsect)从目前段位置07c0h(31k)</span><br><span class="line">;// 移动到9000h(576k)处，共256字(512字节)，然后跳转到</span><br><span class="line">;// 移动后代码的 go 标号处，也即本程序的下一语句处。 </span><br><span class="line">movax,BYTE PTR BOOTSEG;// 将ds段寄存器置为7C0h</span><br><span class="line">movds,ax</span><br><span class="line">movax,BYTE PTR INITSEG;// 将es段寄存器置为9000h</span><br><span class="line">moves,ax</span><br><span class="line">movcx,256;// 移动计数值 ＝ 256字 = 512 字节</span><br><span class="line">subsi,si;// 源地址   ds:si = 07C0h:0000h</span><br><span class="line">subdi,di;// 目的地址 es:di = 9000h:0000h</span><br><span class="line">rep movsw;// 重复执行，直到cx = 0;移动1个字</span><br></pre></td></tr></table></figure><p>在这次复制过程中，ds和si联合使用，构成了源地址；es和di联合使用，构成了目的地址，而<code>mov cx,256</code>循环控制量，提供了需要复制的字数（一个字位两个字节）。</p><p>bootsect复制到新位置后，将ds、es、ss都置成移动后代码所在段处。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">;jmp INITSEG:[go] ;// 间接跳转。这里INITSEG指出跳转到的段地址。</span><br><span class="line">    db 0eah;// 间接跳转指令码</span><br><span class="line">dw go</span><br><span class="line">dw INITSEG</span><br><span class="line">go:movax,cs;// 将ds、es和ss都置成移动后代码所在的段处（9000h）。</span><br><span class="line">movds,ax;// 由于程序中有堆栈操作（push，pop，call），因此必须设置堆栈。</span><br><span class="line">moves,ax</span><br><span class="line">;// put stack at 9ff00.  将堆栈指针sp指向9ff00h（即9000h:0ff00h）处</span><br><span class="line">movss,ax</span><br><span class="line">movsp,0FF00h;/* 由于代码段移动过了，所以要重新设置堆栈段的位置。</span><br><span class="line">;   sp只要指向远大于512偏移（即地址90200h）处</span><br><span class="line">;   都可以。因为从90200h地址开始处还要放置setup程序，</span><br><span class="line">;   而此时setup程序大约为4个扇区，因此sp要指向大</span><br><span class="line">;   于（200h + 200h*4 + 堆栈大小）处。 */</span><br></pre></td></tr></table></figure></li><li><p>将setup程序加载到内存中</p><p>加载setup程序，要借助BIOS提供的int 0x 13h中断向量所指向的中断服务程序（也就是磁盘服务程序）来完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">load_setup:</span><br><span class="line">;// 以下10行的用途是利用BIOS中断INT 13h将setup模块从磁盘第2个扇区</span><br><span class="line">;// 开始读到90200h开始处，共读4个扇区。如果读出错，则复位驱动器，并</span><br><span class="line">;// 重试，没有退路。</span><br><span class="line">;// INT 13h 的使用方法如下：</span><br><span class="line">;// ah = 02h - 读磁盘扇区到内存；al = 需要读出的扇区数量；</span><br><span class="line">;// ch = 磁道（柱面）号的低8位；  cl = 开始扇区（0－5位），磁道号高2位（6－7）；</span><br><span class="line">;// dh = 磁头号；  dl = 驱动器号（如果是硬盘则要置为7）；</span><br><span class="line">;// es:bx -&gt;指向数据缓冲区；  如果出错则CF标志置位。 </span><br><span class="line">movdx,0000h;// drive 0, head 0</span><br><span class="line">movcx,0002h;// sector 2, track 0</span><br><span class="line">movbx,0200h;// address = 512, in INITSEG</span><br><span class="line">movax,0200h+SETUPLEN;// service 2, nr of sectors</span><br><span class="line">int13h;// read it</span><br><span class="line">jncok_load_setup;// ok - continue</span><br><span class="line">movdx,0000h</span><br><span class="line">movax,0000h;// reset the diskette</span><br><span class="line">int13h</span><br><span class="line">jmpload_setup</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>加载第三部分代码-system模块</p><p>仍然使用BIOS提供的int 0x 13h中断。</p><p>bootsect借着BIOS中断int 0x 13h，将240个扇区的system模块加载进内存。</p><p>加载工作主要是由bootsect调用read_it子程序完成的。</p><p>到此为止，第三批程序已经加载完毕，整个操作系统的代码已全部载入内存。bootsect的主体工作已经做完了，还有一点小事，就是要再次确定以下根设备号。</p><p>经过一系列检测，得知软盘为根设备，所以就把根设备号保存在root_dev中，作为机器系统数据之一。</p><p>现在，bootsect程序的任务都已经完成。</p><p>下面通过执行<code>jmpi 0, SETUPSEG</code>这行语句跳转至0x90200处，也就是第二批程序setup程序加载的位置。</p><p>CS：IP指向setup程序的第一条指令，意味着由setup程序接着bootsect程序继续执行。</p><p>setup程序现在开始执行。它做的第一件事情就是利用BIOS提供的中断服务程序从设备上提取内核运行所需的机器系统数据。</p><p>这些机器系统数据被加载到内存的0x90000-0x901FC位置，这些数据将在以后main函数执行时发挥重要作用。</p></li></ul><h2><span id="第三步为执行32位的main函数做过渡工作">第三步，为执行32位的main函数做过渡工作</span></h2><p>接下来，操作系统要使计算机在32位保护模式下工作。</p><p>这期间要做大量的重建工作，并且持续工作到操作系统的main函数的执行过程中。</p><p>在本节中，操作系统执行的操作包括打开32位的寻址空间、打开保护模式、建立保护模式下的中断响应机制等与保护模式配套的相关工作、建立内存的分页机制，以及做好调用main函数的准备。</p><p>setup继续执行……</p><h3><span id="关中断并将system移动到内存地址起始位置0x00000">关中断，并将system移动到内存地址起始位置0x00000</span></h3><p>即将CPU的标志寄存器（EFLAGS）中的中断允许标志置0。意味着，在接下来的执行过程中，无论是否发生中断，系统都不再响应此中断，直到main函数中适应保护模式的中断服务体系被重建完毕才会打开。那时响应中断的服务程序不再是BIOS提供的中断服务程序，取而代之的是由系统自身提供的中断服务程序。</p><blockquote><p>EFLAGS：标志寄存器，存在于CPU中，32位，包含一组状态标志、控制标志和系统标志。第9位IF为中断允许标志。</p></blockquote><blockquote><p>关中断（cli）和开中断（sti）操作在操作系统代码中频繁出现，总是在一个完整的操作过程的两头出现，目的是为了避免中断在此期间介入。</p></blockquote><p>下面，setup做了一个影响深远的动作：将位于0x10000的内核程序拷贝至内存地址起始位置0x00000处。</p><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">;// 从这里开始我们要保护模式方面的工作了。</span><br><span class="line"></span><br><span class="line">cli;// 此时不允许中断。 ;//</span><br><span class="line"></span><br><span class="line">;// 首先我们将system 模块移到正确的位置。</span><br><span class="line">;// bootsect 引导程序是将system 模块读入到从10000（64k）开始的位置。由于当时假设</span><br><span class="line">;// system 模块最大长度不会超过80000（512k），也即其末端不会超过内存地址90000，</span><br><span class="line">;// 所以bootsect 会将自己移动到90000 开始的地方，并把setup 加载到它的后面。</span><br><span class="line">;// 下面这段程序的用途是再把整个system 模块移动到00000 位置，即把从10000 到8ffff</span><br><span class="line">;// 的内存数据块(512k)，整块地向内存低端移动了10000（64k）的位置。</span><br><span class="line"></span><br><span class="line">movax,0000h</span><br><span class="line">cld;// &apos;direction&apos;=0, movs moves forward</span><br><span class="line">do_move:</span><br><span class="line">moves,ax;// es:di -&gt; 目的地址(初始为0000:0)</span><br><span class="line">addax,1000h</span><br><span class="line">cmpax,9000h;// 已经把从8000 段开始的64k 代码移动完？</span><br><span class="line">jzend_move</span><br><span class="line">movds,ax;// ds:si -&gt; 源地址(初始为1000:0)</span><br><span class="line">subdi,di</span><br><span class="line">subsi,si</span><br><span class="line">mov cx,8000h;// 移动8000 字（64k 字节）。</span><br><span class="line">rep movsw</span><br><span class="line">jmpdo_move</span><br></pre></td></tr></table></figure><h3><span id="设置中断描述符表和全局描述符表">设置中断描述符表和全局描述符表</span></h3><p>setup继续为保护模式做准备，此时要通过setup自身提供的数据信息对中断描述符表寄存器IDTR和全局描述符表寄存器GDTR进行初始化设置。</p><blockquote><p>GDT(Global Descriptor Table)：它是系统中唯一存放段寄存器内容（段描述符）的数组，配合程序进行保护模式下的段寻址。它在操作系统的进程切换中具有重要意义，可理解为所有进程的总目录表，其中存放着每一个任务局部描述符表（LDT）地址和任务状态段（TSS）地址，用于完成进程中各段的寻址、现场保护和现场恢复。</p><p>GDTR：GDT可以存放在内存的任何位置，当程序通过段寄存器引用一个段描述符时，需要取得GDT的入口，GDTR所标识的即为此入口。在操作系统对GDT的初始化完成后，可以用LGDT（Load GDT）指令将GDT基地址加载至GDTR。</p><p>IDT(Interrupt Descriptor Table)：保存保护模式下所有中断服务程序的入口地址，类似于实模式下的中断向量表。</p><p>IDTR：IDT基地址寄存器，保存IDT的起始地址。</p></blockquote><blockquote><p>32位的中断机制和16位的中断机制在原理上有比较大的差别，最明显的是16位的中断机制用的是中断向量表，中断向量表的起始位置在0x00000处，这个位置是固定的。</p><p>32位的中断机制用的是中断描述符表IDT，位置是不固定的，可以由操作系统的设计者根据设计要求灵活安排，由IDTR寄存器来锁定其位置。</p></blockquote><blockquote><p>GDT表是保护模式下管理段描述符的数据结构，对操作系统自身的运行和管理，以及进程调度有重大意义。</p></blockquote><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">;// 全局描述符表开始处。描述符表由多个8 字节长的描述符项组成。</span><br><span class="line">;// 这里给出了3 个描述符项。第1 项无用，但须存在。第2 项是系统代码段</span><br><span class="line">;// 描述符，第3 项是系统数据段描述符。每个描述符的具体</span><br><span class="line">;// 含义参见列表后说明。</span><br><span class="line">gdt:</span><br><span class="line">dw0,0,0,0;// 第1 个描述符，不用。</span><br><span class="line">;// 这里在gdt 表中的偏移量为08，当加载代码段寄存器(段选择符)时，使用的是这个偏移值。</span><br><span class="line">dw07FFh;// 8Mb - limit=2047 (2048*4096=8Mb)</span><br><span class="line">dw0000h;// base address=0</span><br><span class="line">dw9A00h;// code read/exec</span><br><span class="line">dw00C0h;// granularity=4096, 386</span><br><span class="line">;// 这里在gdt 表中的偏移量是16，当加载数据段寄存器(如ds 等)时，使用的是这个偏移值。</span><br><span class="line">dw07FFh;// 8Mb - limit=2047 (2048*4096=8Mb)</span><br><span class="line">dw0000h;// base address=0</span><br><span class="line">dw9200h;// data read/write</span><br><span class="line">dw00C0h;// granularity=4096, 386</span><br><span class="line"></span><br><span class="line">idt_48:</span><br><span class="line">dw0;// idt limit=0</span><br><span class="line">dw0,0;// idt base=0L</span><br><span class="line"></span><br><span class="line">gdt_48:</span><br><span class="line">dw800h;// 全局表长度为2k 字节，因为每8 字节组成一个段描述符项</span><br><span class="line">;// 所以表中共可有256 项。</span><br><span class="line">dw512+gdt,9h;// 4 个字节构成的内存线性地址：0009&lt;&lt;16 + 0200+gdt</span><br><span class="line">;// 也即90200 + gdt(即在本程序段中的偏移地址，205 行)。</span><br></pre></td></tr></table></figure><p>此时内核尚未真正运行起来，还没有进程，所以现在创建的GDT表的第一项为空，第二项为内核代码段描述符，第三项为内核数据段描述符，其余项皆为空。</p><p>IDT表虽然已经设置，实为一张空表，原因是目前中断已关，无须调用中断服务程序。</p><p>创建这两个表的过程可理解为是分两步进行的：</p><ul><li>在设计内核代码时，已经将两个表写好，并且把需要的数据也写好；</li><li>将专用寄存器（IDTR和GDTR）指向表</li></ul><blockquote><p>在内存中做出数据的方法有两种：</p><ul><li>划分一块内存区域并初始化数据，“看住”这块内存区域，使之能被找到；</li><li>有代码做出数据，如用push代码压栈，做出数据。</li></ul></blockquote><p>此处采用的是第一种方法。</p><h3><span id="打开a20实现32位寻址">打开A20，实现32位寻址</span></h3><p>打开A20，意味着CPU可以进行32位寻址，最大寻址空间为4GB</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">call empty_8042;// 等待输入缓冲器空。</span><br><span class="line">;// 只有当输入缓冲器为空时才可以对其进行写命令。</span><br><span class="line">moval,0D1h;// D1 命令码-表示要写数据到8042 的P2 端口。P2 端</span><br><span class="line">out64h,al;// 口的位1 用于A20 线的选通。数据要写到60 口。</span><br><span class="line"></span><br><span class="line">call empty_8042;// 等待输入缓冲器空，看命令是否被接受。</span><br><span class="line">moval,0DFh;// A20 on 选通A20 地址线的参数。</span><br><span class="line">out60h,al</span><br><span class="line">call empty_8042;// 输入缓冲器为空，则表示A20 线已经选通。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">;// 下面这个子程序检查键盘命令队列是否为空。这里不使用超时方法- 如果这里死机，</span><br><span class="line">;// 则说明PC 机有问题，我们就没有办法再处理下去了。</span><br><span class="line">;// 只有当输入缓冲器为空时（状态寄存器位2 = 0）才可以对其进行写命令。</span><br><span class="line">empty_8042:</span><br><span class="line">dw 00ebh,00ebh;// jmp $+2, jmp $+2 $ 表示当前指令的地址</span><br><span class="line">;// 这是两个跳转指令的机器码(跳转到下一句)，相当于延时空操作。</span><br><span class="line">inal,64h;// 读AT 键盘控制器状态寄存器。</span><br><span class="line">test al,2;// 测试位2，输入缓冲器满？</span><br><span class="line">jnzempty_8042;// yes - loop</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><blockquote><p>实模式下CPU的寻址范围为0到0xFFFFF，共1MB寻址空间，需要0-19号共20根地址线。进入保护模式后，将使用32位寻址模式，即采用32根地址线进行寻址，第21根到第32根地址线的选通，将意味着寻址模式的切换。</p></blockquote><blockquote><p>实模式下，当程序寻址超过0xFFFFF时，CPU将回滚至内存起始处寻址。（在只有20根地址线的条件下，0xFFFFF+1=0x00000，最高位溢出）。</p><p>例如，系统的段寄存器的最大允许地址为0xFFFF，指令指针的最大允许段内偏移也为0xFFFF，两者确定的最大绝对地址为0x10FFEF，这将意味着程序中可产生的实模式下的寻址范围比1MB多出将近64KB。</p><p>若将A20地址线启用就相对于关闭了CPU在实模式下寻址的“回滚”机制。可以利用这个特点来验证A20是否确实已经打开。</p></blockquote><h3><span id="为在保护模式下执行heads做准备">为在保护模式下执行head.s做准备</span></h3><p>为了建立保护模式下的中断机制，setup将对可编程中断控制器8259A进行重新编程。</p><blockquote><p>8259A中断控制器：8259A是专门为了对8085A和8086/8088进行中断控制而设计的芯片，它是可以用程序控制的中断控制器。单个的8259A能管理8级向量优先级中断。在不增加其他电路的情况下，最多可以级联成64级的向量优先级中断系统。</p></blockquote><blockquote><p>在保护模式下，int 0x00-int 0x1F被Intel保留作为内部（不可屏蔽）中断和异常中断。</p></blockquote><p><strong>setup通过下面的代码将CPU的工作方式设为保护模式</strong>【此后正式进入了保护模式】：</p><p>将CR0寄存器的第0位（PE）置1，即设定处理器的工作方式为保护模式。</p><blockquote><p>CR0寄存器：0号32位控制寄存器，存放系统控制标志。第0位为PE（Protected Mode Enable）标志，置1时CPU工作在保护模式下，置0时为实模式。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">;// 这里设置进入32 位保护模式运行。首先加载机器状态字(lmsw - Load Machine Status Word)，</span><br><span class="line">;// 也称控制寄存器CR0，其比特位0 置1 将导致CPU 工作在保护模式。</span><br><span class="line"></span><br><span class="line">movax,0001h;// 保护模式比特位(PE)。</span><br><span class="line">lmsw ax;// 就这样加载机器状态字</span><br></pre></td></tr></table></figure><p>CPU工作方式转变为保护模式，一个重要的特征就是要根据GDT表来决定后续将执行哪里的程序。</p><p><code>jmpi 0, 8</code></p><p>这一句中的0是段内偏移，8是保护模式下的段选择符，用于选择描述符表和描述符表项以及所要求的特权级。</p><p>8要看成00001000：最后的00表示内核特权级，第3位的0表示GDT表，第4、5两位的01表示所选的表的1项来确定代码段的基址和段限长信息。</p><p>而GDT表的1项内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dw07FFh;// 8Mb - limit=2047 (2048*4096=8Mb)</span><br><span class="line">dw0000h;// base address=0</span><br><span class="line">dw9A00h;// code read/exec</span><br><span class="line">dw00C0h;// granularity=4096, 386</span><br></pre></td></tr></table></figure><p>所以，代码就会从段基址0x00000000、偏移为0处开始执行，也就是head的开始位置，这意味着将执行head程序。</p><h3><span id="heads开始执行">head.s开始执行</span></h3><p><strong>从bootsect到main执行的整体技术策略</strong>：</p><p>在执行main之前，先要执行三个汇编代码生成的程序，即bootsect、setup和head。之后，才执行由main开始的用C语言编写的操作系统内核程序。</p><p>先将head.s汇编成目标代码，将用C语言编写的内核程序编译成目标代码，然后链接成system模块。也就是说，system模块中，既有内核程序，也有head程序，二者是紧挨着的。head在前，内核在后，head在内存中占有25KB+184B的空间。</p><p>head用它自身的代码在它自身所在的空间创建了内核分页机制，即在0x000000的位置创建了也目录表、页表、缓冲区、GDT、IDT，并将head已经执行过的代码所占内存空间覆盖，这意味这head自己将自己废弃，main即将开始执行。</p><p>_pg_dir：用于标识内核分页机制完成后的内核起始位置，也就是物理内存的起始位置0x000000。head将在此建立页目录表，为分页机制做准备。这是内核能够掌控用户进程的基础之一。</p><p>现在head正式开始执行。一切都是为适应保护模式做准备。其本质就是让CS的用法从实模式转变到保护模式。</p><p>在实模式下时，CS本身就是代码段基址。而在保护模式下时，CS本身并不是代码段基址，而是代码段选择符。</p><p><code>jmpi 0, 8</code>这句代码使CS和GDT表的第2项关联，并且使代码的基址指向了0x000000。</p><p>这之后要将DS、ES、FS和GS等其他寄存器从实模式转变到保护模式。执行代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">_startup_32:;// 以下5行设置各个数据段寄存器。指向gdt数据段描述符项</span><br><span class="line">mov eax,10h</span><br><span class="line">;// 再次注意!!! 这里已经处于32 位运行模式，因此这里的$0x10 并不是把地址0x10 装入各</span><br><span class="line">;// 个段寄存器，它现在其实是全局段描述符表中的偏移值，或者更正确地说是一个描述符表</span><br><span class="line">;// 项的选择符。有关选择符的说明请参见setup.s 中的说明。这里$0x10 的含义是请求特权</span><br><span class="line">;// 级0(位0-1=0)、选择全局描述符表(位2=0)、选择表中第2 项(位3-15=2)。它正好指向表中</span><br><span class="line">;// 的数据段描述符项。（描述符的具体数值参见前面setup.s ）。下面代码的含义是：</span><br><span class="line">;// 置ds,es,fs,gs 中的选择符为setup.s 中构造的数据段（全局段描述符表的第2 项）=0x10，</span><br><span class="line">;// 并将堆栈放置在数据段中的_stack_start 数组内，然后使用新的中断描述符表和全局段</span><br><span class="line">;// 描述表.新的全局段描述表中初始内容与setup.s 中的完全一样。</span><br><span class="line">mov ds,ax</span><br><span class="line">mov es,ax</span><br><span class="line">mov fs,ax</span><br><span class="line">mov gs,ax</span><br><span class="line">lss esp,_stack_start;// 表示_stack_start -&gt; ss:esp，设置系统堆栈。</span><br><span class="line">;// stack_start 定义在kernel/sched.c，69 行。</span><br><span class="line">call setup_idt;// 调用设置中断描述符表子程序。</span><br><span class="line">call setup_gdt;// 调用设置全局描述符表子程序。</span><br><span class="line">mov eax,10h;// reload all the segment registers</span><br><span class="line">mov ds,ax;// after changing gdt. CS was already</span><br><span class="line">mov es,ax;// reloaded in &apos;setup_gdt&apos;</span><br><span class="line">mov fs,ax;// 因为修改了gdt，所以需要重新装载所有的段寄存器。</span><br><span class="line">mov gs,ax;// CS 代码段寄存器已经在setup_gdt 中重新加载过了。</span><br><span class="line">lss esp,_stack_start</span><br></pre></td></tr></table></figure><p>执行完毕后，DS、ES、FS和GS中的值都变成0x10。</p><p>0x10应看成二进制的00010000：最后两位的00表示内核特权级，第3位的0表示选择GDT表，第4、5两位的10是GDT表的2项，也就是第3项。</p><p>此时，4个寄存器用的是同一个全局描述符，它们的段基址、段限长和特权级都是相同的。</p><p>SS现在也要转变为栈段选择符，栈顶指针也成为32位的esp，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lss _stack_start, %esp</span><br></pre></td></tr></table></figure><blockquote><p>取段寄存器指令（Load Segment Instruction）:该组指令的功能是把内存单元的一个“低字”传送给指令中指定的16位寄存器，把随后的一个“高字”传送给相应的段寄存器（DS、ES、FS、GS和SS）。其指令格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; LDS/LES/LFS/LGS/LSS Reg, Mem</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>如果Reg是16位寄存器，那么Mem必须是32位指针；如果Reg是32位寄存器，那么Mem必须是48位指针，其低32位给指令中指定的寄存器，高16位给指令中的段寄存器。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kernel/sched.c</span><br><span class="line"><span class="keyword">long</span> user_stack[PAGE_SIZE &gt;&gt; <span class="number">2</span>];<span class="comment">// 定义系统堆栈指针，4K。指针指在最后一项。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 该结构用于设置堆栈ss:esp（数据段选择符，指针），见head.s，第23 行。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">long</span> *a;</span><br><span class="line">  <span class="keyword">short</span> b;</span><br><span class="line">&#125;</span><br><span class="line">stack_start = &#123;&amp;user_stack[PAGE_SIZE &gt;&gt; <span class="number">2</span>], <span class="number">0x10</span>&#125;;</span><br></pre></td></tr></table></figure><p>0x10将SS的值设置为与前面4个段选择符的值相同。这样，SS与前面讲解过的4个段选择符相同，段基址都指向0x000000，段限长都是8MB，特权级都是内核特权级，后面的压栈动作就要在这里进行。</p><p>head接下来对中断描述符表进行设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">;/*</span><br><span class="line">; * 下面这段是设置中断描述符表子程序setup_idt</span><br><span class="line">; *</span><br><span class="line">; * 将中断描述符表idt 设置成具有256 个项，并都指向ignore_int 中断门。然后加载</span><br><span class="line">; * 中断描述符表寄存器(用lidt 指令)。真正实用的中断门以后再安装。当我们在其它</span><br><span class="line">; * 地方认为一切都正常时再开启中断。该子程序将会被页表覆盖掉。</span><br><span class="line">; */</span><br><span class="line">setup_idt:</span><br><span class="line">lea edx,ignore_int;// 将ignore_int 的有效地址（偏移值）值 edx 寄存器</span><br><span class="line">mov eax,00080000h;// 将选择符0x0008 置入eax 的高16 位中。</span><br><span class="line">mov ax,dx;/* selector = 0x0008 = cs */</span><br><span class="line">;// 偏移值的低16 位置入eax 的低16 位中。此时eax 含</span><br><span class="line">;// 有门描述符低4 字节的值。</span><br><span class="line">mov dx,8E00h;/* interrupt gate - dpl=0, present */</span><br><span class="line">;// 此时edx 含有门描述符高4 字节的值。</span><br><span class="line">lea edi,_idt</span><br><span class="line">mov ecx,256</span><br><span class="line">rp_sidt:</span><br><span class="line">mov [edi],eax;// 将哑中断门描述符存入表中。</span><br><span class="line">mov [edi+4],edx</span><br><span class="line">add edi,8;// edi 指向表中下一项。</span><br><span class="line">dec ecx</span><br><span class="line">jne rp_sidt</span><br><span class="line">lidt fword ptr idt_descr;// 加载中断描述符表寄存器值。</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>现在，setup要废除已有的GDT，并在内核中的新位置重新创建全局描述符表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">;/*</span><br><span class="line">; * 下面这段是设置全局描述符表项setup_gdt</span><br><span class="line">; *</span><br><span class="line">; * 这个子程序设置一个新的全局描述符表gdt，并加载。此时仅创建了两个表项，与前</span><br><span class="line">; * 面的一样。该子程序只有两行，“非常的”复杂，所以当然需要这么长的注释了:)。</span><br><span class="line">; */</span><br><span class="line">setup_gdt:</span><br><span class="line">lgdt fword ptr gdt_descr;// 加载全局描述符表寄存器(内容已设置好，见232-238 行)。</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>入栈：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">;// 下面这几个入栈操作(pushl)用于为调用/init/main.c 程序和返回作准备。</span><br><span class="line">;// 前面3 个入栈指令不知道作什么用的，也许是Linus 用于在调试时能看清机器码用的.。</span><br><span class="line">;// 139 行的入栈操作是模拟调用main.c 程序时首先将返回地址入栈的操作，所以如果</span><br><span class="line">;// main.c 程序真的退出时，就会返回到这里的标号L6 处继续执行下去，也即死循环。</span><br><span class="line">;// 140 行将main.c 的地址压入堆栈，这样，在设置分页处理（setup_paging）结束后</span><br><span class="line">;// 执行&apos;ret&apos;返回指令时就会将main.c 程序的地址弹出堆栈，并去执行main.c 程序去了。</span><br><span class="line">after_page_tables:</span><br><span class="line">push 0;// These are the parameters to main :-)</span><br><span class="line">push 0;// 这些是调用main 程序的参数（指init/main.c）。</span><br><span class="line">push 0</span><br><span class="line">push L6;// return address for main, if it decides to.</span><br><span class="line">push _main_rename;// &apos;_main&apos;是编译程序对main 的内部表示方法。</span><br><span class="line">jmp setup_paging</span><br><span class="line">L6:</span><br><span class="line">jmp L6;// main should never return here, but</span><br><span class="line">;// just in case, we know what happens.</span><br></pre></td></tr></table></figure><p>之后，跳转至setup_paging去执行，开始创建分页机制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">;/*</span><br><span class="line">; * Setup_paging</span><br><span class="line">; *</span><br><span class="line">; * 这个子程序通过设置控制寄存器cr0 的标志（PG 位31）来启动对内存的分页处理</span><br><span class="line">; * 功能，并设置各个页表项的内容，以恒等映射前16 MB 的物理内存。分页器假定</span><br><span class="line">; * 不会产生非法的地址映射（也即在只有4Mb 的机器上设置出大于4Mb 的内存地址）。</span><br><span class="line">; *</span><br><span class="line">; * 注意！尽管所有的物理地址都应该由这个子程序进行恒等映射，但只有内核页面管</span><br><span class="line">; * 理函数能直接使用&gt;1Mb 的地址。所有“一般”函数仅使用低于1Mb 的地址空间，或</span><br><span class="line">; * 者是使用局部数据空间，地址空间将被映射到其它一些地方去-- mm(内存管理程序)</span><br><span class="line">; * 会管理这些事的。</span><br><span class="line">; *</span><br><span class="line">; * 对于那些有多于16Mb 内存的家伙- 太幸运了，我还没有，为什么你会有:-)。代码就</span><br><span class="line">; * 在这里，对它进行修改吧。（实际上，这并不太困难的。通常只需修改一些常数等。</span><br><span class="line">; * 我把它设置为16Mb，因为我的机器再怎么扩充甚至不能超过这个界限（当然，我的机 </span><br><span class="line">; * 器很便宜的:-)）。我已经通过设置某类标志来给出需要改动的地方（搜索“16Mb”），</span><br><span class="line">; * 但我不能保证作这些改动就行了 :-( )</span><br><span class="line">; */</span><br><span class="line">align 2;// 按4 字节方式对齐内存地址边界。</span><br><span class="line">setup_paging:;// 首先对5 页内存（1 页目录+ 4 页页表）清零</span><br><span class="line">mov ecx,1024*5;/* 5 pages - pg_dir+4 page tables */</span><br><span class="line">xor eax,eax</span><br><span class="line">xor edi,edi;/* pg_dir is at 0x000 */</span><br><span class="line">;// 页目录从0x000 地址开始。</span><br><span class="line">pushf;// VC内汇编使用cld和std后，需要自己恢复DF的值</span><br><span class="line">cld</span><br><span class="line">rep stosd</span><br><span class="line">;// 下面4 句设置页目录中的项，我们共有4 个页表所以只需设置4 项。</span><br><span class="line">;// 页目录项的结构与页表中项的结构一样，4 个字节为1 项。参见上面的说明。</span><br><span class="line">;// &quot;$pg0+7&quot;表示：0x00001007，是页目录表中的第1 项。</span><br><span class="line">;// 则第1 个页表所在的地址= 0x00001007 &amp; 0xfffff000 = 0x1000；第1 个页表</span><br><span class="line">;// 的属性标志= 0x00001007 &amp; 0x00000fff = 0x07，表示该页存在、用户可读写。</span><br><span class="line">mov eax,_pg_dir</span><br><span class="line">mov [eax],pg0+7;/* set present bit/user r/w */</span><br><span class="line">mov [eax+4],pg1+7;/*  --------- &quot; &quot; --------- */</span><br><span class="line">mov [eax+8],pg2+7;/*  --------- &quot; &quot; --------- */</span><br><span class="line">mov [eax+12],pg3+7;/*  --------- &quot; &quot; --------- */</span><br><span class="line">;// 下面6 行填写4 个页表中所有项的内容，共有：4(页表)*1024(项/页表)=4096 项(0 - 0xfff)，</span><br><span class="line">;// 也即能映射物理内存4096*4Kb = 16Mb。</span><br><span class="line">;// 每项的内容是：当前项所映射的物理内存地址+ 该页的标志（这里均为7）。</span><br><span class="line">;// 使用的方法是从最后一个页表的最后一项开始按倒退顺序填写。一个页表的最后一项</span><br><span class="line">;// 在页表中的位置是1023*4 = 4092。因此最后一页的最后一项的位置就是$pg3+4092。</span><br><span class="line">mov edi,pg3+4092;// edi -&gt; 最后一页的最后一项。</span><br><span class="line">mov eax,00fff007h;/*  16Mb - 4096 + 7 (r/w user,p) */</span><br><span class="line">;// 最后1 项对应物理内存页面的地址是0xfff000，</span><br><span class="line">;// 加上属性标志7，即为0xfff007.</span><br><span class="line">std;// 方向位置位，edi 值递减(4 字节)。</span><br><span class="line">L3:stosd;/* fill pages backwards - more efficient :-) */</span><br><span class="line">sub eax,00001000h;// 每填写好一项，物理地址值减0x1000。</span><br><span class="line">jge L3;// 如果小于0 则说明全添写好了。</span><br><span class="line">popf</span><br><span class="line">;// 设置页目录基址寄存器cr3 的值，指向页目录表。</span><br><span class="line">xor eax,eax;/* 页目录表(pg_dir)在0x0000 处。 */</span><br><span class="line">mov cr3,eax;/* cr3 - page directory start */</span><br><span class="line">;// 设置启动使用分页处理（cr0 的PG 标志，位31）</span><br><span class="line">mov eax,cr0</span><br><span class="line">or  eax,80000000h;// 添上PG 标志。</span><br><span class="line">mov cr0,eax;/* set paging (PG) bit */</span><br><span class="line">ret;/* this also flushes prefetch-queue */</span><br></pre></td></tr></table></figure><p>在执行完setup_paging的ret之后，将先前入栈的、在栈顶的_main函数的地址弹出给CS：EIP，即等价于CPU开始执行main函数程序。</p><p>## </p><p>## </p><h1><span id="文件操作">文件操作</span></h1><h2><span id="打开文件">打开文件</span></h2><h2><span id="读文件">读文件</span></h2><h2><span id="新建文件">新建文件</span></h2><h2><span id="写文件">写文件</span></h2><h2><span id="修改文件">修改文件</span></h2><h2><span id="关闭文件">关闭文件</span></h2><h2><span id="删除文件">删除文件</span></h2><h1><span id="用户进程与内存管理">用户进程与内存管理</span></h1><h2><span id="用户进程的创建">用户进程的创建</span></h2><h2><span id="为用户进程str1的加载做准备">为用户进程str1的加载做准备</span></h2><h2><span id="对缺页中断的处理">对缺页中断的处理</span></h2><h2><span id="str1用户进程的退出">str1用户进程的退出</span></h2><h2><span id="多个用户进程同时运行">多个用户进程同时运行</span></h2><h2><span id="进程的调度与切换">进程的调度与切换</span></h2><h2><span id="内核的分页">内核的分页</span></h2><h2><span id="页写保护">页写保护</span></h2><h1><span id="多个进程同时操作一个文件">多个进程同时操作一个文件</span></h1><h2><span id="三个进程操作同一个文件">三个进程操作同一个文件</span></h2><h2><span id="缓冲区与外设的数据同步">缓冲区与外设的数据同步</span></h2><h1><span id="ipc问题">IPC问题</span></h1><h2><span id="管道机制">管道机制</span></h2><h2><span id="信号机制">信号机制</span></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#从开机加电到执行main函数之前的过程&quot;&gt;从开机加电到执行main函数之前的过程&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#第一步启动bios准备实模式下的中断向量表和中断服务程序&quot;&gt;第一步，启动BIOS，准备&lt;e
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
</feed>
