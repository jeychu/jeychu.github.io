<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>javfa&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-20T13:03:04.336Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Javfa</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java概要</title>
    <link href="http://yoursite.com/2019/03/20/Java%E6%A6%82%E8%A6%81/"/>
    <id>http://yoursite.com/2019/03/20/Java概要/</id>
    <published>2019-03-20T04:17:46.000Z</published>
    <updated>2019-03-20T13:03:04.336Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="类与对象">类与对象</span></h1><h2><span id="java变量的作用域">Java变量的作用域</span></h2><ul><li><p>类级变量</p><p>全局级变量或者静态变量，加static修饰符</p><p>类级变量在类定义后就会一直存在，占用内存空间，可以通过类名来访问，不需要实例化</p></li><li><p>对象实例级变量</p><p>成员变量，实例化后才会分配内存空间，才能访问</p></li><li><p>方法级变量</p><p>方法内部定义的变量，就是局部变量</p></li><li><p>块级变量</p><p>是定义在一个块内的变量，出了这个块变量就消失了。块是指由大括号包围的代码。</p></li></ul><h2><span id="this">this</span></h2><p>用来表示当前对象本身。通过this可以调用本对象的所有方法和属性。</p><p>this只有在实例化后才有意义。</p><p>可以用来区分同名变量、作为构造方法、作为参数传递</p><h2><span id="重载">重载</span></h2><p>重载就是在一个类中，有相同的函数名称，但形参不同的函数。</p><p>说明：</p><ul><li>参数列表不同包括：个数不同、类型不同和顺序不同。</li><li>仅仅参数变量名称不同是不可以的。</li><li>跟成员方法一样，构造方法也可以重载。</li><li>声明为final的方法不能被重载。</li><li>声明为static的方法不能被重载，但是能够被再次声明。</li></ul><h2><span id="包装类-拆箱和装箱">包装类、拆箱和装箱</span></h2><p>Java为每种基本数据类型分别设计了对应的类，称之为包装类（Wrapper Classes）。</p><table><thead><tr><th>基本数据类型</th><th>对应的包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><p>基本类型和对应的包装类可以相互装换： </p><ul><li>由基本类型向对应的包装类转换称为装箱，例如把 int 包装成 Integer 类的对象；</li><li>包装类向对应的基本类型转换称为拆箱，例如把 Integer 类的对象重新简化为 int。</li></ul><h2><span id="java包">Java包</span></h2><h2><span id="源文件的声明规则">源文件的声明规则</span></h2><h1><span id="继承与多态">继承与多态</span></h1><h2><span id="继承">继承</span></h2><p>一个类从另一个类获取方法和属性的过程。</p><p>如果B继承于类A，那么B就拥有A的方法和属性。</p><p>继承使用extends关键字。</p><p>单继承性：Java中，一个类只能有一个父类。</p><p>接口允许多继承。</p><h2><span id="super">super</span></h2><p>和this类似，this表示当前类的实例，super表示父类。</p><p>该关键字的功能：</p><ul><li>调用父类中声明为private的变量</li><li>点取已经覆盖了的方法</li><li>作为方法名表示父类构造方法</li></ul><h2><span id="方法的覆盖和重载">方法的覆盖和重载</span></h2><p>被覆盖的方法在子类中只能通过super调用</p><p>覆盖不会删除父类中的方法，而是对子类的实例隐藏</p><p>方法覆盖的原则：</p><ul><li>覆盖方法的返回类型、方法名称、参数列表必须与原方法的相同。</li><li>覆盖方法不能比原方法访问性差（即访问权限不允许缩小）。</li><li>覆盖方法不能比原方法抛出更多的异常。</li><li>被覆盖的方法不能是final类型，因为final修饰的方法是无法覆盖的。</li><li>被覆盖的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。</li><li>被覆盖的方法不能为static。如果父类中的方法为静态的，而子类中的方法不是静态的，但是两个方法除了这一点外其他都满足覆盖条件，那么会发生编译错误；反之亦然。即使父类和子类中的方法都是静态的，并且满足覆盖条件，但是仍然不会发生覆盖，因为静态方法是在编译的时候把静态方法和类的引用类型进行匹配。</li></ul><p>覆盖和重载的不同：</p><ul><li>方法覆盖要求参数列表必须一致，而方法重载要求参数列表必须不一致。</li><li>方法覆盖要求返回类型必须一致，方法重载对此没有要求。</li><li>方法覆盖只能用于子类覆盖父类的方法，方法重载用于同一个类中的所有方法（包括从父类中继承而来的方法）。</li><li>方法覆盖对方法的访问权限和抛出的异常有特殊的要求，而方法重载在这方面没有任何限制。</li><li>父类的一个方法只能被子类覆盖一次，而一个方法可以在所有的类中可以被重载多次。</li></ul><h2><span id="多态与动态绑定">多态与动态绑定</span></h2><p>父类变量可以引用父类的实例，也可以引用子类的实例。</p><p>多态存在的三个必要条件：</p><ul><li>要有继承</li><li>要有重写覆盖</li><li>父类变量引用子类对象</li></ul><p>当使用多态方式调用方法时：</p><ul><li>首先检查父类中是否有该方法，如果没有，则编译错误；若有，则检查子类是否覆盖了该方法；</li><li>如果子类覆盖了该方法，就调用子类的方法，否则调用父类方法</li></ul><h2><span id="instanceof">instanceof</span></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;类与对象&quot;&gt;类与对象&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span id=&quot;java变量的作用域&quot;&gt;Java变量的作用域&lt;/span&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;类级变量&lt;/p&gt;
&lt;p&gt;全局级变量或者静态变量，加static修饰符&lt;/p&gt;
&lt;p&gt;类级
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Nginx下Lua实现机制</title>
    <link href="http://yoursite.com/2019/03/18/Nginx%E4%B8%8BLua%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/03/18/Nginx下Lua实现机制/</id>
    <published>2019-03-18T13:52:32.000Z</published>
    <updated>2019-03-20T07:56:15.370Z</updated>
    
    <content type="html"><![CDATA[<p>Nginx中的大部分功能是通过模块提供的。一个模块的失效不会影响其他部分，是Nginx扩展性和可靠性的一个保证。</p><p>Nginx使用比较多的场合时反向代理，使用Nginx在前端做登陆校验、JS合并、数据库访问、访问鉴权等。</p><p>Lua是高效、紧凑、嵌入式的快速脚本语言，内建协程，非常便于业务开发。</p><p>ngx_lua模块，将Lua解释器集成进Nginx中，使开发者可以使用Lua脚本语言实现业务。</p><h1><span id="ngx_lua原理">ngx_lua原理</span></h1><p>ngx_lua将Lua集成进Nginx。Lua内建<a href="https://jeychu.github.io/2016/03/20/关于协程/" target="_blank" rel="noopener">协程</a>，使用协程可以很好地将异步回调转换成顺序调用的形式，和Nginx的全异步模式匹配起来：协程调用异步API，然后协程挂起，在异步回调事件到来时，在将协程唤醒，继续执行。</p><p>这样既可以实现全异步的Nginx机制，不会影响Nginx的高并发处理性能，又使开发者以同步的方式编写异步程序。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Nginx中的大部分功能是通过模块提供的。一个模块的失效不会影响其他部分，是Nginx扩展性和可靠性的一个保证。&lt;/p&gt;
&lt;p&gt;Nginx使用比较多的场合时反向代理，使用Nginx在前端做登陆校验、JS合并、数据库访问、访问鉴权等。&lt;/p&gt;
&lt;p&gt;Lua是高效、紧凑、嵌入式
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MySQL优化</title>
    <link href="http://yoursite.com/2019/03/18/MySQL%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/03/18/MySQL优化/</id>
    <published>2019-03-18T12:08:03.000Z</published>
    <updated>2019-03-20T07:37:38.451Z</updated>
    
    <content type="html"><![CDATA[<p>应用程序优化</p><p>硬件优化</p><p>操作系统优化</p><p>数据库参数优化</p><p><img src="/2019/03/18/MySQL优化/1553066900441.png" alt="1553066900441"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;应用程序优化&lt;/p&gt;
&lt;p&gt;硬件优化&lt;/p&gt;
&lt;p&gt;操作系统优化&lt;/p&gt;
&lt;p&gt;数据库参数优化&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/03/18/MySQL优化/1553066900441.png&quot; alt=&quot;1553066900441&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>翻译《 Congestion-Avoidance-and-Control 》</title>
    <link href="http://yoursite.com/2019/03/17/Reading-Congestion-Avoidance-and-Control/"/>
    <id>http://yoursite.com/2019/03/17/Reading-Congestion-Avoidance-and-Control/</id>
    <published>2019-03-17T08:37:27.000Z</published>
    <updated>2019-03-18T11:56:13.258Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址：<a href="https://ee.lbl.gov/papers/congavoid.pdf" target="_blank" rel="noopener">Congestion Avoidance and Control</a></p><h1><span id="拥塞避免和拥塞控制">拥塞避免和拥塞控制</span></h1><p>Van Jacobson</p><p>Michael J.Kearels</p><p>1988年11月</p><h2><span id="引子">引子</span></h2><p>在过去的几年中，计算机网络经历了爆炸性的增长，这种增长带来了严重的拥堵问题。例如，现在常见的情况是，由于本地缓冲区溢出，Internet网关会丢弃10%的传入数据包。我们对其中一些问题的调查表明，造成这些问题的原因很大程度上在于传输协议的实现方式(而不是在于协议本身)：在网络拥塞问题上，以“直白”方式实现基于窗口的传输协议可能会导致完全错误的行为。我们给出了“错误”行为的例子，并描述了一些可以用来使正确的事情发生的简单算法。这些算法是根植于这样的一个想法——即通过强制传输连接遵循“包守恒”原则来实现网络的稳定。我们展示了这些算法是如何从这一原理中派生出来的，以及它们对拥挤网络上的流量有什么影响。</p><p>86年10月，互联网第一次出现了一系列的“拥堵现象”。在此期间，从LBL到加州大学伯克利分校的数据吞吐量(两个站点相距400码、两个IMP跳数)，从32Kbps下降到40bps。我们被这一突然的千倍带宽下降吸引住了，并开始调查为什么事情会变得如此糟糕。特别是，我们想知道是不是4.3BSD(Berkeley UNIX)TCP出现了问题，又是不是可以使它在糟糕的网络条件下更好地工作。这两个问题的答案都是肯定的。</p><p>从那时开始，我们将以下7种新算法纳入4BSD TCP之中：</p><ol><li>round-trip-time variance estimation</li><li>exponential retransmit timer backoff</li><li>slow-start</li><li>more aggressive reveive ack policy</li><li>dynamic window sizing on congestion</li><li>Karn’s clamped retransmit backoff</li><li>fast retransmit</li></ol><p>我们的测量结果和beta测试人员的报告表明，最终产品能很好的解决互联网拥塞的问题。<br>本文简要介绍了1-5项及其背后的理论基础。6是最近由贝尔通信研究的菲尔·卡恩(PhilKarn)在[16]中描述的算法。7在即将出版的“征求意见”(ARPANET“征求意见”)中作了说明。<br>算法1-5来源于这样一个观察：TCP连接上的流(或ISO TP-4或Xerox NS SPP连接)应遵循“包守恒”原则。而且，如果遵守这一原则，拥堵崩溃将成为一个例外。因此，拥塞控制就是查找违反守恒的地方并修复它们。<br>我们所说的“包守恒”是指对于“处于平衡状态”的连接，即这个连接以全窗口数据传输状态稳定运行，它的包流处于“守恒”状态：在旧数据包离开之前，不会将新数据包放入网络。流物理学预测，具有这种性质的系统在面对拥塞情况时应该是健壮的。但对互联网的观察表明，这样的系统也不是特别健壮。为什么会有差异呢？<br>引起包守恒失败的方式只有三种：</p><ul><li>连接没有达到平衡状态，或者</li><li>老包未出之前，新包注入，或者</li><li>由于线路资源限制导致无法达到平衡状态</li></ul><p>在如下章节，我们将对此依次说明。</p><h2><span id="达到平衡状态通过慢启动">达到平衡状态：通过慢启动</span></h2><p><img src="/2019/03/17/Reading-Congestion-Avoidance-and-Control/1552819582010.png" alt="1552819582010"></p><p>失败1发生在一个正在启动的连接，或是一个丢包后正在重新启动的连接。另一种看待守恒属性的方式是，发送方使用ack作为计时，将新的数据包传送到网络。由于接收器生成ack的速度不能比数据包通过网络的速度快，因此该协议是“自计时”(图1)。自计时系统自动调整带宽和延迟变化，并具有较宽的动态范围(考虑到TCP跨越800 Mbps Cray通道到1200 bps数据包无线电链路，这一点很重要)。但同样的东西，使一个自计时系统在运行时保持稳定，却使得启动变得困难-要有数据流，必须有ACK用来计时清出数据包，但是为了获取ACK，必须有数据流。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文地址：&lt;a href=&quot;https://ee.lbl.gov/papers/congavoid.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Congestion Avoidance and Control&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;&lt;span 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>为什么一定要用MQ中间件</title>
    <link href="http://yoursite.com/2019/03/15/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%80%E5%AE%9A%E8%A6%81%E7%94%A8MQ%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>http://yoursite.com/2019/03/15/为什么一定要用MQ中间件/</id>
    <published>2019-03-15T13:14:03.000Z</published>
    <updated>2019-03-18T11:52:24.977Z</updated>
    
    <content type="html"><![CDATA[<p>系统解耦</p><p>异步调用</p><p>流量削峰</p><p>待更。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;系统解耦&lt;/p&gt;
&lt;p&gt;异步调用&lt;/p&gt;
&lt;p&gt;流量削峰&lt;/p&gt;
&lt;p&gt;待更。。。&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux性能优化之网络篇</title>
    <link href="http://yoursite.com/2019/03/15/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E7%BD%91%E7%BB%9C%E7%AF%87/"/>
    <id>http://yoursite.com/2019/03/15/Linux性能优化之网络篇/</id>
    <published>2019-03-15T04:54:05.000Z</published>
    <updated>2019-03-15T11:55:17.513Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="网络模型">网络模型</span></h1><p>OSI网络模型，开放式系统互联通信参考模型<sup>Open System Interconnection Reference Model</sup>。</p><p>为了解决网络互联中异构设备的兼容性问题，并解耦复杂的网络包处理流程，OSI模型把网络互联的框架分为应用层、表示层、会话层、传输层、网络层、数据链路层和物理层等七层，每层负责不同的功能：</p><ul><li>应用层，负责为应用程序提供统一的接口；</li><li>表示层，负责把数据转换成兼容格式；</li><li>会话层，负责维护计算机之间的通信连接；</li><li>传输层，负责为数据加上传输包头，形成数据包；</li><li>网络层，负责数据的路由和转发；</li><li>数据链路层，负责MAC寻址、错误侦测和改错；</li><li>物理层，负责在物理网络中传输数据帧。</li></ul><p>Linux中，使用的是四层模型，即TCP/IP网络模型：</p><ul><li>应用层，负责向用户提供一组应用程序，如HTTP、FTP、DNS等</li><li>传输层，负责端到端的通信，如TCP、UDP等</li><li>网络层，负责网络包的封装、寻址和路由，如IP、ICMP等</li><li>网络接口层，负责网络包在物理网络中的传输，如MAC寻址、错误侦测以及通过网卡传输网络帧等</li></ul><h1><span id="linux网络栈">Linux网络栈</span></h1><p>有了TCP/IP模型后，在进行网络传输时，数据包就会按照协议栈，对上一层发来的数据进行逐层处理；然后封装上该层的协议头，再发送到下一层。</p><h1><span id="linux网络收发流程">Linux网络收发流程</span></h1><h1><span id="性能指标">性能指标</span></h1><ul><li>带宽，表示链路的最大传输速率，单位通常为b/s。</li><li>吞吐量，表示单位事件内成功传输的数据量，单位通常为b/s或则B/s。吞吐量受带宽限制，而吞吐量/带宽，就是该网络的使用率。</li><li>时延，表示从网络请求发出后，一直到收到远端响应，所需要的时间延迟。</li><li>PPS<sup>Packet Per Second</sup>，表示以网络包为单位的传输速率。通常用来评估网络的转发能力，比如硬件交换机，通常可以达到线性转发（即PPS可以达到或者接近理论最大值）。而基于Linux服务器的转发，则容易受网络包大小的影响。</li><li>此外，还有网络可用性、并发连接数<sup>TCP连接数量</sup>、丢包率、重传率等</li></ul><h1><span id="网络配置">网络配置</span></h1><p>ip a </p><p>ifconfig</p><h1><span id="套接字信息">套接字信息</span></h1><h1><span id="协议栈统计信息">协议栈统计信息</span></h1><h1><span id="网络吞吐和pps">网络吞吐和PPS</span></h1><h1><span id="连通性和时延">连通性和时延</span></h1><h1><span id="c10k">C10K</span></h1><p>C10K问题最早由Dan Kegel于1999年提出。那时的服务器是32位，配置很少的内存（2G）和千兆网卡</p><p>怎么在这样的系统支持并发1万的请求？</p><p>从资源上来说，对2GB内存和千兆网卡的服务器来说，同时处理10000个请求，只要每个请求处理占用不到200KB的内存和100Kbit的网络带宽即可。所以物理资源足够，接下来是软件的问题，特别是网络IO模型问题。</p><h2><span id="io模型优化">IO模型优化</span></h2><p>两种IO事件通知的方式：</p><ul><li>水平触发：只要文件描述符可以非阻塞地执行IO，就会触发通知。应用程序可以随时检查文件描述符的状态，然后再根据状态，进行IO操作。</li><li>边缘触发：只有在文件描述符的状态发生改变时（也就是IO请求到达时），才发送一次通知。这时候，应用程序要尽可能多地执行IO，直到无法继续读写，才可以停止。</li></ul><h1><span id="c1000k">C1000K</span></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;网络模型&quot;&gt;网络模型&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;OSI网络模型，开放式系统互联通信参考模型&lt;sup&gt;Open System Interconnection Reference Model&lt;/sup&gt;。&lt;/p&gt;
&lt;p&gt;为了解决网络互联中异构设备的兼容性
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>大型网站技术架构</title>
    <link href="http://yoursite.com/2019/03/14/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"/>
    <id>http://yoursite.com/2019/03/14/大型网站技术架构/</id>
    <published>2019-03-14T15:04:49.000Z</published>
    <updated>2019-03-18T11:53:31.294Z</updated>
    
    <content type="html"><![CDATA[<p>此篇为读书笔记。</p><p>待更。。。</p><h1><span id="概述">概述</span></h1><h2><span id="大型网站架构演化">大型网站架构演化</span></h2><h2><span id="大型网站架构模式">大型网站架构模式</span></h2><h2><span id="大型网站核心架构要素">大型网站核心架构要素</span></h2><h1><span id="架构">架构</span></h1><h2><span id="高性能架构">高性能架构</span></h2><h2><span id="高可用架构">高可用架构</span></h2><h2><span id="伸缩性架构">伸缩性架构</span></h2><h2><span id="可扩展架构">可扩展架构</span></h2><h2><span id="安全架构">安全架构</span></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;此篇为读书笔记。&lt;/p&gt;
&lt;p&gt;待更。。。&lt;/p&gt;
&lt;h1&gt;&lt;span id=&quot;概述&quot;&gt;概述&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span id=&quot;大型网站架构演化&quot;&gt;大型网站架构演化&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span id=&quot;大型网站架构模式&quot;&gt;大型网站架构模式&lt;/s
      
    
    </summary>
    
    
      <category term="web" scheme="http://yoursite.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>TCP状态详解</title>
    <link href="http://yoursite.com/2019/03/12/TCP%E7%8A%B6%E6%80%81%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/03/12/TCP状态详解/</id>
    <published>2019-03-12T13:42:31.000Z</published>
    <updated>2019-03-18T11:51:30.172Z</updated>
    
    <content type="html"><![CDATA[<p>LISTENING：侦听来自远方的TCP端口的连接请求。</p><p>服务器端打开一个socket进行监听，状态为LISTEN。</p><p>待更</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;LISTENING：侦听来自远方的TCP端口的连接请求。&lt;/p&gt;
&lt;p&gt;服务器端打开一个socket进行监听，状态为LISTEN。&lt;/p&gt;
&lt;p&gt;待更&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CDN</title>
    <link href="http://yoursite.com/2019/03/12/CDN/"/>
    <id>http://yoursite.com/2019/03/12/CDN/</id>
    <published>2019-03-12T13:31:55.000Z</published>
    <updated>2019-03-18T11:51:49.775Z</updated>
    
    <content type="html"><![CDATA[<p>CDN ：缓存服务器+智能DNS</p><p>分布式存储 负载均衡 请求重定向 内容管理</p><p>待更。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CDN ：缓存服务器+智能DNS&lt;/p&gt;
&lt;p&gt;分布式存储 负载均衡 请求重定向 内容管理&lt;/p&gt;
&lt;p&gt;待更。。。&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux性能优化之磁盘篇</title>
    <link href="http://yoursite.com/2019/03/12/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E7%A3%81%E7%9B%98%E7%AF%87/"/>
    <id>http://yoursite.com/2019/03/12/Linux性能优化之磁盘篇/</id>
    <published>2019-03-12T08:19:51.000Z</published>
    <updated>2019-03-20T11:12:07.845Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="linux文件系统是怎么工作的">Linux文件系统是怎么工作的？</span></h1><p>和CPU、内存一样，磁盘和文件系统的管理，也是操作系统最核心的功能。</p><ul><li>磁盘为系统提供了最基本的持久化存储；</li><li>文件系统则在磁盘的基础上，提供了一个用来管理文件的树状结构。</li></ul><h2><span id="索引节点和目录项">索引节点和目录项</span></h2><p>文件系统，本身是对存储设备上的文件进行组织管理的机制。组织方式的不同，就会形成不同的文件系统。</p><blockquote><p>在Linux中，一切皆文件：普通文件和目录、块设备、套接字、管道等都要通过统一的文件系统来管理。</p></blockquote><p>为了方便管理，Linux文件系统为每个文件都分配两个数据结构：</p><ul><li>索引节点<sup>index node</sup>：简称为inode，用来记录文件的元数据，比如inode编号、文件大小、访问权限、修改日期、数据的位置等。索引节点和文件一一对应，它跟文件内容一样，都会被持久化存储到磁盘中。所以，索引节点同样占用磁盘空间。</li><li>目录项<sup>dentry</sup>：用来记录文件的名字、索引节点指针以及与其他目录项的关联关系。多个关联的目录项，就构成了文件系统的目录结构。不过，不同于索引节点，目录项是由内核维护的一个<strong>内存数据结构</strong>，所以通常也被叫做目录项缓存。</li></ul><p>索引节点是每个文件的唯一标志，而目录项维护的是文件系统的树状结构。</p><p>目录项和索引节点的关系是多对一，即一个文件可以有多个别名。如硬链接。通过硬链接为文件创建别名，就会对应不同的目录项。这些目录项本质上链接到同一个文件，所以，它们的索引节点相同。</p><p>索引节点和目录项记录了文件的元数据和文件之间的目录关系，那文件数据到底又是怎么存储的呢？</p><p>磁盘读写的最小单位是扇区，而一个扇区只有512B的大小，如果每次都读写这么小的单位，效率是很低的。所以，文件系统把连续的扇区组成逻辑块，然后每次都以逻辑块为最小单位，来管理数据。</p><p>常见的逻辑块大小为4KB，也就是由连续的8个扇区组成。</p><p>目录项、索引节点以及文件数据的关系如下图所示：</p><p><img src="/2019/03/12/Linux性能优化之磁盘篇/1552381349393.png" alt="1552381349393"></p><p>需要注意的是：</p><ul><li>目录项本身就是一个内存缓存，而索引节点则是存储在磁盘中的数据。为了协调磁盘和CPU的性能差异，文件内容会被缓存到Cache中，这些索引节点自然也会缓存到内存中，加速文件的访问。</li><li>磁盘在执行文件系统格式化时，会被分成三个存储区域，超级块、索引节点区和数据块区。其中：<ul><li>超级块，存储整个文件系统的状态；</li><li>索引节点区，用来存储索引节点；</li><li>数据块区，则用来存储文件数据。</li></ul></li></ul><h2><span id="虚拟文件系统">虚拟文件系统</span></h2><p>目录项、索引节点、逻辑块以及超级块，构成了Linux文件系统的四大基本要素。</p><p>为了支持各种不同的文件系统，Linux内核在用户进程和文件系统之间，又引入了一个抽象层，也就是虚拟文件系统VFS<sup>Virtual File System</sup>。</p><p>Linux文件系统架构图：</p><p><img src="/2019/03/12/Linux性能优化之磁盘篇/1552382275869.png" alt="1552382275869"></p><p>在VFS之下，Linux支持各种各样的文件系统，如Ext4、XFS、NFS、ZFS。。。</p><p>按照存储位置的不同，这些文件系统可以分为三类：</p><ul><li>基于磁盘的文件系统，也就是把数据直接存储在计算机本地挂载的磁盘中。如：Ext4、XFS、OverlayFS等；</li><li>基于内存的文件系统，也就是虚拟文件系统。这类文件系统，不需要任何磁盘分配存储空间，但会占用内存。如/proc、/sys<sup>主要用于向用户空间导出层次化的内核对象</sup>；</li><li>网络文件系统，也就是用来访问其他计算机数据的文件系统，比如NFS、SMB、iSCSI等。</li></ul><p>这些文件系统，要先挂载到VFS目录树中的某个子目录<sup>称为挂载点</sup>，然后才能访问其中的文件。</p><h2><span id="文件系统io">文件系统IO</span></h2><p>文件读写方式的各种差异，导致IO的分类多种多样。常见的有：</p><ul><li><p>缓冲与非缓冲IO<sup>是否利用标准库缓存</sup>：</p><ul><li>缓冲IO，指利用标准库缓存来加速文件的访问，标准库内部再通过系统调度访问文件；</li><li>非缓冲IO，指直接通过系统调用来访问文件，不再经过标准库缓存。</li></ul><p>无论缓存IO还是非缓冲IO，最终还是要经过系统调用来访问文件。系统调用后，还会通过页缓存，来减少磁盘的IO操作。</p></li><li><p>直接与非直接IO<sup>是否利用操作系统的页缓存</sup>：</p><ul><li>直接IO，指跳过操作系统的页缓存，直接跟文件系统交互来访问文件；</li><li>非直接IO，文件读写时，先要经过系统的页缓存，然后再由内核或额外的系统调用，真正写入磁盘。</li></ul><p>在系统调用中，指定O_DIRECT标志，可以实现直接IO。如果没有设置过，默认是非直接IO。</p><p>直接IO和非直接IO，本质上还是和文件系统交互。如果是在数据库等场景中，还会有跳过文件系统读写磁盘的情况，也就是裸IO。</p></li><li><p>阻塞与非阻塞IO<sup>根据应用程序是否阻塞自身运行</sup>：</p><ul><li>阻塞IO，指应用程序之下IO操作后，如果没有获得响应，就会阻塞当前线程，自然就不能执行其他任务；</li><li>非阻塞IO，是指应用程序执行IO操作后，不会阻塞当前的线程，可以继续执行其他的任务，随后再通过轮询或者事件通知的形式，获取调用的结果。</li></ul><p>如：在访问管道或网络套接字时，设置O_NONBLOCK标志，就表示用非阻塞方式访问；如果不做任何设置，默认的是阻塞访问。</p></li><li><p>同步和异步IO<sup>根据是否等待响应结果</sup>：</p><ul><li>同步IO，指应用程序执行IO操作后，要一直等到整个IO完成后，才能获得IO响应；</li><li>异步IO，指应用程序执行IO操作后，不用等待完成和完成后的响应，而是继续执行就可以。等到这次IO完成后，响应会用事件通知的方式，告诉应用程序。</li></ul><p>如：在操作文件时，如果设置了O_SYNC或O_DSYNC标志，就代表同步IO。</p><p>在访问管道或网络套接字时，设置了O_ASYNC，就代表异步IO。</p></li></ul><h2><span id="如何查看文件系统的性能情况呢">如何查看文件系统的性能情况呢？</span></h2><h3><span id="容量">容量</span></h3><p>df</p><p><img src="/2019/03/12/Linux性能优化之磁盘篇/1552385605875.png" alt="1552385605875"></p><p>索引节点的容量<sup>inode的个数</sup>，是在格式化磁盘时设定好的，一般由格式化工具自动生成。当你发现索引节点空间不足，但磁盘空间充足时，很可能就是过多小文件导致的。</p><h3><span id="缓存">缓存</span></h3><p>/proc/meminfo</p><p><img src="/2019/03/12/Linux性能优化之磁盘篇/1552386039282.png" alt="1552386039282"></p><p>/proc/slabinfo</p><p><img src="/2019/03/12/Linux性能优化之磁盘篇/1552385847934.png" alt="1552385847934"></p><p>slabtop</p><p><img src="/2019/03/12/Linux性能优化之磁盘篇/1552385975568.png" alt="1552385975568"></p><h1><span id="linux磁盘io是怎么工作的">Linux磁盘IO是怎么工作的？</span></h1><h2><span id="磁盘">磁盘</span></h2><p>磁盘是可以持久化存储的设备，根据存储介质的不同，常见磁盘可以分为：</p><ul><li><p>机械磁盘，也称为硬盘驱动器<sup>Hard Disk Driver</sup>，通常缩写为HDD。机械磁盘主要由盘片和读写磁头组成，数据就存储在盘片的环状磁道中。在读写数据前，需要移动读写磁头，定位到数据所在的磁道，然后才能访问数据。</p><p>如果是连续IO，不需要磁道寻址，可以获得较好性能。对于随机IO，需要不停地移动磁头来定位数据位置，读写性能会比较差。</p><p>最小读写单位是扇区，一般为512字节。</p></li><li><p>固态磁盘<sup>Solid State Disk</sup>，通常缩写为SSD。由固态电子元器件组成。固态磁盘不需要磁道寻址，所以，不管是连续IO，还是随机IO的性能，都比机械磁盘要好很多。</p><p>最小读写单位是页，一般为4KB、8KB等。</p></li></ul><p>无论机械磁盘还是固态磁盘，相同磁盘的随机IO都要比连续IO慢得多，是因为：</p><ul><li>对机械磁盘来说，由于随机IO需要更多的磁头寻道和盘片旋转，它的性能自然要比连续IO慢；</li><li>对固态磁盘来说，虽然它的随机性能比机械硬盘好很多，但同样存在”先擦除再写入”的限制。随机读写会导致大量的垃圾回收，所以它的随机IO的性能比连续IO，还是差了很多。</li><li>连续IO还可以通过预读的方式，来减少IO请求的次数，这也是其性能优异的一个原因。</li></ul><p>按照接口来分类，可以分为：IDE<sup>Integrated Drive Electronics</sup>、SCSI<sup>Small Computer System Interface</sup>、SAS<sup>Serial Attached SCSI</sup>、SATA<sup>Serial ATA</sup>、FC<sup>Fibre Channel</sup>等。</p><p>不同的接口，往往分配不同的设备名称。比如，IDE设备以hd为前缀，SCSI和SATA以sd为前缀。多块同类型的磁盘，按照a、b、c等的字母顺序来编号。</p><p>在Linux中，磁盘是作为一个块设备来管理的，以块为单位读写数据，支持随机读写。</p><p>每个块设备都会被赋予两个设备号，分别是主、次设备号。主设备号用在驱动程序中，用来区分设备类型；次设备号则是用来给多个同类设备编号。</p><h2><span id="通用块层">通用块层</span></h2><p>与VFS类似，为了减少不同块设备的差异带来的影响，Linux通过一个统一的通用块层，来管理各种不同的块设备。</p><p>通用块层，是处在文件系统和磁盘驱动中间的一个块设备抽象层。它主要有两个功能：</p><ul><li>与VFS类似：向上，为文件系统和应用程序，提供访问块设备的标准接口；向下，把各种异构的磁盘设备抽象为统一的块设备，并提供统一框架来管理这些设备的驱动程序；</li><li>给文件系统和应用程序发来的IO请求排队，并通过重新排序、请求合并等方式，提高磁盘读写的效率。</li></ul><p>对IO请求排序的过程，就是IO调度。Linux内核支持四种IO调度算法：</p><ul><li>NONE：不做处理，常用于虚拟机中</li><li>NOOP：最简单的IO调度算法。是一个先入先出的队列，只做一些最基本的请求合并，常用于SSD</li><li>CFQ：是现在很多发行版的默认IO调度器，它为每一个进程维护了一个IO调度队列，并按照时间片来均匀分布每个进程的IO请求。</li><li>DeadLine：分别为读、写创建了不同的IO队列，可以提高机械磁盘的吞吐量，并确保达到最终期限（deadline）的请求被优先处理。多用于IO压力比较重的场景，比如事件库等。</li></ul><h2><span id="io栈">IO栈</span></h2><p>Linux存储系统的IO栈，由上到下分为三个层次，分别是文件系统层、通用块层和设备层。这三个IO层的关系如下图所示：</p><p><img src="/2019/03/12/Linux性能优化之磁盘篇/1552547651555.png" alt="1552547651555"></p><p>通过这张IO全景图，我们可以清楚的理解存储系统IO的工作原理：</p><ul><li>文件系统层，包括虚拟文件系统和其他各种文件系统的具体实现。为上层的应用程序提供标准的文件访问接口；对下通过通用块层，来存储和管理磁盘数据；</li><li>通用块层，包括块设备IO队列和IO调度。对文件系统的IO请求进行排队，通过重新排序和请求合并，然后发送给下一级的设备层；</li><li>设备层，包括存储设备和相应的驱动程序，负责最终物理设备的IO操作。</li></ul><h2><span id="磁盘性能指标">磁盘性能指标</span></h2><ul><li>使用率</li><li>饱和度</li><li>IOPS</li><li>吞吐量</li><li>响应时间</li></ul><h2><span id="磁盘io观测">磁盘IO观测</span></h2><p>每块磁盘的使用情况</p><p>iostat</p><p><img src="/2019/03/12/Linux性能优化之磁盘篇/1552623565915.png" alt="1552623565915"></p><p>进程IO观测</p><p>pidstat -d 1</p><h1><span id="调优策略及实践">调优策略及实践</span></h1><p>文件系统性能研究方法：</p><table><thead><tr><th>方法</th><th style="text-align:center">类型</th></tr></thead><tbody><tr><td>磁盘分析</td><td style="text-align:center">观察分析</td></tr><tr><td>延时分析</td><td style="text-align:center">观察分析</td></tr><tr><td>负载特征归纳</td><td style="text-align:center">观察分析、容量规划</td></tr><tr><td>性能监控</td><td style="text-align:center">观察分析、容量规划</td></tr><tr><td>事件跟踪</td><td style="text-align:center">观察分析</td></tr><tr><td>静态性能调优</td><td style="text-align:center">观察分析、容量规划</td></tr><tr><td>缓存调优</td><td style="text-align:center">观察分析、调优</td></tr><tr><td>负载分离</td><td style="text-align:center">调优</td></tr><tr><td>内存文件系统</td><td style="text-align:center">调优</td></tr><tr><td>微型基准测试</td><td style="text-align:center">实验分析</td></tr></tbody></table><p>这些方法可以单独使用，也可以组合使用。</p><p>推荐按顺序使用以下策略：延时分析、性能监控、负载特征归纳、微型基准测试、静态性能调优和事件跟踪。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;linux文件系统是怎么工作的&quot;&gt;Linux文件系统是怎么工作的？&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;和CPU、内存一样，磁盘和文件系统的管理，也是操作系统最核心的功能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;磁盘为系统提供了最基本的持久化存储；&lt;/li&gt;
&lt;li&gt;文件
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>在CentOS7上安装eBPF-tools,bcc和ply</title>
    <link href="http://yoursite.com/2019/03/12/%E5%9C%A8CentOS7%E4%B8%8A%E5%AE%89%E8%A3%85eBPF-tools-bcc%E5%92%8Cply/"/>
    <id>http://yoursite.com/2019/03/12/在CentOS7上安装eBPF-tools-bcc和ply/</id>
    <published>2019-03-12T03:27:49.000Z</published>
    <updated>2019-03-12T04:20:02.760Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>升级内核：</p><p>CentOS7的内核版本是3.x，要安装使用eBPF，bcc和ply，内核版本至少是4.9，所以需要先升级CentOS7的内核。详见<a href="https://jeychu.github.io/2019/03/11/CentOS7%E5%8D%87%E7%BA%A7%E5%86%85%E6%A0%B8/" target="_blank" rel="noopener">CentOS7升级内核</a>。</p></li><li><p>升级、安装开发工具：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y epel-release</span><br><span class="line">sudo yum update -y</span><br><span class="line">sudo yum groupinstall -y &quot;Development tools&quot;</span><br><span class="line">sudo yum install -y elfutils-libelf-devel iperf cmake3</span><br></pre></td></tr></table></figure></li><li><p>安装LLVM，clang，ply和bcc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/build</span><br><span class="line">cd ~/build</span><br><span class="line">git clone https://github.com/iovisor/ply.git</span><br><span class="line">cd ply</span><br><span class="line">./autogen.sh</span><br><span class="line"> export CFLAGS=-I$&#123;HOME&#125;/build/usr/include</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line">cd ..</span><br><span class="line">curl -LO http://releases.llvm.org/3.9.1/cfe-3.9.1.src.tar.xz</span><br><span class="line">curl -LO http://releases.llvm.org/3.9.1/llvm-3.9.1.src.tar.xz</span><br><span class="line">tar -xf cfe-3.9.1.src.tar.xz</span><br><span class="line">tar -xf llvm-3.9.1.src.tar.xz</span><br><span class="line">mkdir clang-build</span><br><span class="line">mkdir llvm-build</span><br><span class="line"></span><br><span class="line">cd llvm-build</span><br><span class="line">cmake3 -G &quot;Unix Makefiles&quot; -DLLVM_TARGETS_TO_BUILD=&quot;BPF;X86&quot; \</span><br><span class="line">  -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=/usr ../llvm-3.9.1.src</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line">cd ../clang-build</span><br><span class="line">cmake3 -G &quot;Unix Makefiles&quot; -DLLVM_TARGETS_TO_BUILD=&quot;BPF;X86&quot; \</span><br><span class="line">  -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=/usr ../cfe-3.9.1.src</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line">cd ..</span><br><span class="line">git clone https://github.com/iovisor/bcc.git</span><br><span class="line">mkdir bcc-build</span><br><span class="line">cd bcc-build</span><br><span class="line">cmake3 -G &quot;Unix Makefiles&quot; -DCMAKE_INSTALL_PREFIX=/usr ../bcc</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure></li><li><p>安装完成：</p><p><img src="/2019/03/12/在CentOS7上安装eBPF-tools-bcc和ply/1552362190205.png" alt="1552362190205"></p></li></ol><p>参考文献：</p><p><a href="http://hydandata.org/installing-ebpf-tools-bcc-and-ply-on-centos-7" target="_blank" rel="noopener">Installing eBPF tools, bcc and ply on CentOS 7</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;升级内核：&lt;/p&gt;
&lt;p&gt;CentOS7的内核版本是3.x，要安装使用eBPF，bcc和ply，内核版本至少是4.9，所以需要先升级CentOS7的内核。详见&lt;a href=&quot;https://jeychu.github.io/2019/03/11/Cent
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>systemtap</title>
    <link href="http://yoursite.com/2019/03/11/systemtap/"/>
    <id>http://yoursite.com/2019/03/11/systemtap/</id>
    <published>2019-03-11T09:45:32.000Z</published>
    <updated>2019-03-13T02:02:50.123Z</updated>
    
    <content type="html"><![CDATA[<p>此篇为systemtap的学习笔记，待更。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;此篇为systemtap的学习笔记，待更。。。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7升级内核</title>
    <link href="http://yoursite.com/2019/03/11/CentOS7%E5%8D%87%E7%BA%A7%E5%86%85%E6%A0%B8/"/>
    <id>http://yoursite.com/2019/03/11/CentOS7升级内核/</id>
    <published>2019-03-11T07:56:06.000Z</published>
    <updated>2019-03-12T04:16:40.991Z</updated>
    
    <content type="html"><![CDATA[<ol><li>当前版本</li></ol><p><img src="/2019/03/11/CentOS7升级内核/1552291068649.png" alt="1552291068649"></p><ol start="2"><li>开始升级：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</span><br></pre></td></tr></table></figure><p><img src="/2019/03/11/CentOS7升级内核/1552291299843.png" alt="1552291299843"></p><p><img src="/2019/03/11/CentOS7升级内核/1552291341907.png" alt="1552291341907"></p><p><img src="/2019/03/11/CentOS7升级内核/1552291401131.png" alt="1552291401131"></p><ol start="3"><li>将升级后的内核作为默认内核，重启机器</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># grub2-set-default 0</span><br><span class="line"># reboot</span><br></pre></td></tr></table></figure><ol start="4"><li>升级后的版本</li></ol><p><img src="/2019/03/11/CentOS7升级内核/1552353122161.png" alt="1552353122161"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;当前版本&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;/2019/03/11/CentOS7升级内核/1552291068649.png&quot; alt=&quot;1552291068649&quot;&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;开始升级：&lt;/li&gt;
&lt;/ol
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux性能优化之内存篇</title>
    <link href="http://yoursite.com/2019/03/10/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%86%85%E5%AD%98%E7%AF%87/"/>
    <id>http://yoursite.com/2019/03/10/Linux性能优化之内存篇/</id>
    <published>2019-03-10T11:05:56.000Z</published>
    <updated>2019-03-20T05:34:05.925Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#linux内存是怎么工作的">Linux内存是怎么工作的？</a><ul><li><a href="#内存映射">内存映射</a></li><li><a href="#虚拟内存空间分布">虚拟内存空间分布</a></li><li><a href="#内存分配与回收">内存分配与回收</a></li><li><a href="#如何查看内存使用情况">如何查看内存使用情况</a></li></ul></li><li><a href="#buffer和cache">Buffer和Cache</a></li><li><a href="#swap">SWAP</a><ul><li><a href="#swap原理">SWAP原理</a></li></ul></li><li><a href="#如何利用系统缓存优化程序的运行效率">如何利用系统缓存优化程序的运行效率</a></li></ul><!-- tocstop --><h1><span id="linux内存是怎么工作的">Linux内存是怎么工作的？</span></h1><p>内存管理是操作系统最核心的功能之一。内存主要用来存储系统和应用程序的指令、数据、缓存等。</p><p>Linux是怎么管理内存的呢？</p><h2><span id="内存映射">内存映射</span></h2><p>物理内存，也称为主存，大多数计算机用的主存都是动态随机访问内存（DRAM）。</p><p>只有内核才可以直接访问物理内存。进程要访问内存时，该怎么办呢？</p><p>Linux内核给每个进程都提供了一个独立的虚拟地址空间，并且这个地址空间是连续的。</p><p>进程可以很方便地访问虚拟内存。</p><p>虚拟地址空间的内部又被分为内核空间和用户空间两部分，不同字长（单个CPU指令可以处理数的最大长度）的处理器，虚拟地址空间的范围也不同。对于常见的32位和64位系统，它们的虚拟地址空间，如下所示：</p><p><img src="/2019/03/10/Linux性能优化之内存篇/1552216929887.png" alt="1552216929887"></p><p>既然每个进程都有一个这么大的地址空间，那么所有进程的虚拟内存加起来，自然要比实际的物理内存大得多。所以，并不是所有的虚拟内存都会分配物理内存，只有哪些实际使用的虚拟内存才分配物理内存，并且分配后的物理内存，是通过内存映射来管理的。</p><p>内存映射，就是将虚拟内存地址映射到物理内存地址。为了完成内存映射，内核为每个进程都维护了一张页表，记录虚拟地址与物理地址的映射关系，如下图所示：</p><p><img src="/2019/03/10/Linux性能优化之内存篇/1552216874797.png" alt="1552216874797"></p><p>页表存储在CPU的内存管理单元MMU中。</p><p>当进程访问的虚拟地址在页表中查不到时，系统会产生一个缺页异常，进入内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。</p><p>TLB是MMU中页表的高速缓存。由于进程的虚拟地址空间是独立的，而TLB的访问速度又比MMU快得多，所以，通过减少进程的上下文切换，减少TLB的刷新次数，就可以提高TLB缓存的使用率，进而提高CPU的内存访问性能。</p><p>MMU规定了内存映射的最小单位为页，通常是4KB大小，以页为单位来管理内存。这样，每一次内存映射，都需要关联4KB或4KB整数倍的内存空间。</p><p>页的大小只有4KB，整个页表非常大。比如，32位系统就需要100多万个页表项<sup>4GB/4KB=1048576</sup>，才可以实现整个地址空间的映射。</p><p>为了解决页表项过多的问题，Linux提供了两种机制：</p><ul><li><p><strong>多级页表</strong>：把内存分成区块来管理，将原来的映射关系改成区块索引和区块内的偏移。由于虚拟内存空间通常只用了很少一部分，那么，多级页表就只保持这些使用中的区块，这样就可以大大减少页表的项数。</p><p>Linux用四级页表来管理内存页，如下图所示，虚拟内存被分为5个部分，前4个表项用于选择页，而最后一个索引表示页内偏移。</p><p><img src="/2019/03/10/Linux性能优化之内存篇/1552218344165.png" alt="1552218344165"></p></li><li><p><strong>大页</strong></p><p>指的是比普通页更大的内存块，常见的大小有2MB和1GB。通常用在使用大量内存的进程上，如Oracle、DPDK等</p></li></ul><p>通过以上机制，在页表的映射下，进程就可以通过虚拟地址来访问物理内存了。那么，具体到一个Linux进程中，这些内存又是怎么使用的呢？</p><h2><span id="虚拟内存空间分布">虚拟内存空间分布</span></h2><p>虚拟内存空间的分布情况，以32位系统为例，如下所示：</p><p><img src="/2019/03/10/Linux性能优化之内存篇/1552218920555.png" alt="1552218920555"></p><p>最上方的是内核空间。虽然，每个进程的地址空间都包含了内核空间，但这些内核空间，其实关联的都是相同的物理内存。</p><p>下方的用户空间内存被划分成了多个不同的段。</p><p>从低到高分别是五种不同的内存段：</p><ol><li>只读段，包括代码和常量等；</li><li>数据段，包括全局变量等；</li><li>堆，包括动态分配的内存，从低地址开始向上增长；</li><li>文件映射段，包括动态库、共享内存等，从高地址开始向下增长；</li><li>栈，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是8MB。</li></ol><p>内存是怎么分配的呢？</p><h2><span id="内存分配与回收">内存分配与回收</span></h2><p>malloc()是C标准库提供的内存分配函数，对应到系统调用上，有两种实现方式，即brk()和mmap()。</p><ul><li><p>对于小块内存（小于128K），C标准库使用brk()来分配内存。也就是通过移动堆顶的位置来分配内存。这些内存释放后并不会立刻归还系统，而是被缓存起来，重复使用。</p><p>缓存的方式，可以减少缺页异常的发生，提高内存访问效率。</p><p>但是由于内存没有归还系统，易造成内存碎片。</p></li><li><p>对于大块内存（大于128K），则直接使用内存映射mmap()来分配。也就是在文件映射段找一块空闲内存分配出去。</p><p>由于释放时，直接归还系统，所以每次mmap都会发生缺页异常。</p><p>大量的缺页异常，使内核的管理负担增大。所以malloc只对大块内存使用mmap。</p></li></ul><p><strong>当这两种调用发生后，其实并没有真正分配内存。这些内存，都只是在首次访问时才被分配，也就是通过缺页异常进入内核中，再由内核来分配内存。</strong></p><p>内核使用伙伴系统来管理内存分配。和MMU一样，伙伴系统也是以页为单位进行管理，并且通过相邻块的合并，减少内存碎片化。</p><p>对于比页更小的对象，比如不到1K的时候，内核通过slab分配器来管理这些小内存。</p><p>对于内存来说，如果只分配而不释放，就会造成内存泄漏，甚至会耗尽系统内存。所以，在应用程序用完内存后，还需要调用free()或unmap()，来释放这些不用的内存。</p><p>在发现内存紧张时，系统会通过以下方式回收内存：</p><ul><li><p>回收缓存，比如使用LRU（Least Recently Used）算法，回收最近使用最少的内存页面；</p></li><li><p>回收不常访问的内存，把不常用的内存通过交换分区直接写到磁盘中。Swap把一块磁盘空间当成内存来用。从内存到磁盘称为换出，从磁盘读取到内存称为换入。</p></li><li><p>杀死进程，通过OOM（Out Of Memory），直接杀死占用大量内存的进程。内核使用oom_score为每个进程的内存使用情况进行评分：</p><ul><li>一个进程消耗的内存越大，oom_score就越大；</li><li>一个进程运行占用的CPU越大，oom_score就越小。</li></ul><p>oom_score越大，越容易被OOM杀死。</p><p>可以通过调整/proc/中进程的oom_adj来调整进程的oom_score。</p><p>oom_adj的范围为[-17, 15]，数值越大，越容易被OOM杀死；-17表示禁止OOM。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo -16 &gt; /proc/$(pidof sshd)/oom_adj</span><br></pre></td></tr></table></figure><p>将sshd进程的oom_adj调小为-16，以使sshd不容易被OOM杀死。</p></li></ul><h2><span id="如何查看内存使用情况">如何查看内存使用情况</span></h2><p>free</p><p><img src="/2019/03/10/Linux性能优化之内存篇/1552275955243.png" alt="1552275955243"></p><p>available不仅包含未使用的内存，还包括了可回收的缓存，所以一般会比未使用内存更大。不过，并不是所有缓存都可以回收，因为有些缓存可能正在使用中。</p><p>top</p><p><img src="/2019/03/10/Linux性能优化之内存篇/1552276016601.png" alt="1552276016601"></p><p>下面部分显示了每个进程的内存使用情况：</p><ul><li>VIRT是进程虚拟内存的大小，只要是进程申请过的内存，即便还没有真正分配物理内存，也会计算在内；</li><li>RES是常驻内存的大小，也就是进程实际使用的物理内存大小，但不包括Swap和共享内存；</li><li>SHR是共享内存的大小，比如与其他进程共同使用的共享内存、加载的动态链接库以及程序的代码段等；需要注意的是，SHR并不一定是共享的，程序的代码段、非共享的动态链接库，也都计算在SHR里。</li><li>%MEM是进程使用物理内存占系统总内存的百分比。</li></ul><h1><span id="buffer和cache">Buffer和Cache</span></h1><p><strong>磁盘读写的缓冲为</strong>Buffer</p><p><strong>文件读写的缓存为</strong>Cache</p><p>注意磁盘读写和文件读写的不同：</p><blockquote><p>磁盘是块设备，可以划分分区，在分区之上再创建文件系统，挂载到某个目录，就可以在这个目录中读写文件。</p></blockquote><p>读写文件时，会经过文件系统，由文件系统和磁盘交互；</p><p>读写磁盘或分区时，会跳过文件系统，也就是裸IO。</p><p>二者所用缓存是不同的。</p><p>Buffer和Cache的设计目的，是为了系统的IO性能。它们利用内存，充当起慢速磁盘和快速CPU之间的桥梁，可以加速IO的访问速度。</p><p>Buffer和Cache分别缓存的是对磁盘和文件系统的读写数据。</p><ul><li>从写的角度来说，不仅可以优化磁盘和文件的写入，对应用程序也有好处，应用程序可以在数据真正落盘前，就返回去做其他工作；</li><li>从读的角度来说，不仅可以提高那些频繁访问数据的读取速度，也降低了频繁IO对磁盘的压力。</li></ul><h1><span id="swap">SWAP</span></h1><p>当内存泄漏时，或者运行了大内存的应用程序，导致系统的内存资源紧张时，系统会如何应对呢？</p><p>可能会导致两种结果：</p><ul><li><p>内存回收</p><p>系统释放掉可以回收的内存，比如缓存和缓冲区，就属于可回收内存。它们在内存管理中，通常被叫做文件页（File-backed Page)。</p><p>大部分文件页，都可以直接回收，以后又需要时，再从磁盘重新读取就可以了。而那些被应用程序修改过，并且暂时还没写入磁盘的数据（脏页），就得先写入磁盘，然后才能进行内存释放。</p><p>这些脏页，一般可以通过两种方式写入磁盘：</p><ul><li>可以在应用程序中，通过系统调用fsync，把脏页同步到磁盘中；</li><li>可以交给系统，由内核线程pdflush负责这些脏页的刷新。</li></ul><p>除了缓存和缓冲区，通过内存映射获取的文件映射页，也是一种常见的文件页。它也可以被释放掉，下次再访问的时候，从文件重新读取。</p><p>而应用程序动态分配的内存（匿名页<sup>Anonymous Page</sup>）是不能直接释放的。但是如果这些内存在分配后很少被访问，可以暂时把它们先存到磁盘里，以释放内存。这就是SWAP机制。</p></li><li><p>OOM杀死进程。</p></li></ul><h2><span id="swap原理">SWAP原理</span></h2><p>Swap就是把一块磁盘空间或者一个本地文件，当成内存来使用。它包括换出和换入两个过程：</p><ul><li><p>换出，就是把进程暂时不用的内存数据存储到磁盘中，并释放这些数据占用的内存；</p></li><li><p>换入，在进程再次访问这些内存的时候，把它们从磁盘读到内存中来</p></li></ul><h1><span id="如何利用系统缓存优化程序的运行效率">如何利用系统缓存优化程序的运行效率</span></h1><p>缓存命中率，指直接通过缓存获取数据的请求次数，占所有数据请求次数的百分比。</p><p>命中率越高，表示使用缓存带来的收益越高，应用程序的性能也就越好。</p><p>实际上，缓存是现在所有高并发系统必需的核心模块，主要作用就是把经常访问的数据（也就是热点数据），提前读入到内存中。以加快应用程序的响应速度。</p><p>缓存分析工具：cachestat和pcstat</p><p>cachestat在CentOS7上的安装详见：<a href="https://jeychu.github.io/2019/03/12/%E5%9C%A8CentOS7%E4%B8%8A%E5%AE%89%E8%A3%85eBPF-tools-bcc%E5%92%8Cply/" target="_blank" rel="noopener">在CentOS7上安装eBPF-tools,bcc和ply</a></p><p>pcstat的安装：</p><ol><li>安装go语言：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wget https://studygolang.com/dl/golang/go1.11.5.linux-amd64.tar.gz</span><br><span class="line">mkdir /opt/go</span><br><span class="line">tar -xvf go1.11.5.linux-amd64.tar.gz -C /opt/go</span><br><span class="line">mkdir /root/gopath</span><br><span class="line">vim /etc/profile</span><br><span class="line">export GOROOT=/opt/go/go</span><br><span class="line">   export PATH=$PATH:$GOROOT/bin</span><br><span class="line">   export GOPATH=/root/gopath</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><p>​         安装完成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@es gopath]# go version</span><br><span class="line">go version go1.11.5 linux/amd64</span><br></pre></td></tr></table></figure><ol start="2"><li>安装pcstat：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir /root/gopath/golang.org/</span><br><span class="line">cd /root/gopath/golang.org</span><br><span class="line">git clone https://github.com/golang/sys.git</span><br><span class="line">go get github.com/tobert/pcstat/pcstat</span><br><span class="line">export PATH=$PATH:/root/gopath/bin</span><br></pre></td></tr></table></figure><p>​           安装完成：</p><p><img src="/2019/03/10/Linux性能优化之内存篇/1552368584437.png" alt="1552368584437"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#linux内存是怎么工作的&quot;&gt;Linux内存是怎么工作的？&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#内存映射&quot;&gt;内存映射&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#虚拟内存空间分布&quot;&gt;虚拟内存空间分布&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>MySQL的监控</title>
    <link href="http://yoursite.com/2019/03/09/MySQL%E7%9A%84%E7%9B%91%E6%8E%A7/"/>
    <id>http://yoursite.com/2019/03/09/MySQL的监控/</id>
    <published>2019-03-08T18:05:10.000Z</published>
    <updated>2019-03-09T06:17:27.047Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL</p><p>监控哪些内容？</p><ul><li>数据库服务的可用性</li><li>数据库性能</li><li>主从同步的情况</li><li>服务器的资源</li><li></li></ul><p>怎么监控？</p><p>调优</p><p>先找出瓶颈所在，然后针对瓶颈做出优化</p><p>如何找瓶颈？</p><p>利用top ps vmstat iostat netstat /proc/</p><p>然后用perf strace ltrace systemtap 追踪进程 定位函数</p><p>zabbix添加自定义监控项</p><p>写脚本 -&gt; 在agentd.conf中添加UserParameter -&gt; 在server中用zabbix-get测试 -&gt;在web添加item和graph</p><p>故障排查思路：</p><p>网络 DNS解析是否正常 ping延时</p><p>主机</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;MySQL&lt;/p&gt;
&lt;p&gt;监控哪些内容？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据库服务的可用性&lt;/li&gt;
&lt;li&gt;数据库性能&lt;/li&gt;
&lt;li&gt;主从同步的情况&lt;/li&gt;
&lt;li&gt;服务器的资源&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;怎么监控？&lt;/p&gt;
&lt;p&gt;调优&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>The Kernel of Nginx之用好浏览器的缓存</title>
    <link href="http://yoursite.com/2019/03/06/The-Kernel-of-Nginx%E4%B9%8B%E7%94%A8%E5%A5%BD%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98/"/>
    <id>http://yoursite.com/2019/03/06/The-Kernel-of-Nginx之用好浏览器的缓存/</id>
    <published>2019-03-06T03:02:25.000Z</published>
    <updated>2019-03-08T12:57:26.489Z</updated>
    
    <content type="html"><![CDATA[<p>浏览器的缓存与nginx缓存</p><ul><li><p>浏览器缓存</p><ul><li>优点：<ul><li>使用有效缓存时，没有网络消耗，速度最快</li><li>即使有网络消耗，但对失效缓存使用304响应做到网络流量消耗最小化</li></ul></li><li>缺点：<ul><li>只提升一个用户的体验</li></ul></li></ul></li><li><p>Nginx缓存</p><ul><li>优点<ul><li>提升所有用户的体验</li><li>相比浏览器缓存，有效降低上游服务的负载</li><li>通过304响应减少Nginx与上游服务间的流量消耗</li></ul></li><li>缺点<ul><li>用户仍然保持网络消耗</li></ul></li></ul></li></ul><p>同时使用浏览器和Nginx缓存</p><p>浏览器缓存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 浏览器请求</span><br><span class="line">op1=&gt;operation: 有缓存</span><br><span class="line">op2=&gt;operation: 向浏览器请求带If-None_Match</span><br><span class="line">op3=&gt;operation: 向浏览器请求带If-Modified-Since</span><br><span class="line">op4=&gt;operation: 从缓存读取 200（from cache）</span><br><span class="line">op5=&gt;operation: 向web服务器请求</span><br><span class="line">op6=&gt;operation: 请求响应，缓存协商</span><br><span class="line">op7=&gt;operation: 从缓存读取</span><br><span class="line">con1=&gt;condition: 是否过期？</span><br><span class="line">con2=&gt;condition: Etag？</span><br><span class="line">con3=&gt;condition: Last-Modified？</span><br><span class="line">con4=&gt;condition: 200 or 304？</span><br><span class="line">end=&gt;end: 呈现</span><br><span class="line">st-&gt;op1-&gt;con1</span><br><span class="line">con1(no)-&gt;op4-&gt;end</span><br><span class="line">con1(yes)-&gt;con2</span><br><span class="line">con2(yes)-&gt;op2-&gt;con4</span><br><span class="line">con2(no)-&gt;con3</span><br><span class="line">con3(yes)-&gt;op3-&gt;con4</span><br><span class="line">con3(no)-&gt;op5-&gt;op6</span><br><span class="line">con4(yes)-&gt;op6</span><br><span class="line">con4(no)-&gt;op7-&gt;end</span><br><span class="line">op6-&gt;end</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax： etag on|off;</span><br><span class="line">Default: etag on;</span><br><span class="line">Context: http, server, location</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ngx_sprintf(etag-&gt;value.data, <span class="string">"\"%xT-%xO\""</span>,</span><br><span class="line">           r-&gt;headers_out.last_modified_time,</span><br><span class="line">           r-&gt;headers_out.contect_length_n)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;浏览器的缓存与nginx缓存&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;浏览器缓存&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：&lt;ul&gt;
&lt;li&gt;使用有效缓存时，没有网络消耗，速度最快&lt;/li&gt;
&lt;li&gt;即使有网络消耗，但对失效缓存使用304响应做到网络流量消耗最小化&lt;/li&gt;
&lt;/ul&gt;
&lt;/
      
    
    </summary>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx的优化</title>
    <link href="http://yoursite.com/2019/03/06/nginx%E7%9A%84%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/03/06/nginx的优化/</id>
    <published>2019-03-06T02:26:22.000Z</published>
    <updated>2019-03-10T17:26:17.399Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="基本安全优化">基本安全优化</span></h1><h2><span id="隐藏版本信息">隐藏版本信息</span></h2><h2><span id="更改nginx服务的默认用户">更改Nginx服务的默认用户</span></h2><h2><span id="降权启动nginx">降权启动Nginx</span></h2><h1><span id="参数优化nginx服务性能">参数优化Nginx服务性能</span></h1><h2><span id="进程个数-单个进程的最大连接数">进程个数、单个进程的最大连接数</span></h2><h2><span id="绑定cpu">绑定CPU</span></h2><h2><span id="gzip">gzip</span></h2><h2><span id="expires">expires</span></h2><h1><span id="日志的优化">日志的优化</span></h1><h1><span id="防盗链">防盗链</span></h1><h1><span id="防爬虫">防爬虫</span></h1><h1><span id="目录权限优化">目录权限优化</span></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;基本安全优化&quot;&gt;基本安全优化&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span id=&quot;隐藏版本信息&quot;&gt;隐藏版本信息&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span id=&quot;更改nginx服务的默认用户&quot;&gt;更改Nginx服务的默认用户&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;
      
    
    </summary>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>无之文</title>
    <link href="http://yoursite.com/2019/03/04/%E6%97%A0%E9%A2%98/"/>
    <id>http://yoursite.com/2019/03/04/无题/</id>
    <published>2019-03-03T16:28:27.000Z</published>
    <updated>2019-03-20T10:44:31.789Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>‘无意识流’<sup>自撰</sup>码点字儿，权当消遣、游戏。</p><p>具体写些什么，写出什么，我自己也是不知道的。</p><p>不断填充，每更以时间戳为领。</p></blockquote><!-- toc --><ul><li><a href="#1934">19/3/4</a></li><li><a href="#1935">19/3/5</a></li><li><a href="#1936">19/3/6</a></li><li><a href="#1938">19/3/8</a></li><li><a href="#1939">19/3/9</a></li><li><a href="#19310">19/3/10</a></li><li><a href="#19312">19/3/12</a></li><li><a href="#19313">19/3/13</a></li><li><a href="#19314">19/3/14</a></li><li><a href="#19320">19/3/20</a></li></ul><!-- tocstop --><h1><span id="1934">19/3/4</span></h1><p>老夫聊发少年狂，不自量，频思量，要和困滞斗一场<br>人生不如意十八九，又何必，妄自沉，且奋起，争朝夕，人生百年是不枉</p><p>内核源码纷上阵，战得个天昏又地暗<br>人道是，廿一世纪，人工智能日日新，所能之事无限<br>现如今，百业俱兴于互联网<br>信息流转无量，人人都是网中虫<br>码农立功改了世界，创了互联界，人神之间自此有了个第三界</p><p>微信淘宝千百度，淘了个什么，又信了个什么？<br>大小屏幕满城皆是，人人淹没其间。<br>要在屏幕引源流，码农誓要战到深夜，不眠不休。</p><p>王者荣耀坑起来，坑到王者亦非常人也<br>鲁班后羿虽善射，易被珂切<br>项羽是个霸王，本色是喜欢虞姬<br>妲己是个妖女，总想一套秒<br>凯也是个肉，打不死还善单挑<br>典韦疯癫，满场飞奔…</p><p>恩金克思是个宝<br>鲁啊美月协助跑<br>林刘克思做服务<br>韦伯搞网成了王</p><hr><h1><span id="1935">19/3/5</span></h1><p>iHola!</p><p>¿Como estas?</p><p>香尘已隔犹回面<br>居人匹马映林嘶</p><p>新绿小池塘<br>帘动、碎影、斜阳<br>金屋去来 旧时巢燕<br>土花缭绕 前度霉墙<br>绣阁凤帷理丝簧</p><p>天寒水鸟自相依<br>十百为群戏落辉<br>行人过尽都不起<br>忽闻水响一起飞</p><p>携杖来追凉<br>花桥倚胡床<br>船笛参差起<br>池莲自在香</p><hr><h1><span id="1936">19/3/6</span></h1><p>知海无涯<br>海里行<br>无向即无功<br>看四周，都是极似<br>手中罗盘<br>历历晰晰<br>准方向<br>不旁骛<br>自可离海登陆<br>船体牢靠<br>方向笃定<br>定成航海王，掌控自生</p><hr><p>不自怨艾，稳住，都将烟消云散<br>云开日现<br>金晖永在，云遮不显<br>拨云自可见日<br>谁可拨？<br>大风耶？大风起兮云飞扬<br>大风来，尘土混乌云，暗无天日<br>小风耶？和风暖阳，自是佳时<br>小风何来？自来也<br>拨云见日者，非人力<br>人自求福，不自作孽，静待日开，得其光<br>但日总在，不因云遮就无<br>光透云，人依然可得其几许<br>故莫担心，莫贪心，莫失心<br>阴晴才是此间正道<br>阴晴都是那颗太阳</p><hr><h1><span id="1938">19/3/8</span></h1><p>二月二日 三八女节<br>雌雄合一 天地交泰<br>龙飞凤舞 双翔呈瑞<br>元亨利贞 吉吉吉吉</p><hr><h1><span id="1939">19/3/9</span></h1><p>痛通，痛得不欲生，就通了<br>自不量力者，撞的头破血流，心痛通</p><p>太阳照常升起，逝者从未停歇<br>珍惜光阴，涓滴莫弃<br>昨天已不复存在，明天从未到来，唯有今天，才是所有</p><p>乱 清理 有序<br>减 减 减<br>只剩一个 所向披靡</p><p>不家 于外 往西行</p><hr><h1><span id="19310">19/3/10</span></h1><p>喜鹊上下游嬉<br>貔貅口衔红币<br>金蟾门口招财<br>晶洞坐镇玄武<br>金鸡雄立西方</p><p>尼采句，大乱写：</p><p>能飞之人向上飞<br>于不能飞之人看来，<br>愈高愈渺</p><p>凝视深渊，深渊亦然<br>与恶魔斗，慎成恶魔</p><p>每天<br>若不曾起舞<br>即是<br>辜负了生命</p><p>谦逊基于力量<br>傲慢基于无能</p><p>世界弥漫着焦躁不安，因众人皆急于从各自的枷锁中获得解放</p><p>不懂自己才是生命中最难的部分</p><p>曲则全，要曲莫直，曲曲折折，真理渐得显现</p><p>埋怨自己、憎恨他人之时。。。你需要休息了！</p><p>无有音乐，生活是错</p><p>智慧是个女人，她只爱战士——愿你勇敢、无忧、刚强</p><p>明为何而活，自可承受一切，幸与不幸</p><p>受苦之人，没有悲观的权力</p><hr><h1><span id="19312">19/3/12</span></h1><blockquote><p>引子：欲休息，偶翻莎翁十四行诗，译之，或可读？</p></blockquote><blockquote><p>前方高能：催婚催育，歌颂爱情！</p></blockquote><p>// 赞美爱人也</p><p>Shall I compare you to a summer’s day?<br>You are more lovely and more temperate:<br>Rough winds do shake the darling buds of May,<br>And summer’s lease has all too short a date;<br>Sometime too hot the eye of heaven shines,<br>And often is his gold complexion dimm’d<br>And every fair from fair sometime declines,<br>By chance or nature’s changing course untrimm’d:<br>But your eternal summer shall not fade,<br>Nor lose possession of that fair you own,<br>Nor shall Death brag you wand’rest in his shade,<br>When in eternal lines to time you grow’st.<br>So long as men can breathe or eyes can see,<br>So long lives this, and this gives life to you.</p><p>将你比作夏天？<br>你更美好温和：<br>强风摧折五月可爱花蕾，<br>夏之为期也是太过短暂。<br>日光有时太炙，<br>金色时常被霾。<br>美丽总要逝去，<br>不测或是自然。<br>但你常住之夏永不退，<br>你所有之美也将不失。<br>当你在这不朽诗篇中和时间合为一，<br>死神休大言说你在他的阴影里盘桓。<br>只要有人能看能呼吸，<br>此诗长存并予你生命。</p><p>// 谴责单身主义者也</p><p>From fairest creatures we desire increase,<br>That thereby beauty’s rose might never die,<br>But as the riper should by time decrease,<br>His tender heir might bear his memory:<br>But you, contracted to your own bright eyes,<br>Feed your light’s flame with self-substantial fuel,<br>Making a famine where abundance lies,<br>Yourself your foe, to your sweet self too cruel.<br>You that art now the world’s fresh ornament,<br>And only herald to the gaudy spring,<br>Within your own bud buried your content,<br>And, tender churl, make waste in niggarding:<br>Pity the world, or else this glutton be,<br>To eat the world’s due, by the grave and you.</p><p>美好藩息【好为第四声】<br>美瑰不死。<br>黄熟凋零<br>幼子承继。<br>只从你目<br>以己为柴<br>大烧目火。<br>丰地饥馑<br>尔实尔敌<br>残对汝身。<br>世之璀璨<br>春之先使<br>却事埋藏。<br>温柔残暴<br>吝啬浪费。<br>怜悯此世<br>若不怜世<br>实为贪夫<br>世所应得<br>汝墓及汝<br>尽将蚕食</p><hr><h1><span id="19313">19/3/13</span></h1><p>// 赞生育也，生育使美延续</p><p>When forty winters shall besiege your brow,<br>And dig deep trenches in your beauty’s field,<br>Your youth’s proud livery, so gazed on now,<br>Will be a tattered weed of small worth held:<br>Then being asked, where all your beauty lies,<br>Where all the treasure of your lusty days,<br>To say within your own deep-sunken eyes<br>Were an all-eating shame, and thriftless praise.<br>How much more praise deserved your beauty’s use,<br>If you could answer, “This fair child of mine<br>Shall sum my count, and make my old excuse,”<br>Proving his beauty by your succession.<br>This were to be new made when you are old,<br>And see your blood warm when you feel it cold.</p><p>四十个冬天将使你美丽的额头<br>沟壑起伏<br>你的青春华服，众所倾羡<br>也将破烂如杂草毫无价值<br>彼时，若被问：<br>你的美何在？<br>你光辉岁月的珍宝何在？<br>你深陷的眼窝里，<br>只有些能吞噬所有的羞耻和毫无意义的赞美。<br>但如果你能说，我美丽的孩子就是我的总结，<br>宽恕我的老迈，继承我的美<br>如此，你的美应得更多赞誉<br>当你老时，这就是新生<br>当你冷时，这使你热血</p><hr><h1><span id="19314">19/3/14</span></h1><p>世界上只有两种数学书：</p><ul><li>看了第一页，读不下去。。。</li><li>看了第一句，读不下去。。。</li></ul><hr><h1><span id="19320">19/3/20</span></h1><p>王者荣耀中，玩的最多的是项羽，故而读项羽传。<br>项羽骁勇善战。自吹力拔山、气盖世。吹归吹，毕竟是写诗嘛。不这样写，也无法和他的神勇相称。正史记载，项羽驰骋沙场，如入无人之境，不停的手起刀落，常能勇提几百个首级。这实力，也可算历史第一战士了。<br>正史还记载，敌将被项羽一瞋，就吓得魂散，若非夸张，项羽也该封战神了。以这实力，西楚霸王是实至名归。<br>项羽的神威战力从何而来，我也无法想象得出。OS：大家都是人，都是吃米饭馒头长大的，为什么差距这么大呢？他一个人在战场上杀几百个人，还没被干掉，这精力真是好。我怎么写会儿代码，就困了。大写的服！<br>不过最终，项羽还是自刎了。<br>出来混，早晚是要还的啊。看项羽的作风，就是依仗暴力，杀杀杀的，光坑杀就好几回，也是残暴异常。<br>项羽的自我总结：非战之罪，天亡也。真-自知之明，总结的很对，其实就是天要亡他，因为他太残暴、杀了那么多的人，有些都是集体坑杀，毫无抵抗<br>还一把火把集聚重宝的皇宫烧了3个月，真是暴殄天物，太浪费了<br>项羽若得善终，历史都没法写下去。<br>苍天饶过谁？。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;‘无意识流’&lt;sup&gt;自撰&lt;/sup&gt;码点字儿，权当消遣、游戏。&lt;/p&gt;
&lt;p&gt;具体写些什么，写出什么，我自己也是不知道的。&lt;/p&gt;
&lt;p&gt;不断填充，每更以时间戳为领。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Nginx中的位运算</title>
    <link href="http://yoursite.com/2019/03/02/Nginx%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>http://yoursite.com/2019/03/02/Nginx和位运算/</id>
    <published>2019-03-02T10:39:45.000Z</published>
    <updated>2019-03-03T18:01:08.912Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇是学习<a href="https://www.jishuwen.com/d/2EGC/zh-hk" target="_blank" rel="noopener">其他博文</a>的笔记，根据自己的理解，做了些增补和简化。</p></blockquote><p>位运算在Nginx的源码处处可见，如</p><ul><li><p>定义指令的类型</p></li><li><p>标记当前请求是否还有未发送完的数据</p></li><li><p>事件模块里用指针的最低位来标记一个事件是否过期</p></li></ul><p>下面分析以下在Nginx中位运算的经典使用场景。</p><h1><span id="经典使用场景">经典使用场景</span></h1><h2><span id="对齐">对齐</span></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/ngx_config.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_align(d, a)     (((d) + (a - 1)) &amp; ~(a - 1))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_align_ptr(p, a)                                                    \</span></span><br><span class="line">    (u_char *) (((<span class="keyword">uintptr_t</span>) (p) + ((<span class="keyword">uintptr_t</span>) a - <span class="number">1</span>)) &amp; ~((<span class="keyword">uintptr_t</span>) a - <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>该宏使得d按a对齐<sup>第一个大于等于d的a倍数</sup>，其中a必须是2的幂次。</p><p>此宏就是寻找最小的且大于等于d的a的倍数。</p><p>由于a是2的幂次，因此a的二进制表示为00…1…00这样的形式，即它只有一个1，a-1便是00…01…1这样的形式。</p><p>接着，~(a-1)就会将低n为全部置0，n为a的低位连续0的个数。</p><p>此时，如果再将一个数和~（a-1）进行一次按位与，就能把这个数的低n位都清零（即成为a的倍数）。</p><p>而把这个数的低n位都清零，最多是从这个数减去a-1。</p><p>故而，d+（a-1）在经过和~（a-1）按位与而做了清零操作之后，最多也是减去a-1，也就是说，经过低位清零之后，其值最小是d，这样我们就得到了一个大于等于d，且低n位是0的对齐数，即一个大于等于d的a倍数。且是第一个大于等于d的a的倍数。</p><h2><span id="位图">位图</span></h2><p>位图，用以标记状态，只使用一个比特位来标记事物，从而节约内存，提升性能。</p><p>Nginx在对uri进行转义时，需要判断一个字符是否是一个保留字符，这样的字符需要被转义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// src/core/ngx_string.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint32_t</span>   uri_component[] = &#123;</span><br><span class="line">        <span class="number">0xffffffff</span>, <span class="comment">/* 1111 1111 1111 1111  1111 1111 1111 1111 */</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* ?&gt;=&lt; ;:98 7654 3210  /.-, +*)( '&amp;%$ #"!  */</span></span><br><span class="line">        <span class="number">0xfc009fff</span>, <span class="comment">/* 1111 1100 0000 0000  1001 1111 1111 1111 */</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* _^]\ [ZYX WVUT SRQP  ONML KJIH GFED CBA@ */</span></span><br><span class="line">        <span class="number">0x78000001</span>, <span class="comment">/* 0111 1000 0000 0000  0000 0000 0000 0001 */</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">/*  ~&#125;| &#123;zyx wvut srqp  onml kjih gfed cba` */</span></span><br><span class="line">        <span class="number">0xb8000001</span>, <span class="comment">/* 1011 1000 0000 0000  0000 0000 0000 0001 */</span></span><br><span class="line"></span><br><span class="line">        <span class="number">0xffffffff</span>, <span class="comment">/* 1111 1111 1111 1111  1111 1111 1111 1111 */</span></span><br><span class="line">        <span class="number">0xffffffff</span>, <span class="comment">/* 1111 1111 1111 1111  1111 1111 1111 1111 */</span></span><br><span class="line">        <span class="number">0xffffffff</span>, <span class="comment">/* 1111 1111 1111 1111  1111 1111 1111 1111 */</span></span><br><span class="line">        <span class="number">0xffffffff</span>  <span class="comment">/* 1111 1111 1111 1111  1111 1111 1111 1111 */</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>如上所示，一个数组组成一个位图，共包含8各数字，每个数字表示32个状态，因此这个位图标识出了256个字符的状态。为0的位表示一个通用字符，不需要转义，为1的位代表该字符需要转义。<br>如何使用这个位图呢？Nginx在遍历uri的时候，通过一条简单的语句来进行判断：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uri_component[ch &gt;&gt; <span class="number">5</span>] &amp; (<span class="number">1</span> &lt;&lt; (ch &amp; <span class="number">0x1f</span>))</span><br></pre></td></tr></table></figure><p>如上所示，ch表示当前字符，ch&gt;&gt;5是对ch右移5位，这起到一个除以32的效果，这一步操作确定了ch在uri_component的第几个数字上；</p><p>ch&amp;0x1f，则是取出ch低5位的值，相当于取模32，这个值表示ch在对应数字上的第几位；</p><p>1&lt;&lt;(ch&amp;0x1f)，将1左移ch在对应数字上的所在位数。将该数和对应数字相与，就可以取出对应数字上与ch相对应位置的bit位。</p><p>如：ch是‘0’（即数字48），它存在于位图的第二个数字上（48&gt;&gt;5=1)，又在这个数字（0xfc009fff）的第16位上，所以它的状态就是0xfc009fff &amp; 0x10000 = 0，所以‘0’是个通用字符，不用对它转义。</p><blockquote><p>位运算技巧：对一个2的幂次的数进行取模或者除操作的时候，可以通过位运算来实现。</p></blockquote><h2><span id="寻找最低位1的位置">寻找最低位1的位置</span></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; ~(x - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>~(x-1)使得除了最低位1的那个位置，其他位置和x都是相反的，因此二者进行按位与操作后，结果里只可能有一个1，便是原本x最低位的1。</p><h2><span id="寻找最高位1的位置">寻找最高位1的位置</span></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> bsf(<span class="keyword">size_t</span> input)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span> pos;</span><br><span class="line"></span><br><span class="line">    __asm__(<span class="string">"bsfq %1, %0"</span> : <span class="string">"=r"</span> (pos) : <span class="string">"rm"</span> (input));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">size_t bsf(size_t input)</span><br><span class="line">&#123;</span><br><span class="line">    input |= input &gt;&gt; 1;</span><br><span class="line">    input |= input &gt;&gt; 2;</span><br><span class="line">    input |= input &gt;&gt; 4;</span><br><span class="line">    input |= input &gt;&gt; 8;</span><br><span class="line">    input |= input &gt;&gt; 16;</span><br><span class="line">    input |= input &gt;&gt; 32;</span><br><span class="line"></span><br><span class="line">    return input - (input &gt;&gt; 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="计算1的个数">计算1的个数</span></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本篇是学习&lt;a href=&quot;https://www.jishuwen.com/d/2EGC/zh-hk&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;其他博文&lt;/a&gt;的笔记，根据自己的理解，做了些增补和简化。&lt;/p&gt;
&lt;/bloc
      
    
    </summary>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>微服务设计</title>
    <link href="http://yoursite.com/2019/02/28/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2019/02/28/微服务设计/</id>
    <published>2019-02-28T14:53:03.000Z</published>
    <updated>2019-03-14T09:10:03.907Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="微服务">微服务</span></h1><h1><span id="演化式架构师">演化式架构师</span></h1><h1><span id="如何建模服务">如何建模服务</span></h1><h1><span id="集成">集成</span></h1><h1><span id="分解单块系统">分解单块系统</span></h1><h1><span id="部署">部署</span></h1><blockquote><p>构建什么、如何构建以及如何部署？</p></blockquote><h2><span id="持续集成简介">持续集成简介</span></h2><ul><li>你是否每天签入代码到主线？</li><li>你是否有一组测试来验证修改？</li><li>当构建失败后，团队是否把修复CI当作第一优先级的事情来做？</li></ul><h2><span id="把ci映射到微服务">把CI映射到微服务</span></h2><p>如何在微服务、CI构建及源代码三者之间，建立起合适的映射呢？</p><p>最简单的，把所有东西放在一起。如下所示，一个巨大的代码库，其中包括所有的代码，并且只有一个构建。向该代码库任何一次的代码提交都会触发构建，在构建中运行相关的验证，然后生成多个构建物，所有这些都是在同一个构建中完成。</p><p><img src="/2019/02/28/微服务设计/1552533778038.png" alt="1552533778038"></p><p>这种模式存在很多明显的缺点：</p><p>如果我仅仅修改了用户访问中的一行代码，所有其他的服务都需要解析验证和构建，但实际上它们并不需要重新验证和构建，在这里，我们花费了不必要的时间。</p><p>这种方法的一个变体是保留一个代码库，但是用多个CI分别映射到代码库的不同部分，如下所示：</p><p><img src="/2019/02/28/微服务设计/1552533870065.png" alt="1552533870065"></p><p>这种模式可能是双刃剑：一方面它会简化检出/检入的流程，但另一方面，由于可以很轻松地同时提交对多个服务的修改，从而容易做出将多个服务耦合在一起的修改。</p><p>另外一种模式是，每个微服务都有自己的CI，可以在将该微服务部署到生产环境之前做一个快速的验证，如下所示：</p><p><img src="/2019/02/28/微服务设计/1552533913998.png" alt="1552533913998"></p><h2><span id="构建流水线">构建流水线</span></h2><p>使用构建流水线的标准发布流程：</p><p><img src="/2019/02/28/微服务设计/1552536246615.png" alt="1552536246615"></p><p>在微服务的世界，我们想要保证服务之间可以独立于彼此进行部署，所以每个服务都有自己独立的CI。</p><p>但也有例外：刚启动一个新项目时，在什么都没有的情况之下，要花很多时间来识别服务边界。</p><p>在识别出稳定的边界之前，可以把所有的初始服务都放到一起，只用一个构建。此时，也经常会发生跨服务边界的修改，把所有的服务都放在同一个构建中，可以减轻跨服务修改的代价。</p><p>当服务的API稳定之后，就可以开始把它们移动到各自的构建之中。</p><h2><span id="平台特定的构建物">平台特定的构建物</span></h2><p>大多数技术栈都有相应的构建物类型，同时也有相关的工具来创建和安装这些构建物。如：Ruby有gem，Java有JAR包和WAR包，Python有egg。</p><p>从部署的角度，只有构建物本身通常是不够的。如Python应用程序需要运行在Nginx或Apache中。</p><p>为了部署和启动这些构建物，需要安装和配置一些其他的软件。使用Ansible、SaltStack进行自动化配置管理，可以很好的解决这个问题。</p><h2><span id="操作系统构建物">操作系统构建物</span></h2><p>有一种方法可以避免多种技术栈下的构建物所带来的问题，那就是使用操作系统支持的构建物。如，基于RedHat或者CentOS的系统来收，可以使用RPM；对于Ubuntu，可以使用deb包；对于Windows，使用MSI。</p><h2><span id="定制化镜像">定制化镜像</span></h2><p>创建定制化虚拟机镜像：</p><p><img src="/2019/02/28/微服务设计/1552537789945.png" alt="1552537789945"></p><p>只需要构建一次镜像，然后根据这些镜像启动虚拟机，不需要再花费时间来安装相应的依赖，因为它们已经在镜像中安装好了。</p><p>如果你的核心依赖没有改变，那么新版本的服务就可以继续使用相同的基础镜像。</p><h3><span id="将镜像作为构建物">将镜像作为构建物</span></h3><p>把服务本身也包含在镜像中，这样就把镜像变成了构建物。</p><p>现在当你启动镜像时，服务就已经就绪了。</p><p>就像使用OS特定软件包那样，可以认为这些VM镜像是对不同技术栈的一层抽象。我们不需要关心运行在镜像中的服务所使用的语言是Ruby还是Java，我们唯一关心的就是它是否工作。然后把精力放在镜像创建和部署的自动化上即可。</p><h3><span id="不可变服务器">不可变服务器</span></h3><p>通过把配置都存到版本控制代码中，我们可以自动化重建服务，甚至重建整个环境。</p><p>但如果部署完成之后，有人登陆到机器上修改了一些东西，就会导致机器的实际配置和源代码管理中的配置不再一致，整个问题叫做配置漂移。</p><p>为了避免这个问题，可以禁止对任何运行的服务器做手动修改。</p><p>并且，无论修改多么小，都需要经过构建流水线来创建新的机器。</p><h2><span id="环境">环境</span></h2><p>不同环境中部署的服务是相同的，但是每个环境的用途却不一样。</p><p>从笔记本到UAT，再到生产环境，我们希望前面的环境都能不断地靠近生产环境，这样就可以更快地捕获到由于环境差异导致的问题。</p><p>类生产环境和快速反馈之间需要持续地做权衡。</p><h2><span id="服务配置">服务配置</span></h2><p>不同环境的配置差异，如何在部署流程中对其进行处理呢？</p><p>可以对每个环境创建不同的构建物，并把配置内建在该构建物中。</p><p>更好的方法是：只创建一个构建物，并将配置单独管理。</p><p>每个环境一个属性文件。</p><p>应对大量微服务时，这是个很好的方法，即使用专用系统来提供配置。</p><h2><span id="服务与主机之间的映射">服务与主机之间的映射</span></h2><h3><span id="单主机多服务">单主机多服务</span></h3><h3><span id="应用程序容器">应用程序容器</span></h3><h3><span id="每个主机一个服务">每个主机一个服务</span></h3><p><img src="/2019/02/28/微服务设计/1552544268022.png" alt="1552544268022"></p><h3><span id="平台即服务">平台即服务</span></h3><h2><span id="自动化">自动化</span></h2><h2><span id="从物理机到虚拟机">从物理机到虚拟机</span></h2><h2><span id="一个部署接口">一个部署接口</span></h2><p>不管用于部署的底层平台和构建物是什么，使用统一接口来部署给定的服务都是很关键的。</p><p>在很多场景下，都有触发部署的需求，从本地开发测试到生产环境部署。这些不同环境的部署机制应该尽量相似。</p><p>参数化的命令行调用是触发任何部署最合理的方式。可以使用CI工具或手动键入来触发脚本的调用。</p><p>部署脚本需要三个参数：</p><ul><li>部署物是什么？微服务的名字</li><li>把该微服务部署到哪个环境之中？</li><li>该微服务的版本信息</li></ul><p>假设，我们已经创建了一个这样的部署脚本。</p><p>在本地开发时，我们键入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deploy artifact=catalog environment=local version=local</span><br></pre></td></tr></table></figure><p>代码一旦提交，CI进行一次构建，生成一个新的构建物，其编号为b456。这个值会在整个流水线中传递。到了测试阶段，CI会执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deplog artifact=catalog environmet=ci version=b456</span><br></pre></td></tr></table></figure><p>环境定义：</p><h1><span id="测试">测试</span></h1><h1><span id="监控">监控</span></h1><h1><span id="安全">安全</span></h1><h1><span id="康威定律和系统设计">康威定律和系统设计</span></h1><h1><span id="规模化微服务">规模化微服务</span></h1><p>故障无处不在</p><p>何为太多</p><p>功能降级</p><p>架构安全</p><p>反脆弱</p><p>幂等</p><p>扩展</p><p>缓存</p><p>自动伸缩</p><p>CAP</p><p>服务发现</p><p>动态服务注册</p><p>文档服务</p><p>自描述</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;微服务&quot;&gt;微服务&lt;/span&gt;&lt;/h1&gt;&lt;h1&gt;&lt;span id=&quot;演化式架构师&quot;&gt;演化式架构师&lt;/span&gt;&lt;/h1&gt;&lt;h1&gt;&lt;span id=&quot;如何建模服务&quot;&gt;如何建模服务&lt;/span&gt;&lt;/h1&gt;&lt;h1&gt;&lt;span id=&quot;集成&quot;&gt;集成&lt;/span
      
    
    </summary>
    
    
  </entry>
  
</feed>
