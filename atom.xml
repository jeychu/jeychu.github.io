<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>javfa&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-13T02:16:49.465Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Javfa</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>proc目录详解</title>
    <link href="http://yoursite.com/2019/03/13/proc%E7%9B%AE%E5%BD%95%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/03/13/proc目录详解/</id>
    <published>2019-03-13T01:45:17.000Z</published>
    <updated>2019-03-13T02:16:49.465Z</updated>
    
    <content type="html"><![CDATA[<p>此篇为proc目录man手册内容的翻译。</p><p>持续更新。。。</p><p>proc-进程信息伪-文件系统</p><p>proc文件系统是内核数据结构的接口。通常挂载到/proc目录。其中大部分内容只读，也有一些文件可被修改从而变更相应的内核参数。</p><p>proc目录层次结构：</p><p><img src="/2019/03/13/proc目录详解/1552443342611.png" alt="1552443342611"></p><p>/proc/[pid]</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;此篇为proc目录man手册内容的翻译。&lt;/p&gt;
&lt;p&gt;持续更新。。。&lt;/p&gt;
&lt;p&gt;proc-进程信息伪-文件系统&lt;/p&gt;
&lt;p&gt;proc文件系统是内核数据结构的接口。通常挂载到/proc目录。其中大部分内容只读，也有一些文件可被修改从而变更相应的内核参数。&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>TCP状态详解</title>
    <link href="http://yoursite.com/2019/03/12/TCP%E7%8A%B6%E6%80%81%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/03/12/TCP状态详解/</id>
    <published>2019-03-12T13:42:31.000Z</published>
    <updated>2019-03-12T13:46:01.484Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CDN</title>
    <link href="http://yoursite.com/2019/03/12/CDN/"/>
    <id>http://yoursite.com/2019/03/12/CDN/</id>
    <published>2019-03-12T13:31:55.000Z</published>
    <updated>2019-03-12T13:31:55.494Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux性能优化之磁盘篇</title>
    <link href="http://yoursite.com/2019/03/12/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E7%A3%81%E7%9B%98%E7%AF%87/"/>
    <id>http://yoursite.com/2019/03/12/Linux性能优化之磁盘篇/</id>
    <published>2019-03-12T08:19:51.000Z</published>
    <updated>2019-03-13T05:16:18.891Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="linux文件系统是怎么工作的">Linux文件系统是怎么工作的？</span></h1><p>和CPU、内存一样，磁盘和文件系统的管理，也是操作系统最核心的功能。</p><ul><li>磁盘为系统提供了最基本的持久化存储；</li><li>文件系统则在磁盘的基础上，提供了一个用来管理文件的树状结构。</li></ul><h2><span id="索引节点和目录项">索引节点和目录项</span></h2><p>文件系统，本身是对存储设备上的文件进行组织管理的机制。组织方式的不同，就会形成不同的文件系统。</p><blockquote><p>在Linux中，一切皆文件：普通文件和目录、块设备、套接字、管道等都要通过统一的文件系统来管理。</p></blockquote><p>为了方便管理，Linux文件系统为每个文件都分配两个数据结构：</p><ul><li>索引节点<sup>index node</sup>：简称为inode，用来记录文件的元数据，比如inode编号、文件大小、访问权限、修改日期、数据的位置等。索引节点和文件一一对应，它跟文件内容一样，都会被持久化存储到磁盘中。所以，索引节点同样占用磁盘空间。</li><li>目录项<sup>dentry</sup>：用来记录文件的名字、索引节点指针以及与其他目录项的关联关系。多个关联的目录项，就构成了文件系统的目录结构。不过，不同于索引节点，目录项是由内核维护的一个<strong>内存数据结构</strong>，所以通常也被叫做目录项缓存。</li></ul><p>索引节点是每个文件的唯一标志，而目录项维护的是文件系统的树状结构。</p><p>目录项和索引节点的关系是多对一，即一个文件可以有多个别名。如硬链接。通过硬链接为文件创建别名，就会对应不同的目录项。这些目录项本质上链接到同一个文件，所以，它们的索引节点相同。</p><p>索引节点和目录项记录了文件的元数据和文件之间的目录关系，那文件数据到底又是怎么存储的呢？</p><p>磁盘读写的最小单位是扇区，而一个扇区只有512B的大小，如果每次都读写这么小的单位，效率是很低的。所以，文件系统把连续的扇区组成逻辑块，然后每次都以逻辑块为最小单位，来管理数据。</p><p>常见的逻辑块大小为4KB，也就是由连续的8个扇区组成。</p><p>目录项、索引节点以及文件数据的关系如下图所示：</p><p><img src="/2019/03/12/Linux性能优化之磁盘篇/1552381349393.png" alt="1552381349393"></p><p>需要注意的是：</p><ul><li>目录项本身就是一个内存缓存，而索引节点则是存储在磁盘中的数据。为了协调磁盘和CPU的性能差异，文件内容会被缓存到Cache中，这些索引节点自然也会缓存到内存中，加速文件的访问。</li><li>磁盘在执行文件系统格式化时，会被分成三个存储区域，超级块、索引节点区和数据块区。其中：<ul><li>超级块，存储整个文件系统的状态；</li><li>索引节点区，用来存储索引节点；</li><li>数据块区，则用来存储文件数据。</li></ul></li></ul><h2><span id="虚拟文件系统">虚拟文件系统</span></h2><p>目录项、索引节点、逻辑块以及超级块，构成了Linux文件系统的四大基本要素。</p><p>为了支持各种不同的文件系统，Linux内核在用户进程和文件系统之间，又引入了一个抽象层，也就是虚拟文件系统VFS<sup>Virtual File System</sup>。</p><p>Linux文件系统架构图：</p><p><img src="/2019/03/12/Linux性能优化之磁盘篇/1552382275869.png" alt="1552382275869"></p><p>在VFS之下，Linux支持各种各样的文件系统，如Ext4、XFS、NFS、ZFS。。。</p><p>按照存储位置的不同，这些文件系统可以分为三类：</p><ul><li>基于磁盘的文件系统，也就是把数据直接存储在计算机本地挂载的磁盘中。如：Ext4、XFS、OverlayFS等；</li><li>基于内存的文件系统，也就是虚拟文件系统。这类文件系统，不需要任何磁盘分配存储空间，但会占用内存。如/proc、/sys<sup>主要用于向用户空间导出层次化的内核对象</sup>；</li><li>网络文件系统，也就是用来访问其他计算机数据的文件系统，比如NFS、SMB、iSCSI等。</li></ul><p>这些文件系统，要先挂载到VFS目录树中的某个子目录<sup>称为挂载点</sup>，然后才能访问其中的文件。</p><h2><span id="文件系统io">文件系统IO</span></h2><p>文件读写方式的各种差异，导致IO的分类多种多样。常见的有：</p><ul><li><p>缓冲与非缓冲IO<sup>是否利用标准库缓存</sup>：</p><ul><li>缓冲IO，指利用标准库缓存来加速文件的访问，标准库内部再通过系统调度访问文件；</li><li>非缓冲IO，指直接通过系统调用来访问文件，不再经过标准库缓存。</li></ul><p>无论缓存IO还是非缓冲IO，最终还是要经过系统调用来访问文件。系统调用后，还会通过页缓存，来减少磁盘的IO操作。</p></li><li><p>直接与非直接IO<sup>是否利用操作系统的页缓存</sup>：</p><ul><li>直接IO，指跳过操作系统的页缓存，直接跟文件系统交互来访问文件；</li><li>非直接IO，文件读写时，先要经过系统的页缓存，然后再由内核或额外的系统调用，真正写入磁盘。</li></ul><p>在系统调用中，指定O_DIRECT标志，可以实现直接IO。如果没有设置过，默认是非直接IO。</p><p>直接IO和非直接IO，本质上还是和文件系统交互。如果是在数据库等场景中，还会有跳过文件系统读写磁盘的情况，也就是裸IO。</p></li><li><p>阻塞与非阻塞IO<sup>根据应用程序是否阻塞自身运行</sup>：</p><ul><li>阻塞IO，指应用程序之下IO操作后，如果没有获得响应，就会阻塞当前线程，自然就不能执行其他任务；</li><li>非阻塞IO，是指应用程序执行IO操作后，不会阻塞当前的线程，可以继续执行其他的任务，随后再通过轮询或者事件通知的形式，获取调用的结果。</li></ul><p>如：在访问管道或网络套接字时，设置O_NONBLOCK标志，就表示用非阻塞方式访问；如果不做任何设置，默认的是阻塞访问。</p></li><li><p>同步和异步IO<sup>根据是否等待响应结果</sup>：</p><ul><li>同步IO，指应用程序执行IO操作后，要一直等到整个IO完成后，才能获得IO响应；</li><li>异步IO，指应用程序执行IO操作后，不用等待完成和完成后的响应，而是继续执行就可以。等到这次IO完成后，响应会用事件通知的方式，告诉应用程序。</li></ul><p>如：在操作文件时，如果设置了O_SYNC或O_DSYNC标志，就代表同步IO。</p><p>在访问管道或网络套接字时，设置了O_ASYNC，就代表异步IO。</p></li></ul><h2><span id="如何查看文件系统的性能情况呢">如何查看文件系统的性能情况呢？</span></h2><h3><span id="容量">容量</span></h3><p>df</p><p><img src="/2019/03/12/Linux性能优化之磁盘篇/1552385605875.png" alt="1552385605875"></p><p>索引节点的容量<sup>inode的个数</sup>，是在格式化磁盘时设定好的，一般由格式化工具自动生成。当你发现索引节点空间不足，但磁盘空间充足时，很可能就是过多小文件导致的。</p><h3><span id="缓存">缓存</span></h3><p>/proc/meminfo</p><p><img src="/2019/03/12/Linux性能优化之磁盘篇/1552386039282.png" alt="1552386039282"></p><p>/proc/slabinfo</p><p><img src="/2019/03/12/Linux性能优化之磁盘篇/1552385847934.png" alt="1552385847934"></p><p>slabtop</p><p><img src="/2019/03/12/Linux性能优化之磁盘篇/1552385975568.png" alt="1552385975568"></p><h1><span id="linux磁盘io是怎么工作的">Linux磁盘IO是怎么工作的？</span></h1><h2><span id="磁盘">磁盘</span></h2><p>磁盘是可以持久化存储的设备，根据存储介质的不同，常见磁盘可以分为：</p><ul><li><p>机械磁盘，也称为硬盘驱动器<sup>Hard Disk Driver</sup>，通常缩写为HDD。机械磁盘主要由盘片和读写磁头组成，数据就存储在盘片的环状磁道中。在读写数据前，需要移动读写磁头，定位到数据所在的磁道，然后才能访问数据。</p><p>如果是连续IO，不需要磁道寻址，可以获得较好性能。对于随机IO，需要不停地移动磁头来定位数据位置，读写性能会比较差。</p><p>最小读写单位是扇区，一般为512字节。</p></li><li><p>固态磁盘<sup>Solid State Disk</sup>，通常缩写为SSD。由固态电子元器件组成。固态磁盘不需要磁道寻址，所以，不管是连续IO，还是随机IO的性能，都比机械磁盘要好很多。</p><p>最小读写单位是页，一般为4KB、8KB等。</p></li></ul><p>无论机械磁盘还是固态磁盘，相同磁盘的随机IO都要比连续IO慢得多，是因为：</p><ul><li>对机械磁盘来说，由于随机IO需要更多的磁头寻道和盘片旋转，它的性能自然要比连续IO慢；</li><li>对固态磁盘来说，虽然它的随机性能比机械硬盘好很多，但同样存在”先擦除再写入”的限制。随机读写会导致大量的垃圾回收，所以它的随机IO的性能比连续IO，还是差了很多。</li><li>连续IO还可以通过预读的方式，来减少IO请求的次数，这也是其性能优异的一个原因。</li></ul><p>按照接口来分类，可以分为：IDE<sup>Integrated Drive Electronics</sup>、SCSI<sup>Small Computer System Interface</sup>、SAS<sup>Serial Attached SCSI</sup>、SATA<sup>Serial ATA</sup>、FC<sup>Fibre Channel</sup>等。</p><p>不同的接口，往往分配不同的设备名称。比如，IDE设备以hd为前缀，SCSI和SATA以sd为前缀。多块同类型的磁盘，按照a、b、c等的字母顺序来编号。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;linux文件系统是怎么工作的&quot;&gt;Linux文件系统是怎么工作的？&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;和CPU、内存一样，磁盘和文件系统的管理，也是操作系统最核心的功能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;磁盘为系统提供了最基本的持久化存储；&lt;/li&gt;
&lt;li&gt;文件
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>在CentOS7上安装eBPF-tools,bcc和ply</title>
    <link href="http://yoursite.com/2019/03/12/%E5%9C%A8CentOS7%E4%B8%8A%E5%AE%89%E8%A3%85eBPF-tools-bcc%E5%92%8Cply/"/>
    <id>http://yoursite.com/2019/03/12/在CentOS7上安装eBPF-tools-bcc和ply/</id>
    <published>2019-03-12T03:27:49.000Z</published>
    <updated>2019-03-12T04:20:02.760Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>升级内核：</p><p>CentOS7的内核版本是3.x，要安装使用eBPF，bcc和ply，内核版本至少是4.9，所以需要先升级CentOS7的内核。详见<a href="https://jeychu.github.io/2019/03/11/CentOS7%E5%8D%87%E7%BA%A7%E5%86%85%E6%A0%B8/" target="_blank" rel="noopener">CentOS7升级内核</a>。</p></li><li><p>升级、安装开发工具：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y epel-release</span><br><span class="line">sudo yum update -y</span><br><span class="line">sudo yum groupinstall -y &quot;Development tools&quot;</span><br><span class="line">sudo yum install -y elfutils-libelf-devel iperf cmake3</span><br></pre></td></tr></table></figure></li><li><p>安装LLVM，clang，ply和bcc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/build</span><br><span class="line">cd ~/build</span><br><span class="line">git clone https://github.com/iovisor/ply.git</span><br><span class="line">cd ply</span><br><span class="line">./autogen.sh</span><br><span class="line"> export CFLAGS=-I$&#123;HOME&#125;/build/usr/include</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line">cd ..</span><br><span class="line">curl -LO http://releases.llvm.org/3.9.1/cfe-3.9.1.src.tar.xz</span><br><span class="line">curl -LO http://releases.llvm.org/3.9.1/llvm-3.9.1.src.tar.xz</span><br><span class="line">tar -xf cfe-3.9.1.src.tar.xz</span><br><span class="line">tar -xf llvm-3.9.1.src.tar.xz</span><br><span class="line">mkdir clang-build</span><br><span class="line">mkdir llvm-build</span><br><span class="line"></span><br><span class="line">cd llvm-build</span><br><span class="line">cmake3 -G &quot;Unix Makefiles&quot; -DLLVM_TARGETS_TO_BUILD=&quot;BPF;X86&quot; \</span><br><span class="line">  -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=/usr ../llvm-3.9.1.src</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line">cd ../clang-build</span><br><span class="line">cmake3 -G &quot;Unix Makefiles&quot; -DLLVM_TARGETS_TO_BUILD=&quot;BPF;X86&quot; \</span><br><span class="line">  -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=/usr ../cfe-3.9.1.src</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line">cd ..</span><br><span class="line">git clone https://github.com/iovisor/bcc.git</span><br><span class="line">mkdir bcc-build</span><br><span class="line">cd bcc-build</span><br><span class="line">cmake3 -G &quot;Unix Makefiles&quot; -DCMAKE_INSTALL_PREFIX=/usr ../bcc</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure></li><li><p>安装完成：</p><p><img src="/2019/03/12/在CentOS7上安装eBPF-tools-bcc和ply/1552362190205.png" alt="1552362190205"></p></li></ol><p>参考文献：</p><p><a href="http://hydandata.org/installing-ebpf-tools-bcc-and-ply-on-centos-7" target="_blank" rel="noopener">Installing eBPF tools, bcc and ply on CentOS 7</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;升级内核：&lt;/p&gt;
&lt;p&gt;CentOS7的内核版本是3.x，要安装使用eBPF，bcc和ply，内核版本至少是4.9，所以需要先升级CentOS7的内核。详见&lt;a href=&quot;https://jeychu.github.io/2019/03/11/Cent
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>systemtap</title>
    <link href="http://yoursite.com/2019/03/11/systemtap/"/>
    <id>http://yoursite.com/2019/03/11/systemtap/</id>
    <published>2019-03-11T09:45:32.000Z</published>
    <updated>2019-03-13T02:02:50.123Z</updated>
    
    <content type="html"><![CDATA[<p>此篇为systemtap的学习笔记，待更。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;此篇为systemtap的学习笔记，待更。。。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7升级内核</title>
    <link href="http://yoursite.com/2019/03/11/CentOS7%E5%8D%87%E7%BA%A7%E5%86%85%E6%A0%B8/"/>
    <id>http://yoursite.com/2019/03/11/CentOS7升级内核/</id>
    <published>2019-03-11T07:56:06.000Z</published>
    <updated>2019-03-12T04:16:40.991Z</updated>
    
    <content type="html"><![CDATA[<ol><li>当前版本</li></ol><p><img src="/2019/03/11/CentOS7升级内核/1552291068649.png" alt="1552291068649"></p><ol start="2"><li>开始升级：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</span><br></pre></td></tr></table></figure><p><img src="/2019/03/11/CentOS7升级内核/1552291299843.png" alt="1552291299843"></p><p><img src="/2019/03/11/CentOS7升级内核/1552291341907.png" alt="1552291341907"></p><p><img src="/2019/03/11/CentOS7升级内核/1552291401131.png" alt="1552291401131"></p><ol start="3"><li>将升级后的内核作为默认内核，重启机器</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># grub2-set-default 0</span><br><span class="line"># reboot</span><br></pre></td></tr></table></figure><ol start="4"><li>升级后的版本</li></ol><p><img src="/2019/03/11/CentOS7升级内核/1552353122161.png" alt="1552353122161"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;当前版本&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;/2019/03/11/CentOS7升级内核/1552291068649.png&quot; alt=&quot;1552291068649&quot;&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;开始升级：&lt;/li&gt;
&lt;/ol
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux性能优化之内存篇</title>
    <link href="http://yoursite.com/2019/03/10/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%86%85%E5%AD%98%E7%AF%87/"/>
    <id>http://yoursite.com/2019/03/10/Linux性能优化之内存篇/</id>
    <published>2019-03-10T11:05:56.000Z</published>
    <updated>2019-03-12T08:10:57.857Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#linux内存是怎么工作的">Linux内存是怎么工作的？</a><ul><li><a href="#内存映射">内存映射</a></li><li><a href="#虚拟内存空间分布">虚拟内存空间分布</a></li><li><a href="#内存分配与回收">内存分配与回收</a></li><li><a href="#如何查看内存使用情况">如何查看内存使用情况</a></li></ul></li><li><a href="#buffer和cache">Buffer和Cache</a></li><li><a href="#如何利用系统缓存优化程序的运行效率">如何利用系统缓存优化程序的运行效率</a></li></ul><!-- tocstop --><h1><span id="linux内存是怎么工作的">Linux内存是怎么工作的？</span></h1><p>内存管理是操作系统最核心的功能之一。内存主要用来存储系统和应用程序的指令、数据、缓存等。</p><p>Linux是怎么管理内存的呢？</p><h2><span id="内存映射">内存映射</span></h2><p>物理内存，也称为主存，大多数计算机用的主存都是动态随机访问内存（DRAM）。</p><p>只有内核才可以直接访问物理内存。进程要访问内存时，该怎么办呢？</p><p>Linux内核给每个进程都提供了一个独立的虚拟地址空间，并且这个地址空间是连续的。</p><p>进程可以很方便地访问虚拟内存。</p><p>虚拟地址空间的内部又被分为内核空间和用户空间两部分，不同字长（单个CPU指令可以处理数的最大长度）的处理器，虚拟地址空间的范围也不同。对于常见的32位和64位系统，它们的虚拟地址空间，如下所示：</p><p><img src="/2019/03/10/Linux性能优化之内存篇/1552216929887.png" alt="1552216929887"></p><p>既然每个进程都有一个这么大的地址空间，那么所有进程的虚拟内存加起来，自然要比实际的物理内存大得多。所以，并不是所有的虚拟内存都会分配物理内存，只有哪些实际使用的虚拟内存才分配物理内存，并且分配后的物理内存，是通过内存映射来管理的。</p><p>内存映射，就是将虚拟内存地址映射到物理内存地址。为了完成内存映射，内核为每个进程都维护了一张页表，记录虚拟地址与物理地址的映射关系，如下图所示：</p><p><img src="/2019/03/10/Linux性能优化之内存篇/1552216874797.png" alt="1552216874797"></p><p>页表存储在CPU的内存管理单元MMU中。</p><p>当进程访问的虚拟地址在页表中查不到时，系统会产生一个缺页异常，进入内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。</p><p>TLB是MMU中页表的高速缓存。由于进程的虚拟地址空间是独立的，而TLB的访问速度又比MMU快得多，所以，通过减少进程的上下文切换，减少TLB的刷新次数，就可以提高TLB缓存的使用率，进而提高CPU的内存访问性能。</p><p>MMU规定了内存映射的最小单位为页，通常是4KB大小，以页为单位来管理内存。这样，每一次内存映射，都需要关联4KB或4KB整数倍的内存空间。</p><p>页的大小只有4KB，整个页表非常大。比如，32位系统就需要100多万个页表项<sup>4GB/4KB=1048576</sup>，才可以实现整个地址空间的映射。</p><p>为了解决页表项过多的问题，Linux提供了两种机制：</p><ul><li><p><strong>多级页表</strong>：把内存分成区块来管理，将原来的映射关系改成区块索引和区块内的偏移。由于虚拟内存空间通常只用了很少一部分，那么，多级页表就只保持这些使用中的区块，这样就可以大大减少页表的项数。</p><p>Linux用四级页表来管理内存页，如下图所示，虚拟内存被分为5个部分，前4个表项用于选择页，而最后一个索引表示页内偏移。</p><p><img src="/2019/03/10/Linux性能优化之内存篇/1552218344165.png" alt="1552218344165"></p></li><li><p><strong>大页</strong></p><p>指的是比普通页更大的内存块，常见的大小有2MB和1GB。通常用在使用大量内存的进程上，如Oracle、DPDK等</p></li></ul><p>通过以上机制，在页表的映射下，进程就可以通过虚拟地址来访问物理内存了。那么，具体到一个Linux进程中，这些内存又是怎么使用的呢？</p><h2><span id="虚拟内存空间分布">虚拟内存空间分布</span></h2><p>虚拟内存空间的分布情况，以32位系统为例，如下所示：</p><p><img src="/2019/03/10/Linux性能优化之内存篇/1552218920555.png" alt="1552218920555"></p><p>最上方的是内核空间。虽然，每个进程的地址空间都包含了内核空间，但这些内核空间，其实关联的都是相同的物理内存。</p><p>下方的用户空间内存被划分成了多个不同的段。</p><p>从低到高分别是五种不同的内存段：</p><ol><li>只读段，包括代码和常量等；</li><li>数据段，包括全局变量等；</li><li>堆，包括动态分配的内存，从低地址开始向上增长；</li><li>文件映射段，包括动态库、共享内存等，从高地址开始向下增长；</li><li>栈，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是8MB。</li></ol><p>内存是怎么分配的呢？</p><h2><span id="内存分配与回收">内存分配与回收</span></h2><p>malloc()是C标准库提供的内存分配函数，对应到系统调用上，有两种实现方式，即brk()和mmap()。</p><ul><li><p>对于小块内存（小于128K），C标准库使用brk()来分配内存。也就是通过移动堆顶的位置来分配内存。这些内存释放后并不会立刻归还系统，而是被缓存起来，重复使用。</p><p>缓存的方式，可以减少缺页异常的发生，提高内存访问效率。</p><p>但是由于内存没有归还系统，易造成内存碎片。</p></li><li><p>对于大块内存（大于128K），则直接使用内存映射mmap()来分配。也就是在文件映射段找一块空闲内存分配出去。</p><p>由于释放时，直接归还系统，所以每次mmap都会发生缺页异常。</p><p>大量的缺页异常，使内核的管理负担增大。所以malloc只对大块内存使用mmap。</p></li></ul><p><strong>当这两种调用发生后，其实并没有真正分配内存。这些内存，都只是在首次访问时才被分配，也就是通过缺页异常进入内核中，再由内核来分配内存。</strong></p><p>内核使用伙伴系统来管理内存分配。和MMU一样，伙伴系统也是以页为单位进行管理，并且通过相邻块的合并，减少内存碎片化。</p><p>对于比页更小的对象，比如不到1K的时候，内核通过slab分配器来管理这些小内存。</p><p>对于内存来说，如果只分配而不释放，就会造成内存泄漏，甚至会耗尽系统内存。所以，在应用程序用完内存后，还需要调用free()或unmap()，来释放这些不用的内存。</p><p>在发现内存紧张时，系统会通过以下方式回收内存：</p><ul><li><p>回收缓存，比如使用LRU（Least Recently Used）算法，回收最近使用最少的内存页面；</p></li><li><p>回收不常访问的内存，把不常用的内存通过交换分区直接写到磁盘中。Swap把一块磁盘空间当成内存来用。从内存到磁盘称为换出，从磁盘读取到内存称为换入。</p></li><li><p>杀死进程，通过OOM（Out Of Memory），直接杀死占用大量内存的进程。内核使用oom_score为每个进程的内存使用情况进行评分：</p><ul><li>一个进程消耗的内存越大，oom_score就越大；</li><li>一个进程运行占用的CPU越大，oom_score就越小。</li></ul><p>oom_score越大，越容易被OOM杀死。</p><p>可以通过调整/proc/中进程的oom_adj来调整进程的oom_score。</p><p>oom_adj的范围为[-17, 15]，数值越大，越容易被OOM杀死；-17表示禁止OOM。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo -16 &gt; /proc/$(pidof sshd)/oom_adj</span><br></pre></td></tr></table></figure><p>将sshd进程的oom_adj调小为-16，以使sshd不容易被OOM杀死。</p></li></ul><h2><span id="如何查看内存使用情况">如何查看内存使用情况</span></h2><p>free</p><p><img src="/2019/03/10/Linux性能优化之内存篇/1552275955243.png" alt="1552275955243"></p><p>available不仅包含未使用的内存，还包括了可回收的缓存，所以一般会比未使用内存更大。不过，并不是所有缓存都可以回收，因为有些缓存可能正在使用中。</p><p>top</p><p><img src="/2019/03/10/Linux性能优化之内存篇/1552276016601.png" alt="1552276016601"></p><p>下面部分显示了每个进程的内存使用情况：</p><ul><li>VIRT是进程虚拟内存的大小，只要是进程申请过的内存，即便还没有真正分配物理内存，也会计算在内；</li><li>RES是常驻内存的大小，也就是进程实际使用的物理内存大小，但不包括Swap和共享内存；</li><li>SHR是共享内存的大小，比如与其他进程共同使用的共享内存、加载的动态链接库以及程序的代码段等；需要注意的是，SHR并不一定是共享的，程序的代码段、非共享的动态链接库，也都计算在SHR里。</li><li>%MEM是进程使用物理内存占系统总内存的百分比。</li></ul><h1><span id="buffer和cache">Buffer和Cache</span></h1><p><strong>磁盘读写的缓冲为</strong>Buffer</p><p><strong>文件读写的缓存为</strong>Cache</p><p>注意磁盘读写和文件读写的不同：</p><blockquote><p>磁盘是块设备，可以划分分区，在分区之上再创建文件系统，挂载到某个目录，就可以在这个目录中读写文件。</p></blockquote><p>读写文件时，会经过文件系统，由文件系统和磁盘交互；</p><p>读写磁盘或分区时，会跳过文件系统，也就是裸IO。</p><p>二者所用缓存是不同的。</p><p>Buffer和Cache的设计目的，是为了系统的IO性能。它们利用内存，充当起慢速磁盘和快速CPU之间的桥梁，可以加速IO的访问速度。</p><p>Buffer和Cache分别缓存的是对磁盘和文件系统的读写数据。</p><ul><li>从写的角度来说，不仅可以优化磁盘和文件的写入，对应用程序也有好处，应用程序可以在数据真正落盘前，就返回去做其他工作；</li><li>从度的角度来说，不仅可以提高那些频繁访问数据的读取速度，也降低了频繁IO对磁盘的压力。</li></ul><h1><span id="如何利用系统缓存优化程序的运行效率">如何利用系统缓存优化程序的运行效率</span></h1><p>缓存命中率，指直接通过缓存获取数据的请求次数，占所有数据请求次数的百分比。</p><p>命中率越高，表示使用缓存带来的收益越高，应用程序的性能也就越好。</p><p>实际上，缓存是现在所有高并发系统必需的核心模块，主要作用就是把经常访问的数据（也就是热点数据），提前读入到内存中。以加快应用程序的响应速度。</p><p>缓存分析工具：cachestat和pcstat</p><p>cachestat在CentOS7上的安装详见：<a href="https://jeychu.github.io/2019/03/12/%E5%9C%A8CentOS7%E4%B8%8A%E5%AE%89%E8%A3%85eBPF-tools-bcc%E5%92%8Cply/" target="_blank" rel="noopener">在CentOS7上安装eBPF-tools,bcc和ply</a></p><p>pcstat的安装：</p><ol><li>安装go语言：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wget https://studygolang.com/dl/golang/go1.11.5.linux-amd64.tar.gz</span><br><span class="line">mkdir /opt/go</span><br><span class="line">tar -xvf go1.11.5.linux-amd64.tar.gz -C /opt/go</span><br><span class="line">mkdir /root/gopath</span><br><span class="line">vim /etc/profile</span><br><span class="line">export GOROOT=/opt/go/go</span><br><span class="line">   export PATH=$PATH:$GOROOT/bin</span><br><span class="line">   export GOPATH=/root/gopath</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><p>​         安装完成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@es gopath]# go version</span><br><span class="line">go version go1.11.5 linux/amd64</span><br></pre></td></tr></table></figure><ol start="2"><li>安装pcstat：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir /root/gopath/golang.org/</span><br><span class="line">cd /root/gopath/golang.org</span><br><span class="line">git clone https://github.com/golang/sys.git</span><br><span class="line">go get github.com/tobert/pcstat/pcstat</span><br><span class="line">export PATH=$PATH:/root/gopath/bin</span><br></pre></td></tr></table></figure><p>​           安装完成：</p><p><img src="/2019/03/10/Linux性能优化之内存篇/1552368584437.png" alt="1552368584437"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#linux内存是怎么工作的&quot;&gt;Linux内存是怎么工作的？&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#内存映射&quot;&gt;内存映射&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#虚拟内存空间分布&quot;&gt;虚拟内存空间分布&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>MySQL的监控</title>
    <link href="http://yoursite.com/2019/03/09/MySQL%E7%9A%84%E7%9B%91%E6%8E%A7/"/>
    <id>http://yoursite.com/2019/03/09/MySQL的监控/</id>
    <published>2019-03-08T18:05:10.000Z</published>
    <updated>2019-03-09T06:17:27.047Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL</p><p>监控哪些内容？</p><ul><li>数据库服务的可用性</li><li>数据库性能</li><li>主从同步的情况</li><li>服务器的资源</li><li></li></ul><p>怎么监控？</p><p>调优</p><p>先找出瓶颈所在，然后针对瓶颈做出优化</p><p>如何找瓶颈？</p><p>利用top ps vmstat iostat netstat /proc/</p><p>然后用perf strace ltrace systemtap 追踪进程 定位函数</p><p>zabbix添加自定义监控项</p><p>写脚本 -&gt; 在agentd.conf中添加UserParameter -&gt; 在server中用zabbix-get测试 -&gt;在web添加item和graph</p><p>故障排查思路：</p><p>网络 DNS解析是否正常 ping延时</p><p>主机</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;MySQL&lt;/p&gt;
&lt;p&gt;监控哪些内容？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据库服务的可用性&lt;/li&gt;
&lt;li&gt;数据库性能&lt;/li&gt;
&lt;li&gt;主从同步的情况&lt;/li&gt;
&lt;li&gt;服务器的资源&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;怎么监控？&lt;/p&gt;
&lt;p&gt;调优&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>The Kernel of Nginx之用好浏览器的缓存</title>
    <link href="http://yoursite.com/2019/03/06/The-Kernel-of-Nginx%E4%B9%8B%E7%94%A8%E5%A5%BD%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98/"/>
    <id>http://yoursite.com/2019/03/06/The-Kernel-of-Nginx之用好浏览器的缓存/</id>
    <published>2019-03-06T03:02:25.000Z</published>
    <updated>2019-03-08T12:57:26.489Z</updated>
    
    <content type="html"><![CDATA[<p>浏览器的缓存与nginx缓存</p><ul><li><p>浏览器缓存</p><ul><li>优点：<ul><li>使用有效缓存时，没有网络消耗，速度最快</li><li>即使有网络消耗，但对失效缓存使用304响应做到网络流量消耗最小化</li></ul></li><li>缺点：<ul><li>只提升一个用户的体验</li></ul></li></ul></li><li><p>Nginx缓存</p><ul><li>优点<ul><li>提升所有用户的体验</li><li>相比浏览器缓存，有效降低上游服务的负载</li><li>通过304响应减少Nginx与上游服务间的流量消耗</li></ul></li><li>缺点<ul><li>用户仍然保持网络消耗</li></ul></li></ul></li></ul><p>同时使用浏览器和Nginx缓存</p><p>浏览器缓存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 浏览器请求</span><br><span class="line">op1=&gt;operation: 有缓存</span><br><span class="line">op2=&gt;operation: 向浏览器请求带If-None_Match</span><br><span class="line">op3=&gt;operation: 向浏览器请求带If-Modified-Since</span><br><span class="line">op4=&gt;operation: 从缓存读取 200（from cache）</span><br><span class="line">op5=&gt;operation: 向web服务器请求</span><br><span class="line">op6=&gt;operation: 请求响应，缓存协商</span><br><span class="line">op7=&gt;operation: 从缓存读取</span><br><span class="line">con1=&gt;condition: 是否过期？</span><br><span class="line">con2=&gt;condition: Etag？</span><br><span class="line">con3=&gt;condition: Last-Modified？</span><br><span class="line">con4=&gt;condition: 200 or 304？</span><br><span class="line">end=&gt;end: 呈现</span><br><span class="line">st-&gt;op1-&gt;con1</span><br><span class="line">con1(no)-&gt;op4-&gt;end</span><br><span class="line">con1(yes)-&gt;con2</span><br><span class="line">con2(yes)-&gt;op2-&gt;con4</span><br><span class="line">con2(no)-&gt;con3</span><br><span class="line">con3(yes)-&gt;op3-&gt;con4</span><br><span class="line">con3(no)-&gt;op5-&gt;op6</span><br><span class="line">con4(yes)-&gt;op6</span><br><span class="line">con4(no)-&gt;op7-&gt;end</span><br><span class="line">op6-&gt;end</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax： etag on|off;</span><br><span class="line">Default: etag on;</span><br><span class="line">Context: http, server, location</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ngx_sprintf(etag-&gt;value.data, <span class="string">"\"%xT-%xO\""</span>,</span><br><span class="line">           r-&gt;headers_out.last_modified_time,</span><br><span class="line">           r-&gt;headers_out.contect_length_n)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;浏览器的缓存与nginx缓存&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;浏览器缓存&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：&lt;ul&gt;
&lt;li&gt;使用有效缓存时，没有网络消耗，速度最快&lt;/li&gt;
&lt;li&gt;即使有网络消耗，但对失效缓存使用304响应做到网络流量消耗最小化&lt;/li&gt;
&lt;/ul&gt;
&lt;/
      
    
    </summary>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx的优化</title>
    <link href="http://yoursite.com/2019/03/06/nginx%E7%9A%84%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/03/06/nginx的优化/</id>
    <published>2019-03-06T02:26:22.000Z</published>
    <updated>2019-03-10T17:26:17.399Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="基本安全优化">基本安全优化</span></h1><h2><span id="隐藏版本信息">隐藏版本信息</span></h2><h2><span id="更改nginx服务的默认用户">更改Nginx服务的默认用户</span></h2><h2><span id="降权启动nginx">降权启动Nginx</span></h2><h1><span id="参数优化nginx服务性能">参数优化Nginx服务性能</span></h1><h2><span id="进程个数-单个进程的最大连接数">进程个数、单个进程的最大连接数</span></h2><h2><span id="绑定cpu">绑定CPU</span></h2><h2><span id="gzip">gzip</span></h2><h2><span id="expires">expires</span></h2><h1><span id="日志的优化">日志的优化</span></h1><h1><span id="防盗链">防盗链</span></h1><h1><span id="防爬虫">防爬虫</span></h1><h1><span id="目录权限优化">目录权限优化</span></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;基本安全优化&quot;&gt;基本安全优化&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span id=&quot;隐藏版本信息&quot;&gt;隐藏版本信息&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span id=&quot;更改nginx服务的默认用户&quot;&gt;更改Nginx服务的默认用户&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;
      
    
    </summary>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>无之文</title>
    <link href="http://yoursite.com/2019/03/04/%E6%97%A0%E9%A2%98/"/>
    <id>http://yoursite.com/2019/03/04/无题/</id>
    <published>2019-03-03T16:28:27.000Z</published>
    <updated>2019-03-13T08:07:25.777Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>‘无意识流’<sup>自撰</sup>码点字儿，权当消遣、游戏。</p><p>具体写些什么，写出什么，我自己也是不知道的。</p><p>不断填充，每更以时间戳为领。</p></blockquote><!-- toc --><ul><li><a href="#1934">19/3/4</a></li><li><a href="#1935">19/3/5</a></li><li><a href="#1936">19/3/6</a></li><li><a href="#1938">19/3/8</a></li><li><a href="#1939">19/3/9</a></li><li><a href="#19310">19/3/10</a></li><li><a href="#19312">19/3/12</a></li><li><a href="#19313">19/3/13</a></li></ul><!-- tocstop --><h1><span id="1934">19/3/4</span></h1><p>老夫聊发少年狂，不自量，频思量，要和困滞斗一场<br>人生不如意十八九，又何必，妄自沉，且奋起，争朝夕，人生百年是不枉</p><p>内核源码纷上阵，战得个天昏又地暗<br>人道是，廿一世纪，人工智能日日新，所能之事无限<br>现如今，百业俱兴于互联网<br>信息流转无量，人人都是网中虫<br>码农立功改了世界，创了互联界，人神之间自此有了个第三界</p><p>微信淘宝千百度，淘了个什么，又信了个什么？<br>大小屏幕满城皆是，人人淹没其间。<br>要在屏幕引源流，码农誓要战到深夜，不眠不休。</p><p>王者荣耀坑起来，坑到王者亦非常人也<br>鲁班后羿虽善射，易被珂切<br>项羽是个霸王，本色是喜欢虞姬<br>妲己是个妖女，总想一套秒<br>凯也是个肉，打不死还善单挑<br>典韦疯癫，满场飞奔…</p><p>恩金克思是个宝<br>鲁啊美月协助跑<br>林刘克思做服务<br>韦伯搞网成了王</p><hr><h1><span id="1935">19/3/5</span></h1><p>iHola!</p><p>¿Como estas?</p><p>香尘已隔犹回面<br>居人匹马映林嘶</p><p>新绿小池塘<br>帘动、碎影、斜阳<br>金屋去来 旧时巢燕<br>土花缭绕 前度霉墙<br>绣阁凤帷理丝簧</p><p>天寒水鸟自相依<br>十百为群戏落辉<br>行人过尽都不起<br>忽闻水响一起飞</p><p>携杖来追凉<br>花桥倚胡床<br>船笛参差起<br>池莲自在香</p><hr><h1><span id="1936">19/3/6</span></h1><p>知海无涯<br>海里行<br>无向即无功<br>看四周，都是极似<br>手中罗盘<br>历历晰晰<br>准方向<br>不旁骛<br>自可离海登陆<br>船体牢靠<br>方向笃定<br>定成航海王，掌控自生</p><hr><p>不自怨艾，稳住，都将烟消云散<br>云开日现<br>金晖永在，云遮不显<br>拨云自可见日<br>谁可拨？<br>大风耶？大风起兮云飞扬<br>大风来，尘土混乌云，暗无天日<br>小风耶？和风暖阳，自是佳时<br>小风何来？自来也<br>拨云见日者，非人力<br>人自求福，不自作孽，静待日开，得其光<br>但日总在，不因云遮就无<br>光透云，人依然可得其几许<br>故莫担心，莫贪心，莫失心<br>阴晴才是此间正道<br>阴晴都是那颗太阳</p><hr><h1><span id="1938">19/3/8</span></h1><p>二月二日 三八女节<br>雌雄合一 天地交泰<br>龙飞凤舞 双翔呈瑞<br>元亨利贞 吉吉吉吉</p><hr><h1><span id="1939">19/3/9</span></h1><p>痛通，痛得不欲生，就通了<br>自不量力者，撞的头破血流，心痛通</p><p>太阳照常升起，逝者从未停歇<br>珍惜光阴，涓滴莫弃<br>昨天已不复存在，明天从未到来，唯有今天，才是所有</p><p>乱 清理 有序<br>减 减 减<br>只剩一个 所向披靡</p><p>不家 于外 往西行</p><hr><h1><span id="19310">19/3/10</span></h1><p>喜鹊上下游嬉<br>貔貅口衔红币<br>金蟾门口招财<br>晶洞坐镇玄武<br>金鸡雄立西方</p><p>尼采句，大乱写：</p><p>能飞之人向上飞<br>于不能飞之人看来，<br>愈高愈渺</p><p>凝视深渊，深渊亦然<br>与恶魔斗，慎成恶魔</p><p>每天<br>若不曾起舞<br>即是<br>辜负了生命</p><p>谦逊基于力量<br>傲慢基于无能</p><p>世界弥漫着焦躁不安，因众人皆急于从各自的枷锁中获得解放</p><p>不懂自己才是生命中最难的部分</p><p>曲则全，要曲莫直，曲曲折折，真理渐得显现</p><p>埋怨自己、憎恨他人之时。。。你需要休息了！</p><p>无有音乐，生活是错</p><p>智慧是个女人，她只爱战士——愿你勇敢、无忧、刚强</p><p>明为何而活，自可承受一切，幸与不幸</p><p>受苦之人，没有悲观的权力</p><hr><h1><span id="19312">19/3/12</span></h1><blockquote><p>引子：欲休息，偶翻莎翁十四行诗，译之，或可读？</p></blockquote><blockquote><p>前方高能：催婚催育，歌颂爱情！</p></blockquote><p>// 赞美爱人也</p><p>Shall I compare you to a summer’s day?<br>You are more lovely and more temperate:<br>Rough winds do shake the darling buds of May,<br>And summer’s lease has all too short a date;<br>Sometime too hot the eye of heaven shines,<br>And often is his gold complexion dimm’d<br>And every fair from fair sometime declines,<br>By chance or nature’s changing course untrimm’d:<br>But your eternal summer shall not fade,<br>Nor lose possession of that fair you own,<br>Nor shall Death brag you wand’rest in his shade,<br>When in eternal lines to time you grow’st.<br>So long as men can breathe or eyes can see,<br>So long lives this, and this gives life to you.</p><p>将你比作夏天？<br>你更美好温和：<br>强风摧折五月可爱花蕾，<br>夏之为期也是太过短暂。<br>日光有时太炙，<br>金色时常被霾。<br>美丽总要逝去，<br>不测或是自然。<br>但你常住之夏永不退，<br>你所有之美也将不失。<br>当你在这不朽诗篇中和时间合为一，<br>死神休大言说你在他的阴影里盘桓。<br>只要有人能看能呼吸，<br>此诗长存并予你生命。</p><p>// 谴责单身主义者也</p><p>From fairest creatures we desire increase,<br>That thereby beauty’s rose might never die,<br>But as the riper should by time decrease,<br>His tender heir might bear his memory:<br>But you, contracted to your own bright eyes,<br>Feed your light’s flame with self-substantial fuel,<br>Making a famine where abundance lies,<br>Yourself your foe, to your sweet self too cruel.<br>You that art now the world’s fresh ornament,<br>And only herald to the gaudy spring,<br>Within your own bud buried your content,<br>And, tender churl, make waste in niggarding:<br>Pity the world, or else this glutton be,<br>To eat the world’s due, by the grave and you.</p><p>美好藩息【好为第四声】<br>美瑰不死。<br>黄熟凋零<br>幼子承继。<br>只从你目<br>以己为柴<br>大烧目火。<br>丰地饥馑<br>尔实尔敌<br>残对汝身。<br>世之璀璨<br>春之先使<br>却事埋藏。<br>温柔残暴<br>吝啬浪费。<br>怜悯此世<br>若不怜世<br>实为贪夫<br>世所应得<br>汝墓及汝<br>尽将蚕食</p><hr><h1><span id="19313">19/3/13</span></h1><p>// 赞生育也，生育使美延续</p><p>When forty winters shall besiege your brow,<br>And dig deep trenches in your beauty’s field,<br>Your youth’s proud livery, so gazed on now,<br>Will be a tattered weed of small worth held:<br>Then being asked, where all your beauty lies,<br>Where all the treasure of your lusty days,<br>To say within your own deep-sunken eyes<br>Were an all-eating shame, and thriftless praise.<br>How much more praise deserved your beauty’s use,<br>If you could answer, “This fair child of mine<br>Shall sum my count, and make my old excuse,”<br>Proving his beauty by your succession.<br>This were to be new made when you are old,<br>And see your blood warm when you feel it cold.</p><p>四十个冬天将使你美丽的额头<br>沟壑起伏<br>你的青春华服，众所倾羡<br>也将破烂如杂草毫无价值<br>彼时，若被问：<br>你的美何在？<br>你光辉岁月的珍宝何在？<br>你深陷的眼窝里，<br>只有些能吞噬所有的羞耻和毫无意义的赞美。<br>但如果你能说，我美丽的孩子就是我的总结，<br>宽恕我的老迈，继承我的美<br>如此，你的美应得更多赞誉<br>当你老时，这就是新生<br>当你冷时，这使你热血</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;‘无意识流’&lt;sup&gt;自撰&lt;/sup&gt;码点字儿，权当消遣、游戏。&lt;/p&gt;
&lt;p&gt;具体写些什么，写出什么，我自己也是不知道的。&lt;/p&gt;
&lt;p&gt;不断填充，每更以时间戳为领。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Nginx中的位运算</title>
    <link href="http://yoursite.com/2019/03/02/Nginx%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>http://yoursite.com/2019/03/02/Nginx和位运算/</id>
    <published>2019-03-02T10:39:45.000Z</published>
    <updated>2019-03-03T18:01:08.912Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇是学习<a href="https://www.jishuwen.com/d/2EGC/zh-hk" target="_blank" rel="noopener">其他博文</a>的笔记，根据自己的理解，做了些增补和简化。</p></blockquote><p>位运算在Nginx的源码处处可见，如</p><ul><li><p>定义指令的类型</p></li><li><p>标记当前请求是否还有未发送完的数据</p></li><li><p>事件模块里用指针的最低位来标记一个事件是否过期</p></li></ul><p>下面分析以下在Nginx中位运算的经典使用场景。</p><h1><span id="经典使用场景">经典使用场景</span></h1><h2><span id="对齐">对齐</span></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/ngx_config.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_align(d, a)     (((d) + (a - 1)) &amp; ~(a - 1))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_align_ptr(p, a)                                                    \</span></span><br><span class="line">    (u_char *) (((<span class="keyword">uintptr_t</span>) (p) + ((<span class="keyword">uintptr_t</span>) a - <span class="number">1</span>)) &amp; ~((<span class="keyword">uintptr_t</span>) a - <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>该宏使得d按a对齐<sup>第一个大于等于d的a倍数</sup>，其中a必须是2的幂次。</p><p>此宏就是寻找最小的且大于等于d的a的倍数。</p><p>由于a是2的幂次，因此a的二进制表示为00…1…00这样的形式，即它只有一个1，a-1便是00…01…1这样的形式。</p><p>接着，~(a-1)就会将低n为全部置0，n为a的低位连续0的个数。</p><p>此时，如果再将一个数和~（a-1）进行一次按位与，就能把这个数的低n位都清零（即成为a的倍数）。</p><p>而把这个数的低n位都清零，最多是从这个数减去a-1。</p><p>故而，d+（a-1）在经过和~（a-1）按位与而做了清零操作之后，最多也是减去a-1，也就是说，经过低位清零之后，其值最小是d，这样我们就得到了一个大于等于d，且低n位是0的对齐数，即一个大于等于d的a倍数。且是第一个大于等于d的a的倍数。</p><h2><span id="位图">位图</span></h2><p>位图，用以标记状态，只使用一个比特位来标记事物，从而节约内存，提升性能。</p><p>Nginx在对uri进行转义时，需要判断一个字符是否是一个保留字符，这样的字符需要被转义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// src/core/ngx_string.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint32_t</span>   uri_component[] = &#123;</span><br><span class="line">        <span class="number">0xffffffff</span>, <span class="comment">/* 1111 1111 1111 1111  1111 1111 1111 1111 */</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* ?&gt;=&lt; ;:98 7654 3210  /.-, +*)( '&amp;%$ #"!  */</span></span><br><span class="line">        <span class="number">0xfc009fff</span>, <span class="comment">/* 1111 1100 0000 0000  1001 1111 1111 1111 */</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* _^]\ [ZYX WVUT SRQP  ONML KJIH GFED CBA@ */</span></span><br><span class="line">        <span class="number">0x78000001</span>, <span class="comment">/* 0111 1000 0000 0000  0000 0000 0000 0001 */</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">/*  ~&#125;| &#123;zyx wvut srqp  onml kjih gfed cba` */</span></span><br><span class="line">        <span class="number">0xb8000001</span>, <span class="comment">/* 1011 1000 0000 0000  0000 0000 0000 0001 */</span></span><br><span class="line"></span><br><span class="line">        <span class="number">0xffffffff</span>, <span class="comment">/* 1111 1111 1111 1111  1111 1111 1111 1111 */</span></span><br><span class="line">        <span class="number">0xffffffff</span>, <span class="comment">/* 1111 1111 1111 1111  1111 1111 1111 1111 */</span></span><br><span class="line">        <span class="number">0xffffffff</span>, <span class="comment">/* 1111 1111 1111 1111  1111 1111 1111 1111 */</span></span><br><span class="line">        <span class="number">0xffffffff</span>  <span class="comment">/* 1111 1111 1111 1111  1111 1111 1111 1111 */</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>如上所示，一个数组组成一个位图，共包含8各数字，每个数字表示32个状态，因此这个位图标识出了256个字符的状态。为0的位表示一个通用字符，不需要转义，为1的位代表该字符需要转义。<br>如何使用这个位图呢？Nginx在遍历uri的时候，通过一条简单的语句来进行判断：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uri_component[ch &gt;&gt; <span class="number">5</span>] &amp; (<span class="number">1</span> &lt;&lt; (ch &amp; <span class="number">0x1f</span>))</span><br></pre></td></tr></table></figure><p>如上所示，ch表示当前字符，ch&gt;&gt;5是对ch右移5位，这起到一个除以32的效果，这一步操作确定了ch在uri_component的第几个数字上；</p><p>ch&amp;0x1f，则是取出ch低5位的值，相当于取模32，这个值表示ch在对应数字上的第几位；</p><p>1&lt;&lt;(ch&amp;0x1f)，将1左移ch在对应数字上的所在位数。将该数和对应数字相与，就可以取出对应数字上与ch相对应位置的bit位。</p><p>如：ch是‘0’（即数字48），它存在于位图的第二个数字上（48&gt;&gt;5=1)，又在这个数字（0xfc009fff）的第16位上，所以它的状态就是0xfc009fff &amp; 0x10000 = 0，所以‘0’是个通用字符，不用对它转义。</p><blockquote><p>位运算技巧：对一个2的幂次的数进行取模或者除操作的时候，可以通过位运算来实现。</p></blockquote><h2><span id="寻找最低位1的位置">寻找最低位1的位置</span></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; ~(x - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>~(x-1)使得除了最低位1的那个位置，其他位置和x都是相反的，因此二者进行按位与操作后，结果里只可能有一个1，便是原本x最低位的1。</p><h2><span id="寻找最高位1的位置">寻找最高位1的位置</span></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> bsf(<span class="keyword">size_t</span> input)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span> pos;</span><br><span class="line"></span><br><span class="line">    __asm__(<span class="string">"bsfq %1, %0"</span> : <span class="string">"=r"</span> (pos) : <span class="string">"rm"</span> (input));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">size_t bsf(size_t input)</span><br><span class="line">&#123;</span><br><span class="line">    input |= input &gt;&gt; 1;</span><br><span class="line">    input |= input &gt;&gt; 2;</span><br><span class="line">    input |= input &gt;&gt; 4;</span><br><span class="line">    input |= input &gt;&gt; 8;</span><br><span class="line">    input |= input &gt;&gt; 16;</span><br><span class="line">    input |= input &gt;&gt; 32;</span><br><span class="line"></span><br><span class="line">    return input - (input &gt;&gt; 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="计算1的个数">计算1的个数</span></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本篇是学习&lt;a href=&quot;https://www.jishuwen.com/d/2EGC/zh-hk&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;其他博文&lt;/a&gt;的笔记，根据自己的理解，做了些增补和简化。&lt;/p&gt;
&lt;/bloc
      
    
    </summary>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>微服务设计</title>
    <link href="http://yoursite.com/2019/02/28/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2019/02/28/微服务设计/</id>
    <published>2019-02-28T14:53:03.000Z</published>
    <updated>2019-02-28T15:02:21.320Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="微服务">微服务</span></h1><h1><span id="演化式架构师">演化式架构师</span></h1><h1><span id="如何建模服务">如何建模服务</span></h1><h1><span id="集成">集成</span></h1><h1><span id="分解单块系统">分解单块系统</span></h1><h1><span id="部署">部署</span></h1><h1><span id="测试">测试</span></h1><h1><span id="监控">监控</span></h1><h1><span id="安全">安全</span></h1><h1><span id="康威定律和系统设计">康威定律和系统设计</span></h1><h1><span id="规模化微服务">规模化微服务</span></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;微服务&quot;&gt;微服务&lt;/span&gt;&lt;/h1&gt;&lt;h1&gt;&lt;span id=&quot;演化式架构师&quot;&gt;演化式架构师&lt;/span&gt;&lt;/h1&gt;&lt;h1&gt;&lt;span id=&quot;如何建模服务&quot;&gt;如何建模服务&lt;/span&gt;&lt;/h1&gt;&lt;h1&gt;&lt;span id=&quot;集成&quot;&gt;集成&lt;/span
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript In A Nutshell</title>
    <link href="http://yoursite.com/2019/02/26/JavaScript-In-A-Nutshell/"/>
    <id>http://yoursite.com/2019/02/26/JavaScript-In-A-Nutshell/</id>
    <published>2019-02-25T17:49:28.000Z</published>
    <updated>2019-03-02T07:54:16.741Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="基础">基础</span></h1><h2><span id="运行时页面构建过程">运行时页面构建过程</span></h2><h3><span id="生命周期概览">生命周期概览</span></h3><p><img src="/2019/02/26/JavaScript-In-A-Nutshell/1551510836738.png" alt="1551510836738"></p><p>客户端Web应用的周期从用户指定某个网站地址开始，由两个步骤组成：<strong>页面构建和事件处理</strong>。</p><p>来个例子，这个例子展示：每当用户移动鼠标或单击页面就会显示一条消息。</p><p>以下是代码：</p><p><img src="/2019/02/26/JavaScript-In-A-Nutshell/1551511209573.png" alt="1551511209573"></p><p>以下是运行和交互结果：</p><p><img src="/2019/02/26/JavaScript-In-A-Nutshell/1551512582730.png" alt="1551512582730"></p><h3><span id="页面构建阶段">页面构建阶段</span></h3><p>该阶段的目标是建立web应用的UI，主要包括两个步骤：</p><ul><li>解析HTML代码并构建文档对象模型（DOM）；</li><li>执行JavaScript代码。</li></ul><p><img src="/2019/02/26/JavaScript-In-A-Nutshell/1551512933518.png" alt="1551512933518"></p><p><img src="/2019/02/26/JavaScript-In-A-Nutshell/1551513184204.png" alt="1551513184204"></p><h3><span id="事件处理">事件处理</span></h3><h1><span id="理解函数">理解函数</span></h1><p>定义与参数</p><p>理解函数调用</p><p>闭包和作用域</p><p>生成器和promise</p><h1><span id="钻研对象">钻研对象</span></h1><p>面向对象与原型</p><p>控制对象的访问</p><p>处理集合</p><p>正则表达式</p><p>代码模式化</p><h1><span id="洞悉浏览器">洞悉浏览器</span></h1><p>DOM操作</p><p>事件</p><p>跨浏览器的开发技巧</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;基础&quot;&gt;基础&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span id=&quot;运行时页面构建过程&quot;&gt;运行时页面构建过程&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span id=&quot;生命周期概览&quot;&gt;生命周期概览&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/2019/02/
      
    
    </summary>
    
    
      <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Nginx的配置</title>
    <link href="http://yoursite.com/2019/02/21/Nginx%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/02/21/Nginx的配置/</id>
    <published>2019-02-21T15:21:21.000Z</published>
    <updated>2019-02-24T12:50:13.731Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="运行中的nginx进程间的关系">运行中的Nginx进程间的关系</span></h1><p>在正式提供服务的产品环境中，部署Nginx时都是使用一个master进程来管理多个worker进程，一般情况下，worker进程的数量与服务器上的CPU核心数相等。每一个worker进程都时繁忙的，它们在真正地提供互联网服务，master进程则很“清闲”，只负责监控管理worker进程。worker之间通过共享内存、原子操作等一些进程间通信机制来实现负载均衡等功能。</p><p>Nginx是支持单进程（master进程）提供服务的，那么为什么产品环境下要按照master、worker方式配置同时启动多个进程呢？这样做的好处主要有一下两点：</p><ul><li>由于master进程不会对用户请求提供服务，只用于管理真正提供服务的worker进程，所以master进程可以是唯一的，它仅专注于自己的纯管理工作，为管理员提供命令行服务，包括诸如启动服务、停止服务、重新配置文件、平滑升级程序等。master进程需要拥有较大的权限，例如，通常会使用root用户启动master进程。worker进程的权限要小于或者等于master进程，这样master进程才可以完全地管理worker进程。当任意一个worker进程出现错误从而导致coredump时，master进程会立刻启动新的worker进程继续服务。</li><li>多个worker进程处理互联网请求不但可以提高服务的健壮性，最重要的是，这样可以充分利用现在常见的SMP多核架构，从而实现微观上真正的多核并发处理。为什么要把worker进程数量设置得跟CPU核心数量一致呢？对于Nginx，一个worker进程可以同时处理的请求数只受限于内存大小，而且在架构上，<strong>不同的worker进程之间处理并发请求时几乎没有同步锁的限制</strong>，worker进程通常不会进入睡眠状态，因此，当Nginx上的进程数与CPU核心数相等时（最好每一个worker进程都绑定特定的CPU核心【使用taskset命令来设置进程的CPU亲和性（affinity），将进程绑定到某个或某组CPU核心上】），进程间的切换的代价是最小的。</li></ul><h1><span id="nginx服务的基本配置">Nginx服务的基本配置</span></h1><h2><span id="用于调试进程和定位问题的配置项">用于调试进程和定位问题的配置项</span></h2><ol><li><p>是否以守护进程方式运行Nginx</p><p>语法：daemon on|off;</p><p>默认：daemon on;</p><p>关闭守护进程的模式，方便使用gdb跟踪调试Nginx，在研究Nginx架构时很有用。</p></li><li><p>是否以master/worker方式工作</p><p>语法：master_process on | off;</p><p>默认：master_process on;</p><p>如果用off关闭了master_process方式，就不会fork出worker子进程来处理请求，而是用master进程自身来处理请求。</p></li><li><p>error日志的位置</p><p>语法：error_log /path/file level;</p><p>默认：error_log logs/error.log error;</p><p>error日志是定位Nginx问题的最佳工具，我们可以根据自己的需求妥善设置error日志的路径和级别。<br>/path/file可以是：</p><ul><li>一个具体的文件，例如，默认情况下是logs/error.log文件，最好将它放到一个磁盘空间足够大的位置；</li><li>也可以是/dev/null，这也是关闭error日志的唯一方法；</li><li><p>也可以是stderr，将日志输出到标准错误文件中；</p><p>level是日志的输出级别，取值范围是debug、info、notice、warn、error、crit、alert、emerg，从左到右级别依次增大。当设定一个级别时，大于或者等于该级别的日志都会输出到/path/file文件中，小于该级别的日志则不会输出。</p><p>如果日志级别设定到debug，必须在configure时加入–with-debug配置项。</p></li></ul></li><li><p>是否处理几个特殊的调试点</p><p>语法：debug_points [stop|abort]</p><p>这个配置项也是用来帮助用户跟踪调试Nginx的。Nginx在一些关键的错误逻辑中设置了调试点。如果设置了debug_points为stop，那么Nginx的代码执行到这些调试点时就会发出SIGSTOP信号以用于调试。如果设置为abort，则会产生一个coredump文件，可以使用gdb来查看Nginx当时的各种信息。</p></li><li><p>仅对指定的客户端输出debug级别的日志</p><p>语法：debug_connection [IP|CIDR]</p><p>这个配置项实际上属于事件类配置，因此，它必须放在events {…}中才有效。</p><p>对来自于指定IP地址的请求才会输出debug级别的日志，其他请求仍然沿用error_log中配置的日志级别。</p></li><li><p>限制coredump核心转储文件的大小</p><p>语法：worker_rlimit_core size;</p><p>在Linux系统中，当进程发生错误或收到信号而终止时，系统会将进程执行时的内存内容写入一个文件，以作为调试只用，这就是所谓的核心转储（core dumps）.</p></li><li><p>指定coredump文件生成目录</p><p>语法：working_directory path;</p></li></ol><h2><span id="正常运行的配置项">正常运行的配置项</span></h2><ol><li><p>定义环境变量</p><p>语法：env VAR|VAR=VALUE;</p><p>这个配置项可以让用户直接设置操作系统上的环境变量。</p></li><li><p>嵌入其他配置文件</p><p>语法：include /path/file;</p></li><li><p>pid文件的路径</p><p>语法：pid /path/file;</p><p>默认：pid logs/nginx.pid;</p></li><li><p>Nginx worker进程运行的用户和用户组</p><p>语法：user username [groupname];</p><p>默认：user nobody nodoby;</p></li><li><p>指定Nginx worker进程可以打开的最大句柄描述符个数</p><p>语法：worker_rlimit_nofile limit;</p></li><li><p>限制信号队列</p><p>语法：worker_rlimit_sigpending limit;</p><p>设置每个用户发往Nginx的信号队列的大小。也就是说，当某个用户的信号队列满了，这个用户再发送的信号量就会被丢掉。</p></li></ol><h2><span id="优化性能的配置项">优化性能的配置项</span></h2><ol><li><p>Nginx worker进程个数</p><p>语法：worker_processes number;</p><p>默认：worker_processes 1;</p></li><li><p>绑定Nginx worker进程到指定的CPU内核</p><p>语法：worker_cpu_affinity cpumask [cpumask…]</p><p>例如，如果有4个CPU内核，可以进行如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">worker_processes 4;</span><br><span class="line">worker_cpu_affinity 1000 0100 0010 0001;</span><br></pre></td></tr></table></figure></li><li><p>SSL硬件加速</p><p>语法：ssl_engine device;</p><p>如果服务器上有ssl硬件加速设备，那么就可以进行配置以加快SSL协议的处理速度。</p></li><li><p>系统调用gettimeofday的执行频率</p><p>语法：timer_resolution t;</p><p>默认情况下，每次内核的事件调用（如epoll、select、poll、kqueue等）返回时，都会执行一次gettimeofday，实现用内核的时钟来更新Nginx中的缓存时钟。</p><p>在早期的内核中，gettimeofday的执行代价不小，因为中间有一次内核态到用户态的内存复制。需要降低gettimeofday的调用频率时，可以使用该配置项，表示至少每t秒才调用一次。</p><p>但在目前的大多数内核中，gettimeofday只是一次vsyscall，仅仅是对共享内存页中的数据做访问，并不是通常的系统调用，代价不大，一般不必使用这个配置。</p></li><li><p>Nginx worker进程优先级设置</p><p>语法：worker_priority nice;</p><p>默认：worker_pricrity 0;</p><p>当有多个进程处于可执行状态时，系统将按照所有进程的优先级来决定本次内核选择哪一个进程执行。</p><p>进程所分配的时间片大小也与进程优先级相关，优先级越高，进程分配到的时间片也就越大。</p><p>（在默认配置下，最小的时间片时5ms，最大的时间片则有800ms。）</p><p>这样，优先级高的进程会占有更多的系统资源。</p></li></ol><h2><span id="事件类配置项">事件类配置项</span></h2><ol><li><p>是否打开accept锁</p><p>语法：accept_mutex [on|off];</p><p>默认：accept_mutex on;</p><p>accept_mutex是Nginx的负载均衡锁。</p><p>这把锁可以让多个worker进程轮流地、序列化地与新的客户端建立TCP连接。</p><p>当某个worker进程建立的连接数量达到worker_connections配置的最大连接数的7/8时，会大大地减小该worker进程试图建立新TCP连接的机会，以此实现所有的worker进程之上处理的客户端请求数尽量接近。</p><p>如果关闭它，那么建立TCP连接的耗时会更短，但worker进程之间的负载会非常不均衡。不建议关闭它。</p></li><li><p>lock文件的路径</p><p>语法：lock_file path/file;</p><p>默认：lock_file logs/nginx.lock;</p><p>accept_mutex为off时，此配置完全不生效。</p><p>accept_mutex为on是，若由于编译程序、操作系统导致Nginx不支持原子锁，这时会用文件锁来实现accecpt锁，此时lock_file所指定的lock文件才会生效。</p><blockquote><p><strong>文件锁</strong>：在多任务操作系统中，如果一个进程尝试对正在被其他进程读取的文件进行写操作，可能会导致正在进行读操作的进程读取到一些被破坏或者不完整的数据；如果两个进程并发对同一个文件进行写操作，可能会导致该文件遭到破坏。因此，为了避免发生这种问题，必须要采用某种机制来<strong>解决多个进程并发访问同一个文件时所面临的同步问题</strong>，由此而产生了文件加锁方面的技术。</p><p>Linux支持的文件锁主要包括劝告锁（advisory lock）和强制锁（mandatory lock）这两种。此外，Linux中还引入了两种强制锁的变种形式：共享模式强制锁（share-mode mandatory lock）和租借锁（lease）。</p></blockquote></li><li><p>使用accept锁后到真正建立连接之间的延迟时间</p><p>语法：accept_mutex_delay Nms;</p><p>默认：accept_mutex_delay 500ms;</p><p>在使用accept锁后，同一时间只有一个worker进程能够取到accept锁。这个锁不是阻塞锁，如果取不到会立刻返回。如果有一个worker进程试图取锁而未得，它至少要等该配置项所定义的时间间隔后才能再次试图取锁。</p></li><li><p>批量建立新连接</p><p>语法：multi_accept [on|off];</p><p>默认：multi_accept off;</p><p>当事件模型通知有新连接时，尽可能地对本次调度中客户端发起的所有TCP请求都建立连接。</p></li><li><p>选择事件模型</p><p>语法：use [kqueue|rtsig|epoll|/dev/poll|select|poll|eventport];</p><p>默认：Nginx会自动使用最合适的事件模型。</p><p>在Linux系统中，epoll性能是最高的。</p></li><li><p>每个worker的最大连接数</p><p>语法：worker_connections number;</p><p>定义每个worker进程可以同时处理的最大连接数。</p></li></ol><h1><span id="使用http核心模块配置一个静态web服务器">使用HTTP核心模块配置一个静态Web服务器</span></h1>]]></content>
    
    <summary type="html">
    
      Nginx的配置详解
    
    </summary>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Web性能基础</title>
    <link href="http://yoursite.com/2019/02/21/Web%E6%80%A7%E8%83%BD%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/02/21/Web性能基础/</id>
    <published>2019-02-21T02:54:57.000Z</published>
    <updated>2019-02-24T12:48:20.377Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="网络技术概览">网络技术概览</span></h1><h2><span id="延迟与带宽">延迟与带宽</span></h2><p>速度是关键</p><p>WPO（Web Performance Optimization）产业从无到有，快速增长，充分说明用户越来越重视速度方面的用户体验。</p><p>业绩证实：</p><ul><li>网站越快，用户的黏性越高</li><li>网站越快，用户忠诚度更高</li><li>网站越快，用户转化率越高</li></ul><p>延迟和带宽：</p><ul><li><p>延迟：分组从信息源发送到目的地所需的时间</p></li><li><p>带宽：逻辑或物理通信路径最大的吞吐量</p></li></ul><p>延迟的构成：</p><ul><li>传播延迟<br>消息从发送端到接收端需要的时间，是信号传播距离和速度的函数</li><li>传输延迟<br>把消息中的所有比特转移到链路中需要的时间，是消息长度和链路速率的函数</li><li>处理延迟<br>处理分组首部、检查位错误及确定分组目标所需的时间</li><li>排队延迟<br>到来的分组排队等待处理的时间</li></ul><blockquote><p>在软件交互中，哪怕100-200ms左右的延迟，大多数人都会感觉到‘拖拉’；如果超过了300ms的门槛，就会说“反应迟钝”。</p></blockquote><blockquote><p>光速与分组在介质中传播速度之比，叫做该介质的折射率。我们大都假定光纤的折射率约为1.5，即光通过光纤的速度约为每秒200，000，000米。</p></blockquote><h2><span id="tcp">TCP</span></h2><h2><span id="udp">UDP</span></h2><h2><span id="tls">TLS</span></h2><h1><span id="无线网络性能">无线网络性能</span></h1><h2><span id="wifi">WIFI</span></h2><h2><span id="移动网络">移动网络</span></h2><h1><span id="http">HTTP</span></h1><h2><span id="http-1x">HTTP 1.x</span></h2><h2><span id="http-20">HTTP 2.0</span></h2><h2><span id="优化应用的交付">优化应用的交付</span></h2><h1><span id="浏览器api与协议">浏览器API与协议</span></h1><h2><span id="xmlhttprequest">XMLHttpRequest</span></h2><h2><span id="服务器发送事件">服务器发送事件</span></h2><h2><span id="websocket">websocket</span></h2><p>WebSocket可以实现客户端与服务器间同时双向、基于消息的文本或二进制数据传输。<br>WebSocket使得浏览器具备了实时、双向通信的能力，是由HTML5开始提供的一种浏览器与服务器进行全双工通讯的网络技术，属于应用层协议。基于TCP传输协议，并复用HTTP的握手通道。</p><ul><li>优点：<ul><li>支持双向通信，实时性更强</li><li>更好的支持二进制</li><li>较少的控制开销。连接创建后，ws客户端、服务的进行数据交换时，协议控制的数据包头部较小。</li><li>支持扩展。可以扩展协议，实现自定义的自协议（如自定义压缩算法等）</li></ul></li></ul><h3><span id="1-入门例子">1. 入门例子：</span></h3><ul><li>1.1 <strong>服务端</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="built_in">require</span>(<span class="string">'express'</span>)();</span><br><span class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">'http'</span>).Server(app);</span><br><span class="line"><span class="keyword">var</span> WebSocket = <span class="built_in">require</span>(<span class="string">'ws'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wss = <span class="keyword">new</span> WebSocket.Server(&#123; <span class="attr">port</span>: <span class="number">8080</span> &#125;);</span><br><span class="line"></span><br><span class="line">wss.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> <span class="title">connection</span>(<span class="params">ws</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'server: receive connection.'</span>);</span><br><span class="line">    </span><br><span class="line">    ws.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> <span class="title">incoming</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'server: received %s'</span>, message);</span><br><span class="line">        ws.send(<span class="string">'server: reply'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    ws.on(<span class="string">'pong'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'server: received pong from client'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    ws.send(<span class="string">'world'</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// setInterval(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//     ws.ping('', false, true);</span></span><br><span class="line">    <span class="comment">// &#125;, 2000);</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.sendfile(__dirname + <span class="string">'/index.html'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><ul><li>1.2 <strong>客户端</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:8080'</span>);</span><br><span class="line">  ws.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'ws onopen'</span>);</span><br><span class="line">    ws.send(<span class="string">'from client: hello'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  ws.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'ws onmessage'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'from server: '</span> + e.data);</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><ul><li>1.3 <strong>运行结果</strong></li></ul><p><em>服务端输出</em>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server: receive connection.</span><br><span class="line">server: received hello</span><br></pre></td></tr></table></figure></p><p><em>客户端输出</em>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">client: ws connection is open</span><br><span class="line">client: received world</span><br></pre></td></tr></table></figure></p><h3><span id="2-如何建立连接">2. 如何建立连接</span></h3><p>WebSocket复用了HTTP的握手通道。具体是指，客户端通过HTTP请求与WebSocket服务器协商升级协议。</p><ul><li><p>2.1. 客户端：申请协议升级</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: localhost:8080</span><br><span class="line">Origin: http://127.0.0.1:3000</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Sec-WebSocket-Key: w4v7O6xFTi36lq3RNcgctw==</span><br></pre></td></tr></table></figure></li><li><p>2.2. 服务端：响应协议升级</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Connection:Upgrade</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Sec-WebSocket-Accept: Oy4NRAQ13jhfONC7bP8dTKb4PTU=</span><br></pre></td></tr></table></figure></li><li><p>2.3. Sec-WebSocket-Accept的计算</p></li></ul><p>伪代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;toBase64( sha1( Sec-WebSocket-Key +258EAFA5-E914-47DA-95CA-C5AB0DC85B11 )  )</span><br></pre></td></tr></table></figure></p><h3><span id="3-数据帧格式">3. 数据帧格式</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-------+-+-------------+-------------------------------+</span><br><span class="line">|F|R|R|R| opcode|M| Payload len |    Extended payload length    |</span><br><span class="line">|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |</span><br><span class="line">|N|V|V|V|       |S|             |   (if payload len==126/127)   |</span><br><span class="line">| |1|2|3|       |K|             |                               |</span><br><span class="line">+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</span><br><span class="line">|     Extended payload length continued, if payload len == 127  |</span><br><span class="line">+ - - - - - - - - - - - - - - - +-------------------------------+</span><br><span class="line">|                               |Masking-key, if MASK set to 1  |</span><br><span class="line">+-------------------------------+-------------------------------+</span><br><span class="line">| Masking-key (continued)       |          Payload Data         |</span><br><span class="line">+-------------------------------- - - - - - - - - - - - - - - - +</span><br><span class="line">:                     Payload Data continued ...                :</span><br><span class="line">+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</span><br><span class="line">|                     Payload Data continued ...                |</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure><h3><span id="4-数据传递">4. 数据传递</span></h3><p>使用场景及性能</p><h2><span id="webrtc">WebRTC</span></h2>]]></content>
    
    <summary type="html">
    
      有关于Web性能的基础知识
    
    </summary>
    
    
      <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Linux性能优化之CPU篇</title>
    <link href="http://yoursite.com/2019/02/20/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8BCPU%E7%AF%87/"/>
    <id>http://yoursite.com/2019/02/20/Linux性能优化之CPU篇/</id>
    <published>2019-02-20T13:18:11.000Z</published>
    <updated>2019-03-12T08:39:18.531Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#平均负载">平均负载</a></li><li><a href="#上下文切换">上下文切换</a><ul><li><a href="#概述">概述</a></li><li><a href="#怎么查看系统的上下文切换情况">怎么查看系统的上下文切换情况</a></li></ul></li><li><a href="#cpu的使用率">CPU的使用率</a><ul><li><a href="#概述-1">概述</a></li><li><a href="#查看cpu使用率">查看CPU使用率</a></li><li><a href="#cpu使用率过高怎么办">CPU使用率过高怎么办？</a></li></ul></li><li><a href="#不可中断进程和僵尸进程的处理方法">不可中断进程和僵尸进程的处理方法</a><ul><li><a href="#进程状态">进程状态</a></li><li><a href="#处理方法">处理方法</a></li></ul></li><li><a href="#软中断">软中断</a><ul><li><a href="#怎么查看软中断和内核线程呢">怎么查看软中断和内核线程呢？</a></li></ul></li><li><a href="#如何迅速分析出系统cpu的瓶颈在哪里">如何迅速分析出系统CPU的瓶颈在哪里？</a></li><li><a href="#cpu性能优化的几个思路">CPU性能优化的几个思路</a><ul><li><a href="#性能优化方法论">性能优化方法论</a><ul><li><a href="#怎么评估性能优化的效果">怎么评估性能优化的效果？</a></li><li><a href="#多个性能问题同时存在要怎么选择">多个性能问题同时存在，要怎么选择？</a></li><li><a href="#有多种优化方法时要如何选择">有多种优化方法时，要如何选择？</a></li></ul></li><li><a href="#cpu优化">CPU优化</a><ul><li><a href="#应用程序优化">应用程序优化</a></li><li><a href="#系统优化">系统优化</a></li></ul></li><li><a href="#不要过早优化">不要过早优化</a></li></ul></li></ul><!-- tocstop --><h2><span id="平均负载">平均负载</span></h2><p>什么是平均负载？</p><p>是指一定时间内系统中处于可运行状态和不可中断等待状态的进程数的平均数</p><h2><span id="上下文切换">上下文切换</span></h2><h3><span id="概述">概述</span></h3><p>进程在竞争CPU的时候并没有真正运行，为什么还会导致系统的负载升高呢？这是因为CPU上下文切换。</p><p>在每个任务运行前，CPU都需要知道任务从哪里加载，又从哪里开始运行，需要系统事先帮它设置好CPU寄存器和程序计数器（Program Counter，PC）。</p><p>CPU寄存器，是CPU内置的容量小，但速度极快的内存。而程序计数器，则是用来存储CPU正在执行的指令位置、或者即将执行的下一条指令位置。它们都是CPU在运行任何任务前，必须的依赖环境，因此也被叫做CPU上下文。如下图所示：</p><p><img src="/2019/02/20/Linux性能优化之CPU篇/1551593332821.png" alt="1551593332821"></p><p>CPU上下文切换就是先把前一个任务的CPU上下文保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。</p><p>根据任务的不同，CPU的上下文切换可以分为：</p><ul><li><p>进程上下文切换</p><p>Linux按照特权等级，把进程的运行空间分为内核空间和用户空间，对应的特权等级分别为Ring 0和Ring 3。</p><ul><li><p>内核空间（Ring 0）具有最高权限，可以直接访问所有资源；</p></li><li><p>用户空间（Ring 3）只能访问受限资源，不能访问内存等硬件设备，必须通过系统调用进入到内核中，才能访问这些特权资源。</p><p><img src="/2019/02/20/Linux性能优化之CPU篇/1551594532880.png" alt="1551594532880"></p></li></ul><p>对于一个进程，从用户态到内核态的转变，需要通过系统调用来完成。一次系统调用的过程，会发生两次CPU上下文切换。</p><p>进程的上下文切换：进程是由内核来管理和调度的，进程的切换只能发生再内核态。进程的上下文不仅包括虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的状态。</p><p>因此，进程的上下文切换比系统调用时多了一步：在保存当前进程的内核状态和CPU寄存器之前，需要先把该进程的虚拟内存、栈保存下来；而加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈。</p><p>在进程上下文切换次数较多的情况下，很容易导致CPU将大量实际耗费在寄存器、内核栈以及虚拟内存等资源的保存和恢复上，进而大大缩短了真正运行进程的时间。</p><p>另外，Linux通过TLB（Translation Lookaside Buffer）来管理虚拟内存到物理内存的映射关系。当虚拟内存更新后，TLB也需要更新，内存的访问也会随之变慢。</p></li><li><p>线程上下文切换</p><p>线程是调度的基本单位，而进程是资源拥有的基本单位。</p><p>所谓内核中的任务调度，实际上的调度对象是线程；而进程只是给线程提供了虚拟内存、全局变量等资源。</p><p>所以，对于线程和进程，我们可以这样理解：</p><ul><li>当进程只有一个线程时，可以认为进程就等于线程；</li><li>当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源。这些资源在上下文切换时是不需要修改的。</li><li>线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时是需要保存的</li></ul></li><li><p>中断上下文切换</p><p>为了快速响应硬件的事件，中断处理会打断进程的正常调度和执行，转而调用中断处理程序，响应设备事件。</p><p>跟进程上下文不同，中断上下文切换并不涉及到进程的用户态。所以，即便中断过程打断了一个正处在用户态的进程，也不需要保存和恢复这个进程的虚拟内存、全局变量等用户态资源。</p><p>中断上下文，其实只包括内核态中断服务程序执行所必需的状态，包括CPU寄存器、内核堆栈、硬件中断参数等。</p><p>对同一个CPU来说，中断处理比进程拥有更高的优先级，所以中断上下文切换并不会与进程上下文切换同时发生。</p></li></ul><h3><span id="怎么查看系统的上下文切换情况">怎么查看系统的上下文切换情况</span></h3><ol><li>使用vmstat</li></ol><p><img src="/2019/02/20/Linux性能优化之CPU篇/1551598709362.png" alt="1551598709362"></p><ul><li>cs（context switch）是每秒上下文切换的次数</li><li>in（interrupt）是每秒中断的次数</li><li>r（Running or Runnable）是就绪队列的长度，也就是正在运行和等待CPU的进程数</li><li>b（Blocked）则是处于不可中断睡眠状态的进程数</li></ul><ol start="2"><li>对于每个进程的详细情况，可使用pidstat</li></ol><p><img src="/2019/02/20/Linux性能优化之CPU篇/1551599003703.png" alt="1551599003703"></p><p>其中：</p><ul><li>cswch，表示每秒自愿上下文切换（voluntary context switches）的次数</li><li>nvcswch，表示每秒非自愿上下文切换（non  voluntary context switches）的次数。</li></ul><p>这两个概念意味着不同的性能问题：</p><ul><li>自愿上下文切换，是指进程无法获取所需资源，导致的上下文切换。比如说，I/O、内存等系统资源不足时，就会发生自愿上下文切换。</li><li>非自愿上下文切换，则是指进程由于时间片已到等原因，被系统强制调度，进而发生上下文切换。比如说，大量进程都在争抢CPU时，就容易发生非自愿上下文切换。</li></ul><h2><span id="cpu的使用率">CPU的使用率</span></h2><h3><span id="概述">概述</span></h3><p>Linux是多任务操作系统，它将CPU时间划分为时间片，然后通过调度算法轮流分配给各个任务使用。</p><blockquote><p>调度算法：</p><p>Linux的调度算法一直在更新，最新的调度算法是CFS（完全公平调度器）。</p><p>调度算法决定在众多的线程中哪个线程获得执行、什么时候开始执行、执行多久。</p><p>调度器先划分出Scheduler Classes<sup>调度类</sup>，每个不同的Class对应不同类型的线程，每个Class都有自己的优先级。</p><p>调度管理基础代码会遍历在内核中注册了的调度类，选择高优先级的调度类，然后让此调度类按照自己的调度算法选择下一个执行的线程。</p><p>常用的调度类：</p><ul><li><p>SCHED_NORMAL  普通线程调度类</p><p>只具有nice值，映射到用户层的取值范围为-20-19</p><p>调度器要解决一个基本问题是：要先找出‘交互线程’，保证这种线程优先得到调度，然后才考虑其他问题。</p></li><li><p>SCHED_FIFO </p><p>SCHED_RR</p><p>实时线程调度类</p><p>拥有实时优先级（real-time priority）,默认取值为0-99</p></li></ul></blockquote><p>为了维护CPU时间，Linux通过事先定义的节拍率（内核中表示为HZ，表示每秒触发的时间中断的次数），触发时间中断，并使用全局变量Jiffies记录了开机以来的节拍数。每发生一次时间中断，Jiffies的值就加1。</p><p>节拍率HZ是内核的可配选项，可以设置为100、250、1000等。可以通过以下命令查看它的配置值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@geek ~]<span class="comment"># grep -i "config_hz" /boot/config-$(uname -r)</span></span><br><span class="line"><span class="comment"># CONFIG_HZ_PERIODIC is not set</span></span><br><span class="line"><span class="comment"># CONFIG_HZ_100 is not set</span></span><br><span class="line"><span class="comment"># CONFIG_HZ_250 is not set</span></span><br><span class="line"><span class="comment"># CONFIG_HZ_300 is not set</span></span><br><span class="line">CONFIG_HZ_1000=y</span><br><span class="line">CONFIG_HZ=1000</span><br></pre></td></tr></table></figure><p>内核提供了一个用户空间节拍率USER_HZ，它总是固定为100，也就是说，在用户空间一个节拍的时间为1/100秒。</p><p>/proc/stat提供了系统CPU和任务统计信息。执行以下命令，可以看到CPU的相关信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@geek ~]# cat /proc/stat | grep ^cpu</span><br><span class="line">cpu  126633 3769 165166 11498685 3763 0 21088 0 0 0</span><br><span class="line">cpu0 126633 3769 165166 11498685 3763 0 21088 0 0 0</span><br></pre></td></tr></table></figure><p>第一列表示的是CPU编号，第一行没有编号的CPU，表示的是所有CPU的累加。</p><p>其他列表示不同场景下CPU的累加节拍数，单位是1/USER_HZ秒，也就是10ms（1/100秒），其实也就是不同场景下的CPU时间。</p><p>后面的列依照顺序，分别为<sup>括号中内容表示缩写</sup>：</p><ul><li>user（us），代表用户态CPU时间，注意它不包括下面的nice时间，但包括了guest时间。</li><li>nice（ni），代表低优先级用户态CPU时间，也就是进程的nice值被调整为1-19之间的CPU时间。</li><li>system（sys），代表内核态CPU时间。</li><li>idle（id），代表空闲时间。注意，它不包括等待I/O的时间（iowait）</li><li>iowait（wa），代表等待I/O的CPU时间。</li><li>irq（hi），代表处理硬中断的CPU时间。</li><li>softirq（si），代表处理软中断的CPU时间。</li><li>steal（st），代表当系统运行在虚拟机中的时候，被其他虚拟机占用的CPU时间。</li><li>guest（guest），代表通过虚拟化运行其他操作系统的时间，也就是运行虚拟机的CPU时间。</li><li>guest_nice（gnice），代表以低优先级运行的虚拟机时间。</li></ul><p><img src="/2019/02/20/Linux性能优化之CPU篇/1551432942707.png" alt="1551432942707"></p><p>为了计算CPU的使用率，性能工具一般都会取间隔一段时间（比如3秒）的两次值，做差后，在计算出这段时间内的平均CPU使用率，即：</p><p><img src="/2019/02/20/Linux性能优化之CPU篇/1551433018852.png" alt="1551433018852"></p><p>跟系统的指标类似，Linux也给每个进程提供了运行情况的统计信息，也就是/proc/[pid]/stat。</p><p>那是不是说要查看CPU使用率，就必须先读取/proc/stat和/proc/[pid]/stat这两个文件，然后再按照上面的公式计算出来呢？</p><p>当然不是，各种各样的性能分析工具已经帮我们计算好了。</p><p>需要注意的是，性能分析工具给出的都是间隔一段时间的平均CPU使用率，所以要注意间隔时间的设置，特别是用多个工具对比分析时，一定要保证它们用的是相同的时间间隔。</p><p>top默认使用3秒时间间隔，而ps使用的是进程的整个生命周期，所以这两个工具报告的CPU使用率，默认的结果很可能是不一样的。</p><h3><span id="查看cpu使用率">查看CPU使用率</span></h3><p>使用top命令，如下：</p><p><img src="/2019/02/20/Linux性能优化之CPU篇/1551436121518.png" alt="1551436121518"></p><p>对于进程的实时信息，每个进程都有一个%CPU列，表示进程的CPU使用率。它是用户态和内核态CPU使用率的总和，包括进程用户空间使用的CPU、提供系统调用执行的内核空间CPU、以及在就绪队列等待运行的CPU。在虚拟化环境中，它还包括了运行虚拟机占用的CPU。</p><p>所以，top并没有细分进程的用户态CPU和内核态CPU。那要怎么查看每个进程的详细情况呢？可以使用pidstat，是一个专门分析每个进程CPU使用情况的工具。</p><p><img src="/2019/02/20/Linux性能优化之CPU篇/1551436602236.png" alt="1551436602236"></p><p>上面的pidstat命令，间隔1s展示了进程的3组CPU使用率，包括：</p><ul><li>用户态CPU使用率（%usr）</li><li>内核态CPU使用率（%system）</li><li>运行虚拟机CPU使用率（%guest）</li><li>以及总的CPU使用率（%CPU）</li></ul><h3><span id="cpu使用率过高怎么办">CPU使用率过高怎么办？</span></h3><p>通过top、ps、pidstat等工具，能够轻松找到CPU使用率较高的进程。接下来，占用CPU的到底是代码中的哪个函数呢？找到它，才能高效有针对性的进行优化。</p><p>怎么找呢？用GDB？GDB是个功能强大的程序调试利器。但它并不适合在性能分析的早期使用。为什么呢？因为GDB调试程序的过程会中断程序运行，这在线上环境往往是不允许的。所以，GDB只适合在性能分析的后期，当你找到了出问题的大致函数后，线下再借助它来进一步调试函数内部的问题。</p><p>哪种工具适合在第一时间分析进程的CPU问题呢？推荐使用perf。</p><p>perf是Linux2.6.31以后内置的性能分析工具。它以性能数据采样为基础，不仅可以分析系统的各种事件和内核性能，还可以用来分析指定应用程序的性能问题。</p><ul><li><p>perf top</p><p><img src="/2019/02/20/Linux性能优化之CPU篇/1551437842824.png" alt="1551437842824"></p><p>输出结果中，第一行包含三个数据，分别是采样数（Samples）、事件类型（event）和事件总数（Event count）。比如以上例子中，perf总共采集了25k个CPU时钟事件，而总事件数则是262083270。</p><p>再往下看，每一行包含四列，分别是：</p><ul><li>第一列Overhead，是该符号的性能事件所在所有采样中的比例</li><li>第二列Shared Object，是该函数或指令所在的动态共享对象（Dynamic Shared Object),如内核、进程名、动态链接库名、内核模块名等</li><li>第三列，是动态共享对象的类型。比如：[.]表示用户空间的可执行程序、或者动态链接库，而[k]表示内核空间</li><li>最后一列Symbol是符号名，也就是函数名。当函数名未知时，用十六进制的地址来表示。</li></ul></li><li><p>perf record &amp; perf report</p><p>使用perf record保持数据，保存后的数据，需要使用perf record解析展示。</p><p><img src="/2019/02/20/Linux性能优化之CPU篇/1551439032460.png" alt="1551439032460"></p></li></ul><h2><span id="不可中断进程和僵尸进程的处理方法">不可中断进程和僵尸进程的处理方法</span></h2><h3><span id="进程状态">进程状态</span></h3><p>top或ps命令输出中，进程状态栏各符号的含义：</p><ul><li><p>R</p><p>Running或Runnable的缩写，表示进程在CPU的就绪队列中，正在运行或者正在等待运行</p></li><li><p>D</p><p>Disk Sleep的缩写，也就是不可中断睡眠，一般表示进程正在和硬件交互，并且交互过程不允许被其他进程或中断打断</p></li><li><p>Z</p><p>Zombie的缩写，表示僵尸进程，也就是进程实际上已经结束了，但是父进程还没有回收它的资源（比如进程的描述符、PID等）</p></li><li><p>S</p><p>Interruptible Sleep的缩写，也就是可中断状态睡眠，表示进程因为等待某个事件而被系统挂起。当进程等待的事件发生时，它会被唤醒并进入R状态。</p></li><li><p>I</p><p>Idle的缩写。也就是空闲状态，用在不可中断睡眠的内核进程上。</p></li><li><p>T或者t</p><p>Stopped或Traced的缩写，表示进程处于暂停或跟踪状态。</p><p>向一个进程发送SIGSTOP信号，它就会响应这个信号变成Stopped，再向它发送SIGCONT信号，进程又会恢复运行。</p><p>当你用调试器调试一个进程时，在使用断点中断进程后，进程就会变成跟踪状态，这其实是一种特殊的暂停状态，只不过你可以用调试器来跟踪并按需要控制进程的运行。</p></li><li><p>X</p><p>Dead的意思。表示进程已经消亡，所以你不会在top或者ps命令输出中看到它。</p></li></ul><p><img src="/2019/02/20/Linux性能优化之CPU篇/1551502558996.png" alt="1551502558996"></p><ul><li><p>s</p><p>session leader的意思。什么是session呢？session指的是相互关联的进程组。</p></li><li><p>+</p><p>表示的是前台进程</p></li></ul><h3><span id="处理方法">处理方法</span></h3><p>出现僵尸进程，是由于父进程没有回收子进程的资源。所以，要找到僵尸进程的父进程，在父进程里解决。</p><p>使用pstree命令，找到父进程。</p><h2><span id="软中断">软中断</span></h2><p>中断是一种异步的事件处理机制，可以提高系统的并发处理能力。</p><p>由于中断处理程序会打断其他进程的运行，所以，为了减少对正常进程运行调度的影响，中断处理程序就需要尽可能快地运行。</p><p>为了解决中断处理程序执行过长和中断丢失的问题，Linux将中断处理过程分成了两个阶段：</p><ul><li><p>上半部用来快速处理中断，它在中断禁止模式下运行，主要处理跟硬件紧密相关的或时间敏感的工作；</p><p>直接处理硬件请求，硬中断，特点是快速执行</p><p>会打断CPU正在执行的任务，然后立即执行中断处理程序</p></li><li><p>下半部用来延迟处理上半部未完成的工作，通常以内核线程的方式运行。</p><p>由内核触发，软中断，特点是延迟执行</p><p>以内核线程的方式执行，每个CPU都对应一个软中断内核线程，名为“ksoftirqd/CPU编号”</p></li></ul><p>软中断不只包括硬件设备中断处理程序的下半部，一些内核自定义的事件也属于软中断，比如内核调度和RCU锁（Read-Copy Update）</p><h3><span id="怎么查看软中断和内核线程呢">怎么查看软中断和内核线程呢？</span></h3><p>/proc/softirqs</p><p>/proc/interrupts</p><h2><span id="如何迅速分析出系统cpu的瓶颈在哪里">如何迅速分析出系统CPU的瓶颈在哪里？</span></h2><h2><span id="cpu性能优化的几个思路">CPU性能优化的几个思路</span></h2><p>在找到CPU的性能瓶颈之后，下一步要做的就是优化了，也就是找出充分利用CPU的方法，以便完成更多的工作。</p><h3><span id="性能优化方法论">性能优化方法论</span></h3><p>在经过千辛万苦，通过各种性能优化方法，终于找到引发性能问题的瓶颈后，是不是立即就要开始优化了呢？</p><p>此时，不必着急，动手之前，可以先看看下面三个问题：</p><ul><li>要怎么判断优化措施是否是有效的？特别是，优化后性能到底又提升了多少呢？</li><li>性能问题通常不是独立的，如果有多个性能问题同时发生，应该先优化哪一个呢？</li><li>提升性能的方法并不是唯一的，当有多种方法可以选择时，选用哪一种呢？是不是总选那个最大程度提升性能的方法就行了呢？</li></ul><p>如果你可以轻松回答这三个问题，那么优化可以立即开始了。</p><h4><span id="怎么评估性能优化的效果">怎么评估性能优化的效果？</span></h4><p>为了评估效果，我们需要对系统的性能指标进行量化，并且要分别测试出优化前、后的性能指标，用前后指标的变化来对比呈现效果。</p><p>性能评估“三步走”：</p><ul><li>确定性能的量化指标</li><li>测试优化前的性能指标</li><li>测试优化后的性能指标</li></ul><h4><span id="多个性能问题同时存在要怎么选择">多个性能问题同时存在，要怎么选择？</span></h4><p><strong>并不是所有的性能问题都值得优化</strong>。</p><p>80%的问题都是由20%的代码导致的。只要找出这20%的位置，你就可以优化80%的性能。</p><h4><span id="有多种优化方法时要如何选择">有多种优化方法时，要如何选择？</span></h4><p>一般情况下，选能最大提升性能的方法，这也是性能优化的目标。</p><p>但是，性能优化并非没有成本。性能优化通常会带来复杂度的提升，降低程序的可维护性，还可能在优化一个指标时，引发其他指标的异常。</p><p>所以，在考虑选哪个性能优化方法时，需要综合多方面的因素。</p><h3><span id="cpu优化">CPU优化</span></h3><p>在清楚了性能优化最基本的三个问题后，接下来从应用程序和系统的角度，分别来看看如何才能降低CPU使用率，提高CPU的并行处理能力：</p><h4><span id="应用程序优化">应用程序优化</span></h4><p>从应用程序的角度来说，降低CPU使用率的最好方法是，排除所有不必要的工作，只保留最核心的逻辑。比如减少循环的层次、减少递归、减少动态内存分配等等。</p><p>此外，还有：</p><ul><li>编译器优化：很多编译器都会提供优化选项，适当开启它们，在编译阶段你就可以获得编译器的帮助，来提升性能。比如，gcc就提供了优化选项-O2，开启后会自动对应用程序的代码进行优化。</li><li>算法优化：使用复杂度更低的算法，可以显著加快处理速度。比如，在数据比较大的情况下，可以用O(nlogn)的排序算法（如快排、归并排序等）代替O(n^2)的排序算法（如冒泡、插入排序等）</li><li>异步处理：使用异步处理，可以避免程序因为等待某个资源而一直阻塞，从而提升程序的并发处理能力。比如，把轮询替换为事件通知，就可以避免轮询耗费CPU的问题</li><li>多线程代替多进程：相对于进程的上下文切换，线程的上下文切换并不切换进程地址空间，因此可以降低上下文切换的成本。</li><li>善用缓存：经常访问的数据或计算过程中的步骤，可以放到内存中缓存起来，只要在下次要用的时候就直接从内存中获取，加快程序的处理速度。</li></ul><h4><span id="系统优化">系统优化</span></h4><p>从系统的角度来说，优化CPU的运行，一方面要充分利用CPU缓存的本地性，加速缓存访问；另一方面，就要控制进程的CPU使用情况，减少进程间的相互影响。</p><ul><li>CPU绑定：把进程绑定到一个或者多个CPU上，可以提高CPU缓存的命中率，减少跨CPU调度带来的上下文切换问题</li><li>CPU独占：跟CPU绑定类似，进一步将CPU分组，并通过CPU亲和性机制为其分配进程。这样，这些CPU就由指定的进程独占，也就是说，不允许其他进程再来使用这些CPU</li><li>优先级调整：使用nice调整进程的优先级，正值调低优先级，负值调高优先级。</li><li>为进程设置资源限制：使用Linux cgroups来设置进程的CPU使用上限，可以防止由于某个应用自身的问题，而耗尽系统资源</li><li>NUMA优化：支持NUMA的处理器会被划分为多个node，每个node都有自己的本地内存空间。NUMA优化，其实就是让CPU尽可能只访问本地内存</li><li>中断负载均衡：无论是软中断还是硬中断，它们的中断处理程序都可能会耗费大量的CPU。开启irqbalance服务或者配置smp_affinity，就可以把中断处理过程自动负载均衡到多个CPU上。</li></ul><h3><span id="不要过早优化">不要过早优化</span></h3><blockquote><p>过早优化是万恶之源。——高纳德</p></blockquote><p>过早优化不可取。这是因为：</p><ul><li>优化会带来复杂性的提升，降低可维护性；</li><li>需求不是一成不变的。针对当前情况进行的优化，很可能并不适应快速变化的新需求。这样，在新需求出现时，这些复杂的优化，反而可能阻碍新功能的开发。</li></ul><p>所以，性能优化最好是逐步完善，动态进行的，不追求一步到位，<strong>而要首先保证能满足当前的性能要求</strong>。当发现性能不满足要求或者出现性能瓶颈时，再根据性能评估的结果，选择最重要的性能问题进行优化。</p>]]></content>
    
    <summary type="html">
    
      如何做Linux的性能优化
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Discover the Secrets of Linux Kernel</title>
    <link href="http://yoursite.com/2019/02/20/Linux-Kernel/"/>
    <id>http://yoursite.com/2019/02/20/Linux-Kernel/</id>
    <published>2019-02-20T08:47:55.000Z</published>
    <updated>2019-02-28T14:46:09.366Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#如何学习内核">如何学习内核：</a><ul><li><a href="#将内核划分成两层减少内核阅读的难度">将内核划分成两层，减少内核阅读的难度</a><ul><li><a href="#内核基础层">内核基础层</a></li><li><a href="#内核应用层">内核应用层</a></li></ul></li><li><a href="#内核学习最终目的">内核学习最终目的：</a></li></ul></li><li><a href="#内核的基础层和应用层">内核的基础层和应用层</a><ul><li><a href="#内核基础层提供的服务">内核基础层提供的服务</a><ul><li><a href="#内核中使用内存">内核中使用内存</a></li><li><a href="#内核中的任务调度">内核中的任务调度</a></li><li><a href="#软中断和tasklet">软中断和tasklet</a></li><li><a href="#工作队列">工作队列</a></li><li><a href="#自旋锁">自旋锁</a></li><li><a href="#内核信号量">内核信号量</a></li><li><a href="#原子变量">原子变量</a></li></ul></li><li><a href="#内核基础层的数据结构">内核基础层的数据结构</a><ul><li><a href="#双向链表">双向链表</a></li><li><a href="#hash链表">hash链表</a></li><li><a href="#单向链表">单向链表</a></li><li><a href="#红黑树">红黑树</a></li><li><a href="#radix树">radix树</a></li></ul></li><li><a href="#内核应用层-1">内核应用层</a></li></ul></li><li><a href="#文件系统">文件系统</a></li><li><a href="#设备的概念和总体架构">设备的概念和总体架构</a></li><li><a href="#为设备服务的特殊文件系统sysfs">为设备服务的特殊文件系统sysfs</a></li><li><a href="#字符设备和input设备">字符设备和input设备</a></li></ul><!-- tocstop --><h1><span id="如何学习内核">如何学习内核：</span></h1><ul><li>以应用为目的来学习，边学边用，学以致用</li><li>以培养内核的阅读能力为主要目标</li><li>阅读和修改真实的代码，而非只是阅读书籍</li><li>需要不断的更新和学习，因为内核的策略和方法一直在不断的变化着</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">勿贪大求全，聚焦关键应用</span><br><span class="line">奠定基础，循序渐进</span><br><span class="line">兴趣是第一驱动力</span><br></pre></td></tr></table></figure><h2><span id="将内核划分成两层减少内核阅读的难度">将内核划分成两层，减少内核阅读的难度</span></h2><h3><span id="内核基础层">内核基础层</span></h3><blockquote><p>内核中提供基础服务的部分</p></blockquote><ul><li>代码总量很少，但难度高</li><li>提供基本稳定的API</li><li>数据结构 </li><li>内核同步机制</li><li>内存管理和任务调度</li><li>学习方法：<ul><li>以API接口学习为主要内容，不细究实现</li><li>日后应该加强基础层的研读</li></ul></li></ul><h3><span id="内核应用层">内核应用层</span></h3><blockquote><p>建立在基础层之上，提供应用服务的部分</p></blockquote><ul><li>占代码的90%以上，数量多，重复性强</li><li>接口经常变化</li><li>文件系统 </li><li>设备和驱动</li><li>网络</li><li>学习方法：<ul><li>文件系统是应用层的基础和灵魂</li><li>从文件系统入手，驻步扩展</li><li>以架构为核心，举一反三</li><li>设备和驱动不依赖具体设备，以通用架构为主</li></ul></li></ul><h2><span id="内核学习最终目的">内核学习最终目的：</span></h2><ul><li>独立思考，独立学习，不断分享成为在该领域有影响力的专家</li></ul><h1><span id="内核的基础层和应用层">内核的基础层和应用层</span></h1><h2><span id="内核基础层提供的服务">内核基础层提供的服务</span></h2><p>内核通常提供的服务是内存管理、进程管理、设备管理和文件系统。</p><h3><span id="内核中使用内存">内核中使用内存</span></h3><p>内核中提供了两个层次的内存分配接口：</p><ul><li><p>从伙伴系统分配：是最底层的内存管理机制，提供页式的内存管理。</p><p>伙伴系统分配内存调用的是alloc_pages，得到的是页面地址，如果要获得能使用的内存地址，还需要用page_address。</p><p>如果要直接获得内存地址，需要使用_get_free_pages。它封装了alloc_pages和page_address两个函数。</p></li><li><p>从slab系统分配：是伙伴系统之上的内存管理，提供基于对象的内存管理。</p><p>alloc_pages申请的内存是以页为单元的，最少是一个页。如果只是申请一小块内存，一个页就很浪费，而且内核中很多应用也希望一种对象化的内存管理，希望内存管理能自动地构造和析构对象，这就是slab内存管理。</p><p>使用kmem_cache_create创建slab对象来从slab申请内存。kmem_cache_create可以提供对象的名字和大小、构造函数和析构函数等，然后通过kmem_cache_alloc和kmem_cache_free来申请和释放内存。</p><p>内核中常用的kmalloc其实也是slab提供的对象管理，只不过内核已经构建了一些固定大小的对象，用户通过kmalloc申请的时候，就直接使用了这些对象。</p><p>一个内核中创建slab对象的例子如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bh_cachep = kmem_cache_create(<span class="string">"buffer_head"</span>,</span><br><span class="line">                              <span class="keyword">sizeof</span>(struct buffer_head), <span class="number">0</span>,</span><br><span class="line">                              (SLAB_RECLAIM_ACCOUNT|SLAB_PANIC|SLAB_MEM_SPREAD),</span><br><span class="line">                              init_buffer_head,</span><br><span class="line">                              <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>用以下代码申请一个slab对象：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">ret</span> = <span class="title">kmem_cache_alloc</span>(<span class="title">bh_cachep</span>, <span class="title">gfp_flags</span>);</span></span><br></pre></td></tr></table></figure><p>内核中另一个内存分配调用vmalloc的作用是把物理内存不连续的内存页面拼凑为逻辑地址连续的内存区间。</p></li></ul><h3><span id="内核中的任务调度">内核中的任务调度</span></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> wait_event(wq, condition)</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (condition)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    __wait_event(wq, condition);</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __wait_event(wq, condition)</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    DEFINE_WAIT(__wait);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        prepare_to_wait(&amp;wq, &amp;__wait, TASK_UNINTERRUPTIBLE);</span><br><span class="line">        <span class="keyword">if</span> (condition)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        schedule();</span><br><span class="line">    &#125;</span><br><span class="line">    finish_wait(&amp;wq, &amp;__wait);</span><br><span class="line">&#125;<span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>上文定义了一个wait结构，然后设置进程睡眠。如果其他进程唤醒这个进程后，判断条件是否满足，如果满足，删除wait对象，否则进程继续睡眠。</p><h3><span id="软中断和tasklet">软中断和tasklet</span></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_TASKLET_DISABLED(hil_mlcs_tasklet, hil_mlcs_process, <span class="number">0</span>);</span><br><span class="line">tasklet_schedule(&amp;hil_mlcs_tasklet);</span><br></pre></td></tr></table></figure><h3><span id="工作队列">工作队列</span></h3><p>和tasklet类似，都是一种延缓执行的机制。</p><p>不同之处是工作队列有自己的进程上下文，所以工作队列可以睡眠，也可以被调度，而tasklet不可睡眠。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INIT_WORK(&amp;ioc-&gt;sas_persist_task,</span><br><span class="line">         mptsas_persist_clear_table,</span><br><span class="line">         (<span class="keyword">void</span> *)ioc);</span><br><span class="line">schedule_work(&amp;ioc-&gt;sas_persist_task);</span><br></pre></td></tr></table></figure><h3><span id="自旋锁">自旋锁</span></h3><p>用来在多处理器的环境下保护数据。</p><p>如果内核发现数据未锁，就获取锁并运行；如果数据被锁，就一直旋转（其实是一直反复执行一条指令）。之所以说自旋锁用在多处理器环境，是因为在单处理器环境（非抢占式内核）下，自旋锁其实不起作用。在单处理器抢占式内核的情况下，自旋锁起到禁止抢占的作用。</p><p>因为被自旋锁锁着的进程一直旋转，而不是睡眠，所以自旋锁可以用在中断等禁止睡眠的场景。</p><p>自旋锁的使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spin_lock(shost-&gt;host_lock);</span><br><span class="line">shost-&gt;host_busy++;</span><br><span class="line">spin_unlock(shost-&gt;host_lock);</span><br></pre></td></tr></table></figure><h3><span id="内核信号量">内核信号量</span></h3><p>和自旋锁类似，作用是保护数据。</p><p>不同之处在于，进程获取内核信号量的时候，如果不能获取，则进程进入睡眠状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">down(&amp;dev-&gt;sem);</span><br><span class="line">up(&amp;dev-&gt;sem);</span><br></pre></td></tr></table></figure><h3><span id="原子变量">原子变量</span></h3><p>提供了一种原子的、不可中断的操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atomic_t mapped;</span><br></pre></td></tr></table></figure><p>内核提供了一系列的原子变量操作函数，如下所示</p><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td>atomic_add</td><td>加一个整数到原子变量</td></tr><tr><td>atomic_sub</td><td>从原子变量减一个整数</td></tr><tr><td>atomic_read</td><td>读原子变量的数值</td></tr><tr><td>atomic_set</td><td>设置原子变量的数值</td></tr></tbody></table><h2><span id="内核基础层的数据结构">内核基础层的数据结构</span></h2><p>container是Linux中很重要的一个概念，使用container能实现对象的封装。代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> container_of(ptr, type, member) (&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="title">typeof</span><span class="params">(((type *)<span class="number">0</span>)-&gt;member)</span> *__mptr </span>= (ptr);</span><br><span class="line">  (type *)((<span class="keyword">char</span> *)__mptr - offsetof(type, member));&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offsetof(type, member) (size_t)&amp;(((type*)0)-&gt;member)</span></span><br></pre></td></tr></table></figure><p>这个方法可以实现通过结构的一个成员找到整个结构的地址。内核中大量使用了这个方法。</p><h3><span id="双向链表">双向链表</span></h3><p>list是双向链表的一个抽象，定义在/include/linux目录下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_entry(ptr, type, member)</span></span><br><span class="line">container_of(ptr, type, member)</span><br></pre></td></tr></table></figure><table><thead><tr><th>内联函数和宏</th><th>作用</th></tr></thead><tbody><tr><td>LIST_HEAD</td><td>定义并初始化一个list链表</td></tr><tr><td>list_add_tail</td><td>加一个成员到链表尾</td></tr><tr><td>list_del</td><td>删除一个list成员</td></tr><tr><td>list_empty</td><td>检测链表是否为空</td></tr><tr><td>list_for_each</td><td>遍历链表</td></tr><tr><td>list_for_each_safe</td><td>遍历链表（可以删除遍历的成员）</td></tr><tr><td>list_for_each_entry</td><td>遍历链表（通过container方法返回结构指针）</td></tr></tbody></table><h3><span id="hash链表">hash链表</span></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">first</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="单向链表">单向链表</span></h3><h3><span id="红黑树">红黑树</span></h3><p>红黑树是一种自平衡的二叉树，代码位于/lib/rbtree.c文件。</p><h3><span id="radix树">radix树</span></h3><h2><span id="内核应用层">内核应用层</span></h2><h1><span id="文件系统">文件系统</span></h1><p>基本概念</p><p>文件系统的架构</p><p>从代码层深入分析文件系统</p><h1><span id="设备的概念和总体架构">设备的概念和总体架构</span></h1><p>设备的配置表</p><p>访问设备寄存器和设备内存</p><p>设备中断和DMA</p><p>总线对设备的扫描</p><p>设备驱动管理</p><h1><span id="为设备服务的特殊文件系统sysfs">为设备服务的特殊文件系统sysfs</span></h1><p>文件和目录的创建</p><p>sysfs文件的打开操作</p><p>sysfs文件的读写</p><p>kobject结构</p><h1><span id="字符设备和input设备">字符设备和input设备</span></h1><p>文件如何变成设备</p><p>input设备的注册</p><p>input设备架构</p><p>platform总线</p>]]></content>
    
    <summary type="html">
    
      以应用为目的来学习Linux内核，通过阅读和修改代码，培养内核的阅读能力
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>红黑树</title>
    <link href="http://yoursite.com/2018/05/28/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>http://yoursite.com/2018/05/28/红黑树/</id>
    <published>2018-05-28T11:07:51.000Z</published>
    <updated>2019-03-03T21:47:49.471Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="红黑树的性质">红黑树的性质</span></h1><ol><li>每个节点要么是红的要么是黑的；</li><li>根节点是黑的；</li><li>每个叶节点（nil）都是黑的；</li><li>如果一个节点是红的，那么它的两个子节点都是黑的；</li><li>任意节点到叶节点的每条简单路径都包含相同数目的黑节点</li></ol><p><img src="/2018/05/28/红黑树/1551508807317.png" alt="1551508807317"></p><h1><span id="复杂度">复杂度</span></h1><p>因为这5条性质，使得n个节点的红黑树始终保持logn的高度，所以它的查询、插入和删除的时间复杂度都是O(logn)。</p><h1><span id="节点操作">节点操作</span></h1><h2><span id="节点插入">节点插入</span></h2><h3><span id="步骤">步骤：</span></h3><ol><li>将红黑树当作一颗二叉查找树，将节点插入；</li><li>将节点着色为红；</li><li>通过旋转和重新着色等方法来修正该树，使之重新成为一颗红黑树。</li></ol><p>在具体实现的过程中，重点是如何该树重新成为一个红黑树，内容涉及左旋、右旋等专门定义的操作。不必细究。</p><h2><span id="节点删除">节点删除</span></h2><h3><span id="步骤">步骤：</span></h3><ol><li>将红黑树当作一颗二叉查找树，将该节点从二叉查找树中删除；</li><li>通过”旋转和重新着色”等一系列来修正该树，使之重新成为一棵红黑树。</li></ol><p>在具体实现的过程中，重点是如何该树重新成为一个红黑树，内容涉及左旋、右旋等专门定义的操作。不必细究。</p><h1><span id="应用场景">应用场景</span></h1><ol><li><p>著名的linux进程调度<a href="https://en.wikipedia.org/wiki/Completely_Fair_Scheduler" target="_blank" rel="noopener">Completely Fair Scheduler</a>,用红黑树管理进程控制块</p></li><li><p>epoll在内核中的实现，用红黑树管理事件块</p></li><li><p>Nginx中，用红黑树管理<a href="https://www.kancloud.cn/digest/understandingnginx/202602" target="_blank" rel="noopener">timer</a></p></li><li><p>Java的TreeMap实现</p></li><li><p>广泛用在C++的STL中。map和set都是用红黑树实现的。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;红黑树的性质&quot;&gt;红黑树的性质&lt;/span&gt;&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;每个节点要么是红的要么是黑的；&lt;/li&gt;
&lt;li&gt;根节点是黑的；&lt;/li&gt;
&lt;li&gt;每个叶节点（nil）都是黑的；&lt;/li&gt;
&lt;li&gt;如果一个节点是红的，那么它的两个子节点都是黑的；
      
    
    </summary>
    
    
  </entry>
  
</feed>
