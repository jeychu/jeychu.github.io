<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>javfa&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-12T04:20:02.760Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Javfa</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在CentOS7上安装eBPF-tools,bcc和ply</title>
    <link href="http://yoursite.com/2019/03/12/%E5%9C%A8CentOS7%E4%B8%8A%E5%AE%89%E8%A3%85eBPF-tools-bcc%E5%92%8Cply/"/>
    <id>http://yoursite.com/2019/03/12/在CentOS7上安装eBPF-tools-bcc和ply/</id>
    <published>2019-03-12T03:27:49.000Z</published>
    <updated>2019-03-12T04:20:02.760Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>升级内核：</p><p>CentOS7的内核版本是3.x，要安装使用eBPF，bcc和ply，内核版本至少是4.9，所以需要先升级CentOS7的内核。详见<a href="https://jeychu.github.io/2019/03/11/CentOS7%E5%8D%87%E7%BA%A7%E5%86%85%E6%A0%B8/" target="_blank" rel="noopener">CentOS7升级内核</a>。</p></li><li><p>升级、安装开发工具：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y epel-release</span><br><span class="line">sudo yum update -y</span><br><span class="line">sudo yum groupinstall -y &quot;Development tools&quot;</span><br><span class="line">sudo yum install -y elfutils-libelf-devel iperf cmake3</span><br></pre></td></tr></table></figure></li><li><p>安装LLVM，clang，ply和bcc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/build</span><br><span class="line">cd ~/build</span><br><span class="line">git clone https://github.com/iovisor/ply.git</span><br><span class="line">cd ply</span><br><span class="line">./autogen.sh</span><br><span class="line"> export CFLAGS=-I$&#123;HOME&#125;/build/usr/include</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line">cd ..</span><br><span class="line">curl -LO http://releases.llvm.org/3.9.1/cfe-3.9.1.src.tar.xz</span><br><span class="line">curl -LO http://releases.llvm.org/3.9.1/llvm-3.9.1.src.tar.xz</span><br><span class="line">tar -xf cfe-3.9.1.src.tar.xz</span><br><span class="line">tar -xf llvm-3.9.1.src.tar.xz</span><br><span class="line">mkdir clang-build</span><br><span class="line">mkdir llvm-build</span><br><span class="line"></span><br><span class="line">cd llvm-build</span><br><span class="line">cmake3 -G &quot;Unix Makefiles&quot; -DLLVM_TARGETS_TO_BUILD=&quot;BPF;X86&quot; \</span><br><span class="line">  -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=/usr ../llvm-3.9.1.src</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line">cd ../clang-build</span><br><span class="line">cmake3 -G &quot;Unix Makefiles&quot; -DLLVM_TARGETS_TO_BUILD=&quot;BPF;X86&quot; \</span><br><span class="line">  -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=/usr ../cfe-3.9.1.src</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line">cd ..</span><br><span class="line">git clone https://github.com/iovisor/bcc.git</span><br><span class="line">mkdir bcc-build</span><br><span class="line">cd bcc-build</span><br><span class="line">cmake3 -G &quot;Unix Makefiles&quot; -DCMAKE_INSTALL_PREFIX=/usr ../bcc</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure></li><li><p>安装完成：</p><p><img src="/2019/03/12/在CentOS7上安装eBPF-tools-bcc和ply/1552362190205.png" alt="1552362190205"></p></li></ol><p>参考文献：</p><p><a href="http://hydandata.org/installing-ebpf-tools-bcc-and-ply-on-centos-7" target="_blank" rel="noopener">Installing eBPF tools, bcc and ply on CentOS 7</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;升级内核：&lt;/p&gt;
&lt;p&gt;CentOS7的内核版本是3.x，要安装使用eBPF，bcc和ply，内核版本至少是4.9，所以需要先升级CentOS7的内核。详见&lt;a href=&quot;https://jeychu.github.io/2019/03/11/Cent
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>systemtap</title>
    <link href="http://yoursite.com/2019/03/11/systemtap/"/>
    <id>http://yoursite.com/2019/03/11/systemtap/</id>
    <published>2019-03-11T09:45:32.000Z</published>
    <updated>2019-03-11T11:34:48.205Z</updated>
    
    <content type="html"><![CDATA[<p>systemtap脚本的核心：事件和处理器</p><p>事件的发生触发处理器动作</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;systemtap脚本的核心：事件和处理器&lt;/p&gt;
&lt;p&gt;事件的发生触发处理器动作&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7升级内核</title>
    <link href="http://yoursite.com/2019/03/11/CentOS7%E5%8D%87%E7%BA%A7%E5%86%85%E6%A0%B8/"/>
    <id>http://yoursite.com/2019/03/11/CentOS7升级内核/</id>
    <published>2019-03-11T07:56:06.000Z</published>
    <updated>2019-03-12T04:16:40.991Z</updated>
    
    <content type="html"><![CDATA[<ol><li>当前版本</li></ol><p><img src="/2019/03/11/CentOS7升级内核/1552291068649.png" alt="1552291068649"></p><ol start="2"><li>开始升级：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</span><br></pre></td></tr></table></figure><p><img src="/2019/03/11/CentOS7升级内核/1552291299843.png" alt="1552291299843"></p><p><img src="/2019/03/11/CentOS7升级内核/1552291341907.png" alt="1552291341907"></p><p><img src="/2019/03/11/CentOS7升级内核/1552291401131.png" alt="1552291401131"></p><ol start="3"><li>将升级后的内核作为默认内核，重启机器</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># grub2-set-default 0</span><br><span class="line"># reboot</span><br></pre></td></tr></table></figure><ol start="4"><li>升级后的版本</li></ol><p><img src="/2019/03/11/CentOS7升级内核/1552353122161.png" alt="1552353122161"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;当前版本&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;/2019/03/11/CentOS7升级内核/1552291068649.png&quot; alt=&quot;1552291068649&quot;&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;开始升级：&lt;/li&gt;
&lt;/ol
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux性能优化之内存篇</title>
    <link href="http://yoursite.com/2019/03/10/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%86%85%E5%AD%98%E7%AF%87/"/>
    <id>http://yoursite.com/2019/03/10/Linux性能优化之内存篇/</id>
    <published>2019-03-10T11:05:56.000Z</published>
    <updated>2019-03-11T04:26:37.337Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#linux内存是怎么工作的">Linux内存是怎么工作的？</a><ul><li><a href="#内存映射">内存映射</a></li><li><a href="#虚拟内存空间分布">虚拟内存空间分布</a></li><li><a href="#内存分配与回收">内存分配与回收</a></li><li><a href="#如何查看内存使用情况">如何查看内存使用情况</a></li></ul></li><li><a href="#buffer和cache">Buffer和Cache</a></li><li><a href="#如何利用系统缓存优化程序的运行效率">如何利用系统缓存优化程序的运行效率</a></li></ul><!-- tocstop --><h1><span id="linux内存是怎么工作的">Linux内存是怎么工作的？</span></h1><p>内存管理是操作系统最核心的功能之一。内存主要用来存储系统和应用程序的指令、数据、缓存等。</p><p>Linux是怎么管理内存的呢？</p><h2><span id="内存映射">内存映射</span></h2><p>物理内存，也称为主存，大多数计算机用的主存都是动态随机访问内存（DRAM）。</p><p>只有内核才可以直接访问物理内存。进程要访问内存时，该怎么办呢？</p><p>Linux内核给每个进程都提供了一个独立的虚拟地址空间，并且这个地址空间是连续的。</p><p>进程可以很方便地访问虚拟内存。</p><p>虚拟地址空间的内部又被分为内核空间和用户空间两部分，不同字长（单个CPU指令可以处理数的最大长度）的处理器，虚拟地址空间的范围也不同。对于常见的32位和64位系统，它们的虚拟地址空间，如下所示：</p><p><img src="/2019/03/10/Linux性能优化之内存篇/1552216929887.png" alt="1552216929887"></p><p>既然每个进程都有一个这么大的地址空间，那么所有进程的虚拟内存加起来，自然要比实际的物理内存大得多。所以，并不是所有的虚拟内存都会分配物理内存，只有哪些实际使用的虚拟内存才分配物理内存，并且分配后的物理内存，是通过内存映射来管理的。</p><p>内存映射，就是将虚拟内存地址映射到物理内存地址。为了完成内存映射，内核为每个进程都维护了一张页表，记录虚拟地址与物理地址的映射关系，如下图所示：</p><p><img src="/2019/03/10/Linux性能优化之内存篇/1552216874797.png" alt="1552216874797"></p><p>页表存储在CPU的内存管理单元MMU中。</p><p>当进程访问的虚拟地址在页表中查不到时，系统会产生一个缺页异常，进入内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。</p><p>TLB是MMU中页表的高速缓存。由于进程的虚拟地址空间是独立的，而TLB的访问速度又比MMU快得多，所以，通过减少进程的上下文切换，减少TLB的刷新次数，就可以提高TLB缓存的使用率，进而提高CPU的内存访问性能。</p><p>MMU规定了内存映射的最小单位为页，通常是4KB大小，以页为单位来管理内存。这样，每一次内存映射，都需要关联4KB或4KB整数倍的内存空间。</p><p>页的大小只有4KB，整个页表非常大。比如，32位系统就需要100多万个页表项<sup>4GB/4KB=1048576</sup>，才可以实现整个地址空间的映射。</p><p>为了解决页表项过多的问题，Linux提供了两种机制：</p><ul><li><p><strong>多级页表</strong>：把内存分成区块来管理，将原来的映射关系改成区块索引和区块内的偏移。由于虚拟内存空间通常只用了很少一部分，那么，多级页表就只保持这些使用中的区块，这样就可以大大减少页表的项数。</p><p>Linux用四级页表来管理内存页，如下图所示，虚拟内存被分为5个部分，前4个表项用于选择页，而最后一个索引表示页内偏移。</p><p><img src="/2019/03/10/Linux性能优化之内存篇/1552218344165.png" alt="1552218344165"></p></li><li><p><strong>大页</strong></p><p>指的是比普通页更大的内存块，常见的大小有2MB和1GB。通常用在使用大量内存的进程上，如Oracle、DPDK等</p></li></ul><p>通过以上机制，在页表的映射下，进程就可以通过虚拟地址来访问物理内存了。那么，具体到一个Linux进程中，这些内存又是怎么使用的呢？</p><h2><span id="虚拟内存空间分布">虚拟内存空间分布</span></h2><p>虚拟内存空间的分布情况，以32位系统为例，如下所示：</p><p><img src="/2019/03/10/Linux性能优化之内存篇/1552218920555.png" alt="1552218920555"></p><p>最上方的是内核空间。虽然，每个进程的地址空间都包含了内核空间，但这些内核空间，其实关联的都是相同的物理内存。</p><p>下方的用户空间内存被划分成了多个不同的段。</p><p>从低到高分别是五种不同的内存段：</p><ol><li>只读段，包括代码和常量等；</li><li>数据段，包括全局变量等；</li><li>堆，包括动态分配的内存，从低地址开始向上增长；</li><li>文件映射段，包括动态库、共享内存等，从高地址开始向下增长；</li><li>栈，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是8MB。</li></ol><p>内存是怎么分配的呢？</p><h2><span id="内存分配与回收">内存分配与回收</span></h2><p>malloc()是C标准库提供的内存分配函数，对应到系统调用上，有两种实现方式，即brk()和mmap()。</p><ul><li><p>对于小块内存（小于128K），C标准库使用brk()来分配内存。也就是通过移动堆顶的位置来分配内存。这些内存释放后并不会立刻归还系统，而是被缓存起来，重复使用。</p><p>缓存的方式，可以减少缺页异常的发生，提高内存访问效率。</p><p>但是由于内存没有归还系统，易造成内存碎片。</p></li><li><p>对于大块内存（大于128K），则直接使用内存映射mmap()来分配。也就是在文件映射段找一块空闲内存分配出去。</p><p>由于释放时，直接归还系统，所以每次mmap都会发生缺页异常。</p><p>大量的缺页异常，使内核的管理负担增大。所以malloc只对大块内存使用mmap。</p></li></ul><p><strong>当这两种调用发生后，其实并没有真正分配内存。这些内存，都只是在首次访问时才被分配，也就是通过缺页异常进入内核中，再由内核来分配内存。</strong></p><p>内核使用伙伴系统来管理内存分配。和MMU一样，伙伴系统也是以页为单位进行管理，并且通过相邻块的合并，减少内存碎片化。</p><p>对于比页更小的对象，比如不到1K的时候，内核通过slab分配器来管理这些小内存。</p><p>对于内存来说，如果只分配而不释放，就会造成内存泄漏，甚至会耗尽系统内存。所以，在应用程序用完内存后，还需要调用free()或unmap()，来释放这些不用的内存。</p><p>在发现内存紧张时，系统会通过以下方式回收内存：</p><ul><li><p>回收缓存，比如使用LRU（Least Recently Used）算法，回收最近使用最少的内存页面；</p></li><li><p>回收不常访问的内存，把不常用的内存通过交换分区直接写到磁盘中。Swap把一块磁盘空间当成内存来用。从内存到磁盘称为换出，从磁盘读取到内存称为换入。</p></li><li><p>杀死进程，通过OOM（Out Of Memory），直接杀死占用大量内存的进程。内核使用oom_score为每个进程的内存使用情况进行评分：</p><ul><li>一个进程消耗的内存越大，oom_score就越大；</li><li>一个进程运行占用的CPU越大，oom_score就越小。</li></ul><p>oom_score越大，越容易被OOM杀死。</p><p>可以通过调整/proc/中进程的oom_adj来调整进程的oom_score。</p><p>oom_adj的范围为[-17, 15]，数值越大，越容易被OOM杀死；-17表示禁止OOM。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo -16 &gt; /proc/$(pidof sshd)/oom_adj</span><br></pre></td></tr></table></figure><p>将sshd进程的oom_adj调小为-16，以使sshd不容易被OOM杀死。</p></li></ul><h2><span id="如何查看内存使用情况">如何查看内存使用情况</span></h2><p>free</p><p><img src="/2019/03/10/Linux性能优化之内存篇/1552275955243.png" alt="1552275955243"></p><p>available不仅包含未使用的内存，还包括了可回收的缓存，所以一般会比未使用内存更大。不过，并不是所有缓存都可以回收，因为有些缓存可能正在使用中。</p><p>top</p><p><img src="/2019/03/10/Linux性能优化之内存篇/1552276016601.png" alt="1552276016601"></p><p>下面部分显示了每个进程的内存使用情况：</p><ul><li>VIRT是进程虚拟内存的大小，只要是进程申请过的内存，即便还没有真正分配物理内存，也会计算在内；</li><li>RES是常驻内存的大小，也就是进程实际使用的物理内存大小，但不包括Swap和共享内存；</li><li>SHR是共享内存的大小，比如与其他进程共同使用的共享内存、加载的动态链接库以及程序的代码段等；需要注意的是，SHR并不一定是共享的，程序的代码段、非共享的动态链接库，也都计算在SHR里。</li><li>%MEM是进程使用物理内存占系统总内存的百分比。</li></ul><h1><span id="buffer和cache">Buffer和Cache</span></h1><p>磁盘读写的缓冲为Buffer</p><p>文件读写的缓存为Cache</p><p>Buffer和Cache的设计目的，是为了系统的IO性能。它们利用内存，充当起慢速磁盘和快速CPU之间的桥梁，可以加速IO的访问速度。</p><p>Buffer和Cache分别缓存的是对磁盘和文件系统的读写数据。</p><ul><li>从写的角度来说，不仅可以优化磁盘和文件的写入，对应用程序也有好处，应用程序可以在数据真正落盘前，就返回去做其他工作；</li><li>从度的角度来说，不仅可以提高那些频繁访问数据的读取速度，也降低了频繁IO对磁盘的压力。</li></ul><h1><span id="如何利用系统缓存优化程序的运行效率">如何利用系统缓存优化程序的运行效率</span></h1><p>缓存命中率，指直接通过缓存获取数据的请求次数，占所有数据请求次数的百分比。</p><p>命中率越高，表示使用缓存带来的收益越高，应用程序的性能也就越好。</p><p>实际上，缓存是现在所有高并发系统必需的核心模块，主要作用就是把经常访问的数据（也就是热点数据），提前读入到内存中。以加快应用程序的响应速度。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#linux内存是怎么工作的&quot;&gt;Linux内存是怎么工作的？&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#内存映射&quot;&gt;内存映射&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#虚拟内存空间分布&quot;&gt;虚拟内存空间分布&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>MySQL的监控</title>
    <link href="http://yoursite.com/2019/03/09/MySQL%E7%9A%84%E7%9B%91%E6%8E%A7/"/>
    <id>http://yoursite.com/2019/03/09/MySQL的监控/</id>
    <published>2019-03-08T18:05:10.000Z</published>
    <updated>2019-03-09T06:17:27.047Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL</p><p>监控哪些内容？</p><ul><li>数据库服务的可用性</li><li>数据库性能</li><li>主从同步的情况</li><li>服务器的资源</li><li></li></ul><p>怎么监控？</p><p>调优</p><p>先找出瓶颈所在，然后针对瓶颈做出优化</p><p>如何找瓶颈？</p><p>利用top ps vmstat iostat netstat /proc/</p><p>然后用perf strace ltrace systemtap 追踪进程 定位函数</p><p>zabbix添加自定义监控项</p><p>写脚本 -&gt; 在agentd.conf中添加UserParameter -&gt; 在server中用zabbix-get测试 -&gt;在web添加item和graph</p><p>故障排查思路：</p><p>网络 DNS解析是否正常 ping延时</p><p>主机</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;MySQL&lt;/p&gt;
&lt;p&gt;监控哪些内容？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据库服务的可用性&lt;/li&gt;
&lt;li&gt;数据库性能&lt;/li&gt;
&lt;li&gt;主从同步的情况&lt;/li&gt;
&lt;li&gt;服务器的资源&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;怎么监控？&lt;/p&gt;
&lt;p&gt;调优&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>The Kernel of Nginx之用好浏览器的缓存</title>
    <link href="http://yoursite.com/2019/03/06/The-Kernel-of-Nginx%E4%B9%8B%E7%94%A8%E5%A5%BD%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98/"/>
    <id>http://yoursite.com/2019/03/06/The-Kernel-of-Nginx之用好浏览器的缓存/</id>
    <published>2019-03-06T03:02:25.000Z</published>
    <updated>2019-03-08T12:57:26.489Z</updated>
    
    <content type="html"><![CDATA[<p>浏览器的缓存与nginx缓存</p><ul><li><p>浏览器缓存</p><ul><li>优点：<ul><li>使用有效缓存时，没有网络消耗，速度最快</li><li>即使有网络消耗，但对失效缓存使用304响应做到网络流量消耗最小化</li></ul></li><li>缺点：<ul><li>只提升一个用户的体验</li></ul></li></ul></li><li><p>Nginx缓存</p><ul><li>优点<ul><li>提升所有用户的体验</li><li>相比浏览器缓存，有效降低上游服务的负载</li><li>通过304响应减少Nginx与上游服务间的流量消耗</li></ul></li><li>缺点<ul><li>用户仍然保持网络消耗</li></ul></li></ul></li></ul><p>同时使用浏览器和Nginx缓存</p><p>浏览器缓存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 浏览器请求</span><br><span class="line">op1=&gt;operation: 有缓存</span><br><span class="line">op2=&gt;operation: 向浏览器请求带If-None_Match</span><br><span class="line">op3=&gt;operation: 向浏览器请求带If-Modified-Since</span><br><span class="line">op4=&gt;operation: 从缓存读取 200（from cache）</span><br><span class="line">op5=&gt;operation: 向web服务器请求</span><br><span class="line">op6=&gt;operation: 请求响应，缓存协商</span><br><span class="line">op7=&gt;operation: 从缓存读取</span><br><span class="line">con1=&gt;condition: 是否过期？</span><br><span class="line">con2=&gt;condition: Etag？</span><br><span class="line">con3=&gt;condition: Last-Modified？</span><br><span class="line">con4=&gt;condition: 200 or 304？</span><br><span class="line">end=&gt;end: 呈现</span><br><span class="line">st-&gt;op1-&gt;con1</span><br><span class="line">con1(no)-&gt;op4-&gt;end</span><br><span class="line">con1(yes)-&gt;con2</span><br><span class="line">con2(yes)-&gt;op2-&gt;con4</span><br><span class="line">con2(no)-&gt;con3</span><br><span class="line">con3(yes)-&gt;op3-&gt;con4</span><br><span class="line">con3(no)-&gt;op5-&gt;op6</span><br><span class="line">con4(yes)-&gt;op6</span><br><span class="line">con4(no)-&gt;op7-&gt;end</span><br><span class="line">op6-&gt;end</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax： etag on|off;</span><br><span class="line">Default: etag on;</span><br><span class="line">Context: http, server, location</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ngx_sprintf(etag-&gt;value.data, <span class="string">"\"%xT-%xO\""</span>,</span><br><span class="line">           r-&gt;headers_out.last_modified_time,</span><br><span class="line">           r-&gt;headers_out.contect_length_n)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;浏览器的缓存与nginx缓存&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;浏览器缓存&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：&lt;ul&gt;
&lt;li&gt;使用有效缓存时，没有网络消耗，速度最快&lt;/li&gt;
&lt;li&gt;即使有网络消耗，但对失效缓存使用304响应做到网络流量消耗最小化&lt;/li&gt;
&lt;/ul&gt;
&lt;/
      
    
    </summary>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx的优化</title>
    <link href="http://yoursite.com/2019/03/06/nginx%E7%9A%84%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/03/06/nginx的优化/</id>
    <published>2019-03-06T02:26:22.000Z</published>
    <updated>2019-03-10T17:26:17.399Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="基本安全优化">基本安全优化</span></h1><h2><span id="隐藏版本信息">隐藏版本信息</span></h2><h2><span id="更改nginx服务的默认用户">更改Nginx服务的默认用户</span></h2><h2><span id="降权启动nginx">降权启动Nginx</span></h2><h1><span id="参数优化nginx服务性能">参数优化Nginx服务性能</span></h1><h2><span id="进程个数-单个进程的最大连接数">进程个数、单个进程的最大连接数</span></h2><h2><span id="绑定cpu">绑定CPU</span></h2><h2><span id="gzip">gzip</span></h2><h2><span id="expires">expires</span></h2><h1><span id="日志的优化">日志的优化</span></h1><h1><span id="防盗链">防盗链</span></h1><h1><span id="防爬虫">防爬虫</span></h1><h1><span id="目录权限优化">目录权限优化</span></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;基本安全优化&quot;&gt;基本安全优化&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span id=&quot;隐藏版本信息&quot;&gt;隐藏版本信息&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span id=&quot;更改nginx服务的默认用户&quot;&gt;更改Nginx服务的默认用户&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;
      
    
    </summary>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>无之文</title>
    <link href="http://yoursite.com/2019/03/04/%E6%97%A0%E9%A2%98/"/>
    <id>http://yoursite.com/2019/03/04/无题/</id>
    <published>2019-03-03T16:28:27.000Z</published>
    <updated>2019-03-12T00:55:03.334Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>‘无意识流’<sup>自撰</sup>码点字儿，权当消遣、游戏。</p><p>具体写些什么，写出什么，我自己也是不知道的。</p><p>不断填充，每更以时间戳为领。</p></blockquote><!-- toc --><ul><li><a href="#1934">19/3/4</a></li><li><a href="#1935">19/3/5</a></li><li><a href="#1936">19/3/6</a></li><li><a href="#1938">19/3/8</a></li><li><a href="#1939">19/3/9</a></li><li><a href="#19310">19/3/10</a></li><li><a href="#19311">19/3/11</a></li></ul><!-- tocstop --><h1><span id="1934">19/3/4</span></h1><p>老夫聊发少年狂，不自量，频思量，要和困滞斗一场<br>人生不如意十八九，又何必，妄自沉，且奋起，争朝夕，人生百年是不枉</p><p>内核源码纷上阵，战得个天昏又地暗<br>人道是，廿一世纪，人工智能日日新，所能之事无限<br>现如今，百业俱兴于互联网<br>信息流转无量，人人都是网中虫<br>码农立功改了世界，创了互联界，人神之间自此有了个第三界</p><p>微信淘宝千百度，淘了个什么，又信了个什么？<br>大小屏幕满城皆是，人人淹没其间。<br>要在屏幕引源流，码农誓要战到深夜，不眠不休。</p><p>王者荣耀坑起来，坑到王者亦非常人也<br>鲁班后羿虽善射，易被珂切<br>项羽是个霸王，本色是喜欢虞姬<br>妲己是个妖女，总想一套秒<br>凯也是个肉，打不死还善单挑<br>典韦疯癫，满场飞奔…</p><p>恩金克思是个宝<br>鲁啊美月协助跑<br>林刘克思做服务<br>韦伯搞网成了王</p><hr><h1><span id="1935">19/3/5</span></h1><p>iHola!</p><p>¿Como estas?</p><p>香尘已隔犹回面<br>居人匹马映林嘶</p><p>新绿小池塘<br>帘动、碎影、斜阳<br>金屋去来 旧时巢燕<br>土花缭绕 前度霉墙<br>绣阁凤帷理丝簧</p><p>天寒水鸟自相依<br>十百为群戏落辉<br>行人过尽都不起<br>忽闻水响一起飞</p><p>携杖来追凉<br>花桥倚胡床<br>船笛参差起<br>池莲自在香</p><hr><h1><span id="1936">19/3/6</span></h1><p>知海无涯<br>海里行<br>无向即无功<br>看四周，都是极似<br>手中罗盘<br>历历晰晰<br>准方向<br>不旁骛<br>自可离海登陆<br>船体牢靠<br>方向笃定<br>定成航海王，掌控自生</p><hr><p>不自怨艾，稳住，都将烟消云散<br>云开日现<br>金晖永在，云遮不显<br>拨云自可见日<br>谁可拨？<br>大风耶？大风起兮云飞扬<br>大风来，尘土混乌云，暗无天日<br>小风耶？和风暖阳，自是佳时<br>小风何来？自来也<br>拨云见日者，非人力<br>人自求福，不自作孽，静待日开，得其光<br>但日总在，不因云遮就无<br>光透云，人依然可得其几许<br>故莫担心，莫贪心，莫失心<br>阴晴才是此间正道<br>阴晴都是那颗太阳</p><hr><h1><span id="1938">19/3/8</span></h1><p>二月二日 三八女节<br>雌雄合一 天地交泰<br>龙飞凤舞 双翔呈瑞<br>元亨利贞 吉吉吉吉</p><hr><h1><span id="1939">19/3/9</span></h1><p>痛通，痛得不欲生，就通了<br>自不量力者，撞的头破血流，心痛通</p><p>太阳照常升起，逝者从未停歇<br>珍惜光阴，涓滴莫弃<br>昨天已不复存在，明天从未到来，唯有今天，才是所有</p><p>乱 清理 有序<br>减 减 减<br>只剩一个 所向披靡</p><p>不家 于外 往西行</p><hr><h1><span id="19310">19/3/10</span></h1><p>喜鹊上下游嬉<br>貔貅口衔红币<br>金蟾门口招财<br>晶洞坐镇玄武<br>金鸡雄立西方</p><p>尼采句，大乱写：</p><p>能飞之人向上飞<br>于不能飞之人看来，<br>愈高愈渺</p><p>凝视深渊，深渊亦然<br>与恶魔斗，慎成恶魔</p><p>每天<br>若不曾起舞<br>即是<br>辜负生命</p><p>谦逊基于力量<br>傲慢基于无能</p><p>世界弥漫着焦躁不安，因众人皆急于从各自的枷锁中获得解放</p><p>不懂自己才是生命中最难的部分</p><p>曲则全，要曲莫直，曲曲折折，真理渐得显现</p><p>埋怨自己、憎恨他人之时。。。你需要休息了！</p><p>无有音乐，生活是错</p><p>智慧是个女人，她只爱战士——愿你勇敢、无忧、刚强</p><p>明为何而活，自可承受一切，幸与不幸</p><p>受苦之人，没有悲观的权力</p><hr><h1><span id="19311">19/3/11</span></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;‘无意识流’&lt;sup&gt;自撰&lt;/sup&gt;码点字儿，权当消遣、游戏。&lt;/p&gt;
&lt;p&gt;具体写些什么，写出什么，我自己也是不知道的。&lt;/p&gt;
&lt;p&gt;不断填充，每更以时间戳为领。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Nginx中的位运算</title>
    <link href="http://yoursite.com/2019/03/02/Nginx%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>http://yoursite.com/2019/03/02/Nginx和位运算/</id>
    <published>2019-03-02T10:39:45.000Z</published>
    <updated>2019-03-03T18:01:08.912Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇是学习<a href="https://www.jishuwen.com/d/2EGC/zh-hk" target="_blank" rel="noopener">其他博文</a>的笔记，根据自己的理解，做了些增补和简化。</p></blockquote><p>位运算在Nginx的源码处处可见，如</p><ul><li><p>定义指令的类型</p></li><li><p>标记当前请求是否还有未发送完的数据</p></li><li><p>事件模块里用指针的最低位来标记一个事件是否过期</p></li></ul><p>下面分析以下在Nginx中位运算的经典使用场景。</p><h1><span id="经典使用场景">经典使用场景</span></h1><h2><span id="对齐">对齐</span></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/ngx_config.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_align(d, a)     (((d) + (a - 1)) &amp; ~(a - 1))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_align_ptr(p, a)                                                    \</span></span><br><span class="line">    (u_char *) (((<span class="keyword">uintptr_t</span>) (p) + ((<span class="keyword">uintptr_t</span>) a - <span class="number">1</span>)) &amp; ~((<span class="keyword">uintptr_t</span>) a - <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>该宏使得d按a对齐<sup>第一个大于等于d的a倍数</sup>，其中a必须是2的幂次。</p><p>此宏就是寻找最小的且大于等于d的a的倍数。</p><p>由于a是2的幂次，因此a的二进制表示为00…1…00这样的形式，即它只有一个1，a-1便是00…01…1这样的形式。</p><p>接着，~(a-1)就会将低n为全部置0，n为a的低位连续0的个数。</p><p>此时，如果再将一个数和~（a-1）进行一次按位与，就能把这个数的低n位都清零（即成为a的倍数）。</p><p>而把这个数的低n位都清零，最多是从这个数减去a-1。</p><p>故而，d+（a-1）在经过和~（a-1）按位与而做了清零操作之后，最多也是减去a-1，也就是说，经过低位清零之后，其值最小是d，这样我们就得到了一个大于等于d，且低n位是0的对齐数，即一个大于等于d的a倍数。且是第一个大于等于d的a的倍数。</p><h2><span id="位图">位图</span></h2><p>位图，用以标记状态，只使用一个比特位来标记事物，从而节约内存，提升性能。</p><p>Nginx在对uri进行转义时，需要判断一个字符是否是一个保留字符，这样的字符需要被转义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// src/core/ngx_string.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint32_t</span>   uri_component[] = &#123;</span><br><span class="line">        <span class="number">0xffffffff</span>, <span class="comment">/* 1111 1111 1111 1111  1111 1111 1111 1111 */</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* ?&gt;=&lt; ;:98 7654 3210  /.-, +*)( '&amp;%$ #"!  */</span></span><br><span class="line">        <span class="number">0xfc009fff</span>, <span class="comment">/* 1111 1100 0000 0000  1001 1111 1111 1111 */</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* _^]\ [ZYX WVUT SRQP  ONML KJIH GFED CBA@ */</span></span><br><span class="line">        <span class="number">0x78000001</span>, <span class="comment">/* 0111 1000 0000 0000  0000 0000 0000 0001 */</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">/*  ~&#125;| &#123;zyx wvut srqp  onml kjih gfed cba` */</span></span><br><span class="line">        <span class="number">0xb8000001</span>, <span class="comment">/* 1011 1000 0000 0000  0000 0000 0000 0001 */</span></span><br><span class="line"></span><br><span class="line">        <span class="number">0xffffffff</span>, <span class="comment">/* 1111 1111 1111 1111  1111 1111 1111 1111 */</span></span><br><span class="line">        <span class="number">0xffffffff</span>, <span class="comment">/* 1111 1111 1111 1111  1111 1111 1111 1111 */</span></span><br><span class="line">        <span class="number">0xffffffff</span>, <span class="comment">/* 1111 1111 1111 1111  1111 1111 1111 1111 */</span></span><br><span class="line">        <span class="number">0xffffffff</span>  <span class="comment">/* 1111 1111 1111 1111  1111 1111 1111 1111 */</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>如上所示，一个数组组成一个位图，共包含8各数字，每个数字表示32个状态，因此这个位图标识出了256个字符的状态。为0的位表示一个通用字符，不需要转义，为1的位代表该字符需要转义。<br>如何使用这个位图呢？Nginx在遍历uri的时候，通过一条简单的语句来进行判断：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uri_component[ch &gt;&gt; <span class="number">5</span>] &amp; (<span class="number">1</span> &lt;&lt; (ch &amp; <span class="number">0x1f</span>))</span><br></pre></td></tr></table></figure><p>如上所示，ch表示当前字符，ch&gt;&gt;5是对ch右移5位，这起到一个除以32的效果，这一步操作确定了ch在uri_component的第几个数字上；</p><p>ch&amp;0x1f，则是取出ch低5位的值，相当于取模32，这个值表示ch在对应数字上的第几位；</p><p>1&lt;&lt;(ch&amp;0x1f)，将1左移ch在对应数字上的所在位数。将该数和对应数字相与，就可以取出对应数字上与ch相对应位置的bit位。</p><p>如：ch是‘0’（即数字48），它存在于位图的第二个数字上（48&gt;&gt;5=1)，又在这个数字（0xfc009fff）的第16位上，所以它的状态就是0xfc009fff &amp; 0x10000 = 0，所以‘0’是个通用字符，不用对它转义。</p><blockquote><p>位运算技巧：对一个2的幂次的数进行取模或者除操作的时候，可以通过位运算来实现。</p></blockquote><h2><span id="寻找最低位1的位置">寻找最低位1的位置</span></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; ~(x - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>~(x-1)使得除了最低位1的那个位置，其他位置和x都是相反的，因此二者进行按位与操作后，结果里只可能有一个1，便是原本x最低位的1。</p><h2><span id="寻找最高位1的位置">寻找最高位1的位置</span></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> bsf(<span class="keyword">size_t</span> input)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span> pos;</span><br><span class="line"></span><br><span class="line">    __asm__(<span class="string">"bsfq %1, %0"</span> : <span class="string">"=r"</span> (pos) : <span class="string">"rm"</span> (input));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">size_t bsf(size_t input)</span><br><span class="line">&#123;</span><br><span class="line">    input |= input &gt;&gt; 1;</span><br><span class="line">    input |= input &gt;&gt; 2;</span><br><span class="line">    input |= input &gt;&gt; 4;</span><br><span class="line">    input |= input &gt;&gt; 8;</span><br><span class="line">    input |= input &gt;&gt; 16;</span><br><span class="line">    input |= input &gt;&gt; 32;</span><br><span class="line"></span><br><span class="line">    return input - (input &gt;&gt; 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="计算1的个数">计算1的个数</span></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本篇是学习&lt;a href=&quot;https://www.jishuwen.com/d/2EGC/zh-hk&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;其他博文&lt;/a&gt;的笔记，根据自己的理解，做了些增补和简化。&lt;/p&gt;
&lt;/bloc
      
    
    </summary>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>微服务设计</title>
    <link href="http://yoursite.com/2019/02/28/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2019/02/28/微服务设计/</id>
    <published>2019-02-28T14:53:03.000Z</published>
    <updated>2019-02-28T15:02:21.320Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="微服务">微服务</span></h1><h1><span id="演化式架构师">演化式架构师</span></h1><h1><span id="如何建模服务">如何建模服务</span></h1><h1><span id="集成">集成</span></h1><h1><span id="分解单块系统">分解单块系统</span></h1><h1><span id="部署">部署</span></h1><h1><span id="测试">测试</span></h1><h1><span id="监控">监控</span></h1><h1><span id="安全">安全</span></h1><h1><span id="康威定律和系统设计">康威定律和系统设计</span></h1><h1><span id="规模化微服务">规模化微服务</span></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;微服务&quot;&gt;微服务&lt;/span&gt;&lt;/h1&gt;&lt;h1&gt;&lt;span id=&quot;演化式架构师&quot;&gt;演化式架构师&lt;/span&gt;&lt;/h1&gt;&lt;h1&gt;&lt;span id=&quot;如何建模服务&quot;&gt;如何建模服务&lt;/span&gt;&lt;/h1&gt;&lt;h1&gt;&lt;span id=&quot;集成&quot;&gt;集成&lt;/span
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript In A Nutshell</title>
    <link href="http://yoursite.com/2019/02/26/JavaScript-In-A-Nutshell/"/>
    <id>http://yoursite.com/2019/02/26/JavaScript-In-A-Nutshell/</id>
    <published>2019-02-25T17:49:28.000Z</published>
    <updated>2019-03-02T07:54:16.741Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="基础">基础</span></h1><h2><span id="运行时页面构建过程">运行时页面构建过程</span></h2><h3><span id="生命周期概览">生命周期概览</span></h3><p><img src="/2019/02/26/JavaScript-In-A-Nutshell/1551510836738.png" alt="1551510836738"></p><p>客户端Web应用的周期从用户指定某个网站地址开始，由两个步骤组成：<strong>页面构建和事件处理</strong>。</p><p>来个例子，这个例子展示：每当用户移动鼠标或单击页面就会显示一条消息。</p><p>以下是代码：</p><p><img src="/2019/02/26/JavaScript-In-A-Nutshell/1551511209573.png" alt="1551511209573"></p><p>以下是运行和交互结果：</p><p><img src="/2019/02/26/JavaScript-In-A-Nutshell/1551512582730.png" alt="1551512582730"></p><h3><span id="页面构建阶段">页面构建阶段</span></h3><p>该阶段的目标是建立web应用的UI，主要包括两个步骤：</p><ul><li>解析HTML代码并构建文档对象模型（DOM）；</li><li>执行JavaScript代码。</li></ul><p><img src="/2019/02/26/JavaScript-In-A-Nutshell/1551512933518.png" alt="1551512933518"></p><p><img src="/2019/02/26/JavaScript-In-A-Nutshell/1551513184204.png" alt="1551513184204"></p><h3><span id="事件处理">事件处理</span></h3><h1><span id="理解函数">理解函数</span></h1><p>定义与参数</p><p>理解函数调用</p><p>闭包和作用域</p><p>生成器和promise</p><h1><span id="钻研对象">钻研对象</span></h1><p>面向对象与原型</p><p>控制对象的访问</p><p>处理集合</p><p>正则表达式</p><p>代码模式化</p><h1><span id="洞悉浏览器">洞悉浏览器</span></h1><p>DOM操作</p><p>事件</p><p>跨浏览器的开发技巧</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;基础&quot;&gt;基础&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span id=&quot;运行时页面构建过程&quot;&gt;运行时页面构建过程&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span id=&quot;生命周期概览&quot;&gt;生命周期概览&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/2019/02/
      
    
    </summary>
    
    
      <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Nginx的配置</title>
    <link href="http://yoursite.com/2019/02/21/Nginx%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/02/21/Nginx的配置/</id>
    <published>2019-02-21T15:21:21.000Z</published>
    <updated>2019-02-24T12:50:13.731Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="运行中的nginx进程间的关系">运行中的Nginx进程间的关系</span></h1><p>在正式提供服务的产品环境中，部署Nginx时都是使用一个master进程来管理多个worker进程，一般情况下，worker进程的数量与服务器上的CPU核心数相等。每一个worker进程都时繁忙的，它们在真正地提供互联网服务，master进程则很“清闲”，只负责监控管理worker进程。worker之间通过共享内存、原子操作等一些进程间通信机制来实现负载均衡等功能。</p><p>Nginx是支持单进程（master进程）提供服务的，那么为什么产品环境下要按照master、worker方式配置同时启动多个进程呢？这样做的好处主要有一下两点：</p><ul><li>由于master进程不会对用户请求提供服务，只用于管理真正提供服务的worker进程，所以master进程可以是唯一的，它仅专注于自己的纯管理工作，为管理员提供命令行服务，包括诸如启动服务、停止服务、重新配置文件、平滑升级程序等。master进程需要拥有较大的权限，例如，通常会使用root用户启动master进程。worker进程的权限要小于或者等于master进程，这样master进程才可以完全地管理worker进程。当任意一个worker进程出现错误从而导致coredump时，master进程会立刻启动新的worker进程继续服务。</li><li>多个worker进程处理互联网请求不但可以提高服务的健壮性，最重要的是，这样可以充分利用现在常见的SMP多核架构，从而实现微观上真正的多核并发处理。为什么要把worker进程数量设置得跟CPU核心数量一致呢？对于Nginx，一个worker进程可以同时处理的请求数只受限于内存大小，而且在架构上，<strong>不同的worker进程之间处理并发请求时几乎没有同步锁的限制</strong>，worker进程通常不会进入睡眠状态，因此，当Nginx上的进程数与CPU核心数相等时（最好每一个worker进程都绑定特定的CPU核心【使用taskset命令来设置进程的CPU亲和性（affinity），将进程绑定到某个或某组CPU核心上】），进程间的切换的代价是最小的。</li></ul><h1><span id="nginx服务的基本配置">Nginx服务的基本配置</span></h1><h2><span id="用于调试进程和定位问题的配置项">用于调试进程和定位问题的配置项</span></h2><ol><li><p>是否以守护进程方式运行Nginx</p><p>语法：daemon on|off;</p><p>默认：daemon on;</p><p>关闭守护进程的模式，方便使用gdb跟踪调试Nginx，在研究Nginx架构时很有用。</p></li><li><p>是否以master/worker方式工作</p><p>语法：master_process on | off;</p><p>默认：master_process on;</p><p>如果用off关闭了master_process方式，就不会fork出worker子进程来处理请求，而是用master进程自身来处理请求。</p></li><li><p>error日志的位置</p><p>语法：error_log /path/file level;</p><p>默认：error_log logs/error.log error;</p><p>error日志是定位Nginx问题的最佳工具，我们可以根据自己的需求妥善设置error日志的路径和级别。<br>/path/file可以是：</p><ul><li>一个具体的文件，例如，默认情况下是logs/error.log文件，最好将它放到一个磁盘空间足够大的位置；</li><li>也可以是/dev/null，这也是关闭error日志的唯一方法；</li><li><p>也可以是stderr，将日志输出到标准错误文件中；</p><p>level是日志的输出级别，取值范围是debug、info、notice、warn、error、crit、alert、emerg，从左到右级别依次增大。当设定一个级别时，大于或者等于该级别的日志都会输出到/path/file文件中，小于该级别的日志则不会输出。</p><p>如果日志级别设定到debug，必须在configure时加入–with-debug配置项。</p></li></ul></li><li><p>是否处理几个特殊的调试点</p><p>语法：debug_points [stop|abort]</p><p>这个配置项也是用来帮助用户跟踪调试Nginx的。Nginx在一些关键的错误逻辑中设置了调试点。如果设置了debug_points为stop，那么Nginx的代码执行到这些调试点时就会发出SIGSTOP信号以用于调试。如果设置为abort，则会产生一个coredump文件，可以使用gdb来查看Nginx当时的各种信息。</p></li><li><p>仅对指定的客户端输出debug级别的日志</p><p>语法：debug_connection [IP|CIDR]</p><p>这个配置项实际上属于事件类配置，因此，它必须放在events {…}中才有效。</p><p>对来自于指定IP地址的请求才会输出debug级别的日志，其他请求仍然沿用error_log中配置的日志级别。</p></li><li><p>限制coredump核心转储文件的大小</p><p>语法：worker_rlimit_core size;</p><p>在Linux系统中，当进程发生错误或收到信号而终止时，系统会将进程执行时的内存内容写入一个文件，以作为调试只用，这就是所谓的核心转储（core dumps）.</p></li><li><p>指定coredump文件生成目录</p><p>语法：working_directory path;</p></li></ol><h2><span id="正常运行的配置项">正常运行的配置项</span></h2><ol><li><p>定义环境变量</p><p>语法：env VAR|VAR=VALUE;</p><p>这个配置项可以让用户直接设置操作系统上的环境变量。</p></li><li><p>嵌入其他配置文件</p><p>语法：include /path/file;</p></li><li><p>pid文件的路径</p><p>语法：pid /path/file;</p><p>默认：pid logs/nginx.pid;</p></li><li><p>Nginx worker进程运行的用户和用户组</p><p>语法：user username [groupname];</p><p>默认：user nobody nodoby;</p></li><li><p>指定Nginx worker进程可以打开的最大句柄描述符个数</p><p>语法：worker_rlimit_nofile limit;</p></li><li><p>限制信号队列</p><p>语法：worker_rlimit_sigpending limit;</p><p>设置每个用户发往Nginx的信号队列的大小。也就是说，当某个用户的信号队列满了，这个用户再发送的信号量就会被丢掉。</p></li></ol><h2><span id="优化性能的配置项">优化性能的配置项</span></h2><ol><li><p>Nginx worker进程个数</p><p>语法：worker_processes number;</p><p>默认：worker_processes 1;</p></li><li><p>绑定Nginx worker进程到指定的CPU内核</p><p>语法：worker_cpu_affinity cpumask [cpumask…]</p><p>例如，如果有4个CPU内核，可以进行如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">worker_processes 4;</span><br><span class="line">worker_cpu_affinity 1000 0100 0010 0001;</span><br></pre></td></tr></table></figure></li><li><p>SSL硬件加速</p><p>语法：ssl_engine device;</p><p>如果服务器上有ssl硬件加速设备，那么就可以进行配置以加快SSL协议的处理速度。</p></li><li><p>系统调用gettimeofday的执行频率</p><p>语法：timer_resolution t;</p><p>默认情况下，每次内核的事件调用（如epoll、select、poll、kqueue等）返回时，都会执行一次gettimeofday，实现用内核的时钟来更新Nginx中的缓存时钟。</p><p>在早期的内核中，gettimeofday的执行代价不小，因为中间有一次内核态到用户态的内存复制。需要降低gettimeofday的调用频率时，可以使用该配置项，表示至少每t秒才调用一次。</p><p>但在目前的大多数内核中，gettimeofday只是一次vsyscall，仅仅是对共享内存页中的数据做访问，并不是通常的系统调用，代价不大，一般不必使用这个配置。</p></li><li><p>Nginx worker进程优先级设置</p><p>语法：worker_priority nice;</p><p>默认：worker_pricrity 0;</p><p>当有多个进程处于可执行状态时，系统将按照所有进程的优先级来决定本次内核选择哪一个进程执行。</p><p>进程所分配的时间片大小也与进程优先级相关，优先级越高，进程分配到的时间片也就越大。</p><p>（在默认配置下，最小的时间片时5ms，最大的时间片则有800ms。）</p><p>这样，优先级高的进程会占有更多的系统资源。</p></li></ol><h2><span id="事件类配置项">事件类配置项</span></h2><ol><li><p>是否打开accept锁</p><p>语法：accept_mutex [on|off];</p><p>默认：accept_mutex on;</p><p>accept_mutex是Nginx的负载均衡锁。</p><p>这把锁可以让多个worker进程轮流地、序列化地与新的客户端建立TCP连接。</p><p>当某个worker进程建立的连接数量达到worker_connections配置的最大连接数的7/8时，会大大地减小该worker进程试图建立新TCP连接的机会，以此实现所有的worker进程之上处理的客户端请求数尽量接近。</p><p>如果关闭它，那么建立TCP连接的耗时会更短，但worker进程之间的负载会非常不均衡。不建议关闭它。</p></li><li><p>lock文件的路径</p><p>语法：lock_file path/file;</p><p>默认：lock_file logs/nginx.lock;</p><p>accept_mutex为off时，此配置完全不生效。</p><p>accept_mutex为on是，若由于编译程序、操作系统导致Nginx不支持原子锁，这时会用文件锁来实现accecpt锁，此时lock_file所指定的lock文件才会生效。</p><blockquote><p><strong>文件锁</strong>：在多任务操作系统中，如果一个进程尝试对正在被其他进程读取的文件进行写操作，可能会导致正在进行读操作的进程读取到一些被破坏或者不完整的数据；如果两个进程并发对同一个文件进行写操作，可能会导致该文件遭到破坏。因此，为了避免发生这种问题，必须要采用某种机制来<strong>解决多个进程并发访问同一个文件时所面临的同步问题</strong>，由此而产生了文件加锁方面的技术。</p><p>Linux支持的文件锁主要包括劝告锁（advisory lock）和强制锁（mandatory lock）这两种。此外，Linux中还引入了两种强制锁的变种形式：共享模式强制锁（share-mode mandatory lock）和租借锁（lease）。</p></blockquote></li><li><p>使用accept锁后到真正建立连接之间的延迟时间</p><p>语法：accept_mutex_delay Nms;</p><p>默认：accept_mutex_delay 500ms;</p><p>在使用accept锁后，同一时间只有一个worker进程能够取到accept锁。这个锁不是阻塞锁，如果取不到会立刻返回。如果有一个worker进程试图取锁而未得，它至少要等该配置项所定义的时间间隔后才能再次试图取锁。</p></li><li><p>批量建立新连接</p><p>语法：multi_accept [on|off];</p><p>默认：multi_accept off;</p><p>当事件模型通知有新连接时，尽可能地对本次调度中客户端发起的所有TCP请求都建立连接。</p></li><li><p>选择事件模型</p><p>语法：use [kqueue|rtsig|epoll|/dev/poll|select|poll|eventport];</p><p>默认：Nginx会自动使用最合适的事件模型。</p><p>在Linux系统中，epoll性能是最高的。</p></li><li><p>每个worker的最大连接数</p><p>语法：worker_connections number;</p><p>定义每个worker进程可以同时处理的最大连接数。</p></li></ol><h1><span id="使用http核心模块配置一个静态web服务器">使用HTTP核心模块配置一个静态Web服务器</span></h1>]]></content>
    
    <summary type="html">
    
      Nginx的配置详解
    
    </summary>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Web性能基础</title>
    <link href="http://yoursite.com/2019/02/21/Web%E6%80%A7%E8%83%BD%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/02/21/Web性能基础/</id>
    <published>2019-02-21T02:54:57.000Z</published>
    <updated>2019-02-24T12:48:20.377Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="网络技术概览">网络技术概览</span></h1><h2><span id="延迟与带宽">延迟与带宽</span></h2><p>速度是关键</p><p>WPO（Web Performance Optimization）产业从无到有，快速增长，充分说明用户越来越重视速度方面的用户体验。</p><p>业绩证实：</p><ul><li>网站越快，用户的黏性越高</li><li>网站越快，用户忠诚度更高</li><li>网站越快，用户转化率越高</li></ul><p>延迟和带宽：</p><ul><li><p>延迟：分组从信息源发送到目的地所需的时间</p></li><li><p>带宽：逻辑或物理通信路径最大的吞吐量</p></li></ul><p>延迟的构成：</p><ul><li>传播延迟<br>消息从发送端到接收端需要的时间，是信号传播距离和速度的函数</li><li>传输延迟<br>把消息中的所有比特转移到链路中需要的时间，是消息长度和链路速率的函数</li><li>处理延迟<br>处理分组首部、检查位错误及确定分组目标所需的时间</li><li>排队延迟<br>到来的分组排队等待处理的时间</li></ul><blockquote><p>在软件交互中，哪怕100-200ms左右的延迟，大多数人都会感觉到‘拖拉’；如果超过了300ms的门槛，就会说“反应迟钝”。</p></blockquote><blockquote><p>光速与分组在介质中传播速度之比，叫做该介质的折射率。我们大都假定光纤的折射率约为1.5，即光通过光纤的速度约为每秒200，000，000米。</p></blockquote><h2><span id="tcp">TCP</span></h2><h2><span id="udp">UDP</span></h2><h2><span id="tls">TLS</span></h2><h1><span id="无线网络性能">无线网络性能</span></h1><h2><span id="wifi">WIFI</span></h2><h2><span id="移动网络">移动网络</span></h2><h1><span id="http">HTTP</span></h1><h2><span id="http-1x">HTTP 1.x</span></h2><h2><span id="http-20">HTTP 2.0</span></h2><h2><span id="优化应用的交付">优化应用的交付</span></h2><h1><span id="浏览器api与协议">浏览器API与协议</span></h1><h2><span id="xmlhttprequest">XMLHttpRequest</span></h2><h2><span id="服务器发送事件">服务器发送事件</span></h2><h2><span id="websocket">websocket</span></h2><p>WebSocket可以实现客户端与服务器间同时双向、基于消息的文本或二进制数据传输。<br>WebSocket使得浏览器具备了实时、双向通信的能力，是由HTML5开始提供的一种浏览器与服务器进行全双工通讯的网络技术，属于应用层协议。基于TCP传输协议，并复用HTTP的握手通道。</p><ul><li>优点：<ul><li>支持双向通信，实时性更强</li><li>更好的支持二进制</li><li>较少的控制开销。连接创建后，ws客户端、服务的进行数据交换时，协议控制的数据包头部较小。</li><li>支持扩展。可以扩展协议，实现自定义的自协议（如自定义压缩算法等）</li></ul></li></ul><h3><span id="1-入门例子">1. 入门例子：</span></h3><ul><li>1.1 <strong>服务端</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="built_in">require</span>(<span class="string">'express'</span>)();</span><br><span class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">'http'</span>).Server(app);</span><br><span class="line"><span class="keyword">var</span> WebSocket = <span class="built_in">require</span>(<span class="string">'ws'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wss = <span class="keyword">new</span> WebSocket.Server(&#123; <span class="attr">port</span>: <span class="number">8080</span> &#125;);</span><br><span class="line"></span><br><span class="line">wss.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> <span class="title">connection</span>(<span class="params">ws</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'server: receive connection.'</span>);</span><br><span class="line">    </span><br><span class="line">    ws.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> <span class="title">incoming</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'server: received %s'</span>, message);</span><br><span class="line">        ws.send(<span class="string">'server: reply'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    ws.on(<span class="string">'pong'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'server: received pong from client'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    ws.send(<span class="string">'world'</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// setInterval(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//     ws.ping('', false, true);</span></span><br><span class="line">    <span class="comment">// &#125;, 2000);</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.sendfile(__dirname + <span class="string">'/index.html'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><ul><li>1.2 <strong>客户端</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:8080'</span>);</span><br><span class="line">  ws.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'ws onopen'</span>);</span><br><span class="line">    ws.send(<span class="string">'from client: hello'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  ws.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'ws onmessage'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'from server: '</span> + e.data);</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><ul><li>1.3 <strong>运行结果</strong></li></ul><p><em>服务端输出</em>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server: receive connection.</span><br><span class="line">server: received hello</span><br></pre></td></tr></table></figure></p><p><em>客户端输出</em>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">client: ws connection is open</span><br><span class="line">client: received world</span><br></pre></td></tr></table></figure></p><h3><span id="2-如何建立连接">2. 如何建立连接</span></h3><p>WebSocket复用了HTTP的握手通道。具体是指，客户端通过HTTP请求与WebSocket服务器协商升级协议。</p><ul><li><p>2.1. 客户端：申请协议升级</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: localhost:8080</span><br><span class="line">Origin: http://127.0.0.1:3000</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Sec-WebSocket-Key: w4v7O6xFTi36lq3RNcgctw==</span><br></pre></td></tr></table></figure></li><li><p>2.2. 服务端：响应协议升级</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Connection:Upgrade</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Sec-WebSocket-Accept: Oy4NRAQ13jhfONC7bP8dTKb4PTU=</span><br></pre></td></tr></table></figure></li><li><p>2.3. Sec-WebSocket-Accept的计算</p></li></ul><p>伪代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;toBase64( sha1( Sec-WebSocket-Key +258EAFA5-E914-47DA-95CA-C5AB0DC85B11 )  )</span><br></pre></td></tr></table></figure></p><h3><span id="3-数据帧格式">3. 数据帧格式</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-------+-+-------------+-------------------------------+</span><br><span class="line">|F|R|R|R| opcode|M| Payload len |    Extended payload length    |</span><br><span class="line">|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |</span><br><span class="line">|N|V|V|V|       |S|             |   (if payload len==126/127)   |</span><br><span class="line">| |1|2|3|       |K|             |                               |</span><br><span class="line">+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</span><br><span class="line">|     Extended payload length continued, if payload len == 127  |</span><br><span class="line">+ - - - - - - - - - - - - - - - +-------------------------------+</span><br><span class="line">|                               |Masking-key, if MASK set to 1  |</span><br><span class="line">+-------------------------------+-------------------------------+</span><br><span class="line">| Masking-key (continued)       |          Payload Data         |</span><br><span class="line">+-------------------------------- - - - - - - - - - - - - - - - +</span><br><span class="line">:                     Payload Data continued ...                :</span><br><span class="line">+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</span><br><span class="line">|                     Payload Data continued ...                |</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure><h3><span id="4-数据传递">4. 数据传递</span></h3><p>使用场景及性能</p><h2><span id="webrtc">WebRTC</span></h2>]]></content>
    
    <summary type="html">
    
      有关于Web性能的基础知识
    
    </summary>
    
    
      <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Linux性能优化之CPU篇</title>
    <link href="http://yoursite.com/2019/02/20/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/02/20/Linux性能优化/</id>
    <published>2019-02-20T13:18:11.000Z</published>
    <updated>2019-03-10T12:14:04.088Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#平均负载">平均负载</a></li><li><a href="#上下文切换">上下文切换</a><ul><li><a href="#概述">概述</a></li><li><a href="#怎么查看系统的上下文切换情况">怎么查看系统的上下文切换情况</a></li></ul></li><li><a href="#cpu的使用率">CPU的使用率</a><ul><li><a href="#概述-1">概述</a></li><li><a href="#查看cpu使用率">查看CPU使用率</a></li><li><a href="#cpu使用率过高怎么办">CPU使用率过高怎么办？</a></li></ul></li><li><a href="#不可中断进程和僵尸进程的处理方法">不可中断进程和僵尸进程的处理方法</a><ul><li><a href="#进程状态">进程状态</a></li><li><a href="#处理方法">处理方法</a></li></ul></li><li><a href="#软中断">软中断</a><ul><li><a href="#怎么查看软中断和内核线程呢">怎么查看软中断和内核线程呢？</a></li></ul></li><li><a href="#如何迅速分析出系统cpu的瓶颈在哪里">如何迅速分析出系统CPU的瓶颈在哪里？</a></li><li><a href="#cpu性能优化的几个思路">CPU性能优化的几个思路</a><ul><li><a href="#性能优化方法论">性能优化方法论</a><ul><li><a href="#怎么评估性能优化的效果">怎么评估性能优化的效果？</a></li><li><a href="#多个性能问题同时存在要怎么选择">多个性能问题同时存在，要怎么选择？</a></li><li><a href="#有多种优化方法时要如何选择">有多种优化方法时，要如何选择？</a></li></ul></li><li><a href="#cpu优化">CPU优化</a><ul><li><a href="#应用程序优化">应用程序优化</a></li><li><a href="#系统优化">系统优化</a></li></ul></li><li><a href="#不要过早优化">不要过早优化</a></li></ul></li></ul><!-- tocstop --><h2><span id="平均负载">平均负载</span></h2><p>什么是平均负载？</p><p>是指一定时间内系统中处于可运行状态和不可中断等待状态的进程数的平均数</p><h2><span id="上下文切换">上下文切换</span></h2><h3><span id="概述">概述</span></h3><p>进程在竞争CPU的时候并没有真正运行，为什么还会导致系统的负载升高呢？这是因为CPU上下文切换。</p><p>在每个任务运行前，CPU都需要知道任务从哪里加载，又从哪里开始运行，需要系统事先帮它设置好CPU寄存器和程序计数器（Program Counter，PC）。</p><p>CPU寄存器，是CPU内置的容量小，但速度极快的内存。而程序计数器，则是用来存储CPU正在执行的指令位置、或者即将执行的下一条指令位置。它们都是CPU在运行任何任务前，必须的依赖环境，因此也被叫做CPU上下文。如下图所示：</p><p><img src="/2019/02/20/Linux性能优化/1551593332821.png" alt="1551593332821"></p><p>CPU上下文切换就是先把前一个任务的CPU上下文保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。</p><p>根据任务的不同，CPU的上下文切换可以分为：</p><ul><li><p>进程上下文切换</p><p>Linux按照特权等级，把进程的运行空间分为内核空间和用户空间，对应的特权等级分别为Ring 0和Ring 3。</p><ul><li><p>内核空间（Ring 0）具有最高权限，可以直接访问所有资源；</p></li><li><p>用户空间（Ring 3）只能访问受限资源，不能访问内存等硬件设备，必须通过系统调用进入到内核中，才能访问这些特权资源。</p><p><img src="/2019/02/20/Linux性能优化/1551594532880.png" alt="1551594532880"></p></li></ul><p>对于一个进程，从用户态到内核态的转变，需要通过系统调用来完成。一次系统调用的过程，会发生两次CPU上下文切换。</p><p>进程的上下文切换：进程是由内核来管理和调度的，进程的切换只能发生再内核态。进程的上下文不仅包括虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的状态。</p><p>因此，进程的上下文切换比系统调用时多了一步：在保存当前进程的内核状态和CPU寄存器之前，需要先把该进程的虚拟内存、栈保存下来；而加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈。</p><p>在进程上下文切换次数较多的情况下，很容易导致CPU将大量实际耗费在寄存器、内核栈以及虚拟内存等资源的保存和恢复上，进而大大缩短了真正运行进程的时间。</p><p>另外，Linux通过TLB（Translation Lookaside Buffer）来管理虚拟内存到物理内存的映射关系。当虚拟内存更新后，TLB也需要更新，内存的访问也会随之变慢。</p></li><li><p>线程上下文切换</p><p>线程是调度的基本单位，而进程是资源拥有的基本单位。</p><p>所谓内核中的任务调度，实际上的调度对象是线程；而进程只是给线程提供了虚拟内存、全局变量等资源。</p><p>所以，对于线程和进程，我们可以这样理解：</p><ul><li>当进程只有一个线程时，可以认为进程就等于线程；</li><li>当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源。这些资源在上下文切换时是不需要修改的。</li><li>线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时是需要保存的</li></ul></li><li><p>中断上下文切换</p><p>为了快速响应硬件的事件，中断处理会打断进程的正常调度和执行，转而调用中断处理程序，响应设备事件。</p><p>跟进程上下文不同，中断上下文切换并不涉及到进程的用户态。所以，即便中断过程打断了一个正处在用户态的进程，也不需要保存和恢复这个进程的虚拟内存、全局变量等用户态资源。</p><p>中断上下文，其实只包括内核态中断服务程序执行所必需的状态，包括CPU寄存器、内核堆栈、硬件中断参数等。</p><p>对同一个CPU来说，中断处理比进程拥有更高的优先级，所以中断上下文切换并不会与进程上下文切换同时发生。</p></li></ul><h3><span id="怎么查看系统的上下文切换情况">怎么查看系统的上下文切换情况</span></h3><ol><li>使用vmstat</li></ol><p><img src="/2019/02/20/Linux性能优化/1551598709362.png" alt="1551598709362"></p><ul><li>cs（context switch）是每秒上下文切换的次数</li><li>in（interrupt）是每秒中断的次数</li><li>r（Running or Runnable）是就绪队列的长度，也就是正在运行和等待CPU的进程数</li><li>b（Blocked）则是处于不可中断睡眠状态的进程数</li></ul><ol start="2"><li>对于每个进程的详细情况，可使用pidstat</li></ol><p><img src="/2019/02/20/Linux性能优化/1551599003703.png" alt="1551599003703"></p><p>其中：</p><ul><li>cswch，表示每秒自愿上下文切换（voluntary context switches）的次数</li><li>nvcswch，表示每秒非自愿上下文切换（non  voluntary context switches）的次数。</li></ul><p>这两个概念意味着不同的性能问题：</p><ul><li>自愿上下文切换，是指进程无法获取所需资源，导致的上下文切换。比如说，I/O、内存等系统资源不足时，就会发生自愿上下文切换。</li><li>非自愿上下文切换，则是指进程由于时间片已到等原因，被系统强制调度，进而发生上下文切换。比如说，大量进程都在争抢CPU时，就容易发生非自愿上下文切换。</li></ul><h2><span id="cpu的使用率">CPU的使用率</span></h2><h3><span id="概述">概述</span></h3><p>Linux是多任务操作系统，它将CPU时间划分为时间片，然后通过调度算法轮流分配给各个任务使用。</p><blockquote><p>调度算法：</p><p>Linux的调度算法一直在更新，最新的调度算法是CFS（完全公平调度器）。</p><p>调度算法决定在众多的线程中哪个线程获得执行、什么时候开始执行、执行多久。</p><p>调度器先划分出Scheduler Classes<sup>调度类</sup>，每个不同的Class对应不同类型的线程，每个Class都有自己的优先级。</p><p>调度管理基础代码会遍历在内核中注册了的调度类，选择高优先级的调度类，然后让此调度类按照自己的调度算法选择下一个执行的线程。</p><p>常用的调度类：</p><ul><li><p>SCHED_NORMAL  普通线程调度类</p><p>只具有nice值，映射到用户层的取值范围为-20-19</p><p>调度器要解决一个基本问题是：要先找出‘交互线程’，保证这种线程优先得到调度，然后才考虑其他问题。</p></li><li><p>SCHED_FIFO </p><p>SCHED_RR</p><p>实时线程调度类</p><p>拥有实时优先级（real-time priority）,默认取值为0-99</p></li></ul></blockquote><p>为了维护CPU时间，Linux通过事先定义的节拍率（内核中表示为HZ，表示每秒触发的时间中断的次数），触发时间中断，并使用全局变量Jiffies记录了开机以来的节拍数。每发生一次时间中断，Jiffies的值就加1。</p><p>节拍率HZ是内核的可配选项，可以设置为100、250、1000等。可以通过以下命令查看它的配置值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@geek ~]<span class="comment"># grep -i "config_hz" /boot/config-$(uname -r)</span></span><br><span class="line"><span class="comment"># CONFIG_HZ_PERIODIC is not set</span></span><br><span class="line"><span class="comment"># CONFIG_HZ_100 is not set</span></span><br><span class="line"><span class="comment"># CONFIG_HZ_250 is not set</span></span><br><span class="line"><span class="comment"># CONFIG_HZ_300 is not set</span></span><br><span class="line">CONFIG_HZ_1000=y</span><br><span class="line">CONFIG_HZ=1000</span><br></pre></td></tr></table></figure><p>内核提供了一个用户空间节拍率USER_HZ，它总是固定为100，也就是说，在用户空间一个节拍的时间为1/100秒。</p><p>/proc/stat提供了系统CPU和任务统计信息。执行以下命令，可以看到CPU的相关信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@geek ~]# cat /proc/stat | grep ^cpu</span><br><span class="line">cpu  126633 3769 165166 11498685 3763 0 21088 0 0 0</span><br><span class="line">cpu0 126633 3769 165166 11498685 3763 0 21088 0 0 0</span><br></pre></td></tr></table></figure><p>第一列表示的是CPU编号，第一行没有编号的CPU，表示的是所有CPU的累加。</p><p>其他列表示不同场景下CPU的累加节拍数，单位是1/USER_HZ秒，也就是10ms（1/100秒），其实也就是不同场景下的CPU时间。</p><p>后面的列依照顺序，分别为<sup>括号中内容表示缩写</sup>：</p><ul><li>user（us），代表用户态CPU时间，注意它不包括下面的nice时间，但包括了guest时间。</li><li>nice（ni），代表低优先级用户态CPU时间，也就是进程的nice值被调整为1-19之间的CPU时间。</li><li>system（sys），代表内核态CPU时间。</li><li>idle（id），代表空闲时间。注意，它不包括等待I/O的时间（iowait）</li><li>iowait（wa），代表等待I/O的CPU时间。</li><li>irq（hi），代表处理硬中断的CPU时间。</li><li>softirq（si），代表处理软中断的CPU时间。</li><li>steal（st），代表当系统运行在虚拟机中的时候，被其他虚拟机占用的CPU时间。</li><li>guest（guest），代表通过虚拟化运行其他操作系统的时间，也就是运行虚拟机的CPU时间。</li><li>guest_nice（gnice），代表以低优先级运行的虚拟机时间。</li></ul><p><img src="/2019/02/20/Linux性能优化/1551432942707.png" alt="1551432942707"></p><p>为了计算CPU的使用率，性能工具一般都会取间隔一段时间（比如3秒）的两次值，做差后，在计算出这段时间内的平均CPU使用率，即：</p><p><img src="/2019/02/20/Linux性能优化/1551433018852.png" alt="1551433018852"></p><p>跟系统的指标类似，Linux也给每个进程提供了运行情况的统计信息，也就是/proc/[pid]/stat。</p><p>那是不是说要查看CPU使用率，就必须先读取/proc/stat和/proc/[pid]/stat这两个文件，然后再按照上面的公式计算出来呢？</p><p>当然不是，各种各样的性能分析工具已经帮我们计算好了。</p><p>需要注意的是，性能分析工具给出的都是间隔一段时间的平均CPU使用率，所以要注意间隔时间的设置，特别是用多个工具对比分析时，一定要保证它们用的是相同的时间间隔。</p><p>top默认使用3秒时间间隔，而ps使用的是进程的整个生命周期，所以这两个工具报告的CPU使用率，默认的结果很可能是不一样的。</p><h3><span id="查看cpu使用率">查看CPU使用率</span></h3><p>使用top命令，如下：</p><p><img src="/2019/02/20/Linux性能优化/1551436121518.png" alt="1551436121518"></p><p>对于进程的实时信息，每个进程都有一个%CPU列，表示进程的CPU使用率。它是用户态和内核态CPU使用率的总和，包括进程用户空间使用的CPU、提供系统调用执行的内核空间CPU、以及在就绪队列等待运行的CPU。在虚拟化环境中，它还包括了运行虚拟机占用的CPU。</p><p>所以，top并没有细分进程的用户态CPU和内核态CPU。那要怎么查看每个进程的详细情况呢？可以使用pidstat，是一个专门分析每个进程CPU使用情况的工具。</p><p><img src="/2019/02/20/Linux性能优化/1551436602236.png" alt="1551436602236"></p><p>上面的pidstat命令，间隔1s展示了进程的3组CPU使用率，包括：</p><ul><li>用户态CPU使用率（%usr）</li><li>内核态CPU使用率（%system）</li><li>运行虚拟机CPU使用率（%guest）</li><li>以及总的CPU使用率（%CPU）</li></ul><h3><span id="cpu使用率过高怎么办">CPU使用率过高怎么办？</span></h3><p>通过top、ps、pidstat等工具，能够轻松找到CPU使用率较高的进程。接下来，占用CPU的到底是代码中的哪个函数呢？找到它，才能高效有针对性的进行优化。</p><p>怎么找呢？用GDB？GDB是个功能强大的程序调试利器。但它并不适合在性能分析的早期使用。为什么呢？因为GDB调试程序的过程会中断程序运行，这在线上环境往往是不允许的。所以，GDB只适合在性能分析的后期，当你找到了出问题的大致函数后，线下再借助它来进一步调试函数内部的问题。</p><p>哪种工具适合在第一时间分析进程的CPU问题呢？推荐使用perf。</p><p>perf是Linux2.6.31以后内置的性能分析工具。它以性能数据采样为基础，不仅可以分析系统的各种事件和内核性能，还可以用来分析指定应用程序的性能问题。</p><ul><li><p>perf top</p><p><img src="/2019/02/20/Linux性能优化/1551437842824.png" alt="1551437842824"></p><p>输出结果中，第一行包含三个数据，分别是采样数（Samples）、事件类型（event）和事件总数（Event count）。比如以上例子中，perf总共采集了25k个CPU时钟事件，而总事件数则是262083270。</p><p>再往下看，每一行包含四列，分别是：</p><ul><li>第一列Overhead，是该符号的性能事件所在所有采样中的比例</li><li>第二列Shared Object，是该函数或指令所在的动态共享对象（Dynamic Shared Object),如内核、进程名、动态链接库名、内核模块名等</li><li>第三列，是动态共享对象的类型。比如：[.]表示用户空间的可执行程序、或者动态链接库，而[k]表示内核空间</li><li>最后一列Symbol是符号名，也就是函数名。当函数名未知时，用十六进制的地址来表示。</li></ul></li><li><p>perf record &amp; perf report</p><p>使用perf record保持数据，保存后的数据，需要使用perf record解析展示。</p><p><img src="/2019/02/20/Linux性能优化/1551439032460.png" alt="1551439032460"></p></li></ul><h2><span id="不可中断进程和僵尸进程的处理方法">不可中断进程和僵尸进程的处理方法</span></h2><h3><span id="进程状态">进程状态</span></h3><p>top或ps命令输出中，进程状态栏各符号的含义：</p><ul><li><p>R</p><p>Running或Runnable的缩写，表示进程在CPU的就绪队列中，正在运行或者正在等待运行</p></li><li><p>D</p><p>Disk Sleep的缩写，也就是不可中断睡眠，一般表示进程正在和硬件交互，并且交互过程不允许被其他进程或中断打断</p></li><li><p>Z</p><p>Zombie的缩写，表示僵尸进程，也就是进程实际上已经结束了，但是父进程还没有回收它的资源（比如进程的描述符、PID等）</p></li><li><p>S</p><p>Interruptible Sleep的缩写，也就是可中断状态睡眠，表示进程因为等待某个事件而被系统挂起。当进程等待的事件发生时，它会被唤醒并进入R状态。</p></li><li><p>I</p><p>Idle的缩写。也就是空闲状态，用在不可中断睡眠的内核进程上。</p></li><li><p>T或者t</p><p>Stopped或Traced的缩写，表示进程处于暂停或跟踪状态。</p><p>向一个进程发送SIGSTOP信号，它就会响应这个信号变成Stopped，再向它发送SIGCONT信号，进程又会恢复运行。</p><p>当你用调试器调试一个进程时，在使用断点中断进程后，进程就会变成跟踪状态，这其实是一种特殊的暂停状态，只不过你可以用调试器来跟踪并按需要控制进程的运行。</p></li><li><p>X</p><p>Dead的意思。表示进程已经消亡，所以你不会在top或者ps命令输出中看到它。</p></li></ul><p><img src="/2019/02/20/Linux性能优化/1551502558996.png" alt="1551502558996"></p><ul><li><p>s</p><p>session leader的意思。什么是session呢？session指的是相互关联的进程组。</p></li><li><p>+</p><p>表示的是前台进程</p></li></ul><h3><span id="处理方法">处理方法</span></h3><p>出现僵尸进程，是由于父进程没有回收子进程的资源。所以，要找到僵尸进程的父进程，在父进程里解决。</p><p>使用pstree命令，找到父进程。</p><h2><span id="软中断">软中断</span></h2><p>中断是一种异步的事件处理机制，可以提高系统的并发处理能力。</p><p>由于中断处理程序会打断其他进程的运行，所以，为了减少对正常进程运行调度的影响，中断处理程序就需要尽可能快地运行。</p><p>为了解决中断处理程序执行过长和中断丢失的问题，Linux将中断处理过程分成了两个阶段：</p><ul><li><p>上半部用来快速处理中断，它在中断禁止模式下运行，主要处理跟硬件紧密相关的或时间敏感的工作；</p><p>直接处理硬件请求，硬中断，特点是快速执行</p><p>会打断CPU正在执行的任务，然后立即执行中断处理程序</p></li><li><p>下半部用来延迟处理上半部未完成的工作，通常以内核线程的方式运行。</p><p>由内核触发，软中断，特点是延迟执行</p><p>以内核线程的方式执行，每个CPU都对应一个软中断内核线程，名为“ksoftirqd/CPU编号”</p></li></ul><p>软中断不只包括硬件设备中断处理程序的下半部，一些内核自定义的事件也属于软中断，比如内核调度和RCU锁（Read-Copy Update）</p><h3><span id="怎么查看软中断和内核线程呢">怎么查看软中断和内核线程呢？</span></h3><p>/proc/softirqs</p><p>/proc/interrupts</p><h2><span id="如何迅速分析出系统cpu的瓶颈在哪里">如何迅速分析出系统CPU的瓶颈在哪里？</span></h2><h2><span id="cpu性能优化的几个思路">CPU性能优化的几个思路</span></h2><p>在找到CPU的性能瓶颈之后，下一步要做的就是优化了，也就是找出充分利用CPU的方法，以便完成更多的工作。</p><h3><span id="性能优化方法论">性能优化方法论</span></h3><p>在经过千辛万苦，通过各种性能优化方法，终于找到引发性能问题的瓶颈后，是不是立即就要开始优化了呢？</p><p>此时，不必着急，动手之前，可以先看看下面三个问题：</p><ul><li>要怎么判断优化措施是否是有效的？特别是，优化后性能到底又提升了多少呢？</li><li>性能问题通常不是独立的，如果有多个性能问题同时发生，应该先优化哪一个呢？</li><li>提升性能的方法并不是唯一的，当有多种方法可以选择时，选用哪一种呢？是不是总选那个最大程度提升性能的方法就行了呢？</li></ul><p>如果你可以轻松回答这三个问题，那么优化可以立即开始了。</p><h4><span id="怎么评估性能优化的效果">怎么评估性能优化的效果？</span></h4><p>为了评估效果，我们需要对系统的性能指标进行量化，并且要分别测试出优化前、后的性能指标，用前后指标的变化来对比呈现效果。</p><p>性能评估“三步走”：</p><ul><li>确定性能的量化指标</li><li>测试优化前的性能指标</li><li>测试优化后的性能指标</li></ul><h4><span id="多个性能问题同时存在要怎么选择">多个性能问题同时存在，要怎么选择？</span></h4><p><strong>并不是所有的性能问题都值得优化</strong>。</p><p>80%的问题都是由20%的代码导致的。只要找出这20%的位置，你就可以优化80%的性能。</p><h4><span id="有多种优化方法时要如何选择">有多种优化方法时，要如何选择？</span></h4><p>一般情况下，选能最大提升性能的方法，这也是性能优化的目标。</p><p>但是，性能优化并非没有成本。性能优化通常会带来复杂度的提升，降低程序的可维护性，还可能在优化一个指标时，引发其他指标的异常。</p><p>所以，在考虑选哪个性能优化方法时，需要综合多方面的因素。</p><h3><span id="cpu优化">CPU优化</span></h3><p>在清楚了性能优化最基本的三个问题后，接下来从应用程序和系统的角度，分别来看看如何才能降低CPU使用率，提高CPU的并行处理能力：</p><h4><span id="应用程序优化">应用程序优化</span></h4><p>从应用程序的角度来说，降低CPU使用率的最好方法是，排除所有不必要的工作，只保留最核心的逻辑。比如减少循环的层次、减少递归、减少动态内存分配等等。</p><p>此外，还有：</p><ul><li>编译器优化：很多编译器都会提供优化选项，适当开启它们，在编译阶段你就可以获得编译器的帮助，来提升性能。比如，gcc就提供了优化选项-O2，开启后会自动对应用程序的代码进行优化。</li><li>算法优化：使用复杂度更低的算法，可以显著加快处理速度。比如，在数据比较大的情况下，可以用O(nlogn)的排序算法（如快排、归并排序等）代替O(n^2)的排序算法（如冒泡、插入排序等）</li><li>异步处理：使用异步处理，可以避免程序因为等待某个资源而一直阻塞，从而提升程序的并发处理能力。比如，把轮询替换为事件通知，就可以避免轮询耗费CPU的问题</li><li>多线程代替多进程：相对于进程的上下文切换，线程的上下文切换并不切换进程地址空间，因此可以降低上下文切换的成本。</li><li>善用缓存：经常访问的数据或计算过程中的步骤，可以放到内存中缓存起来，只要在下次要用的时候就直接从内存中获取，加快程序的处理速度。</li></ul><h4><span id="系统优化">系统优化</span></h4><p>从系统的角度来说，优化CPU的运行，一方面要充分利用CPU缓存的本地性，加速缓存访问；另一方面，就要控制进程的CPU使用情况，减少进程间的相互影响。</p><ul><li>CPU绑定：把进程绑定到一个或者多个CPU上，可以提高CPU缓存的命中率，减少跨CPU调度带来的上下文切换问题</li><li>CPU独占：跟CPU绑定类似，进一步将CPU分组，并通过CPU亲和性机制为其分配进程。这样，这些CPU就由指定的进程独占，也就是说，不允许其他进程再来使用这些CPU</li><li>优先级调整：使用nice调整进程的优先级，正值调低优先级，负值调高优先级。</li><li>为进程设置资源限制：使用Linux cgroups来设置进程的CPU使用上限，可以防止由于某个应用自身的问题，而耗尽系统资源</li><li>NUMA优化：支持NUMA的处理器会被划分为多个node，每个node都有自己的本地内存空间。NUMA优化，其实就是让CPU尽可能只访问本地内存</li><li>中断负载均衡：无论是软中断还是硬中断，它们的中断处理程序都可能会耗费大量的CPU。开启irqbalance服务或者配置smp_affinity，就可以把中断处理过程自动负载均衡到多个CPU上。</li></ul><h3><span id="不要过早优化">不要过早优化</span></h3><blockquote><p>过早优化是万恶之源。——高纳德</p></blockquote><p>过早优化不可取。这是因为：</p><ul><li>优化会带来复杂性的提升，降低可维护性；</li><li>需求不是一成不变的。针对当前情况进行的优化，很可能并不适应快速变化的新需求。这样，在新需求出现时，这些复杂的优化，反而可能阻碍新功能的开发。</li></ul><p>所以，性能优化最好是逐步完善，动态进行的，不追求一步到位，<strong>而要首先保证能满足当前的性能要求</strong>。当发现性能不满足要求或者出现性能瓶颈时，再根据性能评估的结果，选择最重要的性能问题进行优化。</p>]]></content>
    
    <summary type="html">
    
      如何做Linux的性能优化
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Discover the Secrets of Linux Kernel</title>
    <link href="http://yoursite.com/2019/02/20/Linux-Kernel/"/>
    <id>http://yoursite.com/2019/02/20/Linux-Kernel/</id>
    <published>2019-02-20T08:47:55.000Z</published>
    <updated>2019-02-28T14:46:09.366Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#如何学习内核">如何学习内核：</a><ul><li><a href="#将内核划分成两层减少内核阅读的难度">将内核划分成两层，减少内核阅读的难度</a><ul><li><a href="#内核基础层">内核基础层</a></li><li><a href="#内核应用层">内核应用层</a></li></ul></li><li><a href="#内核学习最终目的">内核学习最终目的：</a></li></ul></li><li><a href="#内核的基础层和应用层">内核的基础层和应用层</a><ul><li><a href="#内核基础层提供的服务">内核基础层提供的服务</a><ul><li><a href="#内核中使用内存">内核中使用内存</a></li><li><a href="#内核中的任务调度">内核中的任务调度</a></li><li><a href="#软中断和tasklet">软中断和tasklet</a></li><li><a href="#工作队列">工作队列</a></li><li><a href="#自旋锁">自旋锁</a></li><li><a href="#内核信号量">内核信号量</a></li><li><a href="#原子变量">原子变量</a></li></ul></li><li><a href="#内核基础层的数据结构">内核基础层的数据结构</a><ul><li><a href="#双向链表">双向链表</a></li><li><a href="#hash链表">hash链表</a></li><li><a href="#单向链表">单向链表</a></li><li><a href="#红黑树">红黑树</a></li><li><a href="#radix树">radix树</a></li></ul></li><li><a href="#内核应用层-1">内核应用层</a></li></ul></li><li><a href="#文件系统">文件系统</a></li><li><a href="#设备的概念和总体架构">设备的概念和总体架构</a></li><li><a href="#为设备服务的特殊文件系统sysfs">为设备服务的特殊文件系统sysfs</a></li><li><a href="#字符设备和input设备">字符设备和input设备</a></li></ul><!-- tocstop --><h1><span id="如何学习内核">如何学习内核：</span></h1><ul><li>以应用为目的来学习，边学边用，学以致用</li><li>以培养内核的阅读能力为主要目标</li><li>阅读和修改真实的代码，而非只是阅读书籍</li><li>需要不断的更新和学习，因为内核的策略和方法一直在不断的变化着</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">勿贪大求全，聚焦关键应用</span><br><span class="line">奠定基础，循序渐进</span><br><span class="line">兴趣是第一驱动力</span><br></pre></td></tr></table></figure><h2><span id="将内核划分成两层减少内核阅读的难度">将内核划分成两层，减少内核阅读的难度</span></h2><h3><span id="内核基础层">内核基础层</span></h3><blockquote><p>内核中提供基础服务的部分</p></blockquote><ul><li>代码总量很少，但难度高</li><li>提供基本稳定的API</li><li>数据结构 </li><li>内核同步机制</li><li>内存管理和任务调度</li><li>学习方法：<ul><li>以API接口学习为主要内容，不细究实现</li><li>日后应该加强基础层的研读</li></ul></li></ul><h3><span id="内核应用层">内核应用层</span></h3><blockquote><p>建立在基础层之上，提供应用服务的部分</p></blockquote><ul><li>占代码的90%以上，数量多，重复性强</li><li>接口经常变化</li><li>文件系统 </li><li>设备和驱动</li><li>网络</li><li>学习方法：<ul><li>文件系统是应用层的基础和灵魂</li><li>从文件系统入手，驻步扩展</li><li>以架构为核心，举一反三</li><li>设备和驱动不依赖具体设备，以通用架构为主</li></ul></li></ul><h2><span id="内核学习最终目的">内核学习最终目的：</span></h2><ul><li>独立思考，独立学习，不断分享成为在该领域有影响力的专家</li></ul><h1><span id="内核的基础层和应用层">内核的基础层和应用层</span></h1><h2><span id="内核基础层提供的服务">内核基础层提供的服务</span></h2><p>内核通常提供的服务是内存管理、进程管理、设备管理和文件系统。</p><h3><span id="内核中使用内存">内核中使用内存</span></h3><p>内核中提供了两个层次的内存分配接口：</p><ul><li><p>从伙伴系统分配：是最底层的内存管理机制，提供页式的内存管理。</p><p>伙伴系统分配内存调用的是alloc_pages，得到的是页面地址，如果要获得能使用的内存地址，还需要用page_address。</p><p>如果要直接获得内存地址，需要使用_get_free_pages。它封装了alloc_pages和page_address两个函数。</p></li><li><p>从slab系统分配：是伙伴系统之上的内存管理，提供基于对象的内存管理。</p><p>alloc_pages申请的内存是以页为单元的，最少是一个页。如果只是申请一小块内存，一个页就很浪费，而且内核中很多应用也希望一种对象化的内存管理，希望内存管理能自动地构造和析构对象，这就是slab内存管理。</p><p>使用kmem_cache_create创建slab对象来从slab申请内存。kmem_cache_create可以提供对象的名字和大小、构造函数和析构函数等，然后通过kmem_cache_alloc和kmem_cache_free来申请和释放内存。</p><p>内核中常用的kmalloc其实也是slab提供的对象管理，只不过内核已经构建了一些固定大小的对象，用户通过kmalloc申请的时候，就直接使用了这些对象。</p><p>一个内核中创建slab对象的例子如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bh_cachep = kmem_cache_create(<span class="string">"buffer_head"</span>,</span><br><span class="line">                              <span class="keyword">sizeof</span>(struct buffer_head), <span class="number">0</span>,</span><br><span class="line">                              (SLAB_RECLAIM_ACCOUNT|SLAB_PANIC|SLAB_MEM_SPREAD),</span><br><span class="line">                              init_buffer_head,</span><br><span class="line">                              <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>用以下代码申请一个slab对象：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">ret</span> = <span class="title">kmem_cache_alloc</span>(<span class="title">bh_cachep</span>, <span class="title">gfp_flags</span>);</span></span><br></pre></td></tr></table></figure><p>内核中另一个内存分配调用vmalloc的作用是把物理内存不连续的内存页面拼凑为逻辑地址连续的内存区间。</p></li></ul><h3><span id="内核中的任务调度">内核中的任务调度</span></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> wait_event(wq, condition)</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (condition)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    __wait_event(wq, condition);</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __wait_event(wq, condition)</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    DEFINE_WAIT(__wait);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        prepare_to_wait(&amp;wq, &amp;__wait, TASK_UNINTERRUPTIBLE);</span><br><span class="line">        <span class="keyword">if</span> (condition)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        schedule();</span><br><span class="line">    &#125;</span><br><span class="line">    finish_wait(&amp;wq, &amp;__wait);</span><br><span class="line">&#125;<span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>上文定义了一个wait结构，然后设置进程睡眠。如果其他进程唤醒这个进程后，判断条件是否满足，如果满足，删除wait对象，否则进程继续睡眠。</p><h3><span id="软中断和tasklet">软中断和tasklet</span></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_TASKLET_DISABLED(hil_mlcs_tasklet, hil_mlcs_process, <span class="number">0</span>);</span><br><span class="line">tasklet_schedule(&amp;hil_mlcs_tasklet);</span><br></pre></td></tr></table></figure><h3><span id="工作队列">工作队列</span></h3><p>和tasklet类似，都是一种延缓执行的机制。</p><p>不同之处是工作队列有自己的进程上下文，所以工作队列可以睡眠，也可以被调度，而tasklet不可睡眠。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INIT_WORK(&amp;ioc-&gt;sas_persist_task,</span><br><span class="line">         mptsas_persist_clear_table,</span><br><span class="line">         (<span class="keyword">void</span> *)ioc);</span><br><span class="line">schedule_work(&amp;ioc-&gt;sas_persist_task);</span><br></pre></td></tr></table></figure><h3><span id="自旋锁">自旋锁</span></h3><p>用来在多处理器的环境下保护数据。</p><p>如果内核发现数据未锁，就获取锁并运行；如果数据被锁，就一直旋转（其实是一直反复执行一条指令）。之所以说自旋锁用在多处理器环境，是因为在单处理器环境（非抢占式内核）下，自旋锁其实不起作用。在单处理器抢占式内核的情况下，自旋锁起到禁止抢占的作用。</p><p>因为被自旋锁锁着的进程一直旋转，而不是睡眠，所以自旋锁可以用在中断等禁止睡眠的场景。</p><p>自旋锁的使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spin_lock(shost-&gt;host_lock);</span><br><span class="line">shost-&gt;host_busy++;</span><br><span class="line">spin_unlock(shost-&gt;host_lock);</span><br></pre></td></tr></table></figure><h3><span id="内核信号量">内核信号量</span></h3><p>和自旋锁类似，作用是保护数据。</p><p>不同之处在于，进程获取内核信号量的时候，如果不能获取，则进程进入睡眠状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">down(&amp;dev-&gt;sem);</span><br><span class="line">up(&amp;dev-&gt;sem);</span><br></pre></td></tr></table></figure><h3><span id="原子变量">原子变量</span></h3><p>提供了一种原子的、不可中断的操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atomic_t mapped;</span><br></pre></td></tr></table></figure><p>内核提供了一系列的原子变量操作函数，如下所示</p><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td>atomic_add</td><td>加一个整数到原子变量</td></tr><tr><td>atomic_sub</td><td>从原子变量减一个整数</td></tr><tr><td>atomic_read</td><td>读原子变量的数值</td></tr><tr><td>atomic_set</td><td>设置原子变量的数值</td></tr></tbody></table><h2><span id="内核基础层的数据结构">内核基础层的数据结构</span></h2><p>container是Linux中很重要的一个概念，使用container能实现对象的封装。代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> container_of(ptr, type, member) (&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="title">typeof</span><span class="params">(((type *)<span class="number">0</span>)-&gt;member)</span> *__mptr </span>= (ptr);</span><br><span class="line">  (type *)((<span class="keyword">char</span> *)__mptr - offsetof(type, member));&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offsetof(type, member) (size_t)&amp;(((type*)0)-&gt;member)</span></span><br></pre></td></tr></table></figure><p>这个方法可以实现通过结构的一个成员找到整个结构的地址。内核中大量使用了这个方法。</p><h3><span id="双向链表">双向链表</span></h3><p>list是双向链表的一个抽象，定义在/include/linux目录下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_entry(ptr, type, member)</span></span><br><span class="line">container_of(ptr, type, member)</span><br></pre></td></tr></table></figure><table><thead><tr><th>内联函数和宏</th><th>作用</th></tr></thead><tbody><tr><td>LIST_HEAD</td><td>定义并初始化一个list链表</td></tr><tr><td>list_add_tail</td><td>加一个成员到链表尾</td></tr><tr><td>list_del</td><td>删除一个list成员</td></tr><tr><td>list_empty</td><td>检测链表是否为空</td></tr><tr><td>list_for_each</td><td>遍历链表</td></tr><tr><td>list_for_each_safe</td><td>遍历链表（可以删除遍历的成员）</td></tr><tr><td>list_for_each_entry</td><td>遍历链表（通过container方法返回结构指针）</td></tr></tbody></table><h3><span id="hash链表">hash链表</span></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">first</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="单向链表">单向链表</span></h3><h3><span id="红黑树">红黑树</span></h3><p>红黑树是一种自平衡的二叉树，代码位于/lib/rbtree.c文件。</p><h3><span id="radix树">radix树</span></h3><h2><span id="内核应用层">内核应用层</span></h2><h1><span id="文件系统">文件系统</span></h1><p>基本概念</p><p>文件系统的架构</p><p>从代码层深入分析文件系统</p><h1><span id="设备的概念和总体架构">设备的概念和总体架构</span></h1><p>设备的配置表</p><p>访问设备寄存器和设备内存</p><p>设备中断和DMA</p><p>总线对设备的扫描</p><p>设备驱动管理</p><h1><span id="为设备服务的特殊文件系统sysfs">为设备服务的特殊文件系统sysfs</span></h1><p>文件和目录的创建</p><p>sysfs文件的打开操作</p><p>sysfs文件的读写</p><p>kobject结构</p><h1><span id="字符设备和input设备">字符设备和input设备</span></h1><p>文件如何变成设备</p><p>input设备的注册</p><p>input设备架构</p><p>platform总线</p>]]></content>
    
    <summary type="html">
    
      以应用为目的来学习Linux内核，通过阅读和修改代码，培养内核的阅读能力
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>红黑树</title>
    <link href="http://yoursite.com/2018/05/28/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>http://yoursite.com/2018/05/28/红黑树/</id>
    <published>2018-05-28T11:07:51.000Z</published>
    <updated>2019-03-03T21:47:49.471Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="红黑树的性质">红黑树的性质</span></h1><ol><li>每个节点要么是红的要么是黑的；</li><li>根节点是黑的；</li><li>每个叶节点（nil）都是黑的；</li><li>如果一个节点是红的，那么它的两个子节点都是黑的；</li><li>任意节点到叶节点的每条简单路径都包含相同数目的黑节点</li></ol><p><img src="/2018/05/28/红黑树/1551508807317.png" alt="1551508807317"></p><h1><span id="复杂度">复杂度</span></h1><p>因为这5条性质，使得n个节点的红黑树始终保持logn的高度，所以它的查询、插入和删除的时间复杂度都是O(logn)。</p><h1><span id="节点操作">节点操作</span></h1><h2><span id="节点插入">节点插入</span></h2><h3><span id="步骤">步骤：</span></h3><ol><li>将红黑树当作一颗二叉查找树，将节点插入；</li><li>将节点着色为红；</li><li>通过旋转和重新着色等方法来修正该树，使之重新成为一颗红黑树。</li></ol><p>在具体实现的过程中，重点是如何该树重新成为一个红黑树，内容涉及左旋、右旋等专门定义的操作。不必细究。</p><h2><span id="节点删除">节点删除</span></h2><h3><span id="步骤">步骤：</span></h3><ol><li>将红黑树当作一颗二叉查找树，将该节点从二叉查找树中删除；</li><li>通过”旋转和重新着色”等一系列来修正该树，使之重新成为一棵红黑树。</li></ol><p>在具体实现的过程中，重点是如何该树重新成为一个红黑树，内容涉及左旋、右旋等专门定义的操作。不必细究。</p><h1><span id="应用场景">应用场景</span></h1><ol><li><p>著名的linux进程调度<a href="https://en.wikipedia.org/wiki/Completely_Fair_Scheduler" target="_blank" rel="noopener">Completely Fair Scheduler</a>,用红黑树管理进程控制块</p></li><li><p>epoll在内核中的实现，用红黑树管理事件块</p></li><li><p>Nginx中，用红黑树管理<a href="https://www.kancloud.cn/digest/understandingnginx/202602" target="_blank" rel="noopener">timer</a></p></li><li><p>Java的TreeMap实现</p></li><li><p>广泛用在C++的STL中。map和set都是用红黑树实现的。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;红黑树的性质&quot;&gt;红黑树的性质&lt;/span&gt;&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;每个节点要么是红的要么是黑的；&lt;/li&gt;
&lt;li&gt;根节点是黑的；&lt;/li&gt;
&lt;li&gt;每个叶节点（nil）都是黑的；&lt;/li&gt;
&lt;li&gt;如果一个节点是红的，那么它的两个子节点都是黑的；
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Nginx和OpenResty的动态流控</title>
    <link href="http://yoursite.com/2018/03/02/nginx%E5%8A%A8%E6%80%81%E6%B5%81%E6%8E%A7/"/>
    <id>http://yoursite.com/2018/03/02/nginx动态流控/</id>
    <published>2018-03-02T12:59:10.000Z</published>
    <updated>2019-03-10T12:20:24.569Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#nginx的动态流控">Nginx的动态流控</a><ul><li><a href="#请求速率限制">请求速率限制</a><ul><li><a href="#limit_req模块">limit_req模块</a></li></ul></li><li><a href="#并发连接数限制">并发连接数限制</a><ul><li><a href="#limit_conn模块">limit_conn模块</a></li></ul></li><li><a href="#下载带宽限制">下载带宽限制</a></li></ul></li><li><a href="#openresty的动态流控">OpenResty的动态流控</a><ul><li><a href="#请求速率限制并发连接数限制">请求速率限制/并发连接数限制</a><ul><li><a href="#restylimitreq模块">resty.limit.req模块</a></li><li><a href="#restylimitconn模块">resty.limit.conn模块</a></li><li><a href="#restylimitcount模块">resty.limit.count模块</a></li></ul></li><li><a href="#跨机器速率限制">跨机器速率限制</a></li></ul></li></ul><!-- tocstop --><h1><span id="nginx的动态流控">Nginx的动态流控</span></h1><h2><span id="请求速率限制">请求速率限制</span></h2><h3><span id="limit_req模块">limit_req模块</span></h3><ol><li>limit_req_zone</li></ol><ul><li><p>语法: limit_req_zone $variable zone=name:size rate=rate;</p></li><li><p>默认值: none</p></li><li><p>配置段: http<br>设置一块共享内存限制域用来保存键值的状态参数。 特别是保存了当前超出请求的数量。 键的值就是指定的变量（空值不会被计算）。如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s;</span><br></pre></td></tr></table></figure><p>说明：</p><p>区域名称为one，大小为10m，平均处理的请求频率不能超过每秒一次。<br>键值是客户端IP。</p><p>使用$binary_remote_addr（client address in a binary form, value’s length is always 4 bytes for IPv4 addresses or 16 bytes for IPv6 addresses）变量， 可以将每条状态记录的大小减少到64个字节，这样1M的内存可以保存大约1万6千个64字节的记录。<br>如果限制域的存储空间耗尽了，对于后续所有请求，服务器都会返回 503 (Service Temporarily Unavailable)错误。</p></li></ul><ol start="2"><li>limit_req</li></ol><ul><li><p>语法: limit_req zone=name [burst=number] [nodelay] [delay=number];</p></li><li><p>默认值: —</p></li><li><p>配置段: http, server, location<br>设置对应的共享内存限制域和允许突发数（burst）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">limit_req_zone $binary_remote_addr zone=javfa_com:10m rate=1r/s;</span><br><span class="line">server &#123;</span><br><span class="line">    location /www.javfa.com/ &#123;</span><br><span class="line">        limit_req zone=javfa_com burst=5;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不带burst参数，则对于超过频率限制的请求，Nginx直接帮你拒绝掉。</p><p>但在实际业务中，偶尔突增也是正常的。针对这些偶尔突增的情况，Nginx引入burst参数。</p><p>功能参数burst（突发），使得请求频率限制允许一定程度的突发请求。此时：</p><ul><li><p>若无nodelay参数，则将指定个数以内的突发请求排队等候依次处理。</p></li><li><p>若有nodelay参数，可以使得突发时需要等待的请求立即得到处理，与此同时，模拟出一个插槽个数为burst指定数目的令牌桶，该桶每(1/rate)s释放一个令牌，空出的槽位等待新的突发请求进来，若槽位填满，随后突发的请求则会被拒绝。</p><p>这样，真实的请求没有在排队，引入虚拟令牌排队，在它满的情况下是不允许其他请求进来的。</p></li><li><p>若有delay参数（版本1.15.7增加），则可以进行更加精细的控制。如：整体突发（burst）配置成12，超过12个肯定是需要拒绝的，而在12个以内，我们希望前面过来的4-6个并发请求能够更快加载，不要进行无效等待，这里设置delay=8，队列中前8个等待的请求直接传给上游，而不会排队，而第8个之后的请求仍会排队，但不会被直接拒绝，只是会慢一点。</p><blockquote><p>Changes with nginx 1.15.7                                        27 Nov 2018<br>*) Feature: the “proxy_requests” directive in the stream module.</p><p>*) Feature: the “delay” parameter of the “limit_req” directive.<br>  Thanks to Vladislav Shabanov and Peter Shchuchkin.</p><p>*) Bugfix: memory leak on errors during reconfiguration.</p><p>*) Bugfix: in the $upstream_response_time, $upstream_connect_time, and<br>  $upstream_header_time variables.</p><p>*) Bugfix: a segmentation fault might occur in a worker process if the<br>  ngx_http_mp4_module was used on 32-bit platforms.</p></blockquote></li></ul></li></ul><h2><span id="并发连接数限制">并发连接数限制</span></h2><h3><span id="limit_conn模块">limit_conn模块</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">limit_conn_zone $binary_remote_addr zone=addr:10m;</span><br><span class="line"></span><br><span class="line">limit_conn_log_level error;</span><br><span class="line">limit_conn_status 503;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    location /download/ &#123;</span><br><span class="line">        limit_conn addr 5;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Nginx 有一个模块叫 limit_conn，在下载的场景中，会出现几个用户同时在下载同一个资源，<strong>对于处理中的请求，该模块是在读完请求头全部内容后才开始计数，</strong>比如同时允许在线 5 人下载，那就限制 5 个，超过的 503 拒绝。特别地，<strong>在 HTTP/2 和 SPDY 协议下，每一个并发请求都会当作一个独立的计数项。</strong></p><blockquote><p><strong>HTTP/2</strong>（超文本传输协议第2版，最初命名为<strong>HTTP 2.0</strong>），简称为<strong>h2</strong>（基于TLS/1.2或以上版本的加密连接）或<strong>h2c</strong>（非加密连接）<a href="https://zh.wikipedia.org/wiki/HTTP/2#cite_note-1" target="_blank" rel="noopener">[1]</a>，是<a href="https://zh.wikipedia.org/wiki/HTTP" target="_blank" rel="noopener">HTTP</a>协议的的第二个主要版本，使用于<a href="https://zh.wikipedia.org/wiki/%E5%85%A8%E7%90%83%E8%B3%87%E8%A8%8A%E7%B6%B2" target="_blank" rel="noopener">万维网</a>。</p><p>HTTP/2是<a href="https://zh.wikipedia.org/wiki/HTTP" target="_blank" rel="noopener">HTTP</a>协议自1999年HTTP 1.1发布后的首个更新，主要基于<a href="https://zh.wikipedia.org/wiki/SPDY" target="_blank" rel="noopener">SPDY</a>协议。它由<a href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E5%B7%A5%E7%A8%8B%E4%BB%BB%E5%8A%A1%E7%BB%84" target="_blank" rel="noopener">互联网工程任务组</a>（IETF）的Hypertext Transfer Protocol Bis（httpbis）工作小组进行开发。<a href="https://zh.wikipedia.org/wiki/HTTP/2#cite_note-charter-2" target="_blank" rel="noopener">[2]</a>该组织于2014年12月将HTTP/2标准提议递交至<a href="https://zh.wikipedia.org/w/index.php?title=Internet_Engineering_Steering_Group&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">IESG</a>进行讨论<a href="https://zh.wikipedia.org/wiki/HTTP/2#cite_note-3" target="_blank" rel="noopener">[3]</a>，于2015年2月17日被批准。<a href="https://zh.wikipedia.org/wiki/HTTP/2#cite_note-approval2-4" target="_blank" rel="noopener">[4]</a></p><p>HTTP/2标准于2015年5月以RFC 7540正式发表。<a href="https://zh.wikipedia.org/wiki/HTTP/2#cite_note-rfc7540-5" target="_blank" rel="noopener">[5]</a>HTTP/2的标准化工作由<a href="https://zh.wikipedia.org/wiki/Google_Chrome" target="_blank" rel="noopener">Chrome</a>、<a href="https://zh.wikipedia.org/wiki/Opera%E7%80%8F%E8%A6%BD%E5%99%A8" target="_blank" rel="noopener">Opera</a>、<a href="https://zh.wikipedia.org/wiki/Firefox" target="_blank" rel="noopener">Firefox</a><a href="https://zh.wikipedia.org/wiki/HTTP/2#cite_note-6" target="_blank" rel="noopener">[6]</a>、<a href="https://zh.wikipedia.org/wiki/Internet_Explorer_11" target="_blank" rel="noopener">Internet Explorer 11</a>、<a href="https://zh.wikipedia.org/wiki/Safari" target="_blank" rel="noopener">Safari</a>、<a href="https://zh.wikipedia.org/w/index.php?title=Amazon_Silk&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">Amazon Silk</a>及<a href="https://zh.wikipedia.org/wiki/Microsoft_Edge" target="_blank" rel="noopener">Edge</a>等浏览器提供支持。<a href="https://zh.wikipedia.org/wiki/HTTP/2#cite_note-7" target="_blank" rel="noopener">[7]</a></p><p>多数主流浏览器已经在2015年底支持了该协议。<a href="https://zh.wikipedia.org/wiki/HTTP/2#cite_note-browser_support-8" target="_blank" rel="noopener">[8]</a>此外，根据<a href="https://zh.wikipedia.org/w/index.php?title=W3Techs&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">W3Techs</a>的数据，在2017年5月，在排名前一千万的网站中，有13.7%支持了HTTP/2。<a href="https://zh.wikipedia.org/wiki/HTTP/2#cite_note-9" target="_blank" rel="noopener">[9]</a></p></blockquote><h2><span id="下载带宽限制">下载带宽限制</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location /download/ &#123;</span><br><span class="line">    limit_rate_after 500k;</span><br><span class="line">    limit_rate 20k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 ngx_http_core_module 模块里面有 limit_rate_after 和 limit_rate 参数，这个是下载带宽限制。如上代码所示，意思是<strong>在下载完前面 500KB 数据后，对接下来的数据以每秒 20KB 速度进行限制，</strong>这个在<strong>文件下载、视频播放等业务场景中应用比较多，可以避免不必要的浪费</strong>。</p><p>例如视频播放，第一个画面能够尽快看到，对用户体验来说很重要，如果用户第一个页面看不到，那他的等待忍耐程度是很差的，所以这个场景下前面的几个字节不应该去限速，在看到第一个画面之后，后面画面是按照一定视频码率播放，所以没必要下载很快，而且快了也没用，它照样是流畅的，但却多浪费了流量资源，如果用户看到一半就关掉，整个视频下载完成，对于用户和内容提供商都是资源浪费。</p><h1><span id="openresty的动态流控">OpenResty的动态流控</span></h1><h2><span id="请求速率限制并发连接数限制">请求速率限制/并发连接数限制</span></h2><p>OpenResty官方有一个叫做<a href="https://github.com/openresty/lua-resty-limit-traffic" target="_blank" rel="noopener">lua-resty-limit-traffic</a>的模块，里面有三种限速策略。</p><h3><span id="restylimitreq模块">resty.limit.req模块</span></h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> limit_req = <span class="built_in">require</span> <span class="string">"resty.limit.req"</span></span><br><span class="line"><span class="keyword">local</span> lim, err = limit_req.new(<span class="string">"mylimit"</span>, <span class="number">5</span>, <span class="number">9</span>)</span><br><span class="line"><span class="keyword">local</span> delay, err = lim:incoming(ngx.var.binary_remote_addr, <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> delay <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> err == <span class="string">"rejected"</span> <span class="keyword">then</span></span><br><span class="line">      <span class="keyword">return</span> ngx.<span class="built_in">exit</span>(<span class="number">429</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> ngx.<span class="built_in">exit</span>(<span class="number">500</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> delay &gt;= <span class="number">0.001</span> <span class="keyword">then</span></span><br><span class="line">    ngx.sleep(delay)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>resty.limit.req 模块的设计与 NGINX limit_req 实现的效果和功能一样，当然它用 Lua 来表达限速逻辑，可以在任何的代码里面去引入，几乎可以在任意上下⽂中使⽤。</p><p>以下是该模块官方示例用法：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- demonstrate the usage of the resty.limit.req module (alone!)</span></span><br><span class="line">http &#123;</span><br><span class="line">    lua_shared_dict my_limit_req_store <span class="number">100</span>m;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        location / &#123;</span><br><span class="line">            access_by_lua_block &#123;</span><br><span class="line">                <span class="comment">-- well, we could put the require() and new() calls in our own Lua</span></span><br><span class="line">                <span class="comment">-- modules to save overhead. here we put them below just for</span></span><br><span class="line">                <span class="comment">-- convenience.</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">local</span> limit_req = <span class="built_in">require</span> <span class="string">"resty.limit.req"</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">-- limit the requests under 200 req/sec with a burst of 100 req/sec,</span></span><br><span class="line">                <span class="comment">-- that is, we delay requests under 300 req/sec and above 200</span></span><br><span class="line">                <span class="comment">-- req/sec, and reject any requests exceeding 300 req/sec.</span></span><br><span class="line">                <span class="keyword">local</span> lim, err = limit_req.new(<span class="string">"my_limit_req_store"</span>, <span class="number">200</span>, <span class="number">100</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> lim <span class="keyword">then</span></span><br><span class="line">                    ngx.<span class="built_in">log</span>(ngx.ERR,</span><br><span class="line">                            <span class="string">"failed to instantiate a resty.limit.req object: "</span>, err)</span><br><span class="line">                    <span class="keyword">return</span> ngx.<span class="built_in">exit</span>(<span class="number">500</span>)</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">-- the following call must be per-request.</span></span><br><span class="line">                <span class="comment">-- here we use the remote (IP) address as the limiting key</span></span><br><span class="line">                <span class="keyword">local</span> key = ngx.var.binary_remote_addr</span><br><span class="line">                <span class="keyword">local</span> delay, err = lim:incoming(key, <span class="literal">true</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> delay <span class="keyword">then</span></span><br><span class="line">                    <span class="keyword">if</span> err == <span class="string">"rejected"</span> <span class="keyword">then</span></span><br><span class="line">                        <span class="keyword">return</span> ngx.<span class="built_in">exit</span>(<span class="number">503</span>)</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">"failed to limit req: "</span>, err)</span><br><span class="line">                    <span class="keyword">return</span> ngx.<span class="built_in">exit</span>(<span class="number">500</span>)</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> delay &gt;= <span class="number">0.001</span> <span class="keyword">then</span></span><br><span class="line">                    <span class="comment">-- the 2nd return value holds the number of excess requests</span></span><br><span class="line">                    <span class="comment">-- per second for the specified key. for example, number 31</span></span><br><span class="line">                    <span class="comment">-- means the current request rate is at 231 req/sec for the</span></span><br><span class="line">                    <span class="comment">-- specified key.</span></span><br><span class="line">                    <span class="keyword">local</span> excess = err</span><br><span class="line"></span><br><span class="line">                    <span class="comment">-- the request exceeding the 200 req/sec but below 300 req/sec,</span></span><br><span class="line">                    <span class="comment">-- so we intentionally delay it here a bit to conform to the</span></span><br><span class="line">                    <span class="comment">-- 200 req/sec rate.</span></span><br><span class="line">                    ngx.sleep(delay)</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            # content handler goes here. <span class="keyword">if</span> it is content_by_lua, <span class="keyword">then</span> you can</span><br><span class="line">            # merge the Lua code above <span class="keyword">in</span> access_by_lua into your content_by_lua<span class="string">'s</span></span><br><span class="line"><span class="string">            # Lua handler to save a little bit of CPU time.</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h3><span id="restylimitconn模块">resty.limit.conn模块</span></h3><p>功能和 NGINX limit_conn 一致，但 Lua 版本允许突发连接进行短暂延迟等候。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"># demonstrate the usage of the resty.limit.traffic module（limit.conn &amp;&amp; limit.req）</span><br><span class="line">http &#123;</span><br><span class="line">    lua_shared_dict my_req_store <span class="number">100</span>m;</span><br><span class="line">    lua_shared_dict my_conn_store <span class="number">100</span>m;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        location / &#123;</span><br><span class="line">            access_by_lua_block &#123;</span><br><span class="line">                <span class="keyword">local</span> limit_conn = <span class="built_in">require</span> <span class="string">"resty.limit.conn"</span></span><br><span class="line">                <span class="keyword">local</span> limit_req = <span class="built_in">require</span> <span class="string">"resty.limit.req"</span></span><br><span class="line">                <span class="keyword">local</span> limit_traffic = <span class="built_in">require</span> <span class="string">"resty.limit.traffic"</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">local</span> lim1, err = limit_req.new(<span class="string">"my_req_store"</span>, <span class="number">300</span>, <span class="number">200</span>)</span><br><span class="line">                <span class="built_in">assert</span>(lim1, err)</span><br><span class="line">                <span class="keyword">local</span> lim2, err = limit_req.new(<span class="string">"my_req_store"</span>, <span class="number">200</span>, <span class="number">100</span>)</span><br><span class="line">                <span class="built_in">assert</span>(lim2, err)</span><br><span class="line">                <span class="keyword">local</span> lim3, err = limit_conn.new(<span class="string">"my_conn_store"</span>, <span class="number">1000</span>, <span class="number">1000</span>, <span class="number">0.5</span>)</span><br><span class="line">                <span class="built_in">assert</span>(lim3, err)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">local</span> limiters = &#123;lim1, lim2, lim3&#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">local</span> host = ngx.var.host</span><br><span class="line">                <span class="keyword">local</span> client = ngx.var.binary_remote_addr</span><br><span class="line">                <span class="keyword">local</span> keys = &#123;host, client, client&#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">local</span> states = &#123;&#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">local</span> delay, err = limit_traffic.combine(limiters, keys, states)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> delay <span class="keyword">then</span></span><br><span class="line">                    <span class="keyword">if</span> err == <span class="string">"rejected"</span> <span class="keyword">then</span></span><br><span class="line">                        <span class="keyword">return</span> ngx.<span class="built_in">exit</span>(<span class="number">503</span>)</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">"failed to limit traffic: "</span>, err)</span><br><span class="line">                    <span class="keyword">return</span> ngx.<span class="built_in">exit</span>(<span class="number">500</span>)</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> lim3:is_committed() <span class="keyword">then</span></span><br><span class="line">                    <span class="keyword">local</span> ctx = ngx.ctx</span><br><span class="line">                    ctx.limit_conn = lim3</span><br><span class="line">                    ctx.limit_conn_key = keys[<span class="number">3</span>]</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"sleeping "</span>, delay, <span class="string">" sec, states: "</span>,</span><br><span class="line">                      <span class="built_in">table</span>.<span class="built_in">concat</span>(states, <span class="string">", "</span>))</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> delay &gt;= <span class="number">0.001</span> <span class="keyword">then</span></span><br><span class="line">                    ngx.sleep(delay)</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            # content handler goes here. <span class="keyword">if</span> it is content_by_lua, <span class="keyword">then</span> you can</span><br><span class="line">            # merge the Lua code above <span class="keyword">in</span> access_by_lua into your</span><br><span class="line">            # content_by_lua<span class="string">'s Lua handler to save a little bit of CPU time.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            log_by_lua_block &#123;</span></span><br><span class="line"><span class="string">                local ctx = ngx.ctx</span></span><br><span class="line"><span class="string">                local lim = ctx.limit_conn</span></span><br><span class="line"><span class="string">                if lim then</span></span><br><span class="line"><span class="string">                    -- if you are using an upstream module in the content phase,</span></span><br><span class="line"><span class="string">                    -- then you probably want to use $upstream_response_time</span></span><br><span class="line"><span class="string">                    -- instead of $request_time below.</span></span><br><span class="line"><span class="string">                    local latency = tonumber(ngx.var.request_time)</span></span><br><span class="line"><span class="string">                    local key = ctx.limit_conn_key</span></span><br><span class="line"><span class="string">                    assert(key)</span></span><br><span class="line"><span class="string">                    local conn, err = lim:leaving(key, latency)</span></span><br><span class="line"><span class="string">                    if not conn then</span></span><br><span class="line"><span class="string">                        ngx.log(ngx.ERR,</span></span><br><span class="line"><span class="string">                                "failed to record the connection leaving ",</span></span><br><span class="line"><span class="string">                                "request: ", err)</span></span><br><span class="line"><span class="string">                        return</span></span><br><span class="line"><span class="string">                    end</span></span><br><span class="line"><span class="string">                end</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h3><span id="restylimitcount模块">resty.limit.count模块</span></h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> limit_count = <span class="built_in">require</span> <span class="string">"resty.limit.count"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> lim, err = limit_count.new(<span class="string">"mylimit"</span>, <span class="number">5000</span>, <span class="number">3600</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> delay, err = lim:incoming(ngx.req.get_headers()[<span class="string">"Authorization"</span>], <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> delay <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> err == <span class="string">"rejected"</span> <span class="keyword">then</span></span><br><span class="line">        ngx.header[<span class="string">"X-RateLimit-Limit"</span>] = <span class="string">"5000"</span></span><br><span class="line">        ngx.header[<span class="string">"X-RateLimit-Remaining"</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> ngx.<span class="built_in">exit</span>(<span class="number">503</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> ngx.<span class="built_in">exit</span>(<span class="number">500</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">ngx.header[<span class="string">"X-RateLimit-Limit"</span>] = <span class="string">"5000"</span></span><br><span class="line">ngx.header[<span class="string">"X-RateLimit_Remaining"</span>] = err <span class="comment">-- current remaining number</span></span><br></pre></td></tr></table></figure><p> resty.limit.count 模块，请求数量限制，这个目前 Nginx 没有，用一句话概括这个模块，就是在<strong>单位时间内确保累计的请求数量不超过一个最大的值</strong>。比如在 1 分钟之内允许累计有 5000个请求，累计超过 5000就拒绝。这个模和 Github API Rate Limiting<strong>的接口设计类似</strong>，也是一个比较经典的限制请求的方式。</p><h2><span id="跨机器速率限制">跨机器速率限制</span></h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> ratelimit = <span class="built_in">require</span> <span class="string">"resty.redis.ratelimit"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> lim, err = ratelimt.new(<span class="string">"mylimit"</span>, <span class="string">"5r/s"</span>, <span class="number">4</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> red = &#123; host = <span class="string">"127.0.0.1"</span>, port = <span class="number">6379</span>, timeout = <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> delay, err = lim:incoming(ngx.var.binary_remote_addr, red)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> delay <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> err == <span class="string">"rejected"</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> ngx.<span class="built_in">exit</span>(<span class="number">429</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> ngx.<span class="built_in">exit</span>(<span class="number">500</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> delay &gt;= <span class="number">0.001</span> <span class="keyword">then</span></span><br><span class="line">    ngx.sleep(delay)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#nginx的动态流控&quot;&gt;Nginx的动态流控&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#请求速率限制&quot;&gt;请求速率限制&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#limit_req模块&quot;&gt;limit_req模块&lt;/
      
    
    </summary>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx-Lua-Directives</title>
    <link href="http://yoursite.com/2018/03/01/Nginx-Lua-Directives/"/>
    <id>http://yoursite.com/2018/03/01/Nginx-Lua-Directives/</id>
    <published>2018-03-01T04:44:13.000Z</published>
    <updated>2019-03-01T06:25:52.347Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#nginx-directives-for-lua">Nginx Directives For Lua</a><ul><li><a href="#lua_capture_error_log">lua_capture_error_log</a></li><li><a href="#lua_use_default_type">lua_use_default_type</a></li><li><a href="#lua_malloc_trim">lua_malloc_trim</a></li><li><a href="#lua_code_cache">lua_code_cache</a></li><li><a href="#lua_regex_cache_max_entries">lua_regex_cache_max_entries</a></li><li><a href="#lua_regex_match_limit">lua_regex_match_limit</a></li><li><a href="#lua_package_path">lua_package_path</a></li><li><a href="#lua_package_cpath">lua_package_cpath</a></li><li><a href="#init_by_lua">init_by_lua</a></li><li><a href="#init_by_lua_block">init_by_lua_block</a></li><li><a href="#init_by_lua_file">init_by_lua_file</a></li><li><a href="#init_worker_by_lua">init_worker_by_lua</a></li><li><a href="#init_worker_by_lua_block">init_worker_by_lua_block</a></li><li><a href="#init_worker_by_lua_file">init_worker_by_lua_file</a></li><li><a href="#set_by_lua">set_by_lua</a></li><li><a href="#set_by_lua_block">set_by_lua_block</a></li><li><a href="#set_by_lua_file">set_by_lua_file</a></li><li><a href="#content_by_lua">content_by_lua</a></li><li><a href="#content_by_lua_block">content_by_lua_block</a></li><li><a href="#content_by_lua_file">content_by_lua_file</a></li><li><a href="#rewrite_by_lua">rewrite_by_lua</a></li><li><a href="#rewrite_by_lua_block">rewrite_by_lua_block</a></li><li><a href="#rewrite_by_lua_file">rewrite_by_lua_file</a></li><li><a href="#access_by_lua">access_by_lua</a></li><li><a href="#access_by_lua_block">access_by_lua_block</a></li><li><a href="#access_by_lua_file">access_by_lua_file</a></li><li><a href="#header_filter_by_lua">header_filter_by_lua</a></li><li><a href="#header_filter_by_lua_block">header_filter_by_lua_block</a></li><li><a href="#header_filter_by_lua_file">header_filter_by_lua_file</a></li><li><a href="#body_filter_by_lua">body_filter_by_lua</a></li><li><a href="#body_filter_by_lua_block">body_filter_by_lua_block</a></li><li><a href="#body_filter_by_lua_file">body_filter_by_lua_file</a></li><li><a href="#log_by_lua">log_by_lua</a></li><li><a href="#log_by_lua_block">log_by_lua_block</a></li><li><a href="#log_by_lua_file">log_by_lua_file</a></li><li><a href="#balancer_by_lua_block">balancer_by_lua_block</a></li><li><a href="#balancer_by_lua_file">balancer_by_lua_file</a></li><li><a href="#lua_need_request_body">lua_need_request_body</a></li><li><a href="#ssl_certificate_by_lua_block">ssl_certificate_by_lua_block</a></li><li><a href="#ssl_certificate_by_lua_file">ssl_certificate_by_lua_file</a></li><li><a href="#ssl_session_fetch_by_lua_block">ssl_session_fetch_by_lua_block</a></li><li><a href="#ssl_session_fetch_by_lua_file">ssl_session_fetch_by_lua_file</a></li><li><a href="#ssl_session_store_by_lua_block">ssl_session_store_by_lua_block</a></li><li><a href="#ssl_session_store_by_lua_file">ssl_session_store_by_lua_file</a></li><li><a href="#lua_shared_dict">lua_shared_dict</a></li><li><a href="#lua_socket_connect_timeout">lua_socket_connect_timeout</a></li><li><a href="#lua_socket_send_timeout">lua_socket_send_timeout</a></li><li><a href="#lua_socket_send_lowat">lua_socket_send_lowat</a></li><li><a href="#lua_socket_read_timeout">lua_socket_read_timeout</a></li><li><a href="#lua_socket_buffer_size">lua_socket_buffer_size</a></li><li><a href="#lua_socket_pool_size">lua_socket_pool_size</a></li><li><a href="#lua_socket_keepalive_timeout">lua_socket_keepalive_timeout</a></li><li><a href="#lua_socket_log_errors">lua_socket_log_errors</a></li><li><a href="#lua_ssl_ciphers">lua_ssl_ciphers</a></li><li><a href="#lua_ssl_crl">lua_ssl_crl</a></li><li><a href="#lua_ssl_protocols">lua_ssl_protocols</a></li><li><a href="#lua_ssl_trusted_certificate">lua_ssl_trusted_certificate</a></li><li><a href="#lua_ssl_verify_depth">lua_ssl_verify_depth</a></li><li><a href="#lua_http10_buffering">lua_http10_buffering</a></li><li><a href="#rewrite_by_lua_no_postpone">rewrite_by_lua_no_postpone</a></li><li><a href="#access_by_lua_no_postpone">access_by_lua_no_postpone</a></li><li><a href="#lua_transform_underscores_in_response_headers">lua_transform_underscores_in_response_headers</a></li><li><a href="#lua_check_client_abort">lua_check_client_abort</a></li><li><a href="#lua_max_pending_timers">lua_max_pending_timers</a></li><li><a href="#lua_max_running_timers">lua_max_running_timers</a></li><li><a href="#lua_sa_restart">lua_sa_restart</a></li></ul></li></ul><!-- tocstop --><h1><span id="nginx-directives-for-lua">Nginx Directives For Lua</span></h1><p>The basic building blocks of scripting Nginx with Lua are directives. Directives are used to specify when the user Lua code is run and how the result will be used. Below is a diagram showing the order in which directives are executed.</p><p><a href="https://cloud.githubusercontent.com/assets/2137369/15272097/77d1c09e-1a37-11e6-97ef-d9767035fc3e.png" target="_blank" rel="noopener"><img src="https://cloud.githubusercontent.com/assets/2137369/15272097/77d1c09e-1a37-11e6-97ef-d9767035fc3e.png" alt="Lua Nginx Modules Directives"></a></p><h2><span id="lua_capture_error_log">lua_capture_error_log</span></h2><p><strong>syntax:</strong> <em>lua_capture_error_log size</em></p><p><strong>default:</strong> <em>none</em></p><p><strong>context:</strong> <em>http</em></p><p>Enables a buffer of the specified <code>size</code> for capturing all the nginx error log message data (not just those produced by this module or the nginx http subsystem, but everything) without touching files or disks.</p><p>You can use units like <code>k</code> and <code>m</code> in the <code>size</code> value, as in</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lua_capture_error_log 100k;</span><br></pre></td></tr></table></figure><p>As a rule of thumb, a 4KB buffer can usually hold about 20 typical error log messages. So do the maths!</p><p>This buffer never grows. If it is full, new error log messages will replace the oldest ones in the buffer.</p><p>The size of the buffer must be bigger than the maximum length of a single error log message (which is 4K in OpenResty and 2K in stock NGINX).</p><p>You can read the messages in the buffer on the Lua land via the <a href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/errlog.md#get_logs" target="_blank" rel="noopener">get_logs()</a> function of the <a href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/errlog.md#readme" target="_blank" rel="noopener">ngx.errlog</a> module of the <a href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/errlog.md#readme" target="_blank" rel="noopener">lua-resty-core</a> library. This Lua API function will return the captured error log messages and also remove these already read from the global capturing buffer, making room for any new error log data. For this reason, the user should not configure this buffer to be too big if the user read the buffered error log data fast enough.</p><p>Note that the log level specified in the standard <a href="http://nginx.org/r/error_log" target="_blank" rel="noopener">error_log</a> directive <em>does</em> have effect on this capturing facility. It only captures log messages of a level no lower than the specified log level in the <a href="http://nginx.org/r/error_log" target="_blank" rel="noopener">error_log</a> directive. The user can still choose to set an even higher filtering log level on the fly via the Lua API function <a href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/errlog.md#set_filter_level" target="_blank" rel="noopener">errlog.set_filter_level</a>. So it is more flexible than the static <a href="http://nginx.org/r/error_log" target="_blank" rel="noopener">error_log</a>directive.</p><p>It is worth noting that there is no way to capture the debugging logs without building OpenResty or NGINX with the <code>./configure</code> option <code>--with-debug</code>. And enabling debugging logs is strongly discouraged in production builds due to high overhead.</p><p>This directive was first introduced in the <code>v0.10.9</code> release.</p><h2><span id="lua_use_default_type">lua_use_default_type</span></h2><p><strong>syntax:</strong> <em>lua_use_default_type on | off</em></p><p><strong>default:</strong> <em>lua_use_default_type on</em></p><p><strong>context:</strong> <em>http, server, location, location if</em></p><p>Specifies whether to use the MIME type specified by the <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#default_type" target="_blank" rel="noopener">default_type</a> directive for the default value of the <code>Content-Type</code>response header. Deactivate this directive if a default <code>Content-Type</code> response header for Lua request handlers is not desired.</p><p>This directive is turned on by default.</p><p>This directive was first introduced in the <code>v0.9.1</code> release.</p><h2><span id="lua_malloc_trim">lua_malloc_trim</span></h2><p><strong>syntax:</strong> <em>lua_malloc_trim <request-count></request-count></em></p><p><strong>default:</strong> <em>lua_malloc_trim 1000</em></p><p><strong>context:</strong> <em>http</em></p><p>Asks the underlying <code>libc</code> runtime library to release its cached free memory back to the operating system every <code>N</code> requests processed by the NGINX core. By default, <code>N</code> is 1000. You can configure the request count by using your own numbers. Smaller numbers mean more frequent releases, which may introduce higher CPU time consumption and smaller memory footprint while larger numbers usually lead to less CPU time overhead and relatively larger memory footprint. Just tune the number for your own use cases.</p><p>Configuring the argument to <code>0</code> essentially turns off the periodical memory trimming altogether.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lua_malloc_trim 0;  # turn off trimming completely</span><br></pre></td></tr></table></figure><p>The current implementation uses an NGINX log phase handler to do the request counting. So the appearance of the<a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#log_subrequest" target="_blank" rel="noopener">log_subrequest on</a> directives in <code>nginx.conf</code> may make the counting faster when subrequests are involved. By default, only “main requests” count.</p><p>Note that this directive does <em>not</em> affect the memory allocated by LuaJIT’s own allocator based on the <code>mmap</code> system call.</p><p>This directive was first introduced in the <code>v0.10.7</code> release.</p><h2><span id="lua_code_cache">lua_code_cache</span></h2><p><strong>syntax:</strong> <em>lua_code_cache on | off</em></p><p><strong>default:</strong> <em>lua_code_cache on</em></p><p><strong>context:</strong> <em>http, server, location, location if</em></p><p>Enables or disables the Lua code cache for Lua code in <code>*_by_lua_file</code> directives (like <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#set_by_lua_file" target="_blank" rel="noopener">set_by_lua_file</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#content_by_lua_file" target="_blank" rel="noopener">content_by_lua_file</a>) and Lua modules.</p><p>When turning off, every request served by ngx_lua will run in a separate Lua VM instance, starting from the <code>0.9.3</code> release. So the Lua files referenced in <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#set_by_lua_file" target="_blank" rel="noopener">set_by_lua_file</a>, <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#content_by_lua_file" target="_blank" rel="noopener">content_by_lua_file</a>, <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#access_by_lua_file" target="_blank" rel="noopener">access_by_lua_file</a>, and etc will not be cached and all Lua modules used will be loaded from scratch. With this in place, developers can adopt an edit-and-refresh approach.</p><p>Please note however, that Lua code written inlined within nginx.conf such as those specified by <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#set_by_lua" target="_blank" rel="noopener">set_by_lua</a>, <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#content_by_lua" target="_blank" rel="noopener">content_by_lua</a>,<a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#access_by_lua" target="_blank" rel="noopener">access_by_lua</a>, and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#rewrite_by_lua" target="_blank" rel="noopener">rewrite_by_lua</a> will not be updated when you edit the inlined Lua code in your <code>nginx.conf</code> file because only the Nginx config file parser can correctly parse the <code>nginx.conf</code> file and the only way is to reload the config file by sending a <code>HUP</code> signal or just to restart Nginx.</p><p>Even when the code cache is enabled, Lua files which are loaded by <code>dofile</code> or <code>loadfile</code> in *_by_lua_file cannot be cached (unless you cache the results yourself). Usually you can either use the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#init_by_lua" target="_blank" rel="noopener">init_by_lua</a> or <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#init-by_lua_file" target="_blank" rel="noopener">init_by_lua_file</a> directives to load all such files or just make these Lua files true Lua modules and load them via <code>require</code>.</p><p>The ngx_lua module does not support the <code>stat</code> mode available with the Apache <code>mod_lua</code> module (yet).</p><p>Disabling the Lua code cache is strongly discouraged for production use and should only be used during development as it has a significant negative impact on overall performance. For example, the performance of a “hello world” Lua example can drop by an order of magnitude after disabling the Lua code cache.</p><h2><span id="lua_regex_cache_max_entries">lua_regex_cache_max_entries</span></h2><p><strong>syntax:</strong> <em>lua_regex_cache_max_entries <num></num></em></p><p><strong>default:</strong> <em>lua_regex_cache_max_entries 1024</em></p><p><strong>context:</strong> <em>http</em></p><p>Specifies the maximum number of entries allowed in the worker process level compiled regex cache.</p><p>The regular expressions used in <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxrematch" target="_blank" rel="noopener">ngx.re.match</a>, <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxregmatch" target="_blank" rel="noopener">ngx.re.gmatch</a>, <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxresub" target="_blank" rel="noopener">ngx.re.sub</a>, and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxregsub" target="_blank" rel="noopener">ngx.re.gsub</a> will be cached within this cache if the regex option <code>o</code> (i.e., compile-once flag) is specified.</p><p>The default number of entries allowed is 1024 and when this limit is reached, new regular expressions will not be cached (as if the <code>o</code> option was not specified) and there will be one, and only one, warning in the <code>error.log</code> file:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2011/08/27 23:18:26 [warn] 31997#0: *1 lua exceeding regex cache max entries (1024), ...</span><br></pre></td></tr></table></figure><p>If you are using the <code>ngx.re.*</code> implementation of <a href="https://github.com/openresty/lua-resty-core" target="_blank" rel="noopener">lua-resty-core</a> by loading the <code>resty.core.regex</code> module (or just the <code>resty.core</code> module), then an LRU cache is used for the regex cache being used here.</p><p>Do not activate the <code>o</code> option for regular expressions (and/or <code>replace</code> string arguments for <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxresub" target="_blank" rel="noopener">ngx.re.sub</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxregsub" target="_blank" rel="noopener">ngx.re.gsub</a>) that are generated <em>on the fly</em> and give rise to infinite variations to avoid hitting the specified limit.</p><h2><span id="lua_regex_match_limit">lua_regex_match_limit</span></h2><p><strong>syntax:</strong> <em>lua_regex_match_limit <num></num></em></p><p><strong>default:</strong> <em>lua_regex_match_limit 0</em></p><p><strong>context:</strong> <em>http</em></p><p>Specifies the “match limit” used by the PCRE library when executing the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxrematch" target="_blank" rel="noopener">ngx.re API</a>. To quote the PCRE manpage, “the limit … has the effect of limiting the amount of backtracking that can take place.”</p><p>When the limit is hit, the error string “pcre_exec() failed: -8” will be returned by the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxrematch" target="_blank" rel="noopener">ngx.re API</a> functions on the Lua land.</p><p>When setting the limit to 0, the default “match limit” when compiling the PCRE library is used. And this is the default value of this directive.</p><p>This directive was first introduced in the <code>v0.8.5</code> release.</p><h2><span id="lua_package_path">lua_package_path</span></h2><p><strong>syntax:</strong> <em>lua_package_path <lua-style-path-str></lua-style-path-str></em></p><p><strong>default:</strong> <em>The content of LUA_PATH environment variable or Lua’s compiled-in defaults.</em></p><p><strong>context:</strong> <em>http</em></p><p>Sets the Lua module search path used by scripts specified by <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#set_by_lua" target="_blank" rel="noopener">set_by_lua</a>, <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#content_by_lua" target="_blank" rel="noopener">content_by_lua</a> and others. The path string is in standard Lua path form, and <code>;;</code> can be used to stand for the original search paths.</p><p>As from the <code>v0.5.0rc29</code> release, the special notation <code>$prefix</code> or <code>${prefix}</code> can be used in the search path string to indicate the path of the <code>server prefix</code> usually determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p><h2><span id="lua_package_cpath">lua_package_cpath</span></h2><p><strong>syntax:</strong> <em>lua_package_cpath <lua-style-cpath-str></lua-style-cpath-str></em></p><p><strong>default:</strong> <em>The content of LUA_CPATH environment variable or Lua’s compiled-in defaults.</em></p><p><strong>context:</strong> <em>http</em></p><p>Sets the Lua C-module search path used by scripts specified by <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#set_by_lua" target="_blank" rel="noopener">set_by_lua</a>, <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#content_by_lua" target="_blank" rel="noopener">content_by_lua</a> and others. The cpath string is in standard Lua cpath form, and <code>;;</code> can be used to stand for the original cpath.</p><p>As from the <code>v0.5.0rc29</code> release, the special notation <code>$prefix</code> or <code>${prefix}</code> can be used in the search path string to indicate the path of the <code>server prefix</code> usually determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p><h2><span id="init_by_lua">init_by_lua</span></h2><p><strong>syntax:</strong> <em>init_by_lua <lua-script-str></lua-script-str></em></p><p><strong>context:</strong> <em>http</em></p><p><strong>phase:</strong> <em>loading-config</em></p><p><strong>NOTE</strong> Use of this directive is <em>discouraged</em> following the <code>v0.9.17</code> release. Use the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#init_by_lua_block" target="_blank" rel="noopener">init_by_lua_block</a> directive instead.</p><p>Runs the Lua code specified by the argument <code>&lt;lua-script-str&gt;</code> on the global Lua VM level when the Nginx master process (if any) is loading the Nginx config file.</p><p>When Nginx receives the <code>HUP</code> signal and starts reloading the config file, the Lua VM will also be re-created and <code>init_by_lua</code>will run again on the new Lua VM. In case that the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lua_code_cache" target="_blank" rel="noopener">lua_code_cache</a> directive is turned off (default on), the <code>init_by_lua</code>handler will run upon every request because in this special mode a standalone Lua VM is always created for each request.</p><p>Usually you can pre-load Lua modules at server start-up by means of this hook and take advantage of modern operating systems’ copy-on-write (COW) optimization. Here is an example for pre-loading Lua modules:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># this runs before forking out nginx worker processes:</span><br><span class="line">init_by_lua_block &#123; require &quot;cjson&quot; &#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    location = /api &#123;</span><br><span class="line">        content_by_lua_block &#123;</span><br><span class="line">            -- the following require() will just  return</span><br><span class="line">            -- the alrady loaded module from package.loaded:</span><br><span class="line">            ngx.say(require &quot;cjson&quot;.encode&#123;dog = 5, cat = 6&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>You can also initialize the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lua_shared_dict" target="_blank" rel="noopener">lua_shared_dict</a> shm storage at this phase. Here is an example for this:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">lua_shared_dict dogs 1m;</span><br><span class="line"></span><br><span class="line">init_by_lua_block &#123;</span><br><span class="line">    local dogs = ngx.shared.dogs;</span><br><span class="line">    dogs:set(&quot;Tom&quot;, 56)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    location = /api &#123;</span><br><span class="line">        content_by_lua_block &#123;</span><br><span class="line">            local dogs = ngx.shared.dogs;</span><br><span class="line">            ngx.say(dogs:get(&quot;Tom&quot;))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>But note that, the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lua_shared_dict" target="_blank" rel="noopener">lua_shared_dict</a>‘s shm storage will not be cleared through a config reload (via the <code>HUP</code> signal, for example). So if you do <em>not</em> want to re-initialize the shm storage in your <code>init_by_lua</code> code in this case, then you just need to set a custom flag in the shm storage and always check the flag in your <code>init_by_lua</code> code.</p><p>Because the Lua code in this context runs before Nginx forks its worker processes (if any), data or code loaded here will enjoy the <a href="http://en.wikipedia.org/wiki/Copy-on-write" target="_blank" rel="noopener">Copy-on-write (COW)</a> feature provided by many operating systems among all the worker processes, thus saving a lot of memory.</p><p>Do <em>not</em> initialize your own Lua global variables in this context because use of Lua global variables have performance penalties and can lead to global namespace pollution (see the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lua-variable-scope" target="_blank" rel="noopener">Lua Variable Scope</a> section for more details). The recommended way is to use proper <a href="http://www.lua.org/manual/5.1/manual.html#5.3" target="_blank" rel="noopener">Lua module</a> files (but do not use the standard Lua function <a href="http://www.lua.org/manual/5.1/manual.html#pdf-module" target="_blank" rel="noopener">module()</a> to define Lua modules because it pollutes the global namespace as well) and call <a href="http://www.lua.org/manual/5.1/manual.html#pdf-require" target="_blank" rel="noopener">require()</a> to load your own module files in <code>init_by_lua</code> or other contexts (<a href="http://www.lua.org/manual/5.1/manual.html#pdf-require" target="_blank" rel="noopener">require()</a>does cache the loaded Lua modules in the global <code>package.loaded</code> table in the Lua registry so your modules will only loaded once for the whole Lua VM instance).</p><p>Only a small set of the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#nginx-api-for-lua" target="_blank" rel="noopener">Nginx API for Lua</a> is supported in this context:</p><ul><li>Logging APIs: <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxlog" target="_blank" rel="noopener">ngx.log</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#print" target="_blank" rel="noopener">print</a>,</li><li>Shared Dictionary API: <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxshareddict" target="_blank" rel="noopener">ngx.shared.DICT</a>.</li></ul><p>More Nginx APIs for Lua may be supported in this context upon future user requests.</p><p>Basically you can safely use Lua libraries that do blocking I/O in this very context because blocking the master process during server start-up is completely okay. Even the Nginx core does blocking I/O (at least on resolving upstream’s host names) at the configure-loading phase.</p><p>You should be very careful about potential security vulnerabilities in your Lua code registered in this context because the Nginx master process is often run under the <code>root</code> account.</p><p>This directive was first introduced in the <code>v0.5.5</code> release.</p><h2><span id="init_by_lua_block">init_by_lua_block</span></h2><p><strong>syntax:</strong> <em>init_by_lua_block { lua-script }</em></p><p><strong>context:</strong> <em>http</em></p><p><strong>phase:</strong> <em>loading-config</em></p><p>Similar to the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#init_by_lua" target="_blank" rel="noopener">init_by_lua</a> directive except that this directive inlines the Lua source directly inside a pair of curly braces (<code>{}</code>) instead of in an NGINX string literal (which requires special character escaping).</p><p>For instance,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">init_by_lua_block &#123;</span><br><span class="line">    print(&quot;I need no extra escaping here, for example: \r\nblah&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This directive was first introduced in the <code>v0.9.17</code> release.</p><h2><span id="init_by_lua_file">init_by_lua_file</span></h2><p><strong>syntax:</strong> <em>init_by_lua_file <path-to-lua-script-file></path-to-lua-script-file></em></p><p><strong>context:</strong> <em>http</em></p><p><strong>phase:</strong> <em>loading-config</em></p><p>Equivalent to <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#init_by_lua" target="_blank" rel="noopener">init_by_lua</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code or <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lualuajit-bytecode-support" target="_blank" rel="noopener">Lua/LuaJIT bytecode</a> to be executed.</p><p>When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p><p>This directive was first introduced in the <code>v0.5.5</code> release.</p><h2><span id="init_worker_by_lua">init_worker_by_lua</span></h2><p><strong>syntax:</strong> <em>init_worker_by_lua <lua-script-str></lua-script-str></em></p><p><strong>context:</strong> <em>http</em></p><p><strong>phase:</strong> <em>starting-worker</em></p><p><strong>NOTE</strong> Use of this directive is <em>discouraged</em> following the <code>v0.9.17</code> release. Use the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#init_worker_by_lua_block" target="_blank" rel="noopener">init_worker_by_lua_block</a> directive instead.</p><p>Runs the specified Lua code upon every Nginx worker process’s startup when the master process is enabled. When the master process is disabled, this hook will just run after <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#init_by_lua" target="_blank" rel="noopener">init_by_lua*</a>.</p><p>This hook is often used to create per-worker reoccurring timers (via the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxtimerat" target="_blank" rel="noopener">ngx.timer.at</a> Lua API), either for backend health-check or other timed routine work. Below is an example,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">init_worker_by_lua &apos;</span><br><span class="line">    local delay = 3  -- in seconds</span><br><span class="line">    local new_timer = ngx.timer.at</span><br><span class="line">    local log = ngx.log</span><br><span class="line">    local ERR = ngx.ERR</span><br><span class="line">    local check</span><br><span class="line"></span><br><span class="line">    check = function(premature)</span><br><span class="line">        if not premature then</span><br><span class="line">            -- do the health check or other routine work</span><br><span class="line">            local ok, err = new_timer(delay, check)</span><br><span class="line">            if not ok then</span><br><span class="line">                log(ERR, &quot;failed to create timer: &quot;, err)</span><br><span class="line">                return</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    local hdl, err = new_timer(delay, check)</span><br><span class="line">    if not hdl then</span><br><span class="line">        log(ERR, &quot;failed to create timer: &quot;, err)</span><br><span class="line">        return</span><br><span class="line">    end</span><br><span class="line">&apos;;</span><br></pre></td></tr></table></figure><p>This directive was first introduced in the <code>v0.9.5</code> release.</p><p>This hook no longer runs in the cache manager and cache loader processes since the <code>v0.10.12</code> release.</p><h2><span id="init_worker_by_lua_block">init_worker_by_lua_block</span></h2><p><strong>syntax:</strong> <em>init_worker_by_lua_block { lua-script }</em></p><p><strong>context:</strong> <em>http</em></p><p><strong>phase:</strong> <em>starting-worker</em></p><p>Similar to the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#init_worker_by_lua" target="_blank" rel="noopener">init_worker_by_lua</a> directive except that this directive inlines the Lua source directly inside a pair of curly braces (<code>{}</code>) instead of in an NGINX string literal (which requires special character escaping).</p><p>For instance,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">init_worker_by_lua_block &#123;</span><br><span class="line">    print(&quot;I need no extra escaping here, for example: \r\nblah&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This directive was first introduced in the <code>v0.9.17</code> release.</p><p>This hook no longer runs in the cache manager and cache loader processes since the <code>v0.10.12</code> release.</p><h2><span id="init_worker_by_lua_file">init_worker_by_lua_file</span></h2><p><strong>syntax:</strong> <em>init_worker_by_lua_file <lua-file-path></lua-file-path></em></p><p><strong>context:</strong> <em>http</em></p><p><strong>phase:</strong> <em>starting-worker</em></p><p>Similar to <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#init_worker_by_lua" target="_blank" rel="noopener">init_worker_by_lua</a>, but accepts the file path to a Lua source file or Lua bytecode file.</p><p>This directive was first introduced in the <code>v0.9.5</code> release.</p><p>This hook no longer runs in the cache manager and cache loader processes since the <code>v0.10.12</code> release.</p><h2><span id="set_by_lua">set_by_lua</span></h2><p><strong>syntax:</strong> <em>set_by_lua $res <lua-script-str> [$arg1 $arg2 …]</lua-script-str></em></p><p><strong>context:</strong> <em>server, server if, location, location if</em></p><p><strong>phase:</strong> <em>rewrite</em></p><p><strong>NOTE</strong> Use of this directive is <em>discouraged</em> following the <code>v0.9.17</code> release. Use the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#set_by_lua_block" target="_blank" rel="noopener">set_by_lua_block</a> directive instead.</p><p>Executes code specified in <code>&lt;lua-script-str&gt;</code> with optional input arguments <code>$arg1 $arg2 ...</code>, and returns string output to <code>$res</code>. The code in <code>&lt;lua-script-str&gt;</code> can make <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#nginx-api-for-lua" target="_blank" rel="noopener">API calls</a> and can retrieve input arguments from the <code>ngx.arg</code> table (index starts from <code>1</code> and increases sequentially).</p><p>This directive is designed to execute short, fast running code blocks as the Nginx event loop is blocked during code execution. Time consuming code sequences should therefore be avoided.</p><p>This directive is implemented by injecting custom commands into the standard <a href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html" target="_blank" rel="noopener">ngx_http_rewrite_module</a>‘s command list. Because <a href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html" target="_blank" rel="noopener">ngx_http_rewrite_module</a> does not support nonblocking I/O in its commands, Lua APIs requiring yielding the current Lua “light thread” cannot work in this directive.</p><p>At least the following API functions are currently disabled within the context of <code>set_by_lua</code>:</p><ul><li>Output API functions (e.g., <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsay" target="_blank" rel="noopener">ngx.say</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsend_headers" target="_blank" rel="noopener">ngx.send_headers</a>)</li><li>Control API functions (e.g., <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxexit" target="_blank" rel="noopener">ngx.exit</a>)</li><li>Subrequest API functions (e.g., <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxlocationcapture" target="_blank" rel="noopener">ngx.location.capture</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxlocationcapture_multi" target="_blank" rel="noopener">ngx.location.capture_multi</a>)</li><li>Cosocket API functions (e.g., <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsockettcp" target="_blank" rel="noopener">ngx.socket.tcp</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxreqsocket" target="_blank" rel="noopener">ngx.req.socket</a>).</li><li>Sleeping API function <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsleep" target="_blank" rel="noopener">ngx.sleep</a>.</li></ul><p>In addition, note that this directive can only write out a value to a single Nginx variable at a time. However, a workaround is possible using the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxvarvariable" target="_blank" rel="noopener">ngx.var.VARIABLE</a> interface.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">location /foo &#123;</span><br><span class="line">    set $diff &apos;&apos;; # we have to predefine the $diff variable here</span><br><span class="line"></span><br><span class="line">    set_by_lua $sum &apos;</span><br><span class="line">        local a = 32</span><br><span class="line">        local b = 56</span><br><span class="line"></span><br><span class="line">        ngx.var.diff = a - b;  -- write to $diff directly</span><br><span class="line">        return a + b;          -- return the $sum value normally</span><br><span class="line">    &apos;;</span><br><span class="line"></span><br><span class="line">    echo &quot;sum = $sum, diff = $diff&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This directive can be freely mixed with all directives of the <a href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html" target="_blank" rel="noopener">ngx_http_rewrite_module</a>, <a href="http://github.com/openresty/set-misc-nginx-module" target="_blank" rel="noopener">set-misc-nginx-module</a>, and <a href="http://github.com/openresty/array-var-nginx-module" target="_blank" rel="noopener">array-var-nginx-module</a> modules. All of these directives will run in the same order as they appear in the config file.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set $foo 32;</span><br><span class="line">set_by_lua $bar &apos;return tonumber(ngx.var.foo) + 1&apos;;</span><br><span class="line">set $baz &quot;bar: $bar&quot;;  # $baz == &quot;bar: 33&quot;</span><br></pre></td></tr></table></figure><p>As from the <code>v0.5.0rc29</code> release, Nginx variable interpolation is disabled in the <code>&lt;lua-script-str&gt;</code> argument of this directive and therefore, the dollar sign character (<code>$</code>) can be used directly.</p><p>This directive requires the <a href="https://github.com/simplresty/ngx_devel_kit" target="_blank" rel="noopener">ngx_devel_kit</a> module.</p><h2><span id="set_by_lua_block">set_by_lua_block</span></h2><p><strong>syntax:</strong> <em>set_by_lua_block $res { lua-script }</em></p><p><strong>context:</strong> <em>server, server if, location, location if</em></p><p><strong>phase:</strong> <em>rewrite</em></p><p>Similar to the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#set_by_lua" target="_blank" rel="noopener">set_by_lua</a> directive except that</p><ol><li>this directive inlines the Lua source directly inside a pair of curly braces (<code>{}</code>) instead of in an NGINX string literal (which requires special character escaping), and</li><li>this directive does not support extra arguments after the Lua script as in <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#set_by_lua" target="_blank" rel="noopener">set_by_lua</a>.</li></ol><p>For example,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set_by_lua_block $res &#123; return 32 + math.cos(32) &#125;</span><br><span class="line"># $res now has the value &quot;32.834223360507&quot; or alike.</span><br></pre></td></tr></table></figure><p>No special escaping is required in the Lua code block.</p><p>This directive was first introduced in the <code>v0.9.17</code> release.</p><h2><span id="set_by_lua_file">set_by_lua_file</span></h2><p><strong>syntax:</strong> <em>set_by_lua_file $res <path-to-lua-script-file> [$arg1 $arg2 …]</path-to-lua-script-file></em></p><p><strong>context:</strong> <em>server, server if, location, location if</em></p><p><strong>phase:</strong> <em>rewrite</em></p><p>Equivalent to <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#set_by_lua" target="_blank" rel="noopener">set_by_lua</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or, as from the <code>v0.5.0rc32</code> release, the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lualuajit-bytecode-support" target="_blank" rel="noopener">Lua/LuaJIT bytecode</a> to be executed.</p><p>Nginx variable interpolation is supported in the <code>&lt;path-to-lua-script-file&gt;</code> argument string of this directive. But special care must be taken for injection attacks.</p><p>When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p><p>When the Lua code cache is turned on (by default), the user code is loaded once at the first request and cached and the Nginx config must be reloaded each time the Lua source file is modified. The Lua code cache can be temporarily disabled during development by switching <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lua_code_cache" target="_blank" rel="noopener">lua_code_cache</a> <code>off</code> in <code>nginx.conf</code> to avoid reloading Nginx.</p><p>This directive requires the <a href="https://github.com/simplresty/ngx_devel_kit" target="_blank" rel="noopener">ngx_devel_kit</a> module.</p><h2><span id="content_by_lua">content_by_lua</span></h2><p><strong>syntax:</strong> <em>content_by_lua <lua-script-str></lua-script-str></em></p><p><strong>context:</strong> <em>location, location if</em></p><p><strong>phase:</strong> <em>content</em></p><p><strong>NOTE</strong> Use of this directive is <em>discouraged</em> following the <code>v0.9.17</code> release. Use the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#content_by_lua_block" target="_blank" rel="noopener">content_by_lua_block</a> directive instead.</p><p>Acts as a “content handler” and executes Lua code string specified in <code>&lt;lua-script-str&gt;</code> for every request. The Lua code may make <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#nginx-api-for-lua" target="_blank" rel="noopener">API calls</a> and is executed as a new spawned coroutine in an independent global environment (i.e. a sandbox).</p><p>Do not use this directive and other content handler directives in the same location. For example, this directive and the <a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_pass" target="_blank" rel="noopener">proxy_pass</a> directive should not be used in the same location.</p><h2><span id="content_by_lua_block">content_by_lua_block</span></h2><p><strong>syntax:</strong> <em>content_by_lua_block { lua-script }</em></p><p><strong>context:</strong> <em>location, location if</em></p><p><strong>phase:</strong> <em>content</em></p><p>Similar to the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#content_by_lua" target="_blank" rel="noopener">content_by_lua</a> directive except that this directive inlines the Lua source directly inside a pair of curly braces (<code>{}</code>) instead of in an NGINX string literal (which requires special character escaping).</p><p>For instance,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">content_by_lua_block &#123;</span><br><span class="line">    ngx.say(&quot;I need no extra escaping here, for example: \r\nblah&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This directive was first introduced in the <code>v0.9.17</code> release.</p><h2><span id="content_by_lua_file">content_by_lua_file</span></h2><p><strong>syntax:</strong> <em>content_by_lua_file <path-to-lua-script-file></path-to-lua-script-file></em></p><p><strong>context:</strong> <em>location, location if</em></p><p><strong>phase:</strong> <em>content</em></p><p>Equivalent to <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#content_by_lua" target="_blank" rel="noopener">content_by_lua</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or, as from the <code>v0.5.0rc32</code> release, the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lualuajit-bytecode-support" target="_blank" rel="noopener">Lua/LuaJIT bytecode</a> to be executed.</p><p>Nginx variables can be used in the <code>&lt;path-to-lua-script-file&gt;</code> string to provide flexibility. This however carries some risks and is not ordinarily recommended.</p><p>When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p><p>When the Lua code cache is turned on (by default), the user code is loaded once at the first request and cached and the Nginx config must be reloaded each time the Lua source file is modified. The Lua code cache can be temporarily disabled during development by switching <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lua_code_cache" target="_blank" rel="noopener">lua_code_cache</a> <code>off</code> in <code>nginx.conf</code> to avoid reloading Nginx.</p><p>Nginx variables are supported in the file path for dynamic dispatch, for example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># CAUTION: contents in nginx var must be carefully filtered,</span><br><span class="line"># otherwise there&apos;ll be great security risk!</span><br><span class="line">location ~ ^/app/([-_a-zA-Z0-9/]+) &#123;</span><br><span class="line">    set $path $1;</span><br><span class="line">    content_by_lua_file /path/to/lua/app/root/$path.lua;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>But be very careful about malicious user inputs and always carefully validate or filter out the user-supplied path components.</p><h2><span id="rewrite_by_lua">rewrite_by_lua</span></h2><p><strong>syntax:</strong> <em>rewrite_by_lua <lua-script-str></lua-script-str></em></p><p><strong>context:</strong> <em>http, server, location, location if</em></p><p><strong>phase:</strong> <em>rewrite tail</em></p><p><strong>NOTE</strong> Use of this directive is <em>discouraged</em> following the <code>v0.9.17</code> release. Use the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#rewrite_by_lua_block" target="_blank" rel="noopener">rewrite_by_lua_block</a> directive instead.</p><p>Acts as a rewrite phase handler and executes Lua code string specified in <code>&lt;lua-script-str&gt;</code> for every request. The Lua code may make <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#nginx-api-for-lua" target="_blank" rel="noopener">API calls</a> and is executed as a new spawned coroutine in an independent global environment (i.e. a sandbox).</p><p>Note that this handler always runs <em>after</em> the standard <a href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html" target="_blank" rel="noopener">ngx_http_rewrite_module</a>. So the following will work as expected:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location /foo &#123;</span><br><span class="line">    set $a 12; # create and initialize $a</span><br><span class="line">    set $b &quot;&quot;; # create and initialize $b</span><br><span class="line">    rewrite_by_lua &apos;ngx.var.b = tonumber(ngx.var.a) + 1&apos;;</span><br><span class="line">    echo &quot;res = $b&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>because <code>set $a 12</code> and <code>set $b &quot;&quot;</code> run <em>before</em> <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#rewrite_by_lua" target="_blank" rel="noopener">rewrite_by_lua</a>.</p><p>On the other hand, the following will not work as expected:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">?  location /foo &#123;</span><br><span class="line">?      set $a 12; # create and initialize $a</span><br><span class="line">?      set $b &apos;&apos;; # create and initialize $b</span><br><span class="line">?      rewrite_by_lua &apos;ngx.var.b = tonumber(ngx.var.a) + 1&apos;;</span><br><span class="line">?      if ($b = &apos;13&apos;) &#123;</span><br><span class="line">?         rewrite ^ /bar redirect;</span><br><span class="line">?         break;</span><br><span class="line">?      &#125;</span><br><span class="line">?</span><br><span class="line">?      echo &quot;res = $b&quot;;</span><br><span class="line">?  &#125;</span><br></pre></td></tr></table></figure><p>because <code>if</code> runs <em>before</em> <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#rewrite_by_lua" target="_blank" rel="noopener">rewrite_by_lua</a> even if it is placed after <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#rewrite_by_lua" target="_blank" rel="noopener">rewrite_by_lua</a> in the config.</p><p>The right way of doing this is as follows:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">location /foo &#123;</span><br><span class="line">    set $a 12; # create and initialize $a</span><br><span class="line">    set $b &apos;&apos;; # create and initialize $b</span><br><span class="line">    rewrite_by_lua &apos;</span><br><span class="line">        ngx.var.b = tonumber(ngx.var.a) + 1</span><br><span class="line">        if tonumber(ngx.var.b) == 13 then</span><br><span class="line">            return ngx.redirect(&quot;/bar&quot;);</span><br><span class="line">        end</span><br><span class="line">    &apos;;</span><br><span class="line"></span><br><span class="line">    echo &quot;res = $b&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note that the <a href="http://www.grid.net.ru/nginx/eval.en.html" target="_blank" rel="noopener">ngx_eval</a> module can be approximated by using <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#rewrite_by_lua" target="_blank" rel="noopener">rewrite_by_lua</a>. For example,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    eval $res &#123;</span><br><span class="line">        proxy_pass http://foo.com/check-spam;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if ($res = &apos;spam&apos;) &#123;</span><br><span class="line">        rewrite ^ /terms-of-use.html redirect;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fastcgi_pass ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>can be implemented in ngx_lua as:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">location = /check-spam &#123;</span><br><span class="line">    internal;</span><br><span class="line">    proxy_pass http://foo.com/check-spam;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">    rewrite_by_lua &apos;</span><br><span class="line">        local res = ngx.location.capture(&quot;/check-spam&quot;)</span><br><span class="line">        if res.body == &quot;spam&quot; then</span><br><span class="line">            return ngx.redirect(&quot;/terms-of-use.html&quot;)</span><br><span class="line">        end</span><br><span class="line">    &apos;;</span><br><span class="line"></span><br><span class="line">    fastcgi_pass ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Just as any other rewrite phase handlers, <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#rewrite_by_lua" target="_blank" rel="noopener">rewrite_by_lua</a> also runs in subrequests.</p><p>Note that when calling <code>ngx.exit(ngx.OK)</code> within a <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#rewrite_by_lua" target="_blank" rel="noopener">rewrite_by_lua</a> handler, the nginx request processing control flow will still continue to the content handler. To terminate the current request from within a <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#rewrite_by_lua" target="_blank" rel="noopener">rewrite_by_lua</a> handler, calling <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxexit" target="_blank" rel="noopener">ngx.exit</a> with status &gt;= 200 (<code>ngx.HTTP_OK</code>) and status &lt; 300 (<code>ngx.HTTP_SPECIAL_RESPONSE</code>) for successful quits and <code>ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)</code> (or its friends) for failures.</p><p>If the <a href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html" target="_blank" rel="noopener">ngx_http_rewrite_module</a>‘s <a href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html#rewrite" target="_blank" rel="noopener">rewrite</a> directive is used to change the URI and initiate location re-lookups (internal redirections), then any <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#rewrite_by_lua" target="_blank" rel="noopener">rewrite_by_lua</a> or <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#rewrite_by_lua_file" target="_blank" rel="noopener">rewrite_by_lua_file</a> code sequences within the current location will not be executed. For example,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location /foo &#123;</span><br><span class="line">    rewrite ^ /bar;</span><br><span class="line">    rewrite_by_lua &apos;ngx.exit(503)&apos;;</span><br><span class="line">&#125;</span><br><span class="line">location /bar &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Here the Lua code <code>ngx.exit(503)</code> will never run. This will be the case if <code>rewrite ^ /bar last</code> is used as this will similarly initiate an internal redirection. If the <code>break</code> modifier is used instead, there will be no internal redirection and the <code>rewrite_by_lua</code> code will be executed.</p><p>The <code>rewrite_by_lua</code> code will always run at the end of the <code>rewrite</code> request-processing phase unless <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#rewrite_by_lua_no_postpone" target="_blank" rel="noopener">rewrite_by_lua_no_postpone</a> is turned on.</p><h2><span id="rewrite_by_lua_block">rewrite_by_lua_block</span></h2><p><strong>syntax:</strong> <em>rewrite_by_lua_block { lua-script }</em></p><p><strong>context:</strong> <em>http, server, location, location if</em></p><p><strong>phase:</strong> <em>rewrite tail</em></p><p>Similar to the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#rewrite_by_lua" target="_blank" rel="noopener">rewrite_by_lua</a> directive except that this directive inlines the Lua source directly inside a pair of curly braces (<code>{}</code>) instead of in an NGINX string literal (which requires special character escaping).</p><p>For instance,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rewrite_by_lua_block &#123;</span><br><span class="line">    do_something(&quot;hello, world!\nhiya\n&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This directive was first introduced in the <code>v0.9.17</code> release.</p><h2><span id="rewrite_by_lua_file">rewrite_by_lua_file</span></h2><p><strong>syntax:</strong> <em>rewrite_by_lua_file <path-to-lua-script-file></path-to-lua-script-file></em></p><p><strong>context:</strong> <em>http, server, location, location if</em></p><p><strong>phase:</strong> <em>rewrite tail</em></p><p>Equivalent to <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#rewrite_by_lua" target="_blank" rel="noopener">rewrite_by_lua</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or, as from the <code>v0.5.0rc32</code> release, the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lualuajit-bytecode-support" target="_blank" rel="noopener">Lua/LuaJIT bytecode</a> to be executed.</p><p>Nginx variables can be used in the <code>&lt;path-to-lua-script-file&gt;</code> string to provide flexibility. This however carries some risks and is not ordinarily recommended.</p><p>When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p><p>When the Lua code cache is turned on (by default), the user code is loaded once at the first request and cached and the Nginx config must be reloaded each time the Lua source file is modified. The Lua code cache can be temporarily disabled during development by switching <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lua_code_cache" target="_blank" rel="noopener">lua_code_cache</a> <code>off</code> in <code>nginx.conf</code> to avoid reloading Nginx.</p><p>The <code>rewrite_by_lua_file</code> code will always run at the end of the <code>rewrite</code> request-processing phase unless <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#rewrite_by_lua_no_postpone" target="_blank" rel="noopener">rewrite_by_lua_no_postpone</a> is turned on.</p><p>Nginx variables are supported in the file path for dynamic dispatch just as in <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#content_by_lua_file" target="_blank" rel="noopener">content_by_lua_file</a>.</p><h2><span id="access_by_lua">access_by_lua</span></h2><p><strong>syntax:</strong> <em>access_by_lua <lua-script-str></lua-script-str></em></p><p><strong>context:</strong> <em>http, server, location, location if</em></p><p><strong>phase:</strong> <em>access tail</em></p><p><strong>NOTE</strong> Use of this directive is <em>discouraged</em> following the <code>v0.9.17</code> release. Use the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#access_by_lua_block" target="_blank" rel="noopener">access_by_lua_block</a> directive instead.</p><p>Acts as an access phase handler and executes Lua code string specified in <code>&lt;lua-script-str&gt;</code> for every request. The Lua code may make <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#nginx-api-for-lua" target="_blank" rel="noopener">API calls</a> and is executed as a new spawned coroutine in an independent global environment (i.e. a sandbox).</p><p>Note that this handler always runs <em>after</em> the standard <a href="http://nginx.org/en/docs/http/ngx_http_access_module.html" target="_blank" rel="noopener">ngx_http_access_module</a>. So the following will work as expected:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    deny    192.168.1.1;</span><br><span class="line">    allow   192.168.1.0/24;</span><br><span class="line">    allow   10.1.1.0/16;</span><br><span class="line">    deny    all;</span><br><span class="line"></span><br><span class="line">    access_by_lua &apos;</span><br><span class="line">        local res = ngx.location.capture(&quot;/mysql&quot;, &#123; ... &#125;)</span><br><span class="line">        ...</span><br><span class="line">    &apos;;</span><br><span class="line"></span><br><span class="line">    # proxy_pass/fastcgi_pass/...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>That is, if a client IP address is in the blacklist, it will be denied before the MySQL query for more complex authentication is executed by <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#access_by_lua" target="_blank" rel="noopener">access_by_lua</a>.</p><p>Note that the <a href="http://mdounin.ru/hg/ngx_http_auth_request_module/" target="_blank" rel="noopener">ngx_auth_request</a> module can be approximated by using <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#access_by_lua" target="_blank" rel="noopener">access_by_lua</a>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    auth_request /auth;</span><br><span class="line"></span><br><span class="line">    # proxy_pass/fastcgi_pass/postgres_pass/...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>can be implemented in ngx_lua as:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    access_by_lua &apos;</span><br><span class="line">        local res = ngx.location.capture(&quot;/auth&quot;)</span><br><span class="line"></span><br><span class="line">        if res.status == ngx.HTTP_OK then</span><br><span class="line">            return</span><br><span class="line">        end</span><br><span class="line"></span><br><span class="line">        if res.status == ngx.HTTP_FORBIDDEN then</span><br><span class="line">            ngx.exit(res.status)</span><br><span class="line">        end</span><br><span class="line"></span><br><span class="line">        ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)</span><br><span class="line">    &apos;;</span><br><span class="line"></span><br><span class="line">    # proxy_pass/fastcgi_pass/postgres_pass/...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>As with other access phase handlers, <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#access_by_lua" target="_blank" rel="noopener">access_by_lua</a> will <em>not</em> run in subrequests.</p><p>Note that when calling <code>ngx.exit(ngx.OK)</code> within a <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#access_by_lua" target="_blank" rel="noopener">access_by_lua</a> handler, the nginx request processing control flow will still continue to the content handler. To terminate the current request from within a <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#access_by_lua" target="_blank" rel="noopener">access_by_lua</a> handler, calling <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxexit" target="_blank" rel="noopener">ngx.exit</a> with status &gt;= 200 (<code>ngx.HTTP_OK</code>) and status &lt; 300 (<code>ngx.HTTP_SPECIAL_RESPONSE</code>) for successful quits and <code>ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)</code> (or its friends) for failures.</p><p>Starting from the <code>v0.9.20</code> release, you can use the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#access_by_lua_no_postpone" target="_blank" rel="noopener">access_by_lua_no_postpone</a> directive to control when to run this handler inside the “access” request-processing phase of NGINX.</p><h2><span id="access_by_lua_block">access_by_lua_block</span></h2><p><strong>syntax:</strong> <em>access_by_lua_block { lua-script }</em></p><p><strong>context:</strong> <em>http, server, location, location if</em></p><p><strong>phase:</strong> <em>access tail</em></p><p>Similar to the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#access_by_lua" target="_blank" rel="noopener">access_by_lua</a> directive except that this directive inlines the Lua source directly inside a pair of curly braces (<code>{}</code>) instead of in an NGINX string literal (which requires special character escaping).</p><p>For instance,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">access_by_lua_block &#123;</span><br><span class="line">    do_something(&quot;hello, world!\nhiya\n&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This directive was first introduced in the <code>v0.9.17</code> release.</p><h2><span id="access_by_lua_file">access_by_lua_file</span></h2><p><strong>syntax:</strong> <em>access_by_lua_file <path-to-lua-script-file></path-to-lua-script-file></em></p><p><strong>context:</strong> <em>http, server, location, location if</em></p><p><strong>phase:</strong> <em>access tail</em></p><p>Equivalent to <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#access_by_lua" target="_blank" rel="noopener">access_by_lua</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or, as from the <code>v0.5.0rc32</code> release, the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lualuajit-bytecode-support" target="_blank" rel="noopener">Lua/LuaJIT bytecode</a> to be executed.</p><p>Nginx variables can be used in the <code>&lt;path-to-lua-script-file&gt;</code> string to provide flexibility. This however carries some risks and is not ordinarily recommended.</p><p>When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p><p>When the Lua code cache is turned on (by default), the user code is loaded once at the first request and cached and the Nginx config must be reloaded each time the Lua source file is modified. The Lua code cache can be temporarily disabled during development by switching <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lua_code_cache" target="_blank" rel="noopener">lua_code_cache</a> <code>off</code> in <code>nginx.conf</code> to avoid repeatedly reloading Nginx.</p><p>Nginx variables are supported in the file path for dynamic dispatch just as in <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#content_by_lua_file" target="_blank" rel="noopener">content_by_lua_file</a>.</p><h2><span id="header_filter_by_lua">header_filter_by_lua</span></h2><p><strong>syntax:</strong> <em>header_filter_by_lua <lua-script-str></lua-script-str></em></p><p><strong>context:</strong> <em>http, server, location, location if</em></p><p><strong>phase:</strong> <em>output-header-filter</em></p><p><strong>NOTE</strong> Use of this directive is <em>discouraged</em> following the <code>v0.9.17</code> release. Use the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#header_filter_by_lua_block" target="_blank" rel="noopener">header_filter_by_lua_block</a> directive instead.</p><p>Uses Lua code specified in <code>&lt;lua-script-str&gt;</code> to define an output header filter.</p><p>Note that the following API functions are currently disabled within this context:</p><ul><li>Output API functions (e.g., <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsay" target="_blank" rel="noopener">ngx.say</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsend_headers" target="_blank" rel="noopener">ngx.send_headers</a>)</li><li>Control API functions (e.g., <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxredirect" target="_blank" rel="noopener">ngx.redirect</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxexec" target="_blank" rel="noopener">ngx.exec</a>)</li><li>Subrequest API functions (e.g., <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxlocationcapture" target="_blank" rel="noopener">ngx.location.capture</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxlocationcapture_multi" target="_blank" rel="noopener">ngx.location.capture_multi</a>)</li><li>Cosocket API functions (e.g., <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsockettcp" target="_blank" rel="noopener">ngx.socket.tcp</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxreqsocket" target="_blank" rel="noopener">ngx.req.socket</a>).</li></ul><p>Here is an example of overriding a response header (or adding one if absent) in our Lua header filter:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    proxy_pass http://mybackend;</span><br><span class="line">    header_filter_by_lua &apos;ngx.header.Foo = &quot;blah&quot;&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This directive was first introduced in the <code>v0.2.1rc20</code> release.</p><h2><span id="header_filter_by_lua_block">header_filter_by_lua_block</span></h2><p><strong>syntax:</strong> <em>header_filter_by_lua_block { lua-script }</em></p><p><strong>context:</strong> <em>http, server, location, location if</em></p><p><strong>phase:</strong> <em>output-header-filter</em></p><p>Similar to the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#header_filter_by_lua" target="_blank" rel="noopener">header_filter_by_lua</a> directive except that this directive inlines the Lua source directly inside a pair of curly braces (<code>{}</code>) instead of in an NGINX string literal (which requires special character escaping).</p><p>For instance,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">header_filter_by_lua_block &#123;</span><br><span class="line">    ngx.header[&quot;content-length&quot;] = nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This directive was first introduced in the <code>v0.9.17</code> release.</p><h2><span id="header_filter_by_lua_file">header_filter_by_lua_file</span></h2><p><strong>syntax:</strong> <em>header_filter_by_lua_file <path-to-lua-script-file></path-to-lua-script-file></em></p><p><strong>context:</strong> <em>http, server, location, location if</em></p><p><strong>phase:</strong> <em>output-header-filter</em></p><p>Equivalent to <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#header_filter_by_lua" target="_blank" rel="noopener">header_filter_by_lua</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or as from the <code>v0.5.0rc32</code> release, the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lualuajit-bytecode-support" target="_blank" rel="noopener">Lua/LuaJIT bytecode</a> to be executed.</p><p>When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p><p>This directive was first introduced in the <code>v0.2.1rc20</code> release.</p><h2><span id="body_filter_by_lua">body_filter_by_lua</span></h2><p><strong>syntax:</strong> <em>body_filter_by_lua <lua-script-str></lua-script-str></em></p><p><strong>context:</strong> <em>http, server, location, location if</em></p><p><strong>phase:</strong> <em>output-body-filter</em></p><p><strong>NOTE</strong> Use of this directive is <em>discouraged</em> following the <code>v0.9.17</code> release. Use the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#body_filter_by_lua_block" target="_blank" rel="noopener">body_filter_by_lua_block</a> directive instead.</p><p>Uses Lua code specified in <code>&lt;lua-script-str&gt;</code> to define an output body filter.</p><p>The input data chunk is passed via <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxarg" target="_blank" rel="noopener">ngx.arg</a>[1] (as a Lua string value) and the “eof” flag indicating the end of the response body data stream is passed via <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxarg" target="_blank" rel="noopener">ngx.arg</a>[2] (as a Lua boolean value).</p><p>Behind the scene, the “eof” flag is just the <code>last_buf</code> (for main requests) or <code>last_in_chain</code> (for subrequests) flag of the Nginx chain link buffers. (Before the <code>v0.7.14</code> release, the “eof” flag does not work at all in subrequests.)</p><p>The output data stream can be aborted immediately by running the following Lua statement:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return ngx.ERROR</span><br></pre></td></tr></table></figure><p>This will truncate the response body and usually result in incomplete and also invalid responses.</p><p>The Lua code can pass its own modified version of the input data chunk to the downstream Nginx output body filters by overriding <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxarg" target="_blank" rel="noopener">ngx.arg</a>[1] with a Lua string or a Lua table of strings. For example, to transform all the lowercase letters in the response body, we can just write:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    proxy_pass http://mybackend;</span><br><span class="line">    body_filter_by_lua &apos;ngx.arg[1] = string.upper(ngx.arg[1])&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>When setting <code>nil</code> or an empty Lua string value to <code>ngx.arg[1]</code>, no data chunk will be passed to the downstream Nginx output filters at all.</p><p>Likewise, new “eof” flag can also be specified by setting a boolean value to <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxarg" target="_blank" rel="noopener">ngx.arg</a>[2]. For example,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">location /t &#123;</span><br><span class="line">    echo hello world;</span><br><span class="line">    echo hiya globe;</span><br><span class="line"></span><br><span class="line">    body_filter_by_lua &apos;</span><br><span class="line">        local chunk = ngx.arg[1]</span><br><span class="line">        if string.match(chunk, &quot;hello&quot;) then</span><br><span class="line">            ngx.arg[2] = true  -- new eof</span><br><span class="line">            return</span><br><span class="line">        end</span><br><span class="line"></span><br><span class="line">        -- just throw away any remaining chunk data</span><br><span class="line">        ngx.arg[1] = nil</span><br><span class="line">    &apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Then <code>GET /t</code> will just return the output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br></pre></td></tr></table></figure><p>That is, when the body filter sees a chunk containing the word “hello”, then it will set the “eof” flag to true immediately, resulting in truncated but still valid responses.</p><p>When the Lua code may change the length of the response body, then it is required to always clear out the <code>Content-Length</code>response header (if any) in a header filter to enforce streaming output, as in</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location /foo &#123;</span><br><span class="line">    # fastcgi_pass/proxy_pass/...</span><br><span class="line"></span><br><span class="line">    header_filter_by_lua_block &#123; ngx.header.content_length = nil &#125;</span><br><span class="line">    body_filter_by_lua &apos;ngx.arg[1] = string.len(ngx.arg[1]) .. &quot;\\n&quot;&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note that the following API functions are currently disabled within this context due to the limitations in NGINX output filter’s current implementation:</p><ul><li>Output API functions (e.g., <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsay" target="_blank" rel="noopener">ngx.say</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsend_headers" target="_blank" rel="noopener">ngx.send_headers</a>)</li><li>Control API functions (e.g., <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxexit" target="_blank" rel="noopener">ngx.exit</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxexec" target="_blank" rel="noopener">ngx.exec</a>)</li><li>Subrequest API functions (e.g., <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxlocationcapture" target="_blank" rel="noopener">ngx.location.capture</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxlocationcapture_multi" target="_blank" rel="noopener">ngx.location.capture_multi</a>)</li><li>Cosocket API functions (e.g., <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsockettcp" target="_blank" rel="noopener">ngx.socket.tcp</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxreqsocket" target="_blank" rel="noopener">ngx.req.socket</a>).</li></ul><p>Nginx output filters may be called multiple times for a single request because response body may be delivered in chunks. Thus, the Lua code specified by in this directive may also run multiple times in the lifetime of a single HTTP request.</p><p>This directive was first introduced in the <code>v0.5.0rc32</code> release.</p><h2><span id="body_filter_by_lua_block">body_filter_by_lua_block</span></h2><p><strong>syntax:</strong> <em>body_filter_by_lua_block { lua-script-str }</em></p><p><strong>context:</strong> <em>http, server, location, location if</em></p><p><strong>phase:</strong> <em>output-body-filter</em></p><p>Similar to the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#body_filter_by_lua" target="_blank" rel="noopener">body_filter_by_lua</a> directive except that this directive inlines the Lua source directly inside a pair of curly braces (<code>{}</code>) instead of in an NGINX string literal (which requires special character escaping).</p><p>For instance,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">body_filter_by_lua_block &#123;</span><br><span class="line">    local data, eof = ngx.arg[1], ngx.arg[2]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This directive was first introduced in the <code>v0.9.17</code> release.</p><h2><span id="body_filter_by_lua_file">body_filter_by_lua_file</span></h2><p><strong>syntax:</strong> <em>body_filter_by_lua_file <path-to-lua-script-file></path-to-lua-script-file></em></p><p><strong>context:</strong> <em>http, server, location, location if</em></p><p><strong>phase:</strong> <em>output-body-filter</em></p><p>Equivalent to <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#body_filter_by_lua" target="_blank" rel="noopener">body_filter_by_lua</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or, as from the <code>v0.5.0rc32</code> release, the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lualuajit-bytecode-support" target="_blank" rel="noopener">Lua/LuaJIT bytecode</a> to be executed.</p><p>When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p><p>This directive was first introduced in the <code>v0.5.0rc32</code> release.</p><h2><span id="log_by_lua">log_by_lua</span></h2><p><strong>syntax:</strong> <em>log_by_lua <lua-script-str></lua-script-str></em></p><p><strong>context:</strong> <em>http, server, location, location if</em></p><p><strong>phase:</strong> <em>log</em></p><p><strong>NOTE</strong> Use of this directive is <em>discouraged</em> following the <code>v0.9.17</code> release. Use the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#log_by_lua_block" target="_blank" rel="noopener">log_by_lua_block</a> directive instead.</p><p>Runs the Lua source code inlined as the <code>&lt;lua-script-str&gt;</code> at the <code>log</code> request processing phase. This does not replace the current access logs, but runs before.</p><p>Note that the following API functions are currently disabled within this context:</p><ul><li>Output API functions (e.g., <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsay" target="_blank" rel="noopener">ngx.say</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsend_headers" target="_blank" rel="noopener">ngx.send_headers</a>)</li><li>Control API functions (e.g., <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxexit" target="_blank" rel="noopener">ngx.exit</a>)</li><li>Subrequest API functions (e.g., <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxlocationcapture" target="_blank" rel="noopener">ngx.location.capture</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxlocationcapture_multi" target="_blank" rel="noopener">ngx.location.capture_multi</a>)</li><li>Cosocket API functions (e.g., <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsockettcp" target="_blank" rel="noopener">ngx.socket.tcp</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxreqsocket" target="_blank" rel="noopener">ngx.req.socket</a>).</li></ul><p>Here is an example of gathering average data for <a href="http://nginx.org/en/docs/http/ngx_http_upstream_module.html#var_upstream_response_time" target="_blank" rel="noopener">$upstream_response_time</a>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">lua_shared_dict log_dict 5M;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://mybackend;</span><br><span class="line"></span><br><span class="line">        log_by_lua &apos;</span><br><span class="line">            local log_dict = ngx.shared.log_dict</span><br><span class="line">            local upstream_time = tonumber(ngx.var.upstream_response_time)</span><br><span class="line"></span><br><span class="line">            local sum = log_dict:get(&quot;upstream_time-sum&quot;) or 0</span><br><span class="line">            sum = sum + upstream_time</span><br><span class="line">            log_dict:set(&quot;upstream_time-sum&quot;, sum)</span><br><span class="line"></span><br><span class="line">            local newval, err = log_dict:incr(&quot;upstream_time-nb&quot;, 1)</span><br><span class="line">            if not newval and err == &quot;not found&quot; then</span><br><span class="line">                log_dict:add(&quot;upstream_time-nb&quot;, 0)</span><br><span class="line">                log_dict:incr(&quot;upstream_time-nb&quot;, 1)</span><br><span class="line">            end</span><br><span class="line">        &apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location = /status &#123;</span><br><span class="line">        content_by_lua_block &#123;</span><br><span class="line">            local log_dict = ngx.shared.log_dict</span><br><span class="line">            local sum = log_dict:get(&quot;upstream_time-sum&quot;)</span><br><span class="line">            local nb = log_dict:get(&quot;upstream_time-nb&quot;)</span><br><span class="line"></span><br><span class="line">            if nb and sum then</span><br><span class="line">                ngx.say(&quot;average upstream response time: &quot;, sum / nb,</span><br><span class="line">                        &quot; (&quot;, nb, &quot; reqs)&quot;)</span><br><span class="line">            else</span><br><span class="line">                ngx.say(&quot;no data yet&quot;)</span><br><span class="line">            end</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This directive was first introduced in the <code>v0.5.0rc31</code> release.</p><h2><span id="log_by_lua_block">log_by_lua_block</span></h2><p><strong>syntax:</strong> <em>log_by_lua_block { lua-script }</em></p><p><strong>context:</strong> <em>http, server, location, location if</em></p><p><strong>phase:</strong> <em>log</em></p><p>Similar to the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#log_by_lua" target="_blank" rel="noopener">log_by_lua</a> directive except that this directive inlines the Lua source directly inside a pair of curly braces (<code>{}</code>) instead of in an NGINX string literal (which requires special character escaping).</p><p>For instance,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">log_by_lua_block &#123;</span><br><span class="line">    print(&quot;I need no extra escaping here, for example: \r\nblah&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This directive was first introduced in the <code>v0.9.17</code> release.</p><h2><span id="log_by_lua_file">log_by_lua_file</span></h2><p><strong>syntax:</strong> <em>log_by_lua_file <path-to-lua-script-file></path-to-lua-script-file></em></p><p><strong>context:</strong> <em>http, server, location, location if</em></p><p><strong>phase:</strong> <em>log</em></p><p>Equivalent to <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#log_by_lua" target="_blank" rel="noopener">log_by_lua</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or, as from the <code>v0.5.0rc32</code> release, the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lualuajit-bytecode-support" target="_blank" rel="noopener">Lua/LuaJIT bytecode</a> to be executed.</p><p>When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p><p>This directive was first introduced in the <code>v0.5.0rc31</code> release.</p><h2><span id="balancer_by_lua_block">balancer_by_lua_block</span></h2><p><strong>syntax:</strong> <em>balancer_by_lua_block { lua-script }</em></p><p><strong>context:</strong> <em>upstream</em></p><p><strong>phase:</strong> <em>content</em></p><p>This directive runs Lua code as an upstream balancer for any upstream entities defined by the <code>upstream {}</code> configuration block.</p><p>For instance,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">upstream foo &#123;</span><br><span class="line">    server 127.0.0.1;</span><br><span class="line">    balancer_by_lua_block &#123;</span><br><span class="line">        -- use Lua to do something interesting here</span><br><span class="line">        -- as a dynamic balancer</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://foo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The resulting Lua load balancer can work with any existing nginx upstream modules like <a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html" target="_blank" rel="noopener">ngx_proxy</a> and <a href="http://nginx.org/en/docs/http/ngx_http_fastcgi_module.html" target="_blank" rel="noopener">ngx_fastcgi</a>.</p><p>Also, the Lua load balancer can work with the standard upstream connection pool mechanism, i.e., the standard <a href="http://nginx.org/en/docs/http/ngx_http_upstream_module.html#keepalive" target="_blank" rel="noopener">keepalive</a>directive. Just ensure that the <a href="http://nginx.org/en/docs/http/ngx_http_upstream_module.html#keepalive" target="_blank" rel="noopener">keepalive</a> directive is used <em>after</em> this <code>balancer_by_lua_block</code> directive in a single <code>upstream {}</code>configuration block.</p><p>The Lua load balancer can totally ignore the list of servers defined in the <code>upstream {}</code> block and select peer from a completely dynamic server list (even changing per request) via the <a href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/balancer.md" target="_blank" rel="noopener">ngx.balancer</a> module from the <a href="https://github.com/openresty/lua-resty-core" target="_blank" rel="noopener">lua-resty-core</a> library.</p><p>The Lua code handler registered by this directive might get called more than once in a single downstream request when the nginx upstream mechanism retries the request on conditions specified by directives like the <a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_next_upstream" target="_blank" rel="noopener">proxy_next_upstream</a> directive.</p><p>This Lua code execution context does not support yielding, so Lua APIs that may yield (like cosockets and “light threads”) are disabled in this context. One can usually work around this limitation by doing such operations in an earlier phase handler (like<a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#access_by_lua" target="_blank" rel="noopener">access_by_lua*</a>) and passing along the result into this context via the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxctx" target="_blank" rel="noopener">ngx.ctx</a> table.</p><p>This directive was first introduced in the <code>v0.10.0</code> release.</p><h2><span id="balancer_by_lua_file">balancer_by_lua_file</span></h2><p><strong>syntax:</strong> <em>balancer_by_lua_file <path-to-lua-script-file></path-to-lua-script-file></em></p><p><strong>context:</strong> <em>upstream</em></p><p><strong>phase:</strong> <em>content</em></p><p>Equivalent to <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#balancer_by_lua_block" target="_blank" rel="noopener">balancer_by_lua_block</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or, as from the <code>v0.5.0rc32</code> release, the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lualuajit-bytecode-support" target="_blank" rel="noopener">Lua/LuaJIT bytecode</a> to be executed.</p><p>When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p><p>This directive was first introduced in the <code>v0.10.0</code> release.</p><h2><span id="lua_need_request_body">lua_need_request_body</span></h2><p><strong>syntax:</strong> <em>lua_need_request_body &lt;on|off&gt;</em></p><p><strong>default:</strong> <em>off</em></p><p><strong>context:</strong> <em>http, server, location, location if</em></p><p><strong>phase:</strong> <em>depends on usage</em></p><p>Determines whether to force the request body data to be read before running rewrite/access/access_by_lua* or not. The Nginx core does not read the client request body by default and if request body data is required, then this directive should be turned <code>on</code> or the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxreqread_body" target="_blank" rel="noopener">ngx.req.read_body</a> function should be called within the Lua code.</p><p>To read the request body data within the <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#var_request_body" target="_blank" rel="noopener">$request_body</a> variable, <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_buffer_size" target="_blank" rel="noopener">client_body_buffer_size</a> must have the same value as <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#client_max_body_size" target="_blank" rel="noopener">client_max_body_size</a>. Because when the content length exceeds <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_buffer_size" target="_blank" rel="noopener">client_body_buffer_size</a> but less than <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#client_max_body_size" target="_blank" rel="noopener">client_max_body_size</a>, Nginx will buffer the data into a temporary file on the disk, which will lead to empty value in the <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#var_request_body" target="_blank" rel="noopener">$request_body</a> variable.</p><p>If the current location includes <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#rewrite_by_lua" target="_blank" rel="noopener">rewrite_by_lua*</a> directives, then the request body will be read just before the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#rewrite_by_lua" target="_blank" rel="noopener">rewrite_by_lua*</a>code is run (and also at the <code>rewrite</code> phase). Similarly, if only <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#content_by_lua" target="_blank" rel="noopener">content_by_lua</a> is specified, the request body will not be read until the content handler’s Lua code is about to run (i.e., the request body will be read during the content phase).</p><p>It is recommended however, to use the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxreqread_body" target="_blank" rel="noopener">ngx.req.read_body</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxreqdiscard_body" target="_blank" rel="noopener">ngx.req.discard_body</a> functions for finer control over the request body reading process instead.</p><p>This also applies to <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#access_by_lua" target="_blank" rel="noopener">access_by_lua*</a>.</p><h2><span id="ssl_certificate_by_lua_block">ssl_certificate_by_lua_block</span></h2><p><strong>syntax:</strong> <em>ssl_certificate_by_lua_block { lua-script }</em></p><p><strong>context:</strong> <em>server</em></p><p><strong>phase:</strong> <em>right-before-SSL-handshake</em></p><p>This directive runs user Lua code when NGINX is about to start the SSL handshake for the downstream SSL (https) connections.</p><p>It is particularly useful for setting the SSL certificate chain and the corresponding private key on a per-request basis. It is also useful to load such handshake configurations nonblockingly from the remote (for example, with the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsockettcp" target="_blank" rel="noopener">cosocket</a> API). And one can also do per-request OCSP stapling handling in pure Lua here as well.</p><p>Another typical use case is to do SSL handshake traffic control nonblockingly in this context, with the help of the <a href="https://github.com/openresty/lua-resty-limit-traffic" target="_blank" rel="noopener">lua-resty-limit-traffic#readme</a> library, for example.</p><p>One can also do interesting things with the SSL handshake requests from the client side, like rejecting old SSL clients using the SSLv3 protocol or even below selectively.</p><p>The <a href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl.md" target="_blank" rel="noopener">ngx.ssl</a> and <a href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ocsp.md" target="_blank" rel="noopener">ngx.ocsp</a> Lua modules provided by the <a href="https://github.com/openresty/lua-resty-core/#readme" target="_blank" rel="noopener">lua-resty-core</a> library are particularly useful in this context. You can use the Lua API offered by these two Lua modules to manipulate the SSL certificate chain and private key for the current SSL connection being initiated.</p><p>This Lua handler does not run at all, however, when NGINX/OpenSSL successfully resumes the SSL session via SSL session IDs or TLS session tickets for the current SSL connection. In other words, this Lua handler only runs when NGINX has to initiate a full SSL handshake.</p><p>Below is a trivial example using the <a href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl.md" target="_blank" rel="noopener">ngx.ssl</a> module at the same time:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name   test.com;</span><br><span class="line"></span><br><span class="line">    ssl_certificate_by_lua_block &#123;</span><br><span class="line">        print(&quot;About to initiate a new SSL handshake!&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>See more complicated examples in the <a href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl.md" target="_blank" rel="noopener">ngx.ssl</a> and <a href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ocsp.md" target="_blank" rel="noopener">ngx.ocsp</a> Lua modules’ official documentation.</p><p>Uncaught Lua exceptions in the user Lua code immediately abort the current SSL session, so does the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxexit" target="_blank" rel="noopener">ngx.exit</a> call with an error code like <code>ngx.ERROR</code>.</p><p>This Lua code execution context <em>does</em> support yielding, so Lua APIs that may yield (like cosockets, sleeping, and “light threads”) are enabled in this context.</p><p>Note, however, you still need to configure the <a href="http://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_certificate" target="_blank" rel="noopener">ssl_certificate</a> and <a href="http://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_certificate_key" target="_blank" rel="noopener">ssl_certificate_key</a> directives even though you will not use this static certificate and private key at all. This is because the NGINX core requires their appearance otherwise you are seeing the following error while starting NGINX:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx: [emerg] no ssl configured for the server</span><br></pre></td></tr></table></figure><p>This directive currently requires the following NGINX core patch to work correctly:</p><p><a href="http://mailman.nginx.org/pipermail/nginx-devel/2016-January/007748.html" target="_blank" rel="noopener">http://mailman.nginx.org/pipermail/nginx-devel/2016-January/007748.html</a></p><p>The bundled version of the NGINX core in OpenResty 1.9.7.2 (or above) already has this patch applied.</p><p>Furthermore, one needs at least OpenSSL 1.0.2e for this directive to work.</p><p>This directive was first introduced in the <code>v0.10.0</code> release.</p><h2><span id="ssl_certificate_by_lua_file">ssl_certificate_by_lua_file</span></h2><p><strong>syntax:</strong> <em>ssl_certificate_by_lua_file <path-to-lua-script-file></path-to-lua-script-file></em></p><p><strong>context:</strong> <em>server</em></p><p><strong>phase:</strong> <em>right-before-SSL-handshake</em></p><p>Equivalent to <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ssl_certificate_by_lua_block" target="_blank" rel="noopener">ssl_certificate_by_lua_block</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or, as from the <code>v0.5.0rc32</code> release, the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lualuajit-bytecode-support" target="_blank" rel="noopener">Lua/LuaJIT bytecode</a> to be executed.</p><p>When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p><p>This directive was first introduced in the <code>v0.10.0</code> release.</p><h2><span id="ssl_session_fetch_by_lua_block">ssl_session_fetch_by_lua_block</span></h2><p><strong>syntax:</strong> <em>ssl_session_fetch_by_lua_block { lua-script }</em></p><p><strong>context:</strong> <em>http</em></p><p><strong>phase:</strong> <em>right-before-SSL-handshake</em></p><p>This directive runs Lua code to look up and load the SSL session (if any) according to the session ID provided by the current SSL handshake request for the downstream.</p><p>The Lua API for obtaining the current session ID and loading a cached SSL session data is provided in the <a href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl/session.md" target="_blank" rel="noopener">ngx.ssl.session</a> Lua module shipped with the <a href="https://github.com/openresty/lua-resty-core#readme" target="_blank" rel="noopener">lua-resty-core</a> library.</p><p>Lua APIs that may yield, like <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsleep" target="_blank" rel="noopener">ngx.sleep</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsockettcp" target="_blank" rel="noopener">cosockets</a>, are enabled in this context.</p><p>This hook, together with the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ssl_session_store_by_lua_block" target="_blank" rel="noopener">ssl_session_store_by_lua*</a> hook, can be used to implement distributed caching mechanisms in pure Lua (based on the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsockettcp" target="_blank" rel="noopener">cosocket</a> API, for example). If a cached SSL session is found and loaded into the current SSL connection context, SSL session resumption can then get immediately initiated and bypass the full SSL handshake process which is very expensive in terms of CPU time.</p><p>Please note that TLS session tickets are very different and it is the clients’ responsibility to cache the SSL session state when session tickets are used. SSL session resumptions based on TLS session tickets would happen automatically without going through this hook (nor the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ssl_session_store_by_lua_block" target="_blank" rel="noopener">ssl_session_store_by_lua*</a> hook). This hook is mainly for older or less capable SSL clients that can only do SSL sessions by session IDs.</p><p>When <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ssl_certificate_by_lua_block" target="_blank" rel="noopener">ssl_certificate_by_lua*</a> is specified at the same time, this hook usually runs before <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ssl_certificate_by_lua_block" target="_blank" rel="noopener">ssl_certificate_by_lua*</a>. When the SSL session is found and successfully loaded for the current SSL connection, SSL session resumption will happen and thus bypass the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ssl_certificate_by_lua_block" target="_blank" rel="noopener">ssl_certificate_by_lua*</a> hook completely. In this case, NGINX also bypasses the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ssl_session_store_by_lua_block" target="_blank" rel="noopener">ssl_session_store_by_lua*</a> hook, for obvious reasons.</p><p>To easily test this hook locally with a modern web browser, you can temporarily put the following line in your https server block to disable the TLS session ticket support:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssl_session_tickets off;</span><br></pre></td></tr></table></figure><p>But do not forget to comment this line out before publishing your site to the world.</p><p>If you are using the <a href="http://openresty.org/en/linux-packages.html" target="_blank" rel="noopener">official pre-built packages</a> for <a href="https://openresty.org/" target="_blank" rel="noopener">OpenResty</a> 1.11.2.1 or later, then everything should work out of the box.</p><p>If you are using OpenSSL libraries not provided by <a href="https://openresty.org/" target="_blank" rel="noopener">OpenResty</a>, then you need to apply the following patch for OpenSSL 1.0.2h or later:</p><p><a href="https://github.com/openresty/openresty/blob/master/patches/openssl-1.0.2h-sess_set_get_cb_yield.patch" target="_blank" rel="noopener">https://github.com/openresty/openresty/blob/master/patches/openssl-1.0.2h-sess_set_get_cb_yield.patch</a></p><p>If you are not using the NGINX core shipped with <a href="https://openresty.org/" target="_blank" rel="noopener">OpenResty</a> 1.11.2.1 or later, then you need to apply the following patch to the standard NGINX core 1.11.2 or later:</p><p><a href="http://openresty.org/download/nginx-1.11.2-nonblocking_ssl_handshake_hooks.patch" target="_blank" rel="noopener">http://openresty.org/download/nginx-1.11.2-nonblocking_ssl_handshake_hooks.patch</a></p><p>This directive was first introduced in the <code>v0.10.6</code> release.</p><p>Note that: this directive is only allowed to used in <strong>http context</strong> from the <code>v0.10.7</code> release (because SSL session resumption happens before server name dispatch).</p><h2><span id="ssl_session_fetch_by_lua_file">ssl_session_fetch_by_lua_file</span></h2><p><strong>syntax:</strong> <em>ssl_session_fetch_by_lua_file <path-to-lua-script-file></path-to-lua-script-file></em></p><p><strong>context:</strong> <em>http</em></p><p><strong>phase:</strong> <em>right-before-SSL-handshake</em></p><p>Equivalent to <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ssl_session_fetch_by_lua_block" target="_blank" rel="noopener">ssl_session_fetch_by_lua_block</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or rather, the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lualuajit-bytecode-support" target="_blank" rel="noopener">Lua/LuaJIT bytecode</a> to be executed.</p><p>When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p><p>This directive was first introduced in the <code>v0.10.6</code> release.</p><p>Note that: this directive is only allowed to used in <strong>http context</strong> from the <code>v0.10.7</code> release (because SSL session resumption happens before server name dispatch).</p><h2><span id="ssl_session_store_by_lua_block">ssl_session_store_by_lua_block</span></h2><p><strong>syntax:</strong> <em>ssl_session_store_by_lua_block { lua-script }</em></p><p><strong>context:</strong> <em>http</em></p><p><strong>phase:</strong> <em>right-after-SSL-handshake</em></p><p>This directive runs Lua code to fetch and save the SSL session (if any) according to the session ID provided by the current SSL handshake request for the downstream. The saved or cached SSL session data can be used for future SSL connections to resume SSL sessions without going through the full SSL handshake process (which is very expensive in terms of CPU time).</p><p>Lua APIs that may yield, like <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsleep" target="_blank" rel="noopener">ngx.sleep</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsockettcp" target="_blank" rel="noopener">cosockets</a>, are <em>disabled</em> in this context. You can still, however, use the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxtimerat" target="_blank" rel="noopener">ngx.timer.at</a>API to create 0-delay timers to save the SSL session data asynchronously to external services (like <code>redis</code> or <code>memcached</code>).</p><p>The Lua API for obtaining the current session ID and the associated session state data is provided in the <a href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl/session.md#readme" target="_blank" rel="noopener">ngx.ssl.session</a> Lua module shipped with the <a href="https://github.com/openresty/lua-resty-core#readme" target="_blank" rel="noopener">lua-resty-core</a> library.</p><p>To easily test this hook locally with a modern web browser, you can temporarily put the following line in your https server block to disable the TLS session ticket support:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssl_session_tickets off;</span><br></pre></td></tr></table></figure><p>But do not forget to comment this line out before publishing your site to the world.</p><p>This directive was first introduced in the <code>v0.10.6</code> release.</p><p>Note that: this directive is only allowed to used in <strong>http context</strong> from the <code>v0.10.7</code> release (because SSL session resumption happens before server name dispatch).</p><h2><span id="ssl_session_store_by_lua_file">ssl_session_store_by_lua_file</span></h2><p><strong>syntax:</strong> <em>ssl_session_store_by_lua_file <path-to-lua-script-file></path-to-lua-script-file></em></p><p><strong>context:</strong> <em>http</em></p><p><strong>phase:</strong> <em>right-after-SSL-handshake</em></p><p>Equivalent to <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ssl_session_store_by_lua_block" target="_blank" rel="noopener">ssl_session_store_by_lua_block</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or rather, the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lualuajit-bytecode-support" target="_blank" rel="noopener">Lua/LuaJIT bytecode</a> to be executed.</p><p>When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p><p>This directive was first introduced in the <code>v0.10.6</code> release.</p><p>Note that: this directive is only allowed to used in <strong>http context</strong> from the <code>v0.10.7</code> release (because SSL session resumption happens before server name dispatch).</p><h2><span id="lua_shared_dict">lua_shared_dict</span></h2><p><strong>syntax:</strong> <em>lua_shared_dict <name> <size></size></name></em></p><p><strong>default:</strong> <em>no</em></p><p><strong>context:</strong> <em>http</em></p><p><strong>phase:</strong> <em>depends on usage</em></p><p>Declares a shared memory zone, <code>&lt;name&gt;</code>, to serve as storage for the shm based Lua dictionary <code>ngx.shared.&lt;name&gt;</code>.</p><p>Shared memory zones are always shared by all the nginx worker processes in the current nginx server instance.</p><p>The <code>&lt;size&gt;</code> argument accepts size units such as <code>k</code> and <code>m</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    lua_shared_dict dogs 10m;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The hard-coded minimum size is 8KB while the practical minimum size depends on actual user data set (some people start with 12KB).</p><p>See <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxshareddict" target="_blank" rel="noopener">ngx.shared.DICT</a> for details.</p><p>This directive was first introduced in the <code>v0.3.1rc22</code> release.</p><h2><span id="lua_socket_connect_timeout">lua_socket_connect_timeout</span></h2><p><strong>syntax:</strong> <em>lua_socket_connect_timeout <time></time></em></p><p><strong>default:</strong> <em>lua_socket_connect_timeout 60s</em></p><p><strong>context:</strong> <em>http, server, location</em></p><p>This directive controls the default timeout value used in TCP/unix-domain socket object’s <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#tcpsockconnect" target="_blank" rel="noopener">connect</a> method and can be overridden by the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#tcpsocksettimeout" target="_blank" rel="noopener">settimeout</a> or <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#tcpsocksettimeouts" target="_blank" rel="noopener">settimeouts</a> methods.</p><p>The <code>&lt;time&gt;</code> argument can be an integer, with an optional time unit, like <code>s</code> (second), <code>ms</code> (millisecond), <code>m</code> (minute). The default time unit is <code>s</code>, i.e., “second”. The default setting is <code>60s</code>.</p><p>This directive was first introduced in the <code>v0.5.0rc1</code> release.</p><h2><span id="lua_socket_send_timeout">lua_socket_send_timeout</span></h2><p><strong>syntax:</strong> <em>lua_socket_send_timeout <time></time></em></p><p><strong>default:</strong> <em>lua_socket_send_timeout 60s</em></p><p><strong>context:</strong> <em>http, server, location</em></p><p>Controls the default timeout value used in TCP/unix-domain socket object’s <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#tcpsocksend" target="_blank" rel="noopener">send</a> method and can be overridden by the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#tcpsocksettimeout" target="_blank" rel="noopener">settimeout</a> or <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#tcpsocksettimeouts" target="_blank" rel="noopener">settimeouts</a> methods.</p><p>The <code>&lt;time&gt;</code> argument can be an integer, with an optional time unit, like <code>s</code> (second), <code>ms</code> (millisecond), <code>m</code> (minute). The default time unit is <code>s</code>, i.e., “second”. The default setting is <code>60s</code>.</p><p>This directive was first introduced in the <code>v0.5.0rc1</code> release.</p><h2><span id="lua_socket_send_lowat">lua_socket_send_lowat</span></h2><p><strong>syntax:</strong> <em>lua_socket_send_lowat <size></size></em></p><p><strong>default:</strong> <em>lua_socket_send_lowat 0</em></p><p><strong>context:</strong> <em>http, server, location</em></p><p>Controls the <code>lowat</code> (low water) value for the cosocket send buffer.</p><h2><span id="lua_socket_read_timeout">lua_socket_read_timeout</span></h2><p><strong>syntax:</strong> <em>lua_socket_read_timeout <time></time></em></p><p><strong>default:</strong> <em>lua_socket_read_timeout 60s</em></p><p><strong>context:</strong> <em>http, server, location</em></p><p><strong>phase:</strong> <em>depends on usage</em></p><p>This directive controls the default timeout value used in TCP/unix-domain socket object’s <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#tcpsockreceive" target="_blank" rel="noopener">receive</a> method and iterator functions returned by the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#tcpsockreceiveuntil" target="_blank" rel="noopener">receiveuntil</a> method. This setting can be overridden by the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#tcpsocksettimeout" target="_blank" rel="noopener">settimeout</a> or <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#tcpsocksettimeouts" target="_blank" rel="noopener">settimeouts</a> methods.</p><p>The <code>&lt;time&gt;</code> argument can be an integer, with an optional time unit, like <code>s</code> (second), <code>ms</code> (millisecond), <code>m</code> (minute). The default time unit is <code>s</code>, i.e., “second”. The default setting is <code>60s</code>.</p><p>This directive was first introduced in the <code>v0.5.0rc1</code> release.</p><h2><span id="lua_socket_buffer_size">lua_socket_buffer_size</span></h2><p><strong>syntax:</strong> <em>lua_socket_buffer_size <size></size></em></p><p><strong>default:</strong> <em>lua_socket_buffer_size 4k/8k</em></p><p><strong>context:</strong> <em>http, server, location</em></p><p>Specifies the buffer size used by cosocket reading operations.</p><p>This buffer does not have to be that big to hold everything at the same time because cosocket supports 100% non-buffered reading and parsing. So even <code>1</code> byte buffer size should still work everywhere but the performance could be terrible.</p><p>This directive was first introduced in the <code>v0.5.0rc1</code> release.</p><h2><span id="lua_socket_pool_size">lua_socket_pool_size</span></h2><p><strong>syntax:</strong> <em>lua_socket_pool_size <size></size></em></p><p><strong>default:</strong> <em>lua_socket_pool_size 30</em></p><p><strong>context:</strong> <em>http, server, location</em></p><p>Specifies the size limit (in terms of connection count) for every cosocket connection pool associated with every remote server (i.e., identified by either the host-port pair or the unix domain socket file path).</p><p>Default to 30 connections for every pool.</p><p>When the connection pool exceeds the available size limit, the least recently used (idle) connection already in the pool will be closed to make room for the current connection.</p><p>Note that the cosocket connection pool is per nginx worker process rather than per nginx server instance, so size limit specified here also applies to every single nginx worker process.</p><p>This directive was first introduced in the <code>v0.5.0rc1</code> release.</p><h2><span id="lua_socket_keepalive_timeout">lua_socket_keepalive_timeout</span></h2><p><strong>syntax:</strong> <em>lua_socket_keepalive_timeout <time></time></em></p><p><strong>default:</strong> <em>lua_socket_keepalive_timeout 60s</em></p><p><strong>context:</strong> <em>http, server, location</em></p><p>This directive controls the default maximal idle time of the connections in the cosocket built-in connection pool. When this timeout reaches, idle connections will be closed and removed from the pool. This setting can be overridden by cosocket objects’ <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#tcpsocksetkeepalive" target="_blank" rel="noopener">setkeepalive</a> method.</p><p>The <code>&lt;time&gt;</code> argument can be an integer, with an optional time unit, like <code>s</code> (second), <code>ms</code> (millisecond), <code>m</code> (minute). The default time unit is <code>s</code>, i.e., “second”. The default setting is <code>60s</code>.</p><p>This directive was first introduced in the <code>v0.5.0rc1</code> release.</p><h2><span id="lua_socket_log_errors">lua_socket_log_errors</span></h2><p><strong>syntax:</strong> <em>lua_socket_log_errors on|off</em></p><p><strong>default:</strong> <em>lua_socket_log_errors on</em></p><p><strong>context:</strong> <em>http, server, location</em></p><p>This directive can be used to toggle error logging when a failure occurs for the TCP or UDP cosockets. If you are already doing proper error handling and logging in your Lua code, then it is recommended to turn this directive off to prevent data flushing in your nginx error log files (which is usually rather expensive).</p><p>This directive was first introduced in the <code>v0.5.13</code> release.</p><h2><span id="lua_ssl_ciphers">lua_ssl_ciphers</span></h2><p><strong>syntax:</strong> <em>lua_ssl_ciphers <ciphers></ciphers></em></p><p><strong>default:</strong> <em>lua_ssl_ciphers DEFAULT</em></p><p><strong>context:</strong> <em>http, server, location</em></p><p>Specifies the enabled ciphers for requests to a SSL/TLS server in the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#tcpsocksslhandshake" target="_blank" rel="noopener">tcpsock:sslhandshake</a> method. The ciphers are specified in the format understood by the OpenSSL library.</p><p>The full list can be viewed using the “openssl ciphers” command.</p><p>This directive was first introduced in the <code>v0.9.11</code> release.</p><h2><span id="lua_ssl_crl">lua_ssl_crl</span></h2><p><strong>syntax:</strong> <em>lua_ssl_crl <file></file></em></p><p><strong>default:</strong> <em>no</em></p><p><strong>context:</strong> <em>http, server, location</em></p><p>Specifies a file with revoked certificates (CRL) in the PEM format used to verify the certificate of the SSL/TLS server in the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#tcpsocksslhandshake" target="_blank" rel="noopener">tcpsock:sslhandshake</a> method.</p><p>This directive was first introduced in the <code>v0.9.11</code> release.</p><h2><span id="lua_ssl_protocols">lua_ssl_protocols</span></h2><p><strong>syntax:</strong> <em>lua_ssl_protocols [SSLv2] [SSLv3] [TLSv1] [TLSv1.1] [TLSv1.2] [TLSv1.3]</em></p><p><strong>default:</strong> <em>lua_ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2</em></p><p><strong>context:</strong> <em>http, server, location</em></p><p>Enables the specified protocols for requests to a SSL/TLS server in the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#tcpsocksslhandshake" target="_blank" rel="noopener">tcpsock:sslhandshake</a> method.</p><p>The support for the <code>TLSv1.3</code> parameter requires version <code>v0.10.12</code> <em>and</em> OpenSSL 1.1.1.</p><p>This directive was first introduced in the <code>v0.9.11</code> release.</p><h2><span id="lua_ssl_trusted_certificate">lua_ssl_trusted_certificate</span></h2><p><strong>syntax:</strong> <em>lua_ssl_trusted_certificate <file></file></em></p><p><strong>default:</strong> <em>no</em></p><p><strong>context:</strong> <em>http, server, location</em></p><p>Specifies a file path with trusted CA certificates in the PEM format used to verify the certificate of the SSL/TLS server in the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#tcpsocksslhandshake" target="_blank" rel="noopener">tcpsock:sslhandshake</a> method.</p><p>This directive was first introduced in the <code>v0.9.11</code> release.</p><p>See also <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lua_ssl_verify_depth" target="_blank" rel="noopener">lua_ssl_verify_depth</a>.</p><h2><span id="lua_ssl_verify_depth">lua_ssl_verify_depth</span></h2><p><strong>syntax:</strong> <em>lua_ssl_verify_depth <number></number></em></p><p><strong>default:</strong> <em>lua_ssl_verify_depth 1</em></p><p><strong>context:</strong> <em>http, server, location</em></p><p>Sets the verification depth in the server certificates chain.</p><p>This directive was first introduced in the <code>v0.9.11</code> release.</p><p>See also <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lua_ssl_trusted_certificate" target="_blank" rel="noopener">lua_ssl_trusted_certificate</a>.</p><h2><span id="lua_http10_buffering">lua_http10_buffering</span></h2><p><strong>syntax:</strong> <em>lua_http10_buffering on|off</em></p><p><strong>default:</strong> <em>lua_http10_buffering on</em></p><p><strong>context:</strong> <em>http, server, location, location-if</em></p><p>Enables or disables automatic response buffering for HTTP 1.0 (or older) requests. This buffering mechanism is mainly used for HTTP 1.0 keep-alive which relies on a proper <code>Content-Length</code> response header.</p><p>If the Lua code explicitly sets a <code>Content-Length</code> response header before sending the headers (either explicitly via <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsend_headers" target="_blank" rel="noopener">ngx.send_headers</a> or implicitly via the first <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsay" target="_blank" rel="noopener">ngx.say</a> or <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxprint" target="_blank" rel="noopener">ngx.print</a> call), then the HTTP 1.0 response buffering will be disabled even when this directive is turned on.</p><p>To output very large response data in a streaming fashion (via the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxflush" target="_blank" rel="noopener">ngx.flush</a> call, for example), this directive MUST be turned off to minimize memory usage.</p><p>This directive is turned <code>on</code> by default.</p><p>This directive was first introduced in the <code>v0.5.0rc19</code> release.</p><h2><span id="rewrite_by_lua_no_postpone">rewrite_by_lua_no_postpone</span></h2><p><strong>syntax:</strong> <em>rewrite_by_lua_no_postpone on|off</em></p><p><strong>default:</strong> <em>rewrite_by_lua_no_postpone off</em></p><p><strong>context:</strong> <em>http</em></p><p>Controls whether or not to disable postponing <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#rewrite_by_lua" target="_blank" rel="noopener">rewrite_by_lua*</a> directives to run at the end of the <code>rewrite</code> request-processing phase. By default, this directive is turned off and the Lua code is postponed to run at the end of the <code>rewrite</code> phase.</p><p>This directive was first introduced in the <code>v0.5.0rc29</code> release.</p><h2><span id="access_by_lua_no_postpone">access_by_lua_no_postpone</span></h2><p><strong>syntax:</strong> <em>access_by_lua_no_postpone on|off</em></p><p><strong>default:</strong> <em>access_by_lua_no_postpone off</em></p><p><strong>context:</strong> <em>http</em></p><p>Controls whether or not to disable postponing <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#access_by_lua" target="_blank" rel="noopener">access_by_lua*</a> directives to run at the end of the <code>access</code> request-processing phase. By default, this directive is turned off and the Lua code is postponed to run at the end of the <code>access</code> phase.</p><p>This directive was first introduced in the <code>v0.9.20</code> release.</p><h2><span id="lua_transform_underscores_in_response_headers">lua_transform_underscores_in_response_headers</span></h2><p><strong>syntax:</strong> <em>lua_transform_underscores_in_response_headers on|off</em></p><p><strong>default:</strong> <em>lua_transform_underscores_in_response_headers on</em></p><p><strong>context:</strong> <em>http, server, location, location-if</em></p><p>Controls whether to transform underscores (<code>_</code>) in the response header names specified in the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxheaderheader" target="_blank" rel="noopener">ngx.header.HEADER</a> API to hypens (<code>-</code>).</p><p>This directive was first introduced in the <code>v0.5.0rc32</code> release.</p><h2><span id="lua_check_client_abort">lua_check_client_abort</span></h2><p><strong>syntax:</strong> <em>lua_check_client_abort on|off</em></p><p><strong>default:</strong> <em>lua_check_client_abort off</em></p><p><strong>context:</strong> <em>http, server, location, location-if</em></p><p>This directive controls whether to check for premature client connection abortion.</p><p>When this directive is on, the ngx_lua module will monitor the premature connection close event on the downstream connections and when there is such an event, it will call the user Lua function callback (registered by <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxon_abort" target="_blank" rel="noopener">ngx.on_abort</a>) or just stop and clean up all the Lua “light threads” running in the current request’s request handler when there is no user callback function registered.</p><p>According to the current implementation, however, if the client closes the connection before the Lua code finishes reading the request body data via <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxreqsocket" target="_blank" rel="noopener">ngx.req.socket</a>, then ngx_lua will neither stop all the running “light threads” nor call the user callback (if <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxon_abort" target="_blank" rel="noopener">ngx.on_abort</a> has been called). Instead, the reading operation on <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxreqsocket" target="_blank" rel="noopener">ngx.req.socket</a> will just return the error message “client aborted” as the second return value (the first return value is surely <code>nil</code>).</p><p>When TCP keepalive is disabled, it is relying on the client side to close the socket gracefully (by sending a <code>FIN</code> packet or something like that). For (soft) real-time web applications, it is highly recommended to configure the <a href="http://tldp.org/HOWTO/TCP-Keepalive-HOWTO/overview.html" target="_blank" rel="noopener">TCP keepalive</a> support in your system’s TCP stack implementation in order to detect “half-open” TCP connections in time.</p><p>For example, on Linux, you can configure the standard <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#listen" target="_blank" rel="noopener">listen</a> directive in your <code>nginx.conf</code> file like this:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listen 80 so_keepalive=2s:2s:8;</span><br></pre></td></tr></table></figure><p>On FreeBSD, you can only tune the system-wide configuration for TCP keepalive, for example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># sysctl net.inet.tcp.keepintvl=2000</span><br><span class="line"># sysctl net.inet.tcp.keepidle=2000</span><br></pre></td></tr></table></figure><p>This directive was first introduced in the <code>v0.7.4</code> release.</p><p>See also <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxon_abort" target="_blank" rel="noopener">ngx.on_abort</a>.</p><h2><span id="lua_max_pending_timers">lua_max_pending_timers</span></h2><p><strong>syntax:</strong> <em>lua_max_pending_timers <count></count></em></p><p><strong>default:</strong> <em>lua_max_pending_timers 1024</em></p><p><strong>context:</strong> <em>http</em></p><p>Controls the maximum number of pending timers allowed.</p><p>Pending timers are those timers that have not expired yet.</p><p>When exceeding this limit, the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxtimerat" target="_blank" rel="noopener">ngx.timer.at</a> call will immediately return <code>nil</code> and the error string “too many pending timers”.</p><p>This directive was first introduced in the <code>v0.8.0</code> release.</p><h2><span id="lua_max_running_timers">lua_max_running_timers</span></h2><p><strong>syntax:</strong> <em>lua_max_running_timers <count></count></em></p><p><strong>default:</strong> <em>lua_max_running_timers 256</em></p><p><strong>context:</strong> <em>http</em></p><p>Controls the maximum number of “running timers” allowed.</p><p>Running timers are those timers whose user callback functions are still running.</p><p>When exceeding this limit, Nginx will stop running the callbacks of newly expired timers and log an error message “N lua_max_running_timers are not enough” where “N” is the current value of this directive.</p><p>This directive was first introduced in the <code>v0.8.0</code> release.</p><h2><span id="lua_sa_restart">lua_sa_restart</span></h2><p><strong>syntax:</strong> <em>lua_sa_restart on|off</em></p><p><strong>default:</strong> <em>lua_sa_restart on</em></p><p><strong>context:</strong> <em>http</em></p><p>When enabled, this module will set the <code>SA_RESTART</code> flag on nginx workers signal dispositions.</p><p>This allows Lua I/O primitives to not be interrupted by nginx’s handling of various signals.</p><p>This directive was first introduced in the <code>v0.10.14</code> release</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#nginx-directives-for-lua&quot;&gt;Nginx Directives For Lua&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#lua_capture_error_log&quot;&gt;lua_capture_
      
    
    </summary>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>nginx-lua-API</title>
    <link href="http://yoursite.com/2018/03/01/nginx-lua-API/"/>
    <id>http://yoursite.com/2018/03/01/nginx-lua-API/</id>
    <published>2018-03-01T04:17:54.000Z</published>
    <updated>2019-03-01T06:26:12.196Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#nginx-api-for-lua">Nginx API for Lua</a><ul><li><a href="#introduction">Introduction</a></li><li><a href="#ngxarg">ngx.arg</a></li><li><a href="#ngxvarvariable">ngx.var.VARIABLE</a></li><li><a href="#core-constants">Core constants</a></li><li><a href="#http-method-constants">HTTP method constants</a></li><li><a href="#http-status-constants">HTTP status constants</a></li><li><a href="#nginx-log-level-constants">Nginx log level constants</a></li><li><a href="#print">print</a></li><li><a href="#ngxctx">ngx.ctx</a></li><li><a href="#ngxlocationcapture">ngx.location.capture</a></li><li><a href="#ngxlocationcapture_multi">ngx.location.capture_multi</a></li><li><a href="#ngxstatus">ngx.status</a></li><li><a href="#ngxheaderheader">ngx.header.HEADER</a></li><li><a href="#ngxrespget_headers">ngx.resp.get_headers</a></li><li><a href="#ngxreqis_internal">ngx.req.is_internal</a></li><li><a href="#ngxreqstart_time">ngx.req.start_time</a></li><li><a href="#ngxreqhttp_version">ngx.req.http_version</a></li><li><a href="#ngxreqraw_header">ngx.req.raw_header</a></li><li><a href="#ngxreqget_method">ngx.req.get_method</a></li><li><a href="#ngxreqset_method">ngx.req.set_method</a></li><li><a href="#ngxreqset_uri">ngx.req.set_uri</a></li><li><a href="#ngxreqset_uri_args">ngx.req.set_uri_args</a></li><li><a href="#ngxreqget_uri_args">ngx.req.get_uri_args</a></li><li><a href="#ngxreqget_post_args">ngx.req.get_post_args</a></li><li><a href="#ngxreqget_headers">ngx.req.get_headers</a></li><li><a href="#ngxreqset_header">ngx.req.set_header</a></li><li><a href="#ngxreqclear_header">ngx.req.clear_header</a></li><li><a href="#ngxreqread_body">ngx.req.read_body</a></li><li><a href="#ngxreqdiscard_body">ngx.req.discard_body</a></li><li><a href="#ngxreqget_body_data">ngx.req.get_body_data</a></li><li><a href="#ngxreqget_body_file">ngx.req.get_body_file</a></li><li><a href="#ngxreqset_body_data">ngx.req.set_body_data</a></li><li><a href="#ngxreqset_body_file">ngx.req.set_body_file</a></li><li><a href="#ngxreqinit_body">ngx.req.init_body</a></li><li><a href="#ngxreqappend_body">ngx.req.append_body</a></li><li><a href="#ngxreqfinish_body">ngx.req.finish_body</a></li><li><a href="#ngxreqsocket">ngx.req.socket</a></li><li><a href="#ngxexec">ngx.exec</a></li><li><a href="#ngxredirect">ngx.redirect</a></li><li><a href="#ngxsend_headers">ngx.send_headers</a></li><li><a href="#ngxheaders_sent">ngx.headers_sent</a></li><li><a href="#ngxprint">ngx.print</a></li><li><a href="#ngxsay">ngx.say</a></li><li><a href="#ngxlog">ngx.log</a></li><li><a href="#ngxflush">ngx.flush</a></li><li><a href="#ngxexit">ngx.exit</a></li><li><a href="#ngxeof">ngx.eof</a></li><li><a href="#ngxsleep">ngx.sleep</a></li><li><a href="#ngxescape_uri">ngx.escape_uri</a></li><li><a href="#ngxunescape_uri">ngx.unescape_uri</a></li><li><a href="#ngxencode_args">ngx.encode_args</a></li><li><a href="#ngxdecode_args">ngx.decode_args</a></li><li><a href="#ngxencode_base64">ngx.encode_base64</a></li><li><a href="#ngxdecode_base64">ngx.decode_base64</a></li><li><a href="#ngxcrc32_short">ngx.crc32_short</a></li><li><a href="#ngxcrc32_long">ngx.crc32_long</a></li><li><a href="#ngxhmac_sha1">ngx.hmac_sha1</a></li><li><a href="#ngxmd5">ngx.md5</a></li><li><a href="#ngxmd5_bin">ngx.md5_bin</a></li><li><a href="#ngxsha1_bin">ngx.sha1_bin</a></li><li><a href="#ngxquote_sql_str">ngx.quote_sql_str</a></li><li><a href="#ngxtoday">ngx.today</a></li><li><a href="#ngxtime">ngx.time</a></li><li><a href="#ngxnow">ngx.now</a></li><li><a href="#ngxupdate_time">ngx.update_time</a></li><li><a href="#ngxlocaltime">ngx.localtime</a></li><li><a href="#ngxutctime">ngx.utctime</a></li><li><a href="#ngxcookie_time">ngx.cookie_time</a></li><li><a href="#ngxhttp_time">ngx.http_time</a></li><li><a href="#ngxparse_http_time">ngx.parse_http_time</a></li><li><a href="#ngxis_subrequest">ngx.is_subrequest</a></li><li><a href="#ngxrematch">ngx.re.match</a></li><li><a href="#ngxrefind">ngx.re.find</a></li><li><a href="#ngxregmatch">ngx.re.gmatch</a></li><li><a href="#ngxresub">ngx.re.sub</a></li><li><a href="#ngxregsub">ngx.re.gsub</a></li><li><a href="#ngxshareddict">ngx.shared.DICT</a></li><li><a href="#ngxshareddictget">ngx.shared.DICT.get</a></li><li><a href="#ngxshareddictget_stale">ngx.shared.DICT.get_stale</a></li><li><a href="#ngxshareddictset">ngx.shared.DICT.set</a></li><li><a href="#ngxshareddictsafe_set">ngx.shared.DICT.safe_set</a></li><li><a href="#ngxshareddictadd">ngx.shared.DICT.add</a></li><li><a href="#ngxshareddictsafe_add">ngx.shared.DICT.safe_add</a></li><li><a href="#ngxshareddictreplace">ngx.shared.DICT.replace</a></li><li><a href="#ngxshareddictdelete">ngx.shared.DICT.delete</a></li><li><a href="#ngxshareddictincr">ngx.shared.DICT.incr</a></li><li><a href="#ngxshareddictlpush">ngx.shared.DICT.lpush</a></li><li><a href="#ngxshareddictrpush">ngx.shared.DICT.rpush</a></li><li><a href="#ngxshareddictlpop">ngx.shared.DICT.lpop</a></li><li><a href="#ngxshareddictrpop">ngx.shared.DICT.rpop</a></li><li><a href="#ngxshareddictllen">ngx.shared.DICT.llen</a></li><li><a href="#ngxshareddictttl">ngx.shared.DICT.ttl</a></li><li><a href="#ngxshareddictexpire">ngx.shared.DICT.expire</a></li><li><a href="#ngxshareddictflush_all">ngx.shared.DICT.flush_all</a></li><li><a href="#ngxshareddictflush_expired">ngx.shared.DICT.flush_expired</a></li><li><a href="#ngxshareddictget_keys">ngx.shared.DICT.get_keys</a></li><li><a href="#ngxshareddictcapacity">ngx.shared.DICT.capacity</a></li><li><a href="#ngxshareddictfree_space">ngx.shared.DICT.free_space</a></li><li><a href="#ngxsocketudp">ngx.socket.udp</a></li><li><a href="#udpsocksetpeername">udpsock:setpeername</a></li><li><a href="#udpsocksend">udpsock:send</a></li><li><a href="#udpsockreceive">udpsock:receive</a></li><li><a href="#udpsockclose">udpsock:close</a></li><li><a href="#udpsocksettimeout">udpsock:settimeout</a></li><li><a href="#ngxsocketstream">ngx.socket.stream</a></li><li><a href="#ngxsockettcp">ngx.socket.tcp</a></li><li><a href="#tcpsockconnect">tcpsock:connect</a></li><li><a href="#tcpsocksslhandshake">tcpsock:sslhandshake</a></li><li><a href="#tcpsocksend">tcpsock:send</a></li><li><a href="#tcpsockreceive">tcpsock:receive</a></li><li><a href="#tcpsockreceiveany">tcpsock:receiveany</a></li><li><a href="#tcpsockreceiveuntil">tcpsock:receiveuntil</a></li><li><a href="#tcpsockclose">tcpsock:close</a></li><li><a href="#tcpsocksettimeout">tcpsock:settimeout</a></li><li><a href="#tcpsocksettimeouts">tcpsock:settimeouts</a></li><li><a href="#tcpsocksetoption">tcpsock:setoption</a></li><li><a href="#tcpsocksetkeepalive">tcpsock:setkeepalive</a></li><li><a href="#tcpsockgetreusedtimes">tcpsock:getreusedtimes</a></li><li><a href="#ngxsocketconnect">ngx.socket.connect</a></li><li><a href="#ngxget_phase">ngx.get_phase</a></li><li><a href="#ngxthreadspawn">ngx.thread.spawn</a></li><li><a href="#ngxthreadwait">ngx.thread.wait</a></li><li><a href="#ngxthreadkill">ngx.thread.kill</a></li><li><a href="#ngxon_abort">ngx.on_abort</a></li><li><a href="#ngxtimerat">ngx.timer.at</a></li><li><a href="#ngxtimerevery">ngx.timer.every</a></li><li><a href="#ngxtimerrunning_count">ngx.timer.running_count</a></li><li><a href="#ngxtimerpending_count">ngx.timer.pending_count</a></li><li><a href="#ngxconfigsubsystem">ngx.config.subsystem</a></li><li><a href="#ngxconfigdebug">ngx.config.debug</a></li><li><a href="#ngxconfigprefix">ngx.config.prefix</a></li><li><a href="#ngxconfignginx_version">ngx.config.nginx_version</a></li><li><a href="#ngxconfignginx_configure">ngx.config.nginx_configure</a></li><li><a href="#ngxconfigngx_lua_version">ngx.config.ngx_lua_version</a></li><li><a href="#ngxworkerexiting">ngx.worker.exiting</a></li><li><a href="#ngxworkerpid">ngx.worker.pid</a></li><li><a href="#ngxworkercount">ngx.worker.count</a></li><li><a href="#ngxworkerid">ngx.worker.id</a></li><li><a href="#ngxsemaphore">ngx.semaphore</a></li><li><a href="#ngxbalancer">ngx.balancer</a></li><li><a href="#ngxssl">ngx.ssl</a></li><li><a href="#ngxocsp">ngx.ocsp</a></li><li><a href="#ndkset_vardirective">ndk.set_var.DIRECTIVE</a></li><li><a href="#coroutinecreate">coroutine.create</a></li><li><a href="#coroutineresume">coroutine.resume</a></li><li><a href="#coroutineyield">coroutine.yield</a></li><li><a href="#coroutinewrap">coroutine.wrap</a></li><li><a href="#coroutinerunning">coroutine.running</a></li><li><a href="#coroutinestatus">coroutine.status</a></li></ul></li></ul><!-- tocstop --><p>本文是GitHub上nginx-lua-module自述文档的一部分，详细列举说明了OpenResty所有的Lua API。</p><p>放到这里，方便查阅。</p><h1><span id="nginx-api-for-lua">Nginx API for Lua</span></h1><h2><span id="introduction">Introduction</span></h2><p>The various <code>*_by_lua</code>, <code>*_by_lua_block</code> and <code>*_by_lua_file</code> configuration directives serve as gateways to the Lua API within the <code>nginx.conf</code> file. The Nginx Lua API described below can only be called within the user Lua code run in the context of these configuration directives.</p><p>The API is exposed to Lua in the form of two standard packages <code>ngx</code> and <code>ndk</code>. These packages are in the default global scope within ngx_lua and are always available within ngx_lua directives.</p><p>The packages can be introduced into external Lua modules like this:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">local say = ngx.say</span><br><span class="line"></span><br><span class="line">local _M = &#123;&#125;</span><br><span class="line"></span><br><span class="line">function _M.foo(a)</span><br><span class="line">    say(a)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">return _M</span><br></pre></td></tr></table></figure><p>Use of the <a href="http://www.lua.org/manual/5.1/manual.html#pdf-package.seeall" target="_blank" rel="noopener">package.seeall</a> flag is strongly discouraged due to its various bad side-effects.</p><p>It is also possible to directly require the packages in external Lua modules:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local ngx = require &quot;ngx&quot;</span><br><span class="line">local ndk = require &quot;ndk&quot;</span><br></pre></td></tr></table></figure><p>The ability to require these packages was introduced in the <code>v0.2.1rc19</code> release.</p><p>Network I/O operations in user code should only be done through the Nginx Lua API calls as the Nginx event loop may be blocked and performance drop off dramatically otherwise. Disk operations with relatively small amount of data can be done using the standard Lua <code>io</code> library but huge file reading and writing should be avoided wherever possible as they may block the Nginx process significantly. Delegating all network and disk I/O operations to Nginx’s subrequests (via the [ngx.location.capture]</p><h2><span id="ngxarg">ngx.arg</span></h2><p><strong>syntax:</strong> <em>val = ngx.arg[index]</em></p><p><strong>context:</strong> set_by_lua*, body_filter_by_lua*</p><p>When this is used in the context of the [set_by_lua*]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value = ngx.arg[n]</span><br></pre></td></tr></table></figure><p>Here is an example</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">location /foo &#123;</span><br><span class="line">    set $a 32;</span><br><span class="line">    set $b 56;</span><br><span class="line"></span><br><span class="line">    set_by_lua $sum</span><br><span class="line">        &apos;return tonumber(ngx.arg[1]) + tonumber(ngx.arg[2])&apos;</span><br><span class="line">        $a $b;</span><br><span class="line"></span><br><span class="line">    echo $sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>that writes out <code>88</code>, the sum of <code>32</code> and <code>56</code>.</p><p>When this table is used in the context of [body_filter_by_lua*]</p><p>The data chunk and “eof” flag passed to the downstream Nginx output filters can also be overridden by assigning values directly to the corresponding table elements. When setting <code>nil</code> or an empty Lua string value to <code>ngx.arg[1]</code>, no data chunk will be passed to the downstream Nginx output filters at all.</p><h2><span id="ngxvarvariable">ngx.var.VARIABLE</span></h2><p><strong>syntax:</strong> <em>ngx.var.VAR_NAME</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*</p><p>Read and write Nginx variable values.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value = ngx.var.some_nginx_variable_name</span><br><span class="line">ngx.var.some_nginx_variable_name = value</span><br></pre></td></tr></table></figure><p>Note that only already defined nginx variables can be written to. For example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location /foo &#123;</span><br><span class="line">    set $my_var &apos;&apos;; # this line is required to create $my_var at config time</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        ngx.var.my_var = 123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>That is, nginx variables cannot be created on-the-fly.</p><p>Some special nginx variables like <code>$args</code> and <code>$limit_rate</code> can be assigned a value, many others are not, like <code>$query_string</code>, <code>$arg_PARAMETER</code>, and <code>$http_NAME</code>.</p><p>Nginx regex group capturing variables <code>$1</code>, <code>$2</code>, <code>$3</code>, and etc, can be read by this interface as well, by writing <code>ngx.var[1]</code>, <code>ngx.var[2]</code>, <code>ngx.var[3]</code>, and etc.</p><p>Setting <code>ngx.var.Foo</code> to a <code>nil</code> value will unset the <code>$Foo</code> Nginx variable.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.var.args = nil</span><br></pre></td></tr></table></figure><p><strong>CAUTION</strong> When reading from an Nginx variable, Nginx will allocate memory in the per-request memory pool which is freed only at request termination. So when you need to read from an Nginx variable repeatedly in your Lua code, cache the Nginx variable value to your own Lua variable, for example,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local val = ngx.var.some_var</span><br><span class="line">--- use the val repeatedly later</span><br></pre></td></tr></table></figure><p>to prevent (temporary) memory leaking within the current request’s lifetime. Another way of caching the result is to use the [ngx.ctx]</p><p>Undefined NGINX variables are evaluated to <code>nil</code> while uninitialized (but defined) NGINX variables are evaluated to an empty Lua string.</p><p>This API requires a relatively expensive metamethod call and it is recommended to avoid using it on hot code paths.</p><h2><span id="core-constants">Core constants</span></h2><p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, *log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ngx.OK (0)</span><br><span class="line">ngx.ERROR (-1)</span><br><span class="line">ngx.AGAIN (-2)</span><br><span class="line">ngx.DONE (-4)</span><br><span class="line">ngx.DECLINED (-5)</span><br></pre></td></tr></table></figure><p>Note that only three of these constants are utilized by the [Nginx API for Lua]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.null</span><br></pre></td></tr></table></figure><p>The <code>ngx.null</code> constant is a <code>NULL</code> light userdata usually used to represent nil values in Lua tables etc and is similar to the <a href="http://www.kyne.com.au/~mark/software/lua-cjson.php" target="_blank" rel="noopener">lua-cjson</a> library’s <code>cjson.null</code> constant. This constant was first introduced in the <code>v0.5.0rc5</code> release.</p><p>The <code>ngx.DECLINED</code> constant was first introduced in the <code>v0.5.0rc19</code> release.</p><h2><span id="http-method-constants">HTTP method constants</span></h2><p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ngx.HTTP_GET</span><br><span class="line">ngx.HTTP_HEAD</span><br><span class="line">ngx.HTTP_PUT</span><br><span class="line">ngx.HTTP_POST</span><br><span class="line">ngx.HTTP_DELETE</span><br><span class="line">ngx.HTTP_OPTIONS   (added in the v0.5.0rc24 release)</span><br><span class="line">ngx.HTTP_MKCOL     (added in the v0.8.2 release)</span><br><span class="line">ngx.HTTP_COPY      (added in the v0.8.2 release)</span><br><span class="line">ngx.HTTP_MOVE      (added in the v0.8.2 release)</span><br><span class="line">ngx.HTTP_PROPFIND  (added in the v0.8.2 release)</span><br><span class="line">ngx.HTTP_PROPPATCH (added in the v0.8.2 release)</span><br><span class="line">ngx.HTTP_LOCK      (added in the v0.8.2 release)</span><br><span class="line">ngx.HTTP_UNLOCK    (added in the v0.8.2 release)</span><br><span class="line">ngx.HTTP_PATCH     (added in the v0.8.2 release)</span><br><span class="line">ngx.HTTP_TRACE     (added in the v0.8.2 release)</span><br></pre></td></tr></table></figure><p>These constants are usually used in [ngx.location.capture]</p><h2><span id="http-status-constants">HTTP status constants</span></h2><p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">value = ngx.HTTP_CONTINUE (100) (first added in the v0.9.20 release)</span><br><span class="line">value = ngx.HTTP_SWITCHING_PROTOCOLS (101) (first added in the v0.9.20 release)</span><br><span class="line">value = ngx.HTTP_OK (200)</span><br><span class="line">value = ngx.HTTP_CREATED (201)</span><br><span class="line">value = ngx.HTTP_ACCEPTED (202) (first added in the v0.9.20 release)</span><br><span class="line">value = ngx.HTTP_NO_CONTENT (204) (first added in the v0.9.20 release)</span><br><span class="line">value = ngx.HTTP_PARTIAL_CONTENT (206) (first added in the v0.9.20 release)</span><br><span class="line">value = ngx.HTTP_SPECIAL_RESPONSE (300)</span><br><span class="line">value = ngx.HTTP_MOVED_PERMANENTLY (301)</span><br><span class="line">value = ngx.HTTP_MOVED_TEMPORARILY (302)</span><br><span class="line">value = ngx.HTTP_SEE_OTHER (303)</span><br><span class="line">value = ngx.HTTP_NOT_MODIFIED (304)</span><br><span class="line">value = ngx.HTTP_TEMPORARY_REDIRECT (307) (first added in the v0.9.20 release)</span><br><span class="line">value = ngx.HTTP_PERMANENT_REDIRECT (308)</span><br><span class="line">value = ngx.HTTP_BAD_REQUEST (400)</span><br><span class="line">value = ngx.HTTP_UNAUTHORIZED (401)</span><br><span class="line">value = ngx.HTTP_PAYMENT_REQUIRED (402) (first added in the v0.9.20 release)</span><br><span class="line">value = ngx.HTTP_FORBIDDEN (403)</span><br><span class="line">value = ngx.HTTP_NOT_FOUND (404)</span><br><span class="line">value = ngx.HTTP_NOT_ALLOWED (405)</span><br><span class="line">value = ngx.HTTP_NOT_ACCEPTABLE (406) (first added in the v0.9.20 release)</span><br><span class="line">value = ngx.HTTP_REQUEST_TIMEOUT (408) (first added in the v0.9.20 release)</span><br><span class="line">value = ngx.HTTP_CONFLICT (409) (first added in the v0.9.20 release)</span><br><span class="line">value = ngx.HTTP_GONE (410)</span><br><span class="line">value = ngx.HTTP_UPGRADE_REQUIRED (426) (first added in the v0.9.20 release)</span><br><span class="line">value = ngx.HTTP_TOO_MANY_REQUESTS (429) (first added in the v0.9.20 release)</span><br><span class="line">value = ngx.HTTP_CLOSE (444) (first added in the v0.9.20 release)</span><br><span class="line">value = ngx.HTTP_ILLEGAL (451) (first added in the v0.9.20 release)</span><br><span class="line">value = ngx.HTTP_INTERNAL_SERVER_ERROR (500)</span><br><span class="line">value = ngx.HTTP_METHOD_NOT_IMPLEMENTED (501)</span><br><span class="line">value = ngx.HTTP_BAD_GATEWAY (502) (first added in the v0.9.20 release)</span><br><span class="line">value = ngx.HTTP_SERVICE_UNAVAILABLE (503)</span><br><span class="line">value = ngx.HTTP_GATEWAY_TIMEOUT (504) (first added in the v0.3.1rc38 release)</span><br><span class="line">value = ngx.HTTP_VERSION_NOT_SUPPORTED (505) (first added in the v0.9.20 release)</span><br><span class="line">value = ngx.HTTP_INSUFFICIENT_STORAGE (507) (first added in the v0.9.20 release)</span><br></pre></td></tr></table></figure><h2><span id="nginx-log-level-constants">Nginx log level constants</span></h2><p><strong>context:</strong> init_by_lua*, init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ngx.STDERR</span><br><span class="line">ngx.EMERG</span><br><span class="line">ngx.ALERT</span><br><span class="line">ngx.CRIT</span><br><span class="line">ngx.ERR</span><br><span class="line">ngx.WARN</span><br><span class="line">ngx.NOTICE</span><br><span class="line">ngx.INFO</span><br><span class="line">ngx.DEBUG</span><br></pre></td></tr></table></figure><p>These constants are usually used by the [ngx.log]</p><h2><span id="print">print</span></h2><p><strong>syntax:</strong> <em>print(…)</em></p><p><strong>context:</strong> init_by_lua*, init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Writes argument values into the nginx <code>error.log</code> file with the <code>ngx.NOTICE</code> log level.</p><p>It is equivalent to</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.log(ngx.NOTICE, ...)</span><br></pre></td></tr></table></figure><p>Lua <code>nil</code> arguments are accepted and result in literal <code>&quot;nil&quot;</code> strings while Lua booleans result in literal <code>&quot;true&quot;</code> or <code>&quot;false&quot;</code>strings. And the <code>ngx.null</code> constant will yield the <code>&quot;null&quot;</code> string output.</p><p>There is a hard coded <code>2048</code> byte limitation on error message lengths in the Nginx core. This limit includes trailing newlines and leading time stamps. If the message size exceeds this limit, Nginx will truncate the message text accordingly. This limit can be manually modified by editing the <code>NGX_MAX_ERROR_STR</code> macro definition in the <code>src/core/ngx_log.h</code> file in the Nginx source tree.</p><h2><span id="ngxctx">ngx.ctx</span></h2><p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*</p><p>This table can be used to store per-request Lua context data and has a life time identical to the current request (as with the Nginx variables).</p><p>Consider the following example,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">location /test &#123;</span><br><span class="line">    rewrite_by_lua_block &#123;</span><br><span class="line">        ngx.ctx.foo = 76</span><br><span class="line">    &#125;</span><br><span class="line">    access_by_lua_block &#123;</span><br><span class="line">        ngx.ctx.foo = ngx.ctx.foo + 3</span><br><span class="line">    &#125;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        ngx.say(ngx.ctx.foo)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Then <code>GET /test</code> will yield the output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">79</span><br></pre></td></tr></table></figure><p>That is, the <code>ngx.ctx.foo</code> entry persists across the rewrite, access, and content phases of a request.</p><p>Every request, including subrequests, has its own copy of the table. For example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">location /sub &#123;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        ngx.say(&quot;sub pre: &quot;, ngx.ctx.blah)</span><br><span class="line">        ngx.ctx.blah = 32</span><br><span class="line">        ngx.say(&quot;sub post: &quot;, ngx.ctx.blah)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /main &#123;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        ngx.ctx.blah = 73</span><br><span class="line">        ngx.say(&quot;main pre: &quot;, ngx.ctx.blah)</span><br><span class="line">        local res = ngx.location.capture(&quot;/sub&quot;)</span><br><span class="line">        ngx.print(res.body)</span><br><span class="line">        ngx.say(&quot;main post: &quot;, ngx.ctx.blah)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Then <code>GET /main</code> will give the output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main pre: 73</span><br><span class="line">sub pre: nil</span><br><span class="line">sub post: 32</span><br><span class="line">main post: 73</span><br></pre></td></tr></table></figure><p>Here, modification of the <code>ngx.ctx.blah</code> entry in the subrequest does not affect the one in the parent request. This is because they have two separate versions of <code>ngx.ctx.blah</code>.</p><p>Internal redirection will destroy the original request <code>ngx.ctx</code> data (if any) and the new request will have an empty <code>ngx.ctx</code>table. For instance,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">location /new &#123;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        ngx.say(ngx.ctx.foo)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /orig &#123;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        ngx.ctx.foo = &quot;hello&quot;</span><br><span class="line">        ngx.exec(&quot;/new&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Then <code>GET /orig</code> will give</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nil</span><br></pre></td></tr></table></figure><p>rather than the original <code>&quot;hello&quot;</code> value.</p><p>Arbitrary data values, including Lua closures and nested tables, can be inserted into this “magic” table. It also allows the registration of custom meta methods.</p><p>Overriding <code>ngx.ctx</code> with a new Lua table is also supported, for example,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.ctx = &#123; foo = 32, bar = 54 &#125;</span><br></pre></td></tr></table></figure><p>When being used in the context of [init_worker_by_lua*]</p><p>The <code>ngx.ctx</code> lookup requires relatively expensive metamethod calls and it is much slower than explicitly passing per-request data along by your own function arguments. So do not abuse this API for saving your own function arguments because it usually has quite some performance impact.</p><p>Because of the metamethod magic, never “local” the <code>ngx.ctx</code> table outside your Lua function scope on the Lua module level due to [worker-level data sharing]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-- mymodule.lua</span><br><span class="line">local _M = &#123;&#125;</span><br><span class="line"></span><br><span class="line">-- the following line is bad since ngx.ctx is a per-request</span><br><span class="line">-- data while this &lt;code&gt;ctx&lt;/code&gt; variable is on the Lua module level</span><br><span class="line">-- and thus is per-nginx-worker.</span><br><span class="line">local ctx = ngx.ctx</span><br><span class="line"></span><br><span class="line">function _M.main()</span><br><span class="line">    ctx.foo = &quot;bar&quot;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">return _M</span><br></pre></td></tr></table></figure><p>Use the following instead:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- mymodule.lua</span><br><span class="line">local _M = &#123;&#125;</span><br><span class="line"></span><br><span class="line">function _M.main(ctx)</span><br><span class="line">    ctx.foo = &quot;bar&quot;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">return _M</span><br></pre></td></tr></table></figure><p>That is, let the caller pass the <code>ctx</code> table explicitly via a function argument.</p><h2><span id="ngxlocationcapture">ngx.location.capture</span></h2><p><strong>syntax:</strong> <em>res = ngx.location.capture(uri, options?)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*</p><p>Issues a synchronous but still non-blocking <em>Nginx Subrequest</em> using <code>uri</code>.</p><p>Nginx’s subrequests provide a powerful way to make non-blocking internal requests to other locations configured with disk file directory or <em>any</em> other nginx C modules like <code>ngx_proxy</code>, <code>ngx_fastcgi</code>, <code>ngx_memc</code>, <code>ngx_postgres</code>, <code>ngx_drizzle</code>, and even ngx_lua itself and etc etc etc.</p><p>Also note that subrequests just mimic the HTTP interface but there is <em>no</em> extra HTTP/TCP traffic <em>nor</em> IPC involved. Everything works internally, efficiently, on the C level.</p><p>Subrequests are completely different from HTTP 301/302 redirection (via [ngx.redirect]</p><p>You should always read the request body (by either calling [ngx.req.read_body]</p><p>This API function (as well as [ngx.location.capture_multi]</p><p>Here is a basic example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = ngx.location.capture(uri)</span><br></pre></td></tr></table></figure><p>Returns a Lua table with 4 slots: <code>res.status</code>, <code>res.header</code>, <code>res.body</code>, and <code>res.truncated</code>.</p><p><code>res.status</code> holds the response status code for the subrequest response.</p><p><code>res.header</code> holds all the response headers of the subrequest and it is a normal Lua table. For multi-value response headers, the value is a Lua (array) table that holds all the values in the order that they appear. For instance, if the subrequest response headers contain the following lines:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: a=3</span><br><span class="line">Set-Cookie: foo=bar</span><br><span class="line">Set-Cookie: baz=blah</span><br></pre></td></tr></table></figure><p>Then <code>res.header[&quot;Set-Cookie&quot;]</code> will be evaluated to the table value <code>{&quot;a=3&quot;, &quot;foo=bar&quot;, &quot;baz=blah&quot;}</code>.</p><p><code>res.body</code> holds the subrequest’s response body data, which might be truncated. You always need to check the <code>res.truncated</code> boolean flag to see if <code>res.body</code> contains truncated data. The data truncation here can only be caused by those unrecoverable errors in your subrequests like the cases that the remote end aborts the connection prematurely in the middle of the response body data stream or a read timeout happens when your subrequest is receiving the response body data from the remote.</p><p>URI query strings can be concatenated to URI itself, for instance,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = ngx.location.capture(&apos;/foo/bar?a=3&amp;b=4&apos;)</span><br></pre></td></tr></table></figure><p>Named locations like <code>@foo</code> are not allowed due to a limitation in the nginx core. Use normal locations combined with the <code>internal</code> directive to prepare internal-only locations.</p><p>An optional option table can be fed as the second argument, which supports the options:</p><ul><li><code>method</code> specify the subrequest’s request method, which only accepts constants like <code>ngx.HTTP_POST</code>.</li><li><code>body</code> specify the subrequest’s request body (string value only).</li><li><code>args</code> specify the subrequest’s URI query arguments (both string value and Lua tables are accepted)</li><li><code>ctx</code> specify a Lua table to be the [ngx.ctx]</li><li><code>vars</code> take a Lua table which holds the values to set the specified Nginx variables in the subrequest as this option’s value. This option was first introduced in the <code>v0.3.1rc31</code> release.</li><li><code>copy_all_vars</code> specify whether to copy over all the Nginx variable values of the current request to the subrequest in question. modifications of the nginx variables in the subrequest will not affect the current (parent) request. This option was first introduced in the <code>v0.3.1rc31</code> release.</li><li><code>share_all_vars</code> specify whether to share all the Nginx variables of the subrequest with the current (parent) request. modifications of the Nginx variables in the subrequest will affect the current (parent) request. Enabling this option may lead to hard-to-debug issues due to bad side-effects and is considered bad and harmful. Only enable this option when you completely know what you are doing.</li><li><code>always_forward_body</code> when set to true, the current (parent) request’s request body will always be forwarded to the subrequest being created if the <code>body</code> option is not specified. The request body read by either [ngx.req.read_body()]</li></ul><p>Issuing a POST subrequest, for example, can be done as follows</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">res = ngx.location.capture(</span><br><span class="line">    &apos;/foo/bar&apos;,</span><br><span class="line">    &#123; method = ngx.HTTP_POST, body = &apos;hello, world&apos; &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>See HTTP method constants methods other than POST. The <code>method</code> option is <code>ngx.HTTP_GET</code> by default.</p><p>The <code>args</code> option can specify extra URI arguments, for instance,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ngx.location.capture(&apos;/foo?a=1&apos;,</span><br><span class="line">    &#123; args = &#123; b = 3, c = &apos;:&apos; &#125; &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>is equivalent to</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.location.capture(&apos;/foo?a=1&amp;b=3&amp;c=%3a&apos;)</span><br></pre></td></tr></table></figure><p>that is, this method will escape argument keys and values according to URI rules and concatenate them together into a complete query string. The format for the Lua table passed as the <code>args</code> argument is identical to the format used in the [ngx.encode_args]</p><p>The <code>args</code> option can also take plain query strings:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ngx.location.capture(&apos;/foo?a=1&apos;,</span><br><span class="line">    &#123; args = &apos;b=3&amp;c=%3a&apos; &#125; &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>This is functionally identical to the previous examples.</p><p>The <code>share_all_vars</code> option controls whether to share nginx variables among the current request and its subrequests. If this option is set to <code>true</code>, then the current request and associated subrequests will share the same Nginx variable scope. Hence, changes to Nginx variables made by a subrequest will affect the current request.</p><p>Care should be taken in using this option as variable scope sharing can have unexpected side effects. The <code>args</code>, <code>vars</code>, or <code>copy_all_vars</code> options are generally preferable instead.</p><p>This option is set to <code>false</code> by default</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">location /other &#123;</span><br><span class="line">    set $dog &quot;$dog world&quot;;</span><br><span class="line">    echo &quot;$uri dog: $dog&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /lua &#123;</span><br><span class="line">    set $dog &apos;hello&apos;;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        res = ngx.location.capture(&quot;/other&quot;,</span><br><span class="line">            &#123; share_all_vars = true &#125;);</span><br><span class="line"></span><br><span class="line">        ngx.print(res.body)</span><br><span class="line">        ngx.say(ngx.var.uri, &quot;: &quot;, ngx.var.dog)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Accessing location <code>/lua</code> gives</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/other dog: hello world</span><br><span class="line">/lua: hello world</span><br></pre></td></tr></table></figure><p>The <code>copy_all_vars</code> option provides a copy of the parent request’s Nginx variables to subrequests when such subrequests are issued. Changes made to these variables by such subrequests will not affect the parent request or any other subrequests sharing the parent request’s variables.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">location /other &#123;</span><br><span class="line">    set $dog &quot;$dog world&quot;;</span><br><span class="line">    echo &quot;$uri dog: $dog&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /lua &#123;</span><br><span class="line">    set $dog &apos;hello&apos;;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        res = ngx.location.capture(&quot;/other&quot;,</span><br><span class="line">            &#123; copy_all_vars = true &#125;);</span><br><span class="line"></span><br><span class="line">        ngx.print(res.body)</span><br><span class="line">        ngx.say(ngx.var.uri, &quot;: &quot;, ngx.var.dog)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Request <code>GET /lua</code> will give the output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/other dog: hello world</span><br><span class="line">/lua: hello</span><br></pre></td></tr></table></figure><p>Note that if both <code>share_all_vars</code> and <code>copy_all_vars</code> are set to true, then <code>share_all_vars</code> takes precedence.</p><p>In addition to the two settings above, it is possible to specify values for variables in the subrequest using the <code>vars</code> option. These variables are set after the sharing or copying of variables has been evaluated, and provides a more efficient method of passing specific values to a subrequest over encoding them as URL arguments and unescaping them in the Nginx config file.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">location /other &#123;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        ngx.say(&quot;dog = &quot;, ngx.var.dog)</span><br><span class="line">        ngx.say(&quot;cat = &quot;, ngx.var.cat)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /lua &#123;</span><br><span class="line">    set $dog &apos;&apos;;</span><br><span class="line">    set $cat &apos;&apos;;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        res = ngx.location.capture(&quot;/other&quot;,</span><br><span class="line">            &#123; vars = &#123; dog = &quot;hello&quot;, cat = 32 &#125;&#125;);</span><br><span class="line"></span><br><span class="line">        ngx.print(res.body)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Accessing <code>/lua</code> will yield the output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dog = hello</span><br><span class="line">cat = 32</span><br></pre></td></tr></table></figure><p>The <code>ctx</code> option can be used to specify a custom Lua table to serve as the [ngx.ctx]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">location /sub &#123;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        ngx.ctx.foo = &quot;bar&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">location /lua &#123;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        local ctx = &#123;&#125;</span><br><span class="line">        res = ngx.location.capture(&quot;/sub&quot;, &#123; ctx = ctx &#125;)</span><br><span class="line"></span><br><span class="line">        ngx.say(ctx.foo);</span><br><span class="line">        ngx.say(ngx.ctx.foo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Then request <code>GET /lua</code> gives</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bar</span><br><span class="line">nil</span><br></pre></td></tr></table></figure><p>It is also possible to use this <code>ctx</code> option to share the same [ngx.ctx]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">location /sub &#123;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        ngx.ctx.foo = &quot;bar&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">location /lua &#123;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        res = ngx.location.capture(&quot;/sub&quot;, &#123; ctx = ngx.ctx &#125;)</span><br><span class="line">        ngx.say(ngx.ctx.foo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Request <code>GET /lua</code> yields the output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bar</span><br></pre></td></tr></table></figure><p>Note that subrequests issued by [ngx.location.capture]</p><p>When the <code>body</code> option is not specified and the <code>always_forward_body</code> option is false (the default value), the <code>POST</code> and <code>PUT</code>subrequests will inherit the request bodies of the parent request (if any).</p><p>There is a hard-coded upper limit on the number of concurrent subrequests possible for every main request. In older versions of Nginx, the limit was <code>50</code> concurrent subrequests and in more recent versions, Nginx <code>1.1.x</code> onwards, this was increased to <code>200</code> concurrent subrequests. When this limit is exceeded, the following error message is added to the <code>error.log</code> file:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[error] 13983#0: *1 subrequests cycle while processing &quot;/uri&quot;</span><br></pre></td></tr></table></figure><p>The limit can be manually modified if required by editing the definition of the <code>NGX_HTTP_MAX_SUBREQUESTS</code> macro in the <code>nginx/src/http/ngx_http_request.h</code> file in the Nginx source tree.</p><p>Please also refer to restrictions on capturing locations configured by [subrequest directives of other modules]</p><h2><span id="ngxlocationcapture_multi">ngx.location.capture_multi</span></h2><p><strong>syntax:</strong> <em>res1, res2, … = ngx.location.capture_multi({ {uri, options?}, {uri, options?}, … })</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*</p><p>Just like [ngx.location.capture]</p><p>This function issues several parallel subrequests specified by the input table and returns their results in the same order. For example,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">res1, res2, res3 = ngx.location.capture_multi&#123;</span><br><span class="line">    &#123; &quot;/foo&quot;, &#123; args = &quot;a=3&amp;b=4&quot; &#125; &#125;,</span><br><span class="line">    &#123; &quot;/bar&quot; &#125;,</span><br><span class="line">    &#123; &quot;/baz&quot;, &#123; method = ngx.HTTP_POST, body = &quot;hello&quot; &#125; &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if res1.status == ngx.HTTP_OK then</span><br><span class="line">    ...</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">if res2.body == &quot;BLAH&quot; then</span><br><span class="line">    ...</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>This function will not return until all the subrequests terminate. The total latency is the longest latency of the individual subrequests rather than the sum.</p><p>Lua tables can be used for both requests and responses when the number of subrequests to be issued is not known in advance:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-- construct the requests table</span><br><span class="line">local reqs = &#123;&#125;</span><br><span class="line">table.insert(reqs, &#123; &quot;/mysql&quot; &#125;)</span><br><span class="line">table.insert(reqs, &#123; &quot;/postgres&quot; &#125;)</span><br><span class="line">table.insert(reqs, &#123; &quot;/redis&quot; &#125;)</span><br><span class="line">table.insert(reqs, &#123; &quot;/memcached&quot; &#125;)</span><br><span class="line"></span><br><span class="line">-- issue all the requests at once and wait until they all return</span><br><span class="line">local resps = &#123; ngx.location.capture_multi(reqs) &#125;</span><br><span class="line"></span><br><span class="line">-- loop over the responses table</span><br><span class="line">for i, resp in ipairs(resps) do</span><br><span class="line">    -- process the response table &quot;resp&quot;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>The [ngx.location.capture]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ngx.location.capture =</span><br><span class="line">    function (uri, args)</span><br><span class="line">        return ngx.location.capture_multi(&#123; &#123;uri, args&#125; &#125;)</span><br><span class="line">    end</span><br></pre></td></tr></table></figure><p>Please also refer to restrictions on capturing locations configured by [subrequest directives of other modules]</p><h2><span id="ngxstatus">ngx.status</span></h2><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*</p><p>Read and write the current request’s response status. This should be called before sending out the response headers.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ngx.status = ngx.HTTP_CREATED</span><br><span class="line">status = ngx.status</span><br></pre></td></tr></table></figure><p>Setting <code>ngx.status</code> after the response header is sent out has no effect but leaving an error message in your nginx’s error log file:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">attempt to set ngx.status after sending out response headers</span><br></pre></td></tr></table></figure><h2><span id="ngxheaderheader">ngx.header.HEADER</span></h2><p><strong>syntax:</strong> <em>ngx.header.HEADER = VALUE</em></p><p><strong>syntax:</strong> <em>value = ngx.header.HEADER</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*</p><p>Set, add to, or clear the current request’s <code>HEADER</code> response header that is to be sent.</p><p>Underscores (<code>_</code>) in the header names will be replaced by hyphens (<code>-</code>) by default. This transformation can be turned off via the [lua_transform_underscores_in_response_headers]</p><p>The header names are matched case-insensitively.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- equivalent to ngx.header[&quot;Content-Type&quot;] = &apos;text/plain&apos;</span><br><span class="line">ngx.header.content_type = &apos;text/plain&apos;;</span><br><span class="line"></span><br><span class="line">ngx.header[&quot;X-My-Header&quot;] = &apos;blah blah&apos;;</span><br></pre></td></tr></table></figure><p>Multi-value headers can be set this way:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.header[&apos;Set-Cookie&apos;] = &#123;&apos;a=32; path=/&apos;, &apos;b=4; path=/&apos;&#125;</span><br></pre></td></tr></table></figure><p>will yield</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: a=32; path=/</span><br><span class="line">Set-Cookie: b=4; path=/</span><br></pre></td></tr></table></figure><p>in the response headers.</p><p>Only Lua tables are accepted (Only the last element in the table will take effect for standard headers such as <code>Content-Type</code>that only accept a single value).</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.header.content_type = &#123;&apos;a&apos;, &apos;b&apos;&#125;</span><br></pre></td></tr></table></figure><p>is equivalent to</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.header.content_type = &apos;b&apos;</span><br></pre></td></tr></table></figure><p>Setting a slot to <code>nil</code> effectively removes it from the response headers:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.header[&quot;X-My-Header&quot;] = nil;</span><br></pre></td></tr></table></figure><p>The same applies to assigning an empty table:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.header[&quot;X-My-Header&quot;] = &#123;&#125;;</span><br></pre></td></tr></table></figure><p>Setting <code>ngx.header.HEADER</code> after sending out response headers (either explicitly with [ngx.send_headers]</p><p>Reading <code>ngx.header.HEADER</code> will return the value of the response header named <code>HEADER</code>.</p><p>Underscores (<code>_</code>) in the header names will also be replaced by dashes (<code>-</code>) and the header names will be matched case-insensitively. If the response header is not present at all, <code>nil</code> will be returned.</p><p>This is particularly useful in the context of [header_filter_by_lua*]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">location /test &#123;</span><br><span class="line">    set $footer &apos;&apos;;</span><br><span class="line"></span><br><span class="line">    proxy_pass http://some-backend;</span><br><span class="line"></span><br><span class="line">    header_filter_by_lua_block &#123;</span><br><span class="line">        if ngx.header[&quot;X-My-Header&quot;] == &quot;blah&quot; then</span><br><span class="line">            ngx.var.footer = &quot;some value&quot;</span><br><span class="line">        end</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    echo_after_body $footer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>For multi-value headers, all of the values of header will be collected in order and returned as a Lua table. For example, response headers</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Foo: bar</span><br><span class="line">Foo: baz</span><br></pre></td></tr></table></figure><p>will result in</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;bar&quot;, &quot;baz&quot;&#125;</span><br></pre></td></tr></table></figure><p>to be returned when reading <code>ngx.header.Foo</code>.</p><p>Note that <code>ngx.header</code> is not a normal Lua table and as such, it is not possible to iterate through it using the Lua <code>ipairs</code>function.</p><p>For reading <em>request</em> headers, use the [ngx.req.get_headers]</p><h2><span id="ngxrespget_headers">ngx.resp.get_headers</span></h2><p><strong>syntax:</strong> <em>headers, err = ngx.resp.get_headers(max_headers?, raw?)</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, balancer_by_lua*</p><p>Returns a Lua table holding all the current response headers for the current request.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">local h, err = ngx.resp.get_headers()</span><br><span class="line"></span><br><span class="line">if err == &quot;truncated&quot; then</span><br><span class="line">    -- one can choose to ignore or reject the current response here</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">for k, v in pairs(h) do</span><br><span class="line">    ...</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>This function has the same signature as [ngx.req.get_headers]</p><p>Note that a maximum of 100 response headers are parsed by default (including those with the same name) and that additional response headers are silently discarded to guard against potential denial of service attacks. Since <code>v0.10.13</code>, when the limit is exceeded, it will return a second value which is the string <code>&quot;truncated&quot;</code>.</p><p>This API was first introduced in the <code>v0.9.5</code> release.</p><h2><span id="ngxreqis_internal">ngx.req.is_internal</span></h2><p><strong>syntax:</strong> <em>is_internal = ngx.req.is_internal()</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*</p><p>Returns a boolean indicating whether the current request is an “internal request”, i.e., a request initiated from inside the current nginx server instead of from the client side.</p><p>Subrequests are all internal requests and so are requests after internal redirects.</p><p>This API was first introduced in the <code>v0.9.20</code> release.</p><h2><span id="ngxreqstart_time">ngx.req.start_time</span></h2><p><strong>syntax:</strong> <em>secs = ngx.req.start_time()</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*</p><p>Returns a floating-point number representing the timestamp (including milliseconds as the decimal part) when the current request was created.</p><p>The following example emulates the <code>$request_time</code> variable value (provided by <a href="http://nginx.org/en/docs/http/ngx_http_log_module.html" target="_blank" rel="noopener">ngx_http_log_module</a>) in pure Lua:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">local request_time = ngx.now() - ngx.req.start_time()</span><br></pre></td></tr></table></figure><p>This function was first introduced in the <code>v0.7.7</code> release.</p><p>See also [ngx.now]</p><h2><span id="ngxreqhttp_version">ngx.req.http_version</span></h2><p><strong>syntax:</strong> <em>num = ngx.req.http_version()</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*</p><p>Returns the HTTP version number for the current request as a Lua number.</p><p>Current possible values are 2.0, 1.0, 1.1, and 0.9. Returns <code>nil</code> for unrecognized values.</p><p>This method was first introduced in the <code>v0.7.17</code> release.</p><h2><span id="ngxreqraw_header">ngx.req.raw_header</span></h2><p><strong>syntax:</strong> <em>str = ngx.req.raw_header(no_request_line?)</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*</p><p>Returns the original raw HTTP protocol header received by the Nginx server.</p><p>By default, the request line and trailing <code>CR LF</code> terminator will also be included. For example,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.print(ngx.req.raw_header())</span><br></pre></td></tr></table></figure><p>gives something like this:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /t HTTP/1.1</span><br><span class="line">Host: localhost</span><br><span class="line">Connection: close</span><br><span class="line">Foo: bar</span><br></pre></td></tr></table></figure><p>You can specify the optional <code>no_request_line</code> argument as a <code>true</code> value to exclude the request line from the result. For example,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.print(ngx.req.raw_header(true))</span><br></pre></td></tr></table></figure><p>outputs something like this:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Host: localhost</span><br><span class="line">Connection: close</span><br><span class="line">Foo: bar</span><br></pre></td></tr></table></figure><p>This method was first introduced in the <code>v0.7.17</code> release.</p><p>This method does not work in HTTP/2 requests yet.</p><h2><span id="ngxreqget_method">ngx.req.get_method</span></h2><p><strong>syntax:</strong> <em>method_name = ngx.req.get_method()</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, balancer_by_lua*, log_by_lua*</p><p>Retrieves the current request’s request method name. Strings like <code>&quot;GET&quot;</code> and <code>&quot;POST&quot;</code> are returned instead of numerical [method constants]</p><p>If the current request is an Nginx subrequest, then the subrequest’s method name will be returned.</p><p>This method was first introduced in the <code>v0.5.6</code> release.</p><p>See also [ngx.req.set_method]</p><h2><span id="ngxreqset_method">ngx.req.set_method</span></h2><p><strong>syntax:</strong> <em>ngx.req.set_method(method_id)</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*</p><p>Overrides the current request’s request method with the <code>method_id</code> argument. Currently only numerical [method constants]</p><p>If the current request is an Nginx subrequest, then the subrequest’s method will be overridden.</p><p>This method was first introduced in the <code>v0.5.6</code> release.</p><p>See also [ngx.req.get_method]</p><h2><span id="ngxreqset_uri">ngx.req.set_uri</span></h2><p><strong>syntax:</strong> <em>ngx.req.set_uri(uri, jump?)</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*</p><p>Rewrite the current request’s (parsed) URI by the <code>uri</code> argument. The <code>uri</code> argument must be a Lua string and cannot be of zero length, or a Lua exception will be thrown.</p><p>The optional boolean <code>jump</code> argument can trigger location rematch (or location jump) as <a href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html" target="_blank" rel="noopener">ngx_http_rewrite_module</a>‘s <a href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html#rewrite" target="_blank" rel="noopener">rewrite</a>directive, that is, when <code>jump</code> is <code>true</code> (default to <code>false</code>), this function will never return and it will tell Nginx to try re-searching locations with the new URI value at the later <code>post-rewrite</code> phase and jumping to the new location.</p><p>Location jump will not be triggered otherwise, and only the current request’s URI will be modified, which is also the default behavior. This function will return but with no returned values when the <code>jump</code> argument is <code>false</code> or absent altogether.</p><p>For example, the following nginx config snippet</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rewrite ^ /foo last;</span><br></pre></td></tr></table></figure><p>can be coded in Lua like this:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.req.set_uri(&quot;/foo&quot;, true)</span><br></pre></td></tr></table></figure><p>Similarly, Nginx config</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rewrite ^ /foo break;</span><br></pre></td></tr></table></figure><p>can be coded in Lua as</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.req.set_uri(&quot;/foo&quot;, false)</span><br></pre></td></tr></table></figure><p>or equivalently,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.req.set_uri(&quot;/foo&quot;)</span><br></pre></td></tr></table></figure><p>The <code>jump</code> argument can only be set to <code>true</code> in [rewrite_by_lua*]</p><p>A more sophisticated example involving regex substitutions is as follows</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location /test &#123;</span><br><span class="line">    rewrite_by_lua_block &#123;</span><br><span class="line">        local uri = ngx.re.sub(ngx.var.uri, &quot;^/test/(.*)&quot;, &quot;/$1&quot;, &quot;o&quot;)</span><br><span class="line">        ngx.req.set_uri(uri)</span><br><span class="line">    &#125;</span><br><span class="line">    proxy_pass http://my_backend;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>which is functionally equivalent to</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location /test &#123;</span><br><span class="line">    rewrite ^/test/(.*) /$1 break;</span><br><span class="line">    proxy_pass http://my_backend;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note that it is not possible to use this interface to rewrite URI arguments and that [ngx.req.set_uri_args]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rewrite ^ /foo?a=3? last;</span><br></pre></td></tr></table></figure><p>can be coded as</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ngx.req.set_uri_args(&quot;a=3&quot;)</span><br><span class="line">ngx.req.set_uri(&quot;/foo&quot;, true)</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ngx.req.set_uri_args(&#123;a = 3&#125;)</span><br><span class="line">ngx.req.set_uri(&quot;/foo&quot;, true)</span><br></pre></td></tr></table></figure><p>This interface was first introduced in the <code>v0.3.1rc14</code> release.</p><h2><span id="ngxreqset_uri_args">ngx.req.set_uri_args</span></h2><p><strong>syntax:</strong> <em>ngx.req.set_uri_args(args)</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*</p><p>Rewrite the current request’s URI query arguments by the <code>args</code> argument. The <code>args</code> argument can be either a Lua string, as in</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.req.set_uri_args(&quot;a=3&amp;b=hello%20world&quot;)</span><br></pre></td></tr></table></figure><p>or a Lua table holding the query arguments’ key-value pairs, as in</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.req.set_uri_args(&#123; a = 3, b = &quot;hello world&quot; &#125;)</span><br></pre></td></tr></table></figure><p>where in the latter case, this method will escape argument keys and values according to the URI escaping rule.</p><p>Multi-value arguments are also supported:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.req.set_uri_args(&#123; a = 3, b = &#123;5, 6&#125; &#125;)</span><br></pre></td></tr></table></figure><p>which will result in a query string like <code>a=3&amp;b=5&amp;b=6</code>.</p><p>This interface was first introduced in the <code>v0.3.1rc13</code> release.</p><p>See also [ngx.req.set_uri]</p><h2><span id="ngxreqget_uri_args">ngx.req.get_uri_args</span></h2><p><strong>syntax:</strong> <em>args, err = ngx.req.get_uri_args(max_args?)</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, balancer_by_lua*</p><p>Returns a Lua table holding all the current request URL query arguments.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">location = /test &#123;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        local args, err = ngx.req.get_uri_args()</span><br><span class="line"></span><br><span class="line">        if err == &quot;truncated&quot; then</span><br><span class="line">            -- one can choose to ignore or reject the current request here</span><br><span class="line">        end</span><br><span class="line"></span><br><span class="line">        for key, val in pairs(args) do</span><br><span class="line">            if type(val) == &quot;table&quot; then</span><br><span class="line">                ngx.say(key, &quot;: &quot;, table.concat(val, &quot;, &quot;))</span><br><span class="line">            else</span><br><span class="line">                ngx.say(key, &quot;: &quot;, val)</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Then <code>GET /test?foo=bar&amp;bar=baz&amp;bar=blah</code> will yield the response body</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo: bar</span><br><span class="line">bar: baz, blah</span><br></pre></td></tr></table></figure><p>Multiple occurrences of an argument key will result in a table value holding all the values for that key in order.</p><p>Keys and values are unescaped according to URI escaping rules. In the settings above, <code>GET /test?a%20b=1%61+2</code> will yield:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a b: 1a 2</span><br></pre></td></tr></table></figure><p>Arguments without the <code>=&lt;value&gt;</code> parts are treated as boolean arguments. <code>GET /test?foo&amp;bar</code> will yield:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo: true</span><br><span class="line">bar: true</span><br></pre></td></tr></table></figure><p>That is, they will take Lua boolean values <code>true</code>. However, they are different from arguments taking empty string values. <code>GET /test?foo=&amp;bar=</code> will give something like</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo:</span><br><span class="line">bar:</span><br></pre></td></tr></table></figure><p>Empty key arguments are discarded. <code>GET /test?=hello&amp;=world</code> will yield an empty output for instance.</p><p>Updating query arguments via the nginx variable <code>$args</code> (or <code>ngx.var.args</code> in Lua) at runtime is also supported:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ngx.var.args = &quot;a=3&amp;b=42&quot;</span><br><span class="line">local args, err = ngx.req.get_uri_args()</span><br></pre></td></tr></table></figure><p>Here the <code>args</code> table will always look like</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;a = 3, b = 42&#125;</span><br></pre></td></tr></table></figure><p>regardless of the actual request query string.</p><p>Note that a maximum of 100 request arguments are parsed by default (including those with the same name) and that additional request arguments are silently discarded to guard against potential denial of service attacks. Since <code>v0.10.13</code>, when the limit is exceeded, it will return a second value which is the string <code>&quot;truncated&quot;</code>.</p><p>However, the optional <code>max_args</code> function argument can be used to override this limit:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">local args, err = ngx.req.get_uri_args(10)</span><br><span class="line">if err == &quot;truncated&quot; then</span><br><span class="line">    -- one can choose to ignore or reject the current request here</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>This argument can be set to zero to remove the limit and to process all request arguments received:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">local args, err = ngx.req.get_uri_args(0)</span><br></pre></td></tr></table></figure><p>Removing the <code>max_args</code> cap is strongly discouraged.</p><h2><span id="ngxreqget_post_args">ngx.req.get_post_args</span></h2><p><strong>syntax:</strong> <em>args, err = ngx.req.get_post_args(max_args?)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*</p><p>Returns a Lua table holding all the current request POST query arguments (of the MIME type <code>application/x-www-form-urlencoded</code>). Call [ngx.req.read_body]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">location = /test &#123;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        ngx.req.read_body()</span><br><span class="line">        local args, err = ngx.req.get_post_args()</span><br><span class="line"></span><br><span class="line">        if err == &quot;truncated&quot; then</span><br><span class="line">            -- one can choose to ignore or reject the current request here</span><br><span class="line">        end</span><br><span class="line"></span><br><span class="line">        if not args then</span><br><span class="line">            ngx.say(&quot;failed to get post args: &quot;, err)</span><br><span class="line">            return</span><br><span class="line">        end</span><br><span class="line">        for key, val in pairs(args) do</span><br><span class="line">            if type(val) == &quot;table&quot; then</span><br><span class="line">                ngx.say(key, &quot;: &quot;, table.concat(val, &quot;, &quot;))</span><br><span class="line">            else</span><br><span class="line">                ngx.say(key, &quot;: &quot;, val)</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Then</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Post request with the body &apos;foo=bar&amp;bar=baz&amp;bar=blah&apos;</span><br><span class="line">$ curl --data &apos;foo=bar&amp;bar=baz&amp;bar=blah&apos; localhost/test</span><br></pre></td></tr></table></figure><p>will yield the response body like</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo: bar</span><br><span class="line">bar: baz, blah</span><br></pre></td></tr></table></figure><p>Multiple occurrences of an argument key will result in a table value holding all of the values for that key in order.</p><p>Keys and values will be unescaped according to URI escaping rules.</p><p>With the settings above,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># POST request with body &apos;a%20b=1%61+2&apos;</span><br><span class="line">$ curl -d &apos;a%20b=1%61+2&apos; localhost/test</span><br></pre></td></tr></table></figure><p>will yield:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a b: 1a 2</span><br></pre></td></tr></table></figure><p>Arguments without the <code>=&lt;value&gt;</code> parts are treated as boolean arguments. <code>POST /test</code> with the request body <code>foo&amp;bar</code> will yield:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo: true</span><br><span class="line">bar: true</span><br></pre></td></tr></table></figure><p>That is, they will take Lua boolean values <code>true</code>. However, they are different from arguments taking empty string values. <code>POST /test</code> with request body <code>foo=&amp;bar=</code> will return something like</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo:</span><br><span class="line">bar:</span><br></pre></td></tr></table></figure><p>Empty key arguments are discarded. <code>POST /test</code> with body <code>=hello&amp;=world</code> will yield empty outputs for instance.</p><p>Note that a maximum of 100 request arguments are parsed by default (including those with the same name) and that additional request arguments are silently discarded to guard against potential denial of service attacks. Since <code>v0.10.13</code>, when the limit is exceeded, it will return a second value which is the string <code>&quot;truncated&quot;</code>.</p><p>However, the optional <code>max_args</code> function argument can be used to override this limit:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">local args, err = ngx.req.get_post_args(10)</span><br><span class="line">if err == &quot;truncated&quot; then</span><br><span class="line">    -- one can choose to ignore or reject the current request here</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>This argument can be set to zero to remove the limit and to process all request arguments received:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">local args, err = ngx.req.get_post_args(0)</span><br></pre></td></tr></table></figure><p>Removing the <code>max_args</code> cap is strongly discouraged.</p><h2><span id="ngxreqget_headers">ngx.req.get_headers</span></h2><p><strong>syntax:</strong> <em>headers, err = ngx.req.get_headers(max_headers?, raw?)</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*</p><p>Returns a Lua table holding all the current request headers.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">local h, err = ngx.req.get_headers()</span><br><span class="line"></span><br><span class="line">if err == &quot;truncated&quot; then</span><br><span class="line">    -- one can choose to ignore or reject the current request here</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">for k, v in pairs(h) do</span><br><span class="line">    ...</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>To read an individual header:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.say(&quot;Host: &quot;, ngx.req.get_headers()[&quot;Host&quot;])</span><br></pre></td></tr></table></figure><p>Note that the [ngx.var.HEADER]</p><p>For multiple instances of request headers such as:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Foo: foo</span><br><span class="line">Foo: bar</span><br><span class="line">Foo: baz</span><br></pre></td></tr></table></figure><p>the value of <code>ngx.req.get_headers()[&quot;Foo&quot;]</code> will be a Lua (array) table such as:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;&#125;</span><br></pre></td></tr></table></figure><p>Note that a maximum of 100 request headers are parsed by default (including those with the same name) and that additional request headers are silently discarded to guard against potential denial of service attacks. Since <code>v0.10.13</code>, when the limit is exceeded, it will return a second value which is the string <code>&quot;truncated&quot;</code>.</p><p>However, the optional <code>max_headers</code> function argument can be used to override this limit:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">local headers, err = ngx.req.get_headers(10)</span><br><span class="line"></span><br><span class="line">if err == &quot;truncated&quot; then</span><br><span class="line">    -- one can choose to ignore or reject the current request here</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>This argument can be set to zero to remove the limit and to process all request headers received:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">local headers, err = ngx.req.get_headers(0)</span><br></pre></td></tr></table></figure><p>Removing the <code>max_headers</code> cap is strongly discouraged.</p><p>Since the <code>0.6.9</code> release, all the header names in the Lua table returned are converted to the pure lower-case form by default, unless the <code>raw</code> argument is set to <code>true</code> (default to <code>false</code>).</p><p>Also, by default, an <code>__index</code> metamethod is added to the resulting Lua table and will normalize the keys to a pure lowercase form with all underscores converted to dashes in case of a lookup miss. For example, if a request header <code>My-Foo-Header</code> is present, then the following invocations will all pick up the value of this header correctly:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ngx.say(headers.my_foo_header)</span><br><span class="line">ngx.say(headers[&quot;My-Foo-Header&quot;])</span><br><span class="line">ngx.say(headers[&quot;my-foo-header&quot;])</span><br></pre></td></tr></table></figure><p>The <code>__index</code> metamethod will not be added when the <code>raw</code> argument is set to <code>true</code>.</p><h2><span id="ngxreqset_header">ngx.req.set_header</span></h2><p><strong>syntax:</strong> <em>ngx.req.set_header(header_name, header_value)</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*</p><p>Set the current request’s request header named <code>header_name</code> to value <code>header_value</code>, overriding any existing ones.</p><p>By default, all the subrequests subsequently initiated by [ngx.location.capture]</p><p>Here is an example of setting the <code>Content-Type</code> header:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.req.set_header(&quot;Content-Type&quot;, &quot;text/css&quot;)</span><br></pre></td></tr></table></figure><p>The <code>header_value</code> can take an array list of values, for example,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.req.set_header(&quot;Foo&quot;, &#123;&quot;a&quot;, &quot;abc&quot;&#125;)</span><br></pre></td></tr></table></figure><p>will produce two new request headers:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Foo: a</span><br><span class="line">Foo: abc</span><br></pre></td></tr></table></figure><p>and old <code>Foo</code> headers will be overridden if there is any.</p><p>When the <code>header_value</code> argument is <code>nil</code>, the request header will be removed. So</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.req.set_header(&quot;X-Foo&quot;, nil)</span><br></pre></td></tr></table></figure><p>is equivalent to</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.req.clear_header(&quot;X-Foo&quot;)</span><br></pre></td></tr></table></figure><h2><span id="ngxreqclear_header">ngx.req.clear_header</span></h2><p><strong>syntax:</strong> <em>ngx.req.clear_header(header_name)</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*</p><p>Clears the current request’s request header named <code>header_name</code>. None of the current request’s existing subrequests will be affected but subsequently initiated subrequests will inherit the change by default.</p><h2><span id="ngxreqread_body">ngx.req.read_body</span></h2><p><strong>syntax:</strong> <em>ngx.req.read_body()</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*</p><p>Reads the client request body synchronously without blocking the Nginx event loop.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ngx.req.read_body()</span><br><span class="line">local args = ngx.req.get_post_args()</span><br></pre></td></tr></table></figure><p>If the request body is already read previously by turning on [lua_need_request_body]</p><p>If the request body has already been explicitly discarded, either by the [ngx.req.discard_body]</p><p>In case of errors, such as connection errors while reading the data, this method will throw out a Lua exception <em>or</em> terminate the current request with a 500 status code immediately.</p><p>The request body data read using this function can be retrieved later via [ngx.req.get_body_data]</p><ol><li>whether the current request body is already larger than the <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_buffer_size" target="_blank" rel="noopener">client_body_buffer_size</a>,</li><li>and whether <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_in_file_only" target="_blank" rel="noopener">client_body_in_file_only</a> has been switched on.</li></ol><p>In cases where current request may have a request body and the request body data is not required, The [ngx.req.discard_body]</p><p>This function was first introduced in the <code>v0.3.1rc17</code> release.</p><h2><span id="ngxreqdiscard_body">ngx.req.discard_body</span></h2><p><strong>syntax:</strong> <em>ngx.req.discard_body()</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*</p><p>Explicitly discard the request body, i.e., read the data on the connection and throw it away immediately (without using the request body by any means).</p><p>This function is an asynchronous call and returns immediately.</p><p>If the request body has already been read, this function does nothing and returns immediately.</p><p>This function was first introduced in the <code>v0.3.1rc17</code> release.</p><p>See also [ngx.req.read_body]</p><h2><span id="ngxreqget_body_data">ngx.req.get_body_data</span></h2><p><strong>syntax:</strong> <em>data = ngx.req.get_body_data()</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, log_by_lua*</p><p>Retrieves in-memory request body data. It returns a Lua string rather than a Lua table holding all the parsed query arguments. Use the [ngx.req.get_post_args]</p><p>This function returns <code>nil</code> if</p><ol><li>the request body has not been read,</li><li>the request body has been read into disk temporary files,</li><li>or the request body has zero size.</li></ol><p>If the request body has not been read yet, call [ngx.req.read_body]</p><p>If the request body has been read into disk files, try calling the [ngx.req.get_body_file]</p><p>To force in-memory request bodies, try setting <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_buffer_size" target="_blank" rel="noopener">client_body_buffer_size</a> to the same size value in <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#client_max_body_size" target="_blank" rel="noopener">client_max_body_size</a>.</p><p>Note that calling this function instead of using <code>ngx.var.request_body</code> or <code>ngx.var.echo_request_body</code> is more efficient because it can save one dynamic memory allocation and one data copy.</p><p>This function was first introduced in the <code>v0.3.1rc17</code> release.</p><p>See also [ngx.req.get_body_file]</p><h2><span id="ngxreqget_body_file">ngx.req.get_body_file</span></h2><p><strong>syntax:</strong> <em>file_name = ngx.req.get_body_file()</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*</p><p>Retrieves the file name for the in-file request body data. Returns <code>nil</code> if the request body has not been read or has been read into memory.</p><p>The returned file is read only and is usually cleaned up by Nginx’s memory pool. It should not be manually modified, renamed, or removed in Lua code.</p><p>If the request body has not been read yet, call [ngx.req.read_body]</p><p>If the request body has been read into memory, try calling the [ngx.req.get_body_data]</p><p>To force in-file request bodies, try turning on <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_in_file_only" target="_blank" rel="noopener">client_body_in_file_only</a>.</p><p>This function was first introduced in the <code>v0.3.1rc17</code> release.</p><p>See also [ngx.req.get_body_data]</p><h2><span id="ngxreqset_body_data">ngx.req.set_body_data</span></h2><p><strong>syntax:</strong> <em>ngx.req.set_body_data(data)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*</p><p>Set the current request’s request body using the in-memory data specified by the <code>data</code> argument.</p><p>If the request body has not been read yet, call [ngx.req.read_body]</p><p>Whether the previous request body has been read into memory or buffered into a disk file, it will be freed or the disk file will be cleaned up immediately, respectively.</p><p>This function was first introduced in the <code>v0.3.1rc18</code> release.</p><p>See also [ngx.req.set_body_file]</p><h2><span id="ngxreqset_body_file">ngx.req.set_body_file</span></h2><p><strong>syntax:</strong> <em>ngx.req.set_body_file(file_name, auto_clean?)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*</p><p>Set the current request’s request body using the in-file data specified by the <code>file_name</code> argument.</p><p>If the request body has not been read yet, call [ngx.req.read_body]</p><p>If the optional <code>auto_clean</code> argument is given a <code>true</code> value, then this file will be removed at request completion or the next time this function or [ngx.req.set_body_data]</p><p>Please ensure that the file specified by the <code>file_name</code> argument exists and is readable by an Nginx worker process by setting its permission properly to avoid Lua exception errors.</p><p>Whether the previous request body has been read into memory or buffered into a disk file, it will be freed or the disk file will be cleaned up immediately, respectively.</p><p>This function was first introduced in the <code>v0.3.1rc18</code> release.</p><p>See also [ngx.req.set_body_data]</p><h2><span id="ngxreqinit_body">ngx.req.init_body</span></h2><p><strong>syntax:</strong> <em>ngx.req.init_body(buffer_size?)</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*</p><p>Creates a new blank request body for the current request and inializes the buffer for later request body data writing via the [ngx.req.append_body]</p><p>If the <code>buffer_size</code> argument is specified, then its value will be used for the size of the memory buffer for body writing with [ngx.req.append_body]</p><p>When the data can no longer be hold in the memory buffer for the request body, then the data will be flushed onto a temporary file just like the standard request body reader in the Nginx core.</p><p>It is important to always call the [ngx.req.finish_body]</p><p>The usage of this function is often like this:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ngx.req.init_body(128 * 1024)  -- buffer is 128KB</span><br><span class="line">for chunk in next_data_chunk() do</span><br><span class="line">    ngx.req.append_body(chunk) -- each chunk can be 4KB</span><br><span class="line">end</span><br><span class="line">ngx.req.finish_body()</span><br></pre></td></tr></table></figure><p>This function can be used with [ngx.req.append_body]</p><p>This function was first introduced in the <code>v0.5.11</code> release.</p><h2><span id="ngxreqappend_body">ngx.req.append_body</span></h2><p><strong>syntax:</strong> <em>ngx.req.append_body(data_chunk)</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*</p><p>Append new data chunk specified by the <code>data_chunk</code> argument onto the existing request body created by the [ngx.req.init_body]</p><p>When the data can no longer be hold in the memory buffer for the request body, then the data will be flushed onto a temporary file just like the standard request body reader in the Nginx core.</p><p>It is important to always call the [ngx.req.finish_body]</p><p>This function can be used with [ngx.req.init_body]</p><p>This function was first introduced in the <code>v0.5.11</code> release.</p><p>See also [ngx.req.init_body]</p><h2><span id="ngxreqfinish_body">ngx.req.finish_body</span></h2><p><strong>syntax:</strong> <em>ngx.req.finish_body()</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*</p><p>Completes the construction process of the new request body created by the [ngx.req.init_body]</p><p>This function can be used with [ngx.req.init_body]</p><p>This function was first introduced in the <code>v0.5.11</code> release.</p><p>See also [ngx.req.init_body]</p><h2><span id="ngxreqsocket">ngx.req.socket</span></h2><p><strong>syntax:</strong> <em>tcpsock, err = ngx.req.socket()</em></p><p><strong>syntax:</strong> <em>tcpsock, err = ngx.req.socket(raw)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*</p><p>Returns a read-only cosocket object that wraps the downstream connection. Only [receive]</p><p>In case of error, <code>nil</code> will be returned as well as a string describing the error.</p><p>The socket object returned by this method is usually used to read the current request’s body in a streaming fashion. Do not turn on the [lua_need_request_body]</p><p>If any request body data has been pre-read into the Nginx core request header buffer, the resulting cosocket object will take care of this to avoid potential data loss resulting from such pre-reading. Chunked request bodies are not yet supported in this API.</p><p>Since the <code>v0.9.0</code> release, this function accepts an optional boolean <code>raw</code> argument. When this argument is <code>true</code>, this function returns a full-duplex cosocket object wrapping around the raw downstream connection socket, upon which you can call the [receive]</p><p>When the <code>raw</code> argument is <code>true</code>, it is required that no pending data from any previous [ngx.say]</p><p>You can use the “raw request socket” returned by <code>ngx.req.socket(true)</code> to implement fancy protocols like <a href="http://en.wikipedia.org/wiki/WebSocket" target="_blank" rel="noopener">WebSocket</a>, or just emit your own raw HTTP response header or body data. You can refer to the [lua-resty-websocket library]</p><p>This function was first introduced in the <code>v0.5.0rc1</code> release.</p><h2><span id="ngxexec">ngx.exec</span></h2><p><strong>syntax:</strong> <em>ngx.exec(uri, args?)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*</p><p>Does an internal redirect to <code>uri</code> with <code>args</code> and is similar to the <a href="http://github.com/openresty/echo-nginx-module#echo_exec" target="_blank" rel="noopener">echo_exec</a> directive of the <a href="http://github.com/openresty/echo-nginx-module" target="_blank" rel="noopener">echo-nginx-module</a>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ngx.exec(&apos;/some-location&apos;);</span><br><span class="line">ngx.exec(&apos;/some-location&apos;, &apos;a=3&amp;b=5&amp;c=6&apos;);</span><br><span class="line">ngx.exec(&apos;/some-location?a=3&amp;b=5&apos;, &apos;c=6&apos;);</span><br></pre></td></tr></table></figure><p>The optional second <code>args</code> can be used to specify extra URI query arguments, for example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.exec(&quot;/foo&quot;, &quot;a=3&amp;b=hello%20world&quot;)</span><br></pre></td></tr></table></figure><p>Alternatively, a Lua table can be passed for the <code>args</code> argument for ngx_lua to carry out URI escaping and string concatenation.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.exec(&quot;/foo&quot;, &#123; a = 3, b = &quot;hello world&quot; &#125;)</span><br></pre></td></tr></table></figure><p>The result is exactly the same as the previous example.</p><p>The format for the Lua table passed as the <code>args</code> argument is identical to the format used in the [ngx.encode_args]</p><p>Named locations are also supported but the second <code>args</code> argument will be ignored if present and the querystring for the new target is inherited from the referring location (if any).</p><p><code>GET /foo/file.php?a=hello</code> will return “hello” and not “goodbye” in the example below</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">location /foo &#123;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        ngx.exec(&quot;@bar&quot;, &quot;a=goodbye&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location @bar &#123;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        local args = ngx.req.get_uri_args()</span><br><span class="line">        for key, val in pairs(args) do</span><br><span class="line">            if key == &quot;a&quot; then</span><br><span class="line">                ngx.say(val)</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note that the <code>ngx.exec</code> method is different from [ngx.redirect]</p><p>Also note that this method call terminates the processing of the current request and that it <em>must</em> be called before [ngx.send_headers]</p><p>It is recommended that a coding style that combines this method call with the <code>return</code> statement, i.e., <code>return ngx.exec(...)</code>be adopted when this method call is used in contexts other than [header_filter_by_lua*]</p><h2><span id="ngxredirect">ngx.redirect</span></h2><p><strong>syntax:</strong> <em>ngx.redirect(uri, status?)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*</p><p>Issue an <code>HTTP 301</code> or <code>302</code> redirection to <code>uri</code>.</p><p>The optional <code>status</code> parameter specifies the HTTP status code to be used. The following status codes are supported right now:</p><ul><li><code>301</code></li><li><code>302</code> (default)</li><li><code>303</code></li><li><code>307</code></li><li><code>308</code></li></ul><p>It is <code>302</code> (<code>ngx.HTTP_MOVED_TEMPORARILY</code>) by default.</p><p>Here is an example assuming the current server name is <code>localhost</code> and that it is listening on port 1984:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return ngx.redirect(&quot;/foo&quot;)</span><br></pre></td></tr></table></figure><p>which is equivalent to</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return ngx.redirect(&quot;/foo&quot;, ngx.HTTP_MOVED_TEMPORARILY)</span><br></pre></td></tr></table></figure><p>Redirecting arbitrary external URLs is also supported, for example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return ngx.redirect(&quot;http://www.google.com&quot;)</span><br></pre></td></tr></table></figure><p>We can also use the numerical code directly as the second <code>status</code> argument:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return ngx.redirect(&quot;/foo&quot;, 301)</span><br></pre></td></tr></table></figure><p>This method is similar to the <a href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html#rewrite" target="_blank" rel="noopener">rewrite</a> directive with the <code>redirect</code> modifier in the standard <a href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html" target="_blank" rel="noopener">ngx_http_rewrite_module</a>, for example, this <code>nginx.conf</code> snippet</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rewrite ^ /foo? redirect;  # nginx config</span><br></pre></td></tr></table></figure><p>is equivalent to the following Lua code</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return ngx.redirect(&apos;/foo&apos;);  -- Lua code</span><br></pre></td></tr></table></figure><p>while</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rewrite ^ /foo? permanent;  # nginx config</span><br></pre></td></tr></table></figure><p>is equivalent to</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return ngx.redirect(&apos;/foo&apos;, ngx.HTTP_MOVED_PERMANENTLY)  -- Lua code</span><br></pre></td></tr></table></figure><p>URI arguments can be specified as well, for example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return ngx.redirect(&apos;/foo?a=3&amp;b=4&apos;)</span><br></pre></td></tr></table></figure><p>Note that this method call terminates the processing of the current request and that it <em>must</em> be called before [ngx.send_headers]</p><p>It is recommended that a coding style that combines this method call with the <code>return</code> statement, i.e., <code>return ngx.redirect(...)</code> be adopted when this method call is used in contexts other than [header_filter_by_lua*]</p><h2><span id="ngxsend_headers">ngx.send_headers</span></h2><p><strong>syntax:</strong> <em>ok, err = ngx.send_headers()</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*</p><p>Explicitly send out the response headers.</p><p>Since <code>v0.8.3</code> this function returns <code>1</code> on success, or returns <code>nil</code> and a string describing the error otherwise.</p><p>Note that there is normally no need to manually send out response headers as ngx_lua will automatically send headers out before content is output with [ngx.say]</p><h2><span id="ngxheaders_sent">ngx.headers_sent</span></h2><p><strong>syntax:</strong> <em>value = ngx.headers_sent</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*</p><p>Returns <code>true</code> if the response headers have been sent (by ngx_lua), and <code>false</code> otherwise.</p><p>This API was first introduced in ngx_lua v0.3.1rc6.</p><h2><span id="ngxprint">ngx.print</span></h2><p><strong>syntax:</strong> <em>ok, err = ngx.print(…)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*</p><p>Emits arguments concatenated to the HTTP client (as response body). If response headers have not been sent, this function will send headers out first and then output body data.</p><p>Since <code>v0.8.3</code> this function returns <code>1</code> on success, or returns <code>nil</code> and a string describing the error otherwise.</p><p>Lua <code>nil</code> values will output <code>&quot;nil&quot;</code> strings and Lua boolean values will output <code>&quot;true&quot;</code> and <code>&quot;false&quot;</code> literal strings respectively.</p><p>Nested arrays of strings are permitted and the elements in the arrays will be sent one by one:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">local table = &#123;</span><br><span class="line">    &quot;hello, &quot;,</span><br><span class="line">    &#123;&quot;world: &quot;, true, &quot; or &quot;, false,</span><br><span class="line">        &#123;&quot;: &quot;, nil&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line">ngx.print(table)</span><br></pre></td></tr></table></figure><p>will yield the output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello, world: true or false: nil</span><br></pre></td></tr></table></figure><p>Non-array table arguments will cause a Lua exception to be thrown.</p><p>The <code>ngx.null</code> constant will yield the <code>&quot;null&quot;</code> string output.</p><p>This is an asynchronous call and will return immediately without waiting for all the data to be written into the system send buffer. To run in synchronous mode, call <code>ngx.flush(true)</code> after calling <code>ngx.print</code>. This can be particularly useful for streaming output. See [ngx.flush]</p><p>Please note that both <code>ngx.print</code> and [ngx.say] will always invoke the whole Nginx output body filter chain, which is an expensive operation. So be careful when calling either of these two in a tight loop; buffer the data yourself in Lua and save the calls.</p><h2><span id="ngxsay">ngx.say</span></h2><p><strong>syntax:</strong> <em>ok, err = ngx.say(…)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*</p><p>Just as [ngx.print]</p><h2><span id="ngxlog">ngx.log</span></h2><p><strong>syntax:</strong> <em>ngx.log(log_level, …)</em></p><p><strong>context:</strong> init_by_lua*, init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Log arguments concatenated to error.log with the given logging level.</p><p>Lua <code>nil</code> arguments are accepted and result in literal <code>&quot;nil&quot;</code> string while Lua booleans result in literal <code>&quot;true&quot;</code> or <code>&quot;false&quot;</code>string outputs. And the <code>ngx.null</code> constant will yield the <code>&quot;null&quot;</code> string output.</p><p>The <code>log_level</code> argument can take constants like <code>ngx.ERR</code> and <code>ngx.WARN</code>. Check out [Nginx log level constants]</p><p>There is a hard coded <code>2048</code> byte limitation on error message lengths in the Nginx core. This limit includes trailing newlines and leading time stamps. If the message size exceeds this limit, Nginx will truncate the message text accordingly. This limit can be manually modified by editing the <code>NGX_MAX_ERROR_STR</code> macro definition in the <code>src/core/ngx_log.h</code> file in the Nginx source tree.</p><h2><span id="ngxflush">ngx.flush</span></h2><p><strong>syntax:</strong> <em>ok, err = ngx.flush(wait?)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*</p><p>Flushes response output to the client.</p><p><code>ngx.flush</code> accepts an optional boolean <code>wait</code> argument (Default: <code>false</code>) first introduced in the <code>v0.3.1rc34</code> release. When called with the default argument, it issues an asynchronous call (Returns immediately without waiting for output data to be written into the system send buffer). Calling the function with the <code>wait</code> argument set to <code>true</code> switches to synchronous mode.</p><p>In synchronous mode, the function will not return until all output data has been written into the system send buffer or until the <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#send_timeout" target="_blank" rel="noopener">send_timeout</a> setting has expired. Note that using the Lua coroutine mechanism means that this function does not block the Nginx event loop even in the synchronous mode.</p><p>When <code>ngx.flush(true)</code> is called immediately after [ngx.print]</p><p>Note that <code>ngx.flush</code> is not functional when in the HTTP 1.0 output buffering mode. See [HTTP 1.0 support]</p><p>Since <code>v0.8.3</code> this function returns <code>1</code> on success, or returns <code>nil</code> and a string describing the error otherwise.</p><h2><span id="ngxexit">ngx.exit</span></h2><p><strong>syntax:</strong> <em>ngx.exit(status)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>When <code>status &gt;= 200</code> (i.e., <code>ngx.HTTP_OK</code> and above), it will interrupt the execution of the current request and return status code to nginx.</p><p>When <code>status == 0</code> (i.e., <code>ngx.OK</code>), it will only quit the current phase handler (or the content handler if the [content_by_lua*]</p><p>The <code>status</code> argument can be <code>ngx.OK</code>, <code>ngx.ERROR</code>, <code>ngx.HTTP_NOT_FOUND</code>, <code>ngx.HTTP_MOVED_TEMPORARILY</code>, or other [HTTP status constants]</p><p>To return an error page with custom contents, use code snippets like this:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ngx.status = ngx.HTTP_GONE</span><br><span class="line">ngx.say(&quot;This is our own content&quot;)</span><br><span class="line">-- to cause quit the whole request rather than the current phase handler</span><br><span class="line">ngx.exit(ngx.HTTP_OK)</span><br></pre></td></tr></table></figure><p>The effect in action:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ curl -i http://localhost/test</span><br><span class="line">HTTP/1.1 410 Gone</span><br><span class="line">Server: nginx/1.0.6</span><br><span class="line">Date: Thu, 15 Sep 2011 00:51:48 GMT</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">This is our own content</span><br></pre></td></tr></table></figure><p>Number literals can be used directly as the argument, for instance,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.exit(501)</span><br></pre></td></tr></table></figure><p>Note that while this method accepts all [HTTP status constants]</p><p>Also note that this method call terminates the processing of the current request and that it is recommended that a coding style that combines this method call with the <code>return</code> statement, i.e., <code>return ngx.exit(...)</code> be used to reinforce the fact that the request processing is being terminated.</p><p>When being used in the contexts of [header_filter_by_lua*]</p><h2><span id="ngxeof">ngx.eof</span></h2><p><strong>syntax:</strong> <em>ok, err = ngx.eof()</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*</p><p>Explicitly specify the end of the response output stream. In the case of HTTP 1.1 chunked encoded output, it will just trigger the Nginx core to send out the “last chunk”.</p><p>When you disable the HTTP 1.1 keep-alive feature for your downstream connections, you can rely on well written HTTP clients to close the connection actively for you when you call this method. This trick can be used do back-ground jobs without letting the HTTP clients to wait on the connection, as in the following example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location = /async &#123;</span><br><span class="line">    keepalive_timeout 0;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        ngx.say(&quot;got the task!&quot;)</span><br><span class="line">        ngx.eof()  -- well written HTTP clients will close the connection at this point</span><br><span class="line">        -- access MySQL, PostgreSQL, Redis, Memcached, and etc here...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>But if you create subrequests to access other locations configured by Nginx upstream modules, then you should configure those upstream modules to ignore client connection abortions if they are not by default. For example, by default the standard <a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html" target="_blank" rel="noopener">ngx_http_proxy_module</a> will terminate both the subrequest and the main request as soon as the client closes the connection, so it is important to turn on the <a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_ignore_client_abort" target="_blank" rel="noopener">proxy_ignore_client_abort</a> directive in your location block configured by <a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html" target="_blank" rel="noopener">ngx_http_proxy_module</a>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy_ignore_client_abort on;</span><br></pre></td></tr></table></figure><p>A better way to do background jobs is to use the [ngx.timer.at]</p><p>Since <code>v0.8.3</code> this function returns <code>1</code> on success, or returns <code>nil</code> and a string describing the error otherwise.</p><h2><span id="ngxsleep">ngx.sleep</span></h2><p><strong>syntax:</strong> <em>ngx.sleep(seconds)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p><p>Sleeps for the specified seconds without blocking. One can specify time resolution up to 0.001 seconds (i.e., one milliseconds).</p><p>Behind the scene, this method makes use of the Nginx timers.</p><p>Since the <code>0.7.20</code> release, The <code>0</code> time argument can also be specified.</p><p>This method was introduced in the <code>0.5.0rc30</code> release.</p><h2><span id="ngxescape_uri">ngx.escape_uri</span></h2><p><strong>syntax:</strong> <em>newstr = ngx.escape_uri(str)</em></p><p><strong>context:</strong> init_by_lua*, init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Escape <code>str</code> as a URI component.</p><h2><span id="ngxunescape_uri">ngx.unescape_uri</span></h2><p><strong>syntax:</strong> <em>newstr = ngx.unescape_uri(str)</em></p><p><strong>context:</strong> init_by_lua*, init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*</p><p>Unescape <code>str</code> as an escaped URI component.</p><p>For example,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.say(ngx.unescape_uri(&quot;b%20r56+7&quot;))</span><br></pre></td></tr></table></figure><p>gives the output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b r56 7</span><br></pre></td></tr></table></figure><h2><span id="ngxencode_args">ngx.encode_args</span></h2><p><strong>syntax:</strong> <em>str = ngx.encode_args(table)</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*</p><p>Encode the Lua table to a query args string according to the URI encoded rules.</p><p>For example,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.encode_args(&#123;foo = 3, [&quot;b r&quot;] = &quot;hello world&quot;&#125;)</span><br></pre></td></tr></table></figure><p>yields</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo=3&amp;b%20r=hello%20world</span><br></pre></td></tr></table></figure><p>The table keys must be Lua strings.</p><p>Multi-value query args are also supported. Just use a Lua table for the argument’s value, for example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.encode_args(&#123;baz = &#123;32, &quot;hello&quot;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>gives</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">baz=32&amp;baz=hello</span><br></pre></td></tr></table></figure><p>If the value table is empty and the effect is equivalent to the <code>nil</code> value.</p><p>Boolean argument values are also supported, for instance,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.encode_args(&#123;a = true, b = 1&#125;)</span><br></pre></td></tr></table></figure><p>yields</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a&amp;b=1</span><br></pre></td></tr></table></figure><p>If the argument value is <code>false</code>, then the effect is equivalent to the <code>nil</code> value.</p><p>This method was first introduced in the <code>v0.3.1rc27</code> release.</p><h2><span id="ngxdecode_args">ngx.decode_args</span></h2><p><strong>syntax:</strong> <em>table, err = ngx.decode_args(str, max_args?)</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Decodes a URI encoded query-string into a Lua table. This is the inverse function of [ngx.encode_args]</p><p>The optional <code>max_args</code> argument can be used to specify the maximum number of arguments parsed from the <code>str</code>argument. By default, a maximum of 100 request arguments are parsed (including those with the same name) and that additional URI arguments are silently discarded to guard against potential denial of service attacks. Since <code>v0.10.13</code>, when the limit is exceeded, it will return a second value which is the string <code>&quot;truncated&quot;</code>.</p><p>This argument can be set to zero to remove the limit and to process all request arguments received:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">local args = ngx.decode_args(str, 0)</span><br></pre></td></tr></table></figure><p>Removing the <code>max_args</code> cap is strongly discouraged.</p><p>This method was introduced in the <code>v0.5.0rc29</code>.</p><h2><span id="ngxencode_base64">ngx.encode_base64</span></h2><p><strong>syntax:</strong> <em>newstr = ngx.encode_base64(str, no_padding?)</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Encodes <code>str</code> to a base64 digest.</p><p>Since the <code>0.9.16</code> release, an optional boolean-typed <code>no_padding</code> argument can be specified to control whether the base64 padding should be appended to the resulting digest (default to <code>false</code>, i.e., with padding enabled).</p><h2><span id="ngxdecode_base64">ngx.decode_base64</span></h2><p><strong>syntax:</strong> <em>newstr = ngx.decode_base64(str)</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Decodes the <code>str</code> argument as a base64 digest to the raw form. Returns <code>nil</code> if <code>str</code> is not well formed.</p><h2><span id="ngxcrc32_short">ngx.crc32_short</span></h2><p><strong>syntax:</strong> <em>intval = ngx.crc32_short(str)</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Calculates the CRC-32 (Cyclic Redundancy Code) digest for the <code>str</code> argument.</p><p>This method performs better on relatively short <code>str</code> inputs (i.e., less than 30 ~ 60 bytes), as compared to [ngx.crc32_long]</p><p>Behind the scene, it is just a thin wrapper around the <code>ngx_crc32_short</code> function defined in the Nginx core.</p><p>This API was first introduced in the <code>v0.3.1rc8</code> release.</p><h2><span id="ngxcrc32_long">ngx.crc32_long</span></h2><p><strong>syntax:</strong> <em>intval = ngx.crc32_long(str)</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Calculates the CRC-32 (Cyclic Redundancy Code) digest for the <code>str</code> argument.</p><p>This method performs better on relatively long <code>str</code> inputs (i.e., longer than 30 ~ 60 bytes), as compared to [ngx.crc32_short]</p><p>Behind the scene, it is just a thin wrapper around the <code>ngx_crc32_long</code> function defined in the Nginx core.</p><p>This API was first introduced in the <code>v0.3.1rc8</code> release.</p><h2><span id="ngxhmac_sha1">ngx.hmac_sha1</span></h2><p><strong>syntax:</strong> <em>digest = ngx.hmac_sha1(secret_key, str)</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Computes the <a href="http://en.wikipedia.org/wiki/HMAC" target="_blank" rel="noopener">HMAC-SHA1</a> digest of the argument <code>str</code> and turns the result using the secret key <code>&lt;secret_key&gt;</code>.</p><p>The raw binary form of the <code>HMAC-SHA1</code> digest will be generated, use [ngx.encode_base64]</p><p>For example,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">local key = &quot;thisisverysecretstuff&quot;</span><br><span class="line">local src = &quot;some string we want to sign&quot;</span><br><span class="line">local digest = ngx.hmac_sha1(key, src)</span><br><span class="line">ngx.say(ngx.encode_base64(digest))</span><br></pre></td></tr></table></figure><p>yields the output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R/pvxzHC4NLtj7S+kXFg/NePTmk=</span><br></pre></td></tr></table></figure><p>This API requires the OpenSSL library enabled in the Nginx build (usually by passing the <code>--with-http_ssl_module</code> option to the <code>./configure</code> script).</p><p>This function was first introduced in the <code>v0.3.1rc29</code> release.</p><h2><span id="ngxmd5">ngx.md5</span></h2><p><strong>syntax:</strong> <em>digest = ngx.md5(str)</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Returns the hexadecimal representation of the MD5 digest of the <code>str</code> argument.</p><p>For example,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location = /md5 &#123;</span><br><span class="line">    content_by_lua_block &#123; ngx.say(ngx.md5(&quot;hello&quot;)) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>yields the output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5d41402abc4b2a76b9719d911017c592</span><br></pre></td></tr></table></figure><p>See [ngx.md5_bin]</p><h2><span id="ngxmd5_bin">ngx.md5_bin</span></h2><p><strong>syntax:</strong> <em>digest = ngx.md5_bin(str)</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Returns the binary form of the MD5 digest of the <code>str</code> argument.</p><p>See [ngx.md5]</p><h2><span id="ngxsha1_bin">ngx.sha1_bin</span></h2><p><strong>syntax:</strong> <em>digest = ngx.sha1_bin(str)</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Returns the binary form of the SHA-1 digest of the <code>str</code> argument.</p><p>This function requires SHA-1 support in the Nginx build. (This usually just means OpenSSL should be installed while building Nginx).</p><p>This function was first introduced in the <code>v0.5.0rc6</code>.</p><h2><span id="ngxquote_sql_str">ngx.quote_sql_str</span></h2><p><strong>syntax:</strong> <em>quoted_value = ngx.quote_sql_str(raw_value)</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Returns a quoted SQL string literal according to the MySQL quoting rules.</p><h2><span id="ngxtoday">ngx.today</span></h2><p><strong>syntax:</strong> <em>str = ngx.today()</em></p><p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Returns current date (in the format <code>yyyy-mm-dd</code>) from the nginx cached time (no syscall involved unlike Lua’s date library).</p><p>This is the local time.</p><h2><span id="ngxtime">ngx.time</span></h2><p><strong>syntax:</strong> <em>secs = ngx.time()</em></p><p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Returns the elapsed seconds from the epoch for the current time stamp from the nginx cached time (no syscall involved unlike Lua’s date library).</p><p>Updates of the Nginx time cache can be forced by calling [ngx.update_time]</p><h2><span id="ngxnow">ngx.now</span></h2><p><strong>syntax:</strong> <em>secs = ngx.now()</em></p><p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Returns a floating-point number for the elapsed time in seconds (including milliseconds as the decimal part) from the epoch for the current time stamp from the nginx cached time (no syscall involved unlike Lua’s date library).</p><p>You can forcibly update the Nginx time cache by calling [ngx.update_time]</p><p>This API was first introduced in <code>v0.3.1rc32</code>.</p><h2><span id="ngxupdate_time">ngx.update_time</span></h2><p><strong>syntax:</strong> <em>ngx.update_time()</em></p><p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Forcibly updates the Nginx current time cache. This call involves a syscall and thus has some overhead, so do not abuse it.</p><p>This API was first introduced in <code>v0.3.1rc32</code>.</p><h2><span id="ngxlocaltime">ngx.localtime</span></h2><p><strong>syntax:</strong> <em>str = ngx.localtime()</em></p><p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Returns the current time stamp (in the format <code>yyyy-mm-dd hh:mm:ss</code>) of the nginx cached time (no syscall involved unlike Lua’s <a href="http://www.lua.org/manual/5.1/manual.html#pdf-os.date" target="_blank" rel="noopener">os.date</a> function).</p><p>This is the local time.</p><h2><span id="ngxutctime">ngx.utctime</span></h2><p><strong>syntax:</strong> <em>str = ngx.utctime()</em></p><p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Returns the current time stamp (in the format <code>yyyy-mm-dd hh:mm:ss</code>) of the nginx cached time (no syscall involved unlike Lua’s <a href="http://www.lua.org/manual/5.1/manual.html#pdf-os.date" target="_blank" rel="noopener">os.date</a> function).</p><p>This is the UTC time.</p><h2><span id="ngxcookie_time">ngx.cookie_time</span></h2><p><strong>syntax:</strong> <em>str = ngx.cookie_time(sec)</em></p><p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Returns a formatted string can be used as the cookie expiration time. The parameter <code>sec</code> is the time stamp in seconds (like those returned from [ngx.time]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ngx.say(ngx.cookie_time(1290079655))</span><br><span class="line">    -- yields &quot;Thu, 18-Nov-10 11:27:35 GMT&quot;</span><br></pre></td></tr></table></figure><h2><span id="ngxhttp_time">ngx.http_time</span></h2><p><strong>syntax:</strong> <em>str = ngx.http_time(sec)</em></p><p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Returns a formated string can be used as the http header time (for example, being used in <code>Last-Modified</code> header). The parameter <code>sec</code> is the time stamp in seconds (like those returned from [ngx.time]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ngx.say(ngx.http_time(1290079655))</span><br><span class="line">    -- yields &quot;Thu, 18 Nov 2010 11:27:35 GMT&quot;</span><br></pre></td></tr></table></figure><h2><span id="ngxparse_http_time">ngx.parse_http_time</span></h2><p><strong>syntax:</strong> <em>sec = ngx.parse_http_time(str)</em></p><p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Parse the http time string (as returned by [ngx.http_time]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">local time = ngx.parse_http_time(&quot;Thu, 18 Nov 2010 11:27:35 GMT&quot;)</span><br><span class="line">if time == nil then</span><br><span class="line">    ...</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2><span id="ngxis_subrequest">ngx.is_subrequest</span></h2><p><strong>syntax:</strong> <em>value = ngx.is_subrequest</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*</p><p>Returns <code>true</code> if the current request is an nginx subrequest, or <code>false</code> otherwise.</p><h2><span id="ngxrematch">ngx.re.match</span></h2><p><strong>syntax:</strong> <em>captures, err = ngx.re.match(subject, regex, options?, ctx?, res_table?)</em></p><p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Matches the <code>subject</code> string using the Perl compatible regular expression <code>regex</code> with the optional <code>options</code>.</p><p>Only the first occurrence of the match is returned, or <code>nil</code> if no match is found. In case of errors, like seeing a bad regular expression or exceeding the PCRE stack limit, <code>nil</code> and a string describing the error will be returned.</p><p>When a match is found, a Lua table <code>captures</code> is returned, where <code>captures[0]</code> holds the whole substring being matched, and <code>captures[1]</code> holds the first parenthesized sub-pattern’s capturing, <code>captures[2]</code> the second, and so on.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">local m, err = ngx.re.match(&quot;hello, 1234&quot;, &quot;[0-9]+&quot;)</span><br><span class="line">if m then</span><br><span class="line">    -- m[0] == &quot;1234&quot;</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line">    if err then</span><br><span class="line">        ngx.log(ngx.ERR, &quot;error: &quot;, err)</span><br><span class="line">        return</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    ngx.say(&quot;match not found&quot;)</span><br><span class="line">end</span><br><span class="line">local m, err = ngx.re.match(&quot;hello, 1234&quot;, &quot;([0-9])[0-9]+&quot;)</span><br><span class="line">-- m[0] == &quot;1234&quot;</span><br><span class="line">-- m[1] == &quot;1&quot;</span><br></pre></td></tr></table></figure><p>Named captures are also supported since the <code>v0.7.14</code> release and are returned in the same Lua table as key-value pairs as the numbered captures.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">local m, err = ngx.re.match(&quot;hello, 1234&quot;, &quot;([0-9][$1]?&lt;remaining&gt;[0-9]+)&quot;)</span><br><span class="line">-- m[0] == &quot;1234&quot;</span><br><span class="line">-- m[1] == &quot;1&quot;</span><br><span class="line">-- m[2] == &quot;234&quot;</span><br><span class="line">-- m[&quot;remaining&quot;] == &quot;234&quot;</span><br></pre></td></tr></table></figure><p>Unmatched subpatterns will have <code>false</code> values in their <code>captures</code> table fields.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">local m, err = ngx.re.match(&quot;hello, world&quot;, &quot;(world)|(hello)|(?&lt;named&gt;howdy)&quot;)</span><br><span class="line">-- m[0] == &quot;hello&quot;</span><br><span class="line">-- m[1] == false</span><br><span class="line">-- m[2] == &quot;hello&quot;</span><br><span class="line">-- m[3] == false</span><br><span class="line">-- m[&quot;named&quot;] == false</span><br></pre></td></tr></table></figure><p>Specify <code>options</code> to control how the match operation will be performed. The following option characters are supported:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">a             anchored mode (only match from the beginning)</span><br><span class="line"></span><br><span class="line">d             enable the DFA mode (or the longest token match semantics).</span><br><span class="line">              this requires PCRE 6.0+ or else a Lua exception will be thrown.</span><br><span class="line">              first introduced in ngx_lua v0.3.1rc30.</span><br><span class="line"></span><br><span class="line">D             enable duplicate named pattern support. This allows named</span><br><span class="line">              subpattern names to be repeated, returning the captures in</span><br><span class="line">              an array-like Lua table. for example,</span><br><span class="line">                local m = ngx.re.match(&quot;hello, world&quot;,</span><br><span class="line">                                       &quot;(?&lt;named&gt;\w+), (?&lt;named&gt;\w+)&quot;,</span><br><span class="line">                                       &quot;D&quot;)</span><br><span class="line">                -- m[&quot;named&quot;] == &#123;&quot;hello&quot;, &quot;world&quot;&#125;</span><br><span class="line">              this option was first introduced in the v0.7.14 release.</span><br><span class="line">              this option requires at least PCRE 8.12.</span><br><span class="line"></span><br><span class="line">i             case insensitive mode (similar to Perl&apos;s /i modifier)</span><br><span class="line"></span><br><span class="line">j             enable PCRE JIT compilation, this requires PCRE 8.21+ which</span><br><span class="line">              must be built with the --enable-jit option. for optimum performance,</span><br><span class="line">              this option should always be used together with the &apos;o&apos; option.</span><br><span class="line">              first introduced in ngx_lua v0.3.1rc30.</span><br><span class="line"></span><br><span class="line">J             enable the PCRE Javascript compatible mode. this option was</span><br><span class="line">              first introduced in the v0.7.14 release. this option requires</span><br><span class="line">              at least PCRE 8.12.</span><br><span class="line"></span><br><span class="line">m             multi-line mode (similar to Perl&apos;s /m modifier)</span><br><span class="line"></span><br><span class="line">o             compile-once mode (similar to Perl&apos;s /o modifier),</span><br><span class="line">              to enable the worker-process-level compiled-regex cache</span><br><span class="line"></span><br><span class="line">s             single-line mode (similar to Perl&apos;s /s modifier)</span><br><span class="line"></span><br><span class="line">u             UTF-8 mode. this requires PCRE to be built with</span><br><span class="line">              the --enable-utf8 option or else a Lua exception will be thrown.</span><br><span class="line"></span><br><span class="line">U             similar to &quot;u&quot; but disables PCRE&apos;s UTF-8 validity check on</span><br><span class="line">              the subject string. first introduced in ngx_lua v0.8.1.</span><br><span class="line"></span><br><span class="line">x             extended mode (similar to Perl&apos;s /x modifier)</span><br></pre></td></tr></table></figure><p>These options can be combined:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">local m, err = ngx.re.match(&quot;hello, world&quot;, &quot;HEL LO&quot;, &quot;ix&quot;)</span><br><span class="line">-- m[0] == &quot;hello&quot;</span><br><span class="line">local m, err = ngx.re.match(&quot;hello, 美好生活&quot;, &quot;HELLO, (.&#123;2&#125;)&quot;, &quot;iu&quot;)</span><br><span class="line">-- m[0] == &quot;hello, 美好&quot;</span><br><span class="line">-- m[1] == &quot;美好&quot;</span><br></pre></td></tr></table></figure><p>The <code>o</code> option is useful for performance tuning, because the regex pattern in question will only be compiled once, cached in the worker-process level, and shared among all requests in the current Nginx worker process. The upper limit of the regex cache can be tuned via the [lua_regex_cache_max_entries]</p><p>The optional fourth argument, <code>ctx</code>, can be a Lua table holding an optional <code>pos</code> field. When the <code>pos</code> field in the <code>ctx</code> table argument is specified, <code>ngx.re.match</code> will start matching from that offset (starting from 1). Regardless of the presence of the <code>pos</code> field in the <code>ctx</code> table, <code>ngx.re.match</code> will always set this <code>pos</code> field to the position <em>after</em> the substring matched by the whole pattern in case of a successful match. When match fails, the <code>ctx</code> table will be left intact.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">local ctx = &#123;&#125;</span><br><span class="line">local m, err = ngx.re.match(&quot;1234, hello&quot;, &quot;[0-9]+&quot;, &quot;&quot;, ctx)</span><br><span class="line">     -- m[0] = &quot;1234&quot;</span><br><span class="line">     -- ctx.pos == 5</span><br><span class="line">local ctx = &#123; pos = 2 &#125;</span><br><span class="line">local m, err = ngx.re.match(&quot;1234, hello&quot;, &quot;[0-9]+&quot;, &quot;&quot;, ctx)</span><br><span class="line">     -- m[0] = &quot;234&quot;</span><br><span class="line">     -- ctx.pos == 5</span><br></pre></td></tr></table></figure><p>The <code>ctx</code> table argument combined with the <code>a</code> regex modifier can be used to construct a lexer atop <code>ngx.re.match</code>.</p><p>Note that, the <code>options</code> argument is not optional when the <code>ctx</code> argument is specified and that the empty Lua string (<code>&quot;&quot;</code>) must be used as placeholder for <code>options</code> if no meaningful regex options are required.</p><p>This method requires the PCRE library enabled in Nginx. ([Known Issue With Special Escaping Sequences]</p><p>To confirm that PCRE JIT is enabled, activate the Nginx debug log by adding the <code>--with-debug</code> option to Nginx or OpenResty’s <code>./configure</code> script. Then, enable the “debug” error log level in <code>error_log</code> directive. The following message will be generated if PCRE JIT is enabled:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pcre JIT compiling result: 1</span><br></pre></td></tr></table></figure><p>Starting from the <code>0.9.4</code> release, this function also accepts a 5th argument, <code>res_table</code>, for letting the caller supply the Lua table used to hold all the capturing results. Starting from <code>0.9.6</code>, it is the caller’s responsibility to ensure this table is empty. This is very useful for recycling Lua tables and saving GC and table allocation overhead.</p><p>This feature was introduced in the <code>v0.2.1rc11</code> release.</p><h2><span id="ngxrefind">ngx.re.find</span></h2><p><strong>syntax:</strong> <em>from, to, err = ngx.re.find(subject, regex, options?, ctx?, nth?)</em></p><p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Similar to [ngx.re.match]</p><p>In case of errors (like bad regexes or any PCRE runtime errors), this API function returns two <code>nil</code> values followed by a string describing the error.</p><p>If no match is found, this function just returns a <code>nil</code> value.</p><p>Below is an example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">local s = &quot;hello, 1234&quot;</span><br><span class="line">local from, to, err = ngx.re.find(s, &quot;([0-9]+)&quot;, &quot;jo&quot;)</span><br><span class="line">if from then</span><br><span class="line">    ngx.say(&quot;from: &quot;, from)</span><br><span class="line">    ngx.say(&quot;to: &quot;, to)</span><br><span class="line">    ngx.say(&quot;matched: &quot;, string.sub(s, from, to))</span><br><span class="line">else</span><br><span class="line">    if err then</span><br><span class="line">        ngx.say(&quot;error: &quot;, err)</span><br><span class="line">        return</span><br><span class="line">    end</span><br><span class="line">    ngx.say(&quot;not matched!&quot;)</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>This example produces the output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from: 8</span><br><span class="line">to: 11</span><br><span class="line">matched: 1234</span><br></pre></td></tr></table></figure><p>Because this API function does not create new Lua strings nor new Lua tables, it is much faster than [ngx.re.match]</p><p>Since the <code>0.9.3</code> release, an optional 5th argument, <code>nth</code>, is supported to specify which (submatch) capture’s indexes to return. When <code>nth</code> is 0 (which is the default), the indexes for the whole matched substring is returned; when <code>nth</code> is 1, then the 1st submatch capture’s indexes are returned; when <code>nth</code> is 2, then the 2nd submatch capture is returned, and so on. When the specified submatch does not have a match, then two <code>nil</code> values will be returned. Below is an example for this:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">local str = &quot;hello, 1234&quot;</span><br><span class="line">local from, to = ngx.re.find(str, &quot;([0-9][$1][0-9]+)&quot;, &quot;jo&quot;, nil, 2)</span><br><span class="line">if from then</span><br><span class="line">    ngx.say(&quot;matched 2nd submatch: &quot;, string.sub(str, from, to))  -- yields &quot;234&quot;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>This API function was first introduced in the <code>v0.9.2</code> release.</p><h2><span id="ngxregmatch">ngx.re.gmatch</span></h2><p><strong>syntax:</strong> <em>iterator, err = ngx.re.gmatch(subject, regex, options?)</em></p><p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Similar to [ngx.re.match]</p><p>In case of errors, like seeing an ill-formed regular expression, <code>nil</code> and a string describing the error will be returned.</p><p>Here is a small example to demonstrate its basic usage:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">local iterator, err = ngx.re.gmatch(&quot;hello, world!&quot;, &quot;([a-z]+)&quot;, &quot;i&quot;)</span><br><span class="line">if not iterator then</span><br><span class="line">    ngx.log(ngx.ERR, &quot;error: &quot;, err)</span><br><span class="line">    return</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">local m</span><br><span class="line">m, err = iterator()    -- m[0] == m[1] == &quot;hello&quot;</span><br><span class="line">if err then</span><br><span class="line">    ngx.log(ngx.ERR, &quot;error: &quot;, err)</span><br><span class="line">    return</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">m, err = iterator()    -- m[0] == m[1] == &quot;world&quot;</span><br><span class="line">if err then</span><br><span class="line">    ngx.log(ngx.ERR, &quot;error: &quot;, err)</span><br><span class="line">    return</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">m, err = iterator()    -- m == nil</span><br><span class="line">if err then</span><br><span class="line">    ngx.log(ngx.ERR, &quot;error: &quot;, err)</span><br><span class="line">    return</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>More often we just put it into a Lua loop:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">local it, err = ngx.re.gmatch(&quot;hello, world!&quot;, &quot;([a-z]+)&quot;, &quot;i&quot;)</span><br><span class="line">if not it then</span><br><span class="line">    ngx.log(ngx.ERR, &quot;error: &quot;, err)</span><br><span class="line">    return</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">while true do</span><br><span class="line">    local m, err = it()</span><br><span class="line">    if err then</span><br><span class="line">        ngx.log(ngx.ERR, &quot;error: &quot;, err)</span><br><span class="line">        return</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    if not m then</span><br><span class="line">        -- no match found (any more)</span><br><span class="line">        break</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    -- found a match</span><br><span class="line">    ngx.say(m[0])</span><br><span class="line">    ngx.say(m[1])</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>The optional <code>options</code> argument takes exactly the same semantics as the [ngx.re.match]</p><p>The current implementation requires that the iterator returned should only be used in a single request. That is, one should <em>not</em>assign it to a variable belonging to persistent namespace like a Lua package.</p><p>This method requires the PCRE library enabled in Nginx. ([Known Issue With Special Escaping Sequences]</p><p>This feature was first introduced in the <code>v0.2.1rc12</code> release.</p><h2><span id="ngxresub">ngx.re.sub</span></h2><p><strong>syntax:</strong> <em>newstr, n, err = ngx.re.sub(subject, regex, replace, options?)</em></p><p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Substitutes the first match of the Perl compatible regular expression <code>regex</code> on the <code>subject</code> argument string with the string or function argument <code>replace</code>. The optional <code>options</code> argument has exactly the same meaning as in [ngx.re.match]</p><p>This method returns the resulting new string as well as the number of successful substitutions. In case of failures, like syntax errors in the regular expressions or the <code>&lt;replace&gt;</code> string argument, it will return <code>nil</code> and a string describing the error.</p><p>When the <code>replace</code> is a string, then it is treated as a special template for string replacement. For example,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">local newstr, n, err = ngx.re.sub(&quot;hello, 1234&quot;, &quot;([0-9])[0-9]&quot;, &quot;[$0][$1]&quot;)</span><br><span class="line">if newstr then</span><br><span class="line">    -- newstr == &quot;hello, [12][1]34&quot;</span><br><span class="line">    -- n == 1</span><br><span class="line">else</span><br><span class="line">    ngx.log(ngx.ERR, &quot;error: &quot;, err)</span><br><span class="line">    return</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>where <code>$0</code> referring to the whole substring matched by the pattern and <code>$1</code> referring to the first parenthesized capturing substring.</p><p>Curly braces can also be used to disambiguate variable names from the background string literals:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">local newstr, n, err = ngx.re.sub(&quot;hello, 1234&quot;, &quot;[0-9]&quot;, &quot;$&#123;0&#125;00&quot;)</span><br><span class="line">    -- newstr == &quot;hello, 100234&quot;</span><br><span class="line">    -- n == 1</span><br></pre></td></tr></table></figure><p>Literal dollar sign characters (<code>$</code>) in the <code>replace</code> string argument can be escaped by another dollar sign, for instance,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">local newstr, n, err = ngx.re.sub(&quot;hello, 1234&quot;, &quot;[0-9]&quot;, &quot;$$&quot;)</span><br><span class="line">    -- newstr == &quot;hello, $234&quot;</span><br><span class="line">    -- n == 1</span><br></pre></td></tr></table></figure><p>Do not use backlashes to escape dollar signs; it will not work as expected.</p><p>When the <code>replace</code> argument is of type “function”, then it will be invoked with the “match table” as the argument to generate the replace string literal for substitution. The “match table” fed into the <code>replace</code> function is exactly the same as the return value of [ngx.re.match]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">local func = function (m)</span><br><span class="line">    return &quot;[&quot; .. m[0] .. &quot;][&quot; .. m[1] .. &quot;]&quot;</span><br><span class="line">end</span><br><span class="line">local newstr, n, err = ngx.re.sub(&quot;hello, 1234&quot;, &quot;( [0-9] ) [0-9]&quot;, func, &quot;x&quot;)</span><br><span class="line">    -- newstr == &quot;hello, [12][1]34&quot;</span><br><span class="line">    -- n == 1</span><br></pre></td></tr></table></figure><p>The dollar sign characters in the return value of the <code>replace</code> function argument are not special at all.</p><p>This method requires the PCRE library enabled in Nginx. ([Known Issue With Special Escaping Sequences]</p><p>This feature was first introduced in the <code>v0.2.1rc13</code> release.</p><h2><span id="ngxregsub">ngx.re.gsub</span></h2><p><strong>syntax:</strong> <em>newstr, n, err = ngx.re.gsub(subject, regex, replace, options?)</em></p><p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Just like [ngx.re.sub]</p><p>Here is some examples:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">local newstr, n, err = ngx.re.gsub(&quot;hello, world&quot;, &quot;([a-z])[a-z]+&quot;, &quot;[$0,$1]&quot;, &quot;i&quot;)</span><br><span class="line">if newstr then</span><br><span class="line">    -- newstr == &quot;[hello,h], [world,w]&quot;</span><br><span class="line">    -- n == 2</span><br><span class="line">else</span><br><span class="line">    ngx.log(ngx.ERR, &quot;error: &quot;, err)</span><br><span class="line">    return</span><br><span class="line">end</span><br><span class="line">local func = function (m)</span><br><span class="line">    return &quot;[&quot; .. m[0] .. &quot;,&quot; .. m[1] .. &quot;]&quot;</span><br><span class="line">end</span><br><span class="line">local newstr, n, err = ngx.re.gsub(&quot;hello, world&quot;, &quot;([a-z])[a-z]+&quot;, func, &quot;i&quot;)</span><br><span class="line">    -- newstr == &quot;[hello,h], [world,w]&quot;</span><br><span class="line">    -- n == 2</span><br></pre></td></tr></table></figure><p>This method requires the PCRE library enabled in Nginx. ([Known Issue With Special Escaping Sequences]</p><p>This feature was first introduced in the <code>v0.2.1rc15</code> release.</p><h2><span id="ngxshareddict">ngx.shared.DICT</span></h2><p><strong>syntax:</strong> <em>dict = ngx.shared.DICT</em></p><p><strong>syntax:</strong> <em>dict = ngx.shared[name_var]</em></p><p><strong>context:</strong> init_by_lua*, init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Fetching the shm-based Lua dictionary object for the shared memory zone named <code>DICT</code> defined by the [lua_shared_dict]</p><p>Shared memory zones are always shared by all the nginx worker processes in the current nginx server instance.</p><p>The resulting object <code>dict</code> has the following methods:</p><ul><li>[get]</li><li>[get_stale]</li><li>[set]</li><li>[safe_set]</li><li>[add]</li><li>[safe_add]</li><li>[replace]</li><li>[delete]</li><li>[incr]</li><li>[lpush]</li><li>[rpush]</li><li>[lpop]</li><li>[rpop]</li><li>[llen]</li><li>[ttl]</li><li>[expire]</li><li>[flush_all]</li><li>[flush_expired]</li><li>[get_keys]</li><li>[capacity]</li><li>[free_space]</li></ul><p>All these methods are <em>atomic</em> operations, that is, safe from concurrent accesses from multiple nginx worker processes for the same <code>lua_shared_dict</code> zone.</p><p>Here is an example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    lua_shared_dict dogs 10m;</span><br><span class="line">    server &#123;</span><br><span class="line">        location /set &#123;</span><br><span class="line">            content_by_lua_block &#123;</span><br><span class="line">                local dogs = ngx.shared.dogs</span><br><span class="line">                dogs:set(&quot;Jim&quot;, 8)</span><br><span class="line">                ngx.say(&quot;STORED&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        location /get &#123;</span><br><span class="line">            content_by_lua_block &#123;</span><br><span class="line">                local dogs = ngx.shared.dogs</span><br><span class="line">                ngx.say(dogs:get(&quot;Jim&quot;))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Let us test it:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ curl localhost/set</span><br><span class="line">STORED</span><br><span class="line"></span><br><span class="line">$ curl localhost/get</span><br><span class="line">8</span><br><span class="line"></span><br><span class="line">$ curl localhost/get</span><br><span class="line">8</span><br></pre></td></tr></table></figure><p>The number <code>8</code> will be consistently output when accessing <code>/get</code> regardless of how many Nginx workers there are because the <code>dogs</code> dictionary resides in the shared memory and visible to <em>all</em> of the worker processes.</p><p>The shared dictionary will retain its contents through a server config reload (either by sending the <code>HUP</code> signal to the Nginx process or by using the <code>-s reload</code> command-line option).</p><p>The contents in the dictionary storage will be lost, however, when the Nginx server quits.</p><p>This feature was first introduced in the <code>v0.3.1rc22</code> release.</p><h2><span id="ngxshareddictget">ngx.shared.DICT.get</span></h2><p><strong>syntax:</strong> <em>value, flags = ngx.shared.DICT:get(key)</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Retrieving the value in the dictionary [ngx.shared.DICT]</p><p>In case of errors, <code>nil</code> and a string describing the error will be returned.</p><p>The value returned will have the original data type when they were inserted into the dictionary, for example, Lua booleans, numbers, or strings.</p><p>The first argument to this method must be the dictionary object itself, for example,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local cats = ngx.shared.cats</span><br><span class="line">local value, flags = cats.get(cats, &quot;Marry&quot;)</span><br></pre></td></tr></table></figure><p>or use Lua’s syntactic sugar for method calls:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local cats = ngx.shared.cats</span><br><span class="line">local value, flags = cats:get(&quot;Marry&quot;)</span><br></pre></td></tr></table></figure><p>These two forms are fundamentally equivalent.</p><p>If the user flags is <code>0</code> (the default), then no flags value will be returned.</p><p>This feature was first introduced in the <code>v0.3.1rc22</code> release.</p><p>See also [ngx.shared.DICT]</p><h2><span id="ngxshareddictget_stale">ngx.shared.DICT.get_stale</span></h2><p><strong>syntax:</strong> <em>value, flags, stale = ngx.shared.DICT:get_stale(key)</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Similar to the [get]</p><p>Returns a 3rd value, <code>stale</code>, indicating whether the key has expired or not.</p><p>Note that the value of an expired key is not guaranteed to be available so one should never rely on the availability of expired items.</p><p>This method was first introduced in the <code>0.8.6</code> release.</p><p>See also [ngx.shared.DICT]</p><h2><span id="ngxshareddictset">ngx.shared.DICT.set</span></h2><p><strong>syntax:</strong> <em>success, err, forcible = ngx.shared.DICT:set(key, value, exptime?, flags?)</em></p><p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Unconditionally sets a key-value pair into the shm-based dictionary [ngx.shared.DICT]</p><ul><li><code>success</code>: boolean value to indicate whether the key-value pair is stored or not.</li><li><code>err</code>: textual error message, can be <code>&quot;no memory&quot;</code>.</li><li><code>forcible</code>: a boolean value to indicate whether other valid items have been removed forcibly when out of storage in the shared memory zone.</li></ul><p>The <code>value</code> argument inserted can be Lua booleans, numbers, strings, or <code>nil</code>. Their value type will also be stored into the dictionary and the same data type can be retrieved later via the [get]</p><p>The optional <code>exptime</code> argument specifies expiration time (in seconds) for the inserted key-value pair. The time resolution is <code>0.001</code> seconds. If the <code>exptime</code> takes the value <code>0</code> (which is the default), then the item will never expire.</p><p>The optional <code>flags</code> argument specifies a user flags value associated with the entry to be stored. It can also be retrieved later with the value. The user flags is stored as an unsigned 32-bit integer internally. Defaults to <code>0</code>. The user flags argument was first introduced in the <code>v0.5.0rc2</code> release.</p><p>When it fails to allocate memory for the current key-value item, then <code>set</code> will try removing existing items in the storage according to the Least-Recently Used (LRU) algorithm. Note that, LRU takes priority over expiration time here. If up to tens of existing items have been removed and the storage left is still insufficient (either due to the total capacity limit specified by [lua_shared_dict]</p><p>If this method succeeds in storing the current item by forcibly removing other not-yet-expired items in the dictionary via LRU, the <code>forcible</code> return value will be <code>true</code>. If it stores the item without forcibly removing other valid items, then the return value <code>forcible</code> will be <code>false</code>.</p><p>The first argument to this method must be the dictionary object itself, for example,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local cats = ngx.shared.cats</span><br><span class="line">local succ, err, forcible = cats.set(cats, &quot;Marry&quot;, &quot;it is a nice cat!&quot;)</span><br></pre></td></tr></table></figure><p>or use Lua’s syntactic sugar for method calls:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local cats = ngx.shared.cats</span><br><span class="line">local succ, err, forcible = cats:set(&quot;Marry&quot;, &quot;it is a nice cat!&quot;)</span><br></pre></td></tr></table></figure><p>These two forms are fundamentally equivalent.</p><p>This feature was first introduced in the <code>v0.3.1rc22</code> release.</p><p>Please note that while internally the key-value pair is set atomically, the atomicity does not go across the method call boundary.</p><p>See also [ngx.shared.DICT]</p><h2><span id="ngxshareddictsafe_set">ngx.shared.DICT.safe_set</span></h2><p><strong>syntax:</strong> <em>ok, err = ngx.shared.DICT:safe_set(key, value, exptime?, flags?)</em></p><p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Similar to the [set]</p><p>This feature was first introduced in the <code>v0.7.18</code> release.</p><p>See also [ngx.shared.DICT]</p><h2><span id="ngxshareddictadd">ngx.shared.DICT.add</span></h2><p><strong>syntax:</strong> <em>success, err, forcible = ngx.shared.DICT:add(key, value, exptime?, flags?)</em></p><p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Just like the [set]</p><p>If the <code>key</code> argument already exists in the dictionary (and not expired for sure), the <code>success</code> return value will be <code>false</code> and the <code>err</code> return value will be <code>&quot;exists&quot;</code>.</p><p>This feature was first introduced in the <code>v0.3.1rc22</code> release.</p><p>See also [ngx.shared.DICT]</p><h2><span id="ngxshareddictsafe_add">ngx.shared.DICT.safe_add</span></h2><p><strong>syntax:</strong> <em>ok, err = ngx.shared.DICT:safe_add(key, value, exptime?, flags?)</em></p><p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Similar to the [add]</p><p>This feature was first introduced in the <code>v0.7.18</code> release.</p><p>See also [ngx.shared.DICT]</p><h2><span id="ngxshareddictreplace">ngx.shared.DICT.replace</span></h2><p><strong>syntax:</strong> <em>success, err, forcible = ngx.shared.DICT:replace(key, value, exptime?, flags?)</em></p><p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Just like the [set]</p><p>If the <code>key</code> argument does <em>not</em> exist in the dictionary (or expired already), the <code>success</code> return value will be <code>false</code> and the <code>err</code> return value will be <code>&quot;not found&quot;</code>.</p><p>This feature was first introduced in the <code>v0.3.1rc22</code> release.</p><p>See also [ngx.shared.DICT]</p><h2><span id="ngxshareddictdelete">ngx.shared.DICT.delete</span></h2><p><strong>syntax:</strong> <em>ngx.shared.DICT:delete(key)</em></p><p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Unconditionally removes the key-value pair from the shm-based dictionary [ngx.shared.DICT]</p><p>It is equivalent to <code>ngx.shared.DICT:set(key, nil)</code>.</p><p>This feature was first introduced in the <code>v0.3.1rc22</code> release.</p><p>See also [ngx.shared.DICT]</p><h2><span id="ngxshareddictincr">ngx.shared.DICT.incr</span></h2><p><strong>syntax:</strong> <em>newval, err, forcible? = ngx.shared.DICT:incr(key, value, init?, init_ttl?)</em></p><p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p><strong>optional requirement:</strong> <code>resty.core.shdict</code> or <code>resty.core</code></p><p>Increments the (numerical) value for <code>key</code> in the shm-based dictionary [ngx.shared.DICT]</p><p>When the key does not exist or has already expired in the shared dictionary,</p><ol><li>if the <code>init</code> argument is not specified or takes the value <code>nil</code>, this method will return <code>nil</code> and the error string <code>&quot;not found&quot;</code>, or</li><li>if the <code>init</code> argument takes a number value, this method will create a new <code>key</code> with the value <code>init + value</code>.</li></ol><p>Like the [add]</p><p>The optional <code>init_ttl</code> argument specifies expiration time (in seconds) of the value when it is initialized via the <code>init</code>argument. The time resolution is <code>0.001</code> seconds. If <code>init_ttl</code> takes the value <code>0</code> (which is the default), then the item will never expire. This argument cannot be provided without providing the <code>init</code> argument as well, and has no effect if the value already exists (e.g., if it was previously inserted via [set]</p><p><strong>Note:</strong> Usage of the <code>init_ttl</code> argument requires the <code>resty.core.shdict</code> or <code>resty.core</code> modules from the [lua-resty-core]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">require &quot;resty.core&quot;</span><br><span class="line"></span><br><span class="line">local cats = ngx.shared.cats</span><br><span class="line">local newval, err = cats:incr(&quot;black_cats&quot;, 1, 0, 0.1)</span><br><span class="line"></span><br><span class="line">print(newval) -- 1</span><br><span class="line"></span><br><span class="line">ngx.sleep(0.2)</span><br><span class="line"></span><br><span class="line">local val, err = cats:get(&quot;black_cats&quot;)</span><br><span class="line">print(val) -- nil</span><br></pre></td></tr></table></figure><p>The <code>forcible</code> return value will always be <code>nil</code> when the <code>init</code> argument is not specified.</p><p>If this method succeeds in storing the current item by forcibly removing other not-yet-expired items in the dictionary via LRU, the <code>forcible</code> return value will be <code>true</code>. If it stores the item without forcibly removing other valid items, then the return value <code>forcible</code> will be <code>false</code>.</p><p>If the original value is not a valid Lua number in the dictionary, it will return <code>nil</code> and <code>&quot;not a number&quot;</code>.</p><p>The <code>value</code> argument and <code>init</code> argument can be any valid Lua numbers, like negative numbers or floating-point numbers.</p><p>This method was first introduced in the <code>v0.3.1rc22</code> release.</p><p>The optional <code>init</code> parameter was first added in the <code>v0.10.6</code> release.</p><p>The optional <code>init_ttl</code> parameter was introduced in the <code>v0.10.12rc2</code> release.</p><p>See also [ngx.shared.DICT]</p><h2><span id="ngxshareddictlpush">ngx.shared.DICT.lpush</span></h2><p><strong>syntax:</strong> <em>length, err = ngx.shared.DICT:lpush(key, value)</em></p><p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Inserts the specified (numerical or string) <code>value</code> at the head of the list named <code>key</code> in the shm-based dictionary [ngx.shared.DICT]</p><p>If <code>key</code> does not exist, it is created as an empty list before performing the push operation. When the <code>key</code> already takes a value that is not a list, it will return <code>nil</code> and <code>&quot;value not a list&quot;</code>.</p><p>It never overrides the (least recently used) unexpired items in the store when running out of storage in the shared memory zone. In this case, it will immediately return <code>nil</code> and the string “no memory”.</p><p>This feature was first introduced in the <code>v0.10.6</code> release.</p><p>See also [ngx.shared.DICT]</p><h2><span id="ngxshareddictrpush">ngx.shared.DICT.rpush</span></h2><p><strong>syntax:</strong> <em>length, err = ngx.shared.DICT:rpush(key, value)</em></p><p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Similar to the [lpush]</p><p>This feature was first introduced in the <code>v0.10.6</code> release.</p><p>See also [ngx.shared.DICT]</p><h2><span id="ngxshareddictlpop">ngx.shared.DICT.lpop</span></h2><p><strong>syntax:</strong> <em>val, err = ngx.shared.DICT:lpop(key)</em></p><p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Removes and returns the first element of the list named <code>key</code> in the shm-based dictionary [ngx.shared.DICT]</p><p>If <code>key</code> does not exist, it will return <code>nil</code>. When the <code>key</code> already takes a value that is not a list, it will return <code>nil</code> and <code>&quot;value not a list&quot;</code>.</p><p>This feature was first introduced in the <code>v0.10.6</code> release.</p><p>See also [ngx.shared.DICT]</p><h2><span id="ngxshareddictrpop">ngx.shared.DICT.rpop</span></h2><p><strong>syntax:</strong> <em>val, err = ngx.shared.DICT:rpop(key)</em></p><p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Removes and returns the last element of the list named <code>key</code> in the shm-based dictionary [ngx.shared.DICT]</p><p>If <code>key</code> does not exist, it will return <code>nil</code>. When the <code>key</code> already takes a value that is not a list, it will return <code>nil</code> and <code>&quot;value not a list&quot;</code>.</p><p>This feature was first introduced in the <code>v0.10.6</code> release.</p><p>See also [ngx.shared.DICT]</p><h2><span id="ngxshareddictllen">ngx.shared.DICT.llen</span></h2><p><strong>syntax:</strong> <em>len, err = ngx.shared.DICT:llen(key)</em></p><p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Returns the number of elements in the list named <code>key</code> in the shm-based dictionary [ngx.shared.DICT]</p><p>If key does not exist, it is interpreted as an empty list and 0 is returned. When the <code>key</code> already takes a value that is not a list, it will return <code>nil</code> and <code>&quot;value not a list&quot;</code>.</p><p>This feature was first introduced in the <code>v0.10.6</code> release.</p><p>See also [ngx.shared.DICT]</p><h2><span id="ngxshareddictttl">ngx.shared.DICT.ttl</span></h2><p><strong>syntax:</strong> <em>ttl, err = ngx.shared.DICT:ttl(key)</em></p><p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p><strong>requires:</strong> <code>resty.core.shdict</code> or <code>resty.core</code></p><p>Retrieves the remaining TTL (time-to-live in seconds) of a key-value pair in the shm-based dictionary [ngx.shared.DICT]</p><p>If the key does not exist (or has already expired), this method will return <code>nil</code> and the error string <code>&quot;not found&quot;</code>.</p><p>The TTL is originally determined by the <code>exptime</code> argument of the [set]</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">require &quot;resty.core&quot;</span><br><span class="line"></span><br><span class="line">local cats = ngx.shared.cats</span><br><span class="line">local succ, err = cats:set(&quot;Marry&quot;, &quot;a nice cat&quot;, 0.5)</span><br><span class="line"></span><br><span class="line">ngx.sleep(0.2)</span><br><span class="line"></span><br><span class="line">local ttl, err = cats:ttl(&quot;Marry&quot;)</span><br><span class="line">ngx.say(ttl) -- 0.3</span><br></pre></td></tr></table></figure><p>This feature was first introduced in the <code>v0.10.11</code> release.</p><p><strong>Note:</strong> This method requires the <code>resty.core.shdict</code> or <code>resty.core</code> modules from the [lua-resty-core]</p><p>See also [ngx.shared.DICT]</p><h2><span id="ngxshareddictexpire">ngx.shared.DICT.expire</span></h2><p><strong>syntax:</strong> <em>success, err = ngx.shared.DICT:expire(key, exptime)</em></p><p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p><strong>requires:</strong> <code>resty.core.shdict</code> or <code>resty.core</code></p><p>Updates the <code>exptime</code> (in second) of a key-value pair in the shm-based dictionary [ngx.shared.DICT]</p><p>If the key does not exist, this method will return <code>nil</code> and the error string <code>&quot;not found&quot;</code>.</p><p>The <code>exptime</code> argument has a resolution of <code>0.001</code> seconds. If <code>exptime</code> is <code>0</code>, then the item will never expire.</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">require &quot;resty.core&quot;</span><br><span class="line"></span><br><span class="line">local cats = ngx.shared.cats</span><br><span class="line">local succ, err = cats:set(&quot;Marry&quot;, &quot;a nice cat&quot;, 0.1)</span><br><span class="line"></span><br><span class="line">succ, err = cats:expire(&quot;Marry&quot;, 0.5)</span><br><span class="line"></span><br><span class="line">ngx.sleep(0.2)</span><br><span class="line"></span><br><span class="line">local val, err = cats:get(&quot;Marry&quot;)</span><br><span class="line">ngx.say(val) -- &quot;a nice cat&quot;</span><br></pre></td></tr></table></figure><p>This feature was first introduced in the <code>v0.10.11</code> release.</p><p><strong>Note:</strong> This method requires the <code>resty.core.shdict</code> or <code>resty.core</code> modules from the [lua-resty-core]</p><p>See also [ngx.shared.DICT]</p><h2><span id="ngxshareddictflush_all">ngx.shared.DICT.flush_all</span></h2><p><strong>syntax:</strong> <em>ngx.shared.DICT:flush_all()</em></p><p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Flushes out all the items in the dictionary. This method does not actuall free up all the memory blocks in the dictionary but just marks all the existing items as expired.</p><p>This feature was first introduced in the <code>v0.5.0rc17</code> release.</p><p>See also [ngx.shared.DICT.flush_expired]</p><h2><span id="ngxshareddictflush_expired">ngx.shared.DICT.flush_expired</span></h2><p><strong>syntax:</strong> <em>flushed = ngx.shared.DICT:flush_expired(max_count?)</em></p><p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Flushes out the expired items in the dictionary, up to the maximal number specified by the optional <code>max_count</code> argument. When the <code>max_count</code> argument is given <code>0</code> or not given at all, then it means unlimited. Returns the number of items that have actually been flushed.</p><p>Unlike the [flush_all]</p><p>This feature was first introduced in the <code>v0.6.3</code> release.</p><p>See also [ngx.shared.DICT.flush_all]</p><h2><span id="ngxshareddictget_keys">ngx.shared.DICT.get_keys</span></h2><p><strong>syntax:</strong> <em>keys = ngx.shared.DICT:get_keys(max_count?)</em></p><p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Fetch a list of the keys from the dictionary, up to <code>&lt;max_count&gt;</code>.</p><p>By default, only the first 1024 keys (if any) are returned. When the <code>&lt;max_count&gt;</code> argument is given the value <code>0</code>, then all the keys will be returned even there is more than 1024 keys in the dictionary.</p><p><strong>CAUTION</strong> Avoid calling this method on dictionaries with a very large number of keys as it may lock the dictionary for significant amount of time and block Nginx worker processes trying to access the dictionary.</p><p>This feature was first introduced in the <code>v0.7.3</code> release.</p><h2><span id="ngxshareddictcapacity">ngx.shared.DICT.capacity</span></h2><p><strong>syntax:</strong> <em>capacity_bytes = ngx.shared.DICT:capacity()</em></p><p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p><strong>requires:</strong> <code>resty.core.shdict</code> or <code>resty.core</code></p><p>Retrieves the capacity in bytes for the shm-based dictionary [ngx.shared.DICT]</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">require &quot;resty.core.shdict&quot;</span><br><span class="line"></span><br><span class="line">local cats = ngx.shared.cats</span><br><span class="line">local capacity_bytes = cats:capacity()</span><br></pre></td></tr></table></figure><p>This feature was first introduced in the <code>v0.10.11</code> release.</p><p><strong>Note:</strong> This method requires the <code>resty.core.shdict</code> or <code>resty.core</code> modules from the [lua-resty-core]</p><p>This feature requires at least nginx core version <code>0.7.3</code>.</p><p>See also [ngx.shared.DICT]</p><h2><span id="ngxshareddictfree_space">ngx.shared.DICT.free_space</span></h2><p><strong>syntax:</strong> <em>free_page_bytes = ngx.shared.DICT:free_space()</em></p><p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p><strong>requires:</strong> <code>resty.core.shdict</code> or <code>resty.core</code></p><p>Retrieves the free page size in bytes for the shm-based dictionary [ngx.shared.DICT]</p><p><strong>Note:</strong> The memory for ngx.shared.DICT is allocated via the nginx slab allocator which has each slot for data size ranges like ~8, 9~16, 17~32, …, 1025~2048, 2048~ bytes. And pages are assigned to a slot if there is no room in already assigned pages for the slot.</p><p>So even if the return value of the <code>free_space</code> method is zero, there may be room in already assigned pages, so you may successfully set a new key value pair to the shared dict without getting <code>true</code> for <code>forcible</code> or non nil <code>err</code> from the <code>ngx.shared.DICT.set</code>.</p><p>On the other hand, if already assigned pages for a slot are full and a new key value pair is added to the slot and there is no free page, you may get <code>true</code> for <code>forcible</code> or non nil <code>err</code> from the <code>ngx.shared.DICT.set</code> method.</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">require &quot;resty.core.shdict&quot;</span><br><span class="line"></span><br><span class="line">local cats = ngx.shared.cats</span><br><span class="line">local free_page_bytes = cats:free_space()</span><br></pre></td></tr></table></figure><p>This feature was first introduced in the <code>v0.10.11</code> release.</p><p><strong>Note:</strong> This method requires the <code>resty.core.shdict</code> or <code>resty.core</code> modules from the [lua-resty-core]</p><p>This feature requires at least nginx core version <code>1.11.7</code>.</p><p>See also [ngx.shared.DICT]</p><h2><span id="ngxsocketudp">ngx.socket.udp</span></h2><p><strong>syntax:</strong> <em>udpsock = ngx.socket.udp()</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p><p>Creates and returns a UDP or datagram-oriented unix domain socket object (also known as one type of the “cosocket” objects). The following methods are supported on this object:</p><ul><li>[setpeername]</li><li>[send]</li><li>[receive]</li><li>[close]</li><li>[settimeout]</li></ul><p>It is intended to be compatible with the UDP API of the <a href="http://w3.impa.br/~diego/software/luasocket/udp.html" target="_blank" rel="noopener">LuaSocket</a> library but is 100% nonblocking out of the box.</p><p>This feature was first introduced in the <code>v0.5.7</code> release.</p><p>See also [ngx.socket.tcp]</p><h2><span id="udpsocksetpeername">udpsock:setpeername</span></h2><p><strong>syntax:</strong> <em>ok, err = udpsock:setpeername(host, port)</em></p><p><strong>syntax:</strong> <em>ok, err = udpsock:setpeername(“unix:/path/to/unix-domain.socket”)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p><p>Attempts to connect a UDP socket object to a remote server or to a datagram unix domain socket file. Because the datagram protocol is actually connection-less, this method does not really establish a “connection”, but only just set the name of the remote peer for subsequent read/write operations.</p><p>Both IP addresses and domain names can be specified as the <code>host</code> argument. In case of domain names, this method will use Nginx core’s dynamic resolver to parse the domain name without blocking and it is required to configure the <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#resolver" target="_blank" rel="noopener">resolver</a>directive in the <code>nginx.conf</code> file like this:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resolver 8.8.8.8;  # use Google&apos;s public DNS nameserver</span><br></pre></td></tr></table></figure><p>If the nameserver returns multiple IP addresses for the host name, this method will pick up one randomly.</p><p>In case of error, the method returns <code>nil</code> followed by a string describing the error. In case of success, the method returns <code>1</code>.</p><p>Here is an example for connecting to a UDP (memcached) server:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">location /test &#123;</span><br><span class="line">    resolver 8.8.8.8;</span><br><span class="line"></span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        local sock = ngx.socket.udp()</span><br><span class="line">        local ok, err = sock:setpeername(&quot;my.memcached.server.domain&quot;, 11211)</span><br><span class="line">        if not ok then</span><br><span class="line">            ngx.say(&quot;failed to connect to memcached: &quot;, err)</span><br><span class="line">            return</span><br><span class="line">        end</span><br><span class="line">        ngx.say(&quot;successfully connected to memcached!&quot;)</span><br><span class="line">        sock:close()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Since the <code>v0.7.18</code> release, connecting to a datagram unix domain socket file is also possible on Linux:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">local sock = ngx.socket.udp()</span><br><span class="line">local ok, err = sock:setpeername(&quot;unix:/tmp/some-datagram-service.sock&quot;)</span><br><span class="line">if not ok then</span><br><span class="line">    ngx.say(&quot;failed to connect to the datagram unix domain socket: &quot;, err)</span><br><span class="line">    return</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>assuming the datagram service is listening on the unix domain socket file <code>/tmp/some-datagram-service.sock</code> and the client socket will use the “autobind” feature on Linux.</p><p>Calling this method on an already connected socket object will cause the original connection to be closed first.</p><p>This method was first introduced in the <code>v0.5.7</code> release.</p><h2><span id="udpsocksend">udpsock:send</span></h2><p><strong>syntax:</strong> <em>ok, err = udpsock:send(data)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p><p>Sends data on the current UDP or datagram unix domain socket object.</p><p>In case of success, it returns <code>1</code>. Otherwise, it returns <code>nil</code> and a string describing the error.</p><p>The input argument <code>data</code> can either be a Lua string or a (nested) Lua table holding string fragments. In case of table arguments, this method will copy all the string elements piece by piece to the underlying Nginx socket send buffers, which is usually optimal than doing string concatenation operations on the Lua land.</p><p>This feature was first introduced in the <code>v0.5.7</code> release.</p><h2><span id="udpsockreceive">udpsock:receive</span></h2><p><strong>syntax:</strong> <em>data, err = udpsock:receive(size?)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p><p>Receives data from the UDP or datagram unix domain socket object with an optional receive buffer size argument, <code>size</code>.</p><p>This method is a synchronous operation and is 100% nonblocking.</p><p>In case of success, it returns the data received; in case of error, it returns <code>nil</code> with a string describing the error.</p><p>If the <code>size</code> argument is specified, then this method will use this size as the receive buffer size. But when this size is greater than <code>8192</code>, then <code>8192</code> will be used instead.</p><p>If no argument is specified, then the maximal buffer size, <code>8192</code> is assumed.</p><p>Timeout for the reading operation is controlled by the [lua_socket_read_timeout]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sock:settimeout(1000)  -- one second timeout</span><br><span class="line">local data, err = sock:receive()</span><br><span class="line">if not data then</span><br><span class="line">    ngx.say(&quot;failed to read a packet: &quot;, err)</span><br><span class="line">    return</span><br><span class="line">end</span><br><span class="line">ngx.say(&quot;successfully read a packet: &quot;, data)</span><br></pre></td></tr></table></figure><p>It is important here to call the [settimeout]</p><p>This feature was first introduced in the <code>v0.5.7</code> release.</p><h2><span id="udpsockclose">udpsock:close</span></h2><p><strong>syntax:</strong> <em>ok, err = udpsock:close()</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p><p>Closes the current UDP or datagram unix domain socket. It returns the <code>1</code> in case of success and returns <code>nil</code> with a string describing the error otherwise.</p><p>Socket objects that have not invoked this method (and associated connections) will be closed when the socket object is released by the Lua GC (Garbage Collector) or the current client HTTP request finishes processing.</p><p>This feature was first introduced in the <code>v0.5.7</code> release.</p><h2><span id="udpsocksettimeout">udpsock:settimeout</span></h2><p><strong>syntax:</strong> <em>udpsock:settimeout(time)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p><p>Set the timeout value in milliseconds for subsequent socket operations (like [receive]</p><p>Settings done by this method takes priority over those config directives, like [lua_socket_read_timeout]</p><p>This feature was first introduced in the <code>v0.5.7</code> release.</p><h2><span id="ngxsocketstream">ngx.socket.stream</span></h2><p>Just an alias to [ngx.socket.tcp]</p><p>This API function was first added to the <code>v0.10.1</code> release.</p><h2><span id="ngxsockettcp">ngx.socket.tcp</span></h2><p><strong>syntax:</strong> <em>tcpsock = ngx.socket.tcp()</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p><p>Creates and returns a TCP or stream-oriented unix domain socket object (also known as one type of the “cosocket” objects). The following methods are supported on this object:</p><ul><li>[connect]</li><li>[sslhandshake]</li><li>[send]</li><li>[receive]</li><li>[close]</li><li>[settimeout]</li><li>[settimeouts]</li><li>[setoption]</li><li>[receiveany]</li><li>[receiveuntil]</li><li>[setkeepalive]</li><li>[getreusedtimes]</li></ul><p>It is intended to be compatible with the TCP API of the <a href="http://w3.impa.br/~diego/software/luasocket/tcp.html" target="_blank" rel="noopener">LuaSocket</a> library but is 100% nonblocking out of the box. Also, we introduce some new APIs to provide more functionalities.</p><p>The cosocket object created by this API function has exactly the same lifetime as the Lua handler creating it. So never pass the cosocket object to any other Lua handler (including ngx.timer callback functions) and never share the cosocket object between different NGINX requests.</p><p>For every cosocket object’s underlying connection, if you do not explicitly close it (via [close]</p><ul><li>the current request handler completes, or</li><li>the Lua cosocket object value gets collected by the Lua GC.</li></ul><p>Fatal errors in cosocket operations always automatically close the current connection (note that, read timeout error is the only error that is not fatal), and if you call [close]</p><p>Starting from the <code>0.9.9</code> release, the cosocket object here is full-duplex, that is, a reader “light thread” and a writer “light thread” can operate on a single cosocket object simultaneously (both “light threads” must belong to the same Lua handler though, see reasons above). But you cannot have two “light threads” both reading (or writing or connecting) the same cosocket, otherwise you might get an error like “socket busy reading” when calling the methods of the cosocket object.</p><p>This feature was first introduced in the <code>v0.5.0rc1</code> release.</p><p>See also [ngx.socket.udp]</p><h2><span id="tcpsockconnect">tcpsock:connect</span></h2><p><strong>syntax:</strong> <em>ok, err = tcpsock:connect(host, port, options_table?)</em></p><p><strong>syntax:</strong> <em>ok, err = tcpsock:connect(“unix:/path/to/unix-domain.socket”, options_table?)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p><p>Attempts to connect a TCP socket object to a remote server or to a stream unix domain socket file without blocking.</p><p>Before actually resolving the host name and connecting to the remote backend, this method will always look up the connection pool for matched idle connections created by previous calls of this method (or the [ngx.socket.connect]</p><p>Both IP addresses and domain names can be specified as the <code>host</code> argument. In case of domain names, this method will use Nginx core’s dynamic resolver to parse the domain name without blocking and it is required to configure the <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#resolver" target="_blank" rel="noopener">resolver</a>directive in the <code>nginx.conf</code> file like this:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resolver 8.8.8.8;  # use Google&apos;s public DNS nameserver</span><br></pre></td></tr></table></figure><p>If the nameserver returns multiple IP addresses for the host name, this method will pick up one randomly.</p><p>In case of error, the method returns <code>nil</code> followed by a string describing the error. In case of success, the method returns <code>1</code>.</p><p>Here is an example for connecting to a TCP server:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">location /test &#123;</span><br><span class="line">    resolver 8.8.8.8;</span><br><span class="line"></span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        local sock = ngx.socket.tcp()</span><br><span class="line">        local ok, err = sock:connect(&quot;www.google.com&quot;, 80)</span><br><span class="line">        if not ok then</span><br><span class="line">            ngx.say(&quot;failed to connect to google: &quot;, err)</span><br><span class="line">            return</span><br><span class="line">        end</span><br><span class="line">        ngx.say(&quot;successfully connected to google!&quot;)</span><br><span class="line">        sock:close()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Connecting to a Unix Domain Socket file is also possible:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">local sock = ngx.socket.tcp()</span><br><span class="line">local ok, err = sock:connect(&quot;unix:/tmp/memcached.sock&quot;)</span><br><span class="line">if not ok then</span><br><span class="line">    ngx.say(&quot;failed to connect to the memcached unix domain socket: &quot;, err)</span><br><span class="line">    return</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>assuming memcached (or something else) is listening on the unix domain socket file <code>/tmp/memcached.sock</code>.</p><p>Timeout for the connecting operation is controlled by the [lua_socket_connect_timeout]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">local sock = ngx.socket.tcp()</span><br><span class="line">sock:settimeout(1000)  -- one second timeout</span><br><span class="line">local ok, err = sock:connect(host, port)</span><br></pre></td></tr></table></figure><p>It is important here to call the [settimeout]</p><p>Calling this method on an already connected socket object will cause the original connection to be closed first.</p><p>An optional Lua table can be specified as the last argument to this method to specify various connect options:</p><ul><li><code>pool</code> specify a custom name for the connection pool being used. If omitted, then the connection pool name will be generated from the string template <code>&quot;&lt;host&gt;:&lt;port&gt;&quot;</code> or <code>&quot;&lt;unix-socket-path&gt;&quot;</code>.</li><li><code>pool_size</code> specify the size of the connection pool. If omitted and no <code>backlog</code> option was provided, no pool will be created. If omitted but <code>backlog</code> was provided, the pool will be created with a default size equal to the value of the [lua_socket_pool_size]</li><li><code>backlog</code> if specified, this module will limit the total number of opened connections for this pool. No more connections than <code>pool_size</code> can be opened for this pool at any time. If the connection pool is full, subsequent connect operations will be queued into a queue equal to this option’s value (the “backlog” queue). If the number of queued connect operations is equal to <code>backlog</code>, subsequent connect operations will fail and return <code>nil</code> plus the error string <code>&quot;too many waiting connect operations&quot;</code>. The queued connect operations will be resumed once the number of connections in the pool is less than <code>pool_size</code>. The queued connect operation will abort once they have been queued for more than <code>connect_timeout</code>, controlled by [settimeouts]</li></ul><p>The support for the options table argument was first introduced in the <code>v0.5.7</code> release.</p><p>This method was first introduced in the <code>v0.5.0rc1</code> release.</p><h2><span id="tcpsocksslhandshake">tcpsock:sslhandshake</span></h2><p><strong>syntax:</strong> <em>session, err = tcpsock:sslhandshake(reused_session?, server_name?, ssl_verify?, send_status_req?)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p><p>Does SSL/TLS handshake on the currently established connection.</p><p>The optional <code>reused_session</code> argument can take a former SSL session userdata returned by a previous <code>sslhandshake</code> call for exactly the same target. For short-lived connections, reusing SSL sessions can usually speed up the handshake by one order by magnitude but it is not so useful if the connection pool is enabled. This argument defaults to <code>nil</code>. If this argument takes the boolean <code>false</code> value, no SSL session userdata would return by this call and only a Lua boolean will be returned as the first return value; otherwise the current SSL session will always be returned as the first argument in case of successes.</p><p>The optional <code>server_name</code> argument is used to specify the server name for the new TLS extension Server Name Indication (SNI). Use of SNI can make different servers share the same IP address on the server side. Also, when SSL verification is enabled, this <code>server_name</code> argument is also used to validate the server name specified in the server certificate sent from the remote.</p><p>The optional <code>ssl_verify</code> argument takes a Lua boolean value to control whether to perform SSL verification. When set to <code>true</code>, the server certificate will be verified according to the CA certificates specified by the [lua_ssl_trusted_certificate]</p><p>The optional <code>send_status_req</code> argument takes a boolean that controls whether to send the OCSP status request in the SSL handshake request (which is for requesting OCSP stapling).</p><p>For connections that have already done SSL/TLS handshake, this method returns immediately.</p><p>This method was first introduced in the <code>v0.9.11</code> release.</p><h2><span id="tcpsocksend">tcpsock:send</span></h2><p><strong>syntax:</strong> <em>bytes, err = tcpsock:send(data)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p><p>Sends data without blocking on the current TCP or Unix Domain Socket connection.</p><p>This method is a synchronous operation that will not return until <em>all</em> the data has been flushed into the system socket send buffer or an error occurs.</p><p>In case of success, it returns the total number of bytes that have been sent. Otherwise, it returns <code>nil</code> and a string describing the error.</p><p>The input argument <code>data</code> can either be a Lua string or a (nested) Lua table holding string fragments. In case of table arguments, this method will copy all the string elements piece by piece to the underlying Nginx socket send buffers, which is usually optimal than doing string concatenation operations on the Lua land.</p><p>Timeout for the sending operation is controlled by the [lua_socket_send_timeout]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sock:settimeout(1000)  -- one second timeout</span><br><span class="line">local bytes, err = sock:send(request)</span><br></pre></td></tr></table></figure><p>It is important here to call the [settimeout]</p><p>In case of any connection errors, this method always automatically closes the current connection.</p><p>This feature was first introduced in the <code>v0.5.0rc1</code> release.</p><h2><span id="tcpsockreceive">tcpsock:receive</span></h2><p><strong>syntax:</strong> <em>data, err, partial = tcpsock:receive(size)</em></p><p><strong>syntax:</strong> <em>data, err, partial = tcpsock:receive(pattern?)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p><p>Receives data from the connected socket according to the reading pattern or size.</p><p>This method is a synchronous operation just like the [send]</p><p>In case of success, it returns the data received; in case of error, it returns <code>nil</code> with a string describing the error and the partial data received so far.</p><p>If a number-like argument is specified (including strings that look like numbers), then it is interpreted as a size. This method will not return until it reads exactly this size of data or an error occurs.</p><p>If a non-number-like string argument is specified, then it is interpreted as a “pattern”. The following patterns are supported:</p><ul><li><code>&#39;*a&#39;</code>: reads from the socket until the connection is closed. No end-of-line translation is performed;</li><li><code>&#39;*l&#39;</code>: reads a line of text from the socket. The line is terminated by a <code>Line Feed</code> (LF) character (ASCII 10), optionally preceded by a <code>Carriage Return</code> (CR) character (ASCII 13). The CR and LF characters are not included in the returned line. In fact, all CR characters are ignored by the pattern.</li></ul><p>If no argument is specified, then it is assumed to be the pattern <code>&#39;*l&#39;</code>, that is, the line reading pattern.</p><p>Timeout for the reading operation is controlled by the [lua_socket_read_timeout]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sock:settimeout(1000)  -- one second timeout</span><br><span class="line">local line, err, partial = sock:receive()</span><br><span class="line">if not line then</span><br><span class="line">    ngx.say(&quot;failed to read a line: &quot;, err)</span><br><span class="line">    return</span><br><span class="line">end</span><br><span class="line">ngx.say(&quot;successfully read a line: &quot;, line)</span><br></pre></td></tr></table></figure><p>It is important here to call the [settimeout]</p><p>Since the <code>v0.8.8</code> release, this method no longer automatically closes the current connection when the read timeout error happens. For other connection errors, this method always automatically closes the connection.</p><p>This feature was first introduced in the <code>v0.5.0rc1</code> release.</p><h2><span id="tcpsockreceiveany">tcpsock:receiveany</span></h2><p><strong>syntax:</strong> <em>data, err = tcpsock:receiveany(max)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p><p>Returns any data received by the connected socket, at most <code>max</code> bytes.</p><p>This method is a synchronous operation just like the [send]</p><p>In case of success, it returns the data received; in case of error, it returns <code>nil</code> with a string describing the error.</p><p>If the received data is more than this size, this method will return with exactly this size of data. The remaining data in the underlying receive buffer could be returned in the next reading operation.</p><p>Timeout for the reading operation is controlled by the [lua_socket_read_timeout]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sock:settimeouts(1000, 1000, 1000)  -- one second timeout for connect/read/write</span><br><span class="line">local data, err = sock:receiveany(10 * 1024 * 1024) -- read any data, at most 10K</span><br><span class="line">if not data then</span><br><span class="line">    ngx.say(&quot;failed to read any data: &quot;, err)</span><br><span class="line">    return</span><br><span class="line">end</span><br><span class="line">ngx.say(&quot;successfully read: &quot;, data)</span><br></pre></td></tr></table></figure><p>This method doesn’t automatically close the current connection when the read timeout error occurs. For other connection errors, this method always automatically closes the connection.</p><p>This feature was first introduced in the <code>v0.10.14</code> release.</p><h2><span id="tcpsockreceiveuntil">tcpsock:receiveuntil</span></h2><p><strong>syntax:</strong> <em>iterator = tcpsock:receiveuntil(pattern, options?)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p><p>This method returns an iterator Lua function that can be called to read the data stream until it sees the specified pattern or an error occurs.</p><p>Here is an example for using this method to read a data stream with the boundary sequence <code>--abcedhb</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">local reader = sock:receiveuntil(&quot;\r\n--abcedhb&quot;)</span><br><span class="line">local data, err, partial = reader()</span><br><span class="line">if not data then</span><br><span class="line">    ngx.say(&quot;failed to read the data stream: &quot;, err)</span><br><span class="line">end</span><br><span class="line">ngx.say(&quot;read the data stream: &quot;, data)</span><br></pre></td></tr></table></figure><p>When called without any argument, the iterator function returns the received data right <em>before</em> the specified pattern string in the incoming data stream. So for the example above, if the incoming data stream is <code>&#39;hello, world! -agentzh\r\n--abcedhb blah blah&#39;</code>, then the string <code>&#39;hello, world! -agentzh&#39;</code> will be returned.</p><p>In case of error, the iterator function will return <code>nil</code> along with a string describing the error and the partial data bytes that have been read so far.</p><p>The iterator function can be called multiple times and can be mixed safely with other cosocket method calls or other iterator function calls.</p><p>The iterator function behaves differently (i.e., like a real iterator) when it is called with a <code>size</code> argument. That is, it will read that <code>size</code> of data on each invocation and will return <code>nil</code> at the last invocation (either sees the boundary pattern or meets an error). For the last successful invocation of the iterator function, the <code>err</code> return value will be <code>nil</code> too. The iterator function will be reset after the last successful invocation that returns <code>nil</code> data and <code>nil</code> error. Consider the following example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">local reader = sock:receiveuntil(&quot;\r\n--abcedhb&quot;)</span><br><span class="line"></span><br><span class="line">while true do</span><br><span class="line">    local data, err, partial = reader(4)</span><br><span class="line">    if not data then</span><br><span class="line">        if err then</span><br><span class="line">            ngx.say(&quot;failed to read the data stream: &quot;, err)</span><br><span class="line">            break</span><br><span class="line">        end</span><br><span class="line"></span><br><span class="line">        ngx.say(&quot;read done&quot;)</span><br><span class="line">        break</span><br><span class="line">    end</span><br><span class="line">    ngx.say(&quot;read chunk: [&quot;, data, &quot;]&quot;)</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>Then for the incoming data stream <code>&#39;hello, world! -agentzh\r\n--abcedhb blah blah&#39;</code>, we shall get the following output from the sample code above:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">read chunk: [hell]</span><br><span class="line">read chunk: [o, w]</span><br><span class="line">read chunk: [orld]</span><br><span class="line">read chunk: [! -a]</span><br><span class="line">read chunk: [gent]</span><br><span class="line">read chunk: [zh]</span><br><span class="line">read done</span><br></pre></td></tr></table></figure><p>Note that, the actual data returned <em>might</em> be a little longer than the size limit specified by the <code>size</code> argument when the boundary pattern has ambiguity for streaming parsing. Near the boundary of the data stream, the data string actually returned could also be shorter than the size limit.</p><p>Timeout for the iterator function’s reading operation is controlled by the [lua_socket_read_timeout]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">local readline = sock:receiveuntil(&quot;\r\n&quot;)</span><br><span class="line"></span><br><span class="line">sock:settimeout(1000)  -- one second timeout</span><br><span class="line">line, err, partial = readline()</span><br><span class="line">if not line then</span><br><span class="line">    ngx.say(&quot;failed to read a line: &quot;, err)</span><br><span class="line">    return</span><br><span class="line">end</span><br><span class="line">ngx.say(&quot;successfully read a line: &quot;, line)</span><br></pre></td></tr></table></figure><p>It is important here to call the [settimeout]</p><p>As from the <code>v0.5.1</code> release, this method also takes an optional <code>options</code> table argument to control the behavior. The following options are supported:</p><ul><li><code>inclusive</code></li></ul><p>The <code>inclusive</code> takes a boolean value to control whether to include the pattern string in the returned data string. Default to <code>false</code>. For example,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">local reader = tcpsock:receiveuntil(&quot;_END_&quot;, &#123; inclusive = true &#125;)</span><br><span class="line">local data = reader()</span><br><span class="line">ngx.say(data)</span><br></pre></td></tr></table></figure><p>Then for the input data stream <code>&quot;hello world _END_ blah blah blah&quot;</code>, then the example above will output <code>hello world _END_</code>, including the pattern string <code>_END_</code> itself.</p><p>Since the <code>v0.8.8</code> release, this method no longer automatically closes the current connection when the read timeout error happens. For other connection errors, this method always automatically closes the connection.</p><p>This method was first introduced in the <code>v0.5.0rc1</code> release.</p><h2><span id="tcpsockclose">tcpsock:close</span></h2><p><strong>syntax:</strong> <em>ok, err = tcpsock:close()</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p><p>Closes the current TCP or stream unix domain socket. It returns the <code>1</code> in case of success and returns <code>nil</code> with a string describing the error otherwise.</p><p>Note that there is no need to call this method on socket objects that have invoked the [setkeepalive]</p><p>Socket objects that have not invoked this method (and associated connections) will be closed when the socket object is released by the Lua GC (Garbage Collector) or the current client HTTP request finishes processing.</p><p>This feature was first introduced in the <code>v0.5.0rc1</code> release.</p><h2><span id="tcpsocksettimeout">tcpsock:settimeout</span></h2><p><strong>syntax:</strong> <em>tcpsock:settimeout(time)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p><p>Set the timeout value in milliseconds for subsequent socket operations ([connect]</p><p>Settings done by this method takes priority over those config directives, i.e., [lua_socket_connect_timeout]</p><p>Note that this method does <em>not</em> affect the [lua_socket_keepalive_timeout]</p><p>This feature was first introduced in the <code>v0.5.0rc1</code> release.</p><h2><span id="tcpsocksettimeouts">tcpsock:settimeouts</span></h2><p><strong>syntax:</strong> <em>tcpsock:settimeouts(connect_timeout, send_timeout, read_timeout)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p><p>Sets the connect timeout thresold, send timeout threshold, and read timeout threshold, respetively, in milliseconds, for subsequent socket operations ([connect]</p><p>Settings done by this method takes priority over those config directives, i.e., [lua_socket_connect_timeout]</p><p>You are recommended to use [settimeouts]</p><p>Note that this method does <em>not</em> affect the [lua_socket_keepalive_timeout]</p><p>This feature was first introduced in the <code>v0.10.7</code> release.</p><h2><span id="tcpsocksetoption">tcpsock:setoption</span></h2><p><strong>syntax:</strong> <em>tcpsock:setoption(option, value?)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p><p>This function is added for <a href="http://w3.impa.br/~diego/software/luasocket/tcp.html" target="_blank" rel="noopener">LuaSocket</a> API compatibility and does nothing for now. Its functionality will be implemented in future.</p><p>This feature was first introduced in the <code>v0.5.0rc1</code> release.</p><h2><span id="tcpsocksetkeepalive">tcpsock:setkeepalive</span></h2><p><strong>syntax:</strong> <em>ok, err = tcpsock:setkeepalive(timeout?, size?)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p><p>Puts the current socket’s connection immediately into the cosocket built-in connection pool and keep it alive until other [connect]</p><p>The first optional argument, <code>timeout</code>, can be used to specify the maximal idle timeout (in milliseconds) for the current connection. If omitted, the default setting in the [lua_socket_keepalive_timeout]</p><p>The second optional argument <code>size</code> is considered deprecated since the <code>v0.10.14</code> release of this module, in favor of the<code>pool_size</code> option of the [connect]</p><p>In case of success, this method returns <code>1</code>; otherwise, it returns <code>nil</code> and a string describing the error.</p><p>When the system receive buffer for the current connection has unread data, then this method will return the “connection in dubious state” error message (as the second return value) because the previous session has unread data left behind for the next session and the connection is not safe to be reused.</p><p>This method also makes the current cosocket object enter the “closed” state, so there is no need to manually call the [close]</p><p>This feature was first introduced in the <code>v0.5.0rc1</code> release.</p><h2><span id="tcpsockgetreusedtimes">tcpsock:getreusedtimes</span></h2><p><strong>syntax:</strong> <em>count, err = tcpsock:getreusedtimes()</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p><p>This method returns the (successfully) reused times for the current connection. In case of error, it returns <code>nil</code> and a string describing the error.</p><p>If the current connection does not come from the built-in connection pool, then this method always returns <code>0</code>, that is, the connection has never been reused (yet). If the connection comes from the connection pool, then the return value is always non-zero. So this method can also be used to determine if the current connection comes from the pool.</p><p>This feature was first introduced in the <code>v0.5.0rc1</code> release.</p><h2><span id="ngxsocketconnect">ngx.socket.connect</span></h2><p><strong>syntax:</strong> <em>tcpsock, err = ngx.socket.connect(host, port)</em></p><p><strong>syntax:</strong> <em>tcpsock, err = ngx.socket.connect(“unix:/path/to/unix-domain.socket”)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.**</p><p>This function is a shortcut for combining [ngx.socket.tcp()]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">local sock = ngx.socket.tcp()</span><br><span class="line">local ok, err = sock:connect(...)</span><br><span class="line">if not ok then</span><br><span class="line">    return nil, err</span><br><span class="line">end</span><br><span class="line">return sock</span><br></pre></td></tr></table></figure><p>There is no way to use the [settimeout]</p><p>This feature was first introduced in the <code>v0.5.0rc1</code> release.</p><h2><span id="ngxget_phase">ngx.get_phase</span></h2><p><strong>syntax:</strong> <em>str = ngx.get_phase()</em></p><p><strong>context:</strong> init_by_lua*, init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Retrieves the current running phase name. Possible return values are</p><ul><li><code>init</code> for the context of [init_by_lua*]</li><li><code>init_worker</code> for the context of [init_worker_by_lua*]</li><li><code>ssl_cert</code> for the context of [ssl_certificate_by_lua*]</li><li><code>ssl_session_fetch</code> for the context of [ssl_session_fetch_by_lua*]</li><li><code>ssl_session_store</code> for the context of [ssl_session_store_by_lua*]</li><li><code>set</code> for the context of [set_by_lua*]</li><li><code>rewrite</code> for the context of [rewrite_by_lua*]</li><li><code>balancer</code> for the context of [balancer_by_lua*]</li><li><code>access</code> for the context of [access_by_lua*]</li><li><code>content</code> for the context of [content_by_lua*]</li><li><code>header_filter</code> for the context of [header_filter_by_lua*]</li><li><code>body_filter</code> for the context of [body_filter_by_lua*]</li><li><code>log</code> for the context of [log_by_lua*]</li><li><code>timer</code> for the context of user callback functions for [ngx.timer.*]</li></ul><p>This API was first introduced in the <code>v0.5.10</code> release.</p><h2><span id="ngxthreadspawn">ngx.thread.spawn</span></h2><p><strong>syntax:</strong> <em>co = ngx.thread.spawn(func, arg1, arg2, …)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p><p>Spawns a new user “light thread” with the Lua function <code>func</code> as well as those optional arguments <code>arg1</code>, <code>arg2</code>, and etc. Returns a Lua thread (or Lua coroutine) object represents this “light thread”.</p><p>“Light threads” are just a special kind of Lua coroutines that are scheduled by the ngx_lua module.</p><p>Before <code>ngx.thread.spawn</code> returns, the <code>func</code> will be called with those optional arguments until it returns, aborts with an error, or gets yielded due to I/O operations via the [Nginx API for Lua]</p><p>After <code>ngx.thread.spawn</code> returns, the newly-created “light thread” will keep running asynchronously usually at various I/O events.</p><p>All the Lua code chunks running by [rewrite_by_lua]</p><p>By default, the corresponding Nginx handler (e.g., [rewrite_by_lua]</p><ol><li>both the “entry thread” and all the user “light threads” terminates,</li><li>a “light thread” (either the “entry thread” or a user “light thread” aborts by calling [ngx.exit]</li><li>the “entry thread” terminates with a Lua error.</li></ol><p>When the user “light thread” terminates with a Lua error, however, it will not abort other running “light threads” like the “entry thread” does.</p><p>Due to the limitation in the Nginx subrequest model, it is not allowed to abort a running Nginx subrequest in general. So it is also prohibited to abort a running “light thread” that is pending on one ore more Nginx subrequests. You must call [ngx.thread.wait]</p><p>The “light threads” are not scheduled in a pre-emptive way. In other words, no time-slicing is performed automatically. A “light thread” will keep running exclusively on the CPU until</p><ol><li>a (nonblocking) I/O operation cannot be completed in a single run,</li><li>it calls [coroutine.yield]</li><li>it is aborted by a Lua error or an invocation of [ngx.exit]</li></ol><p>For the first two cases, the “light thread” will usually be resumed later by the ngx_lua scheduler unless a “stop-the-world” event happens.</p><p>User “light threads” can create “light threads” themselves. And normal user coroutines created by [coroutine.create]</p><p>The “parent coroutine” can call [ngx.thread.wait]</p><p>You can call coroutine.status() and coroutine.yield() on the “light thread” coroutines.</p><p>The status of the “light thread” coroutine can be “zombie” if</p><ol><li>the current “light thread” already terminates (either successfully or with an error),</li><li>its parent coroutine is still alive, and</li><li>its parent coroutine is not waiting on it with [ngx.thread.wait]</li></ol><p>The following example demonstrates the use of coroutine.yield() in the “light thread” coroutines to do manual time-slicing:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">local yield = coroutine.yield</span><br><span class="line"></span><br><span class="line">function f()</span><br><span class="line">    local self = coroutine.running()</span><br><span class="line">    ngx.say(&quot;f 1&quot;)</span><br><span class="line">    yield(self)</span><br><span class="line">    ngx.say(&quot;f 2&quot;)</span><br><span class="line">    yield(self)</span><br><span class="line">    ngx.say(&quot;f 3&quot;)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">local self = coroutine.running()</span><br><span class="line">ngx.say(&quot;0&quot;)</span><br><span class="line">yield(self)</span><br><span class="line"></span><br><span class="line">ngx.say(&quot;1&quot;)</span><br><span class="line">ngx.thread.spawn(f)</span><br><span class="line"></span><br><span class="line">ngx.say(&quot;2&quot;)</span><br><span class="line">yield(self)</span><br><span class="line"></span><br><span class="line">ngx.say(&quot;3&quot;)</span><br><span class="line">yield(self)</span><br><span class="line"></span><br><span class="line">ngx.say(&quot;4&quot;)</span><br></pre></td></tr></table></figure><p>Then it will generate the output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">f 1</span><br><span class="line">2</span><br><span class="line">f 2</span><br><span class="line">3</span><br><span class="line">f 3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>“Light threads” are mostly useful for making concurrent upstream requests in a single Nginx request handler, much like a generalized version of [ngx.location.capture_multi]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">-- query mysql, memcached, and a remote http service at the same time,</span><br><span class="line">-- output the results in the order that they</span><br><span class="line">-- actually return the results.</span><br><span class="line"></span><br><span class="line">local mysql = require &quot;resty.mysql&quot;</span><br><span class="line">local memcached = require &quot;resty.memcached&quot;</span><br><span class="line"></span><br><span class="line">local function query_mysql()</span><br><span class="line">    local db = mysql:new()</span><br><span class="line">    db:connect&#123;</span><br><span class="line">                host = &quot;127.0.0.1&quot;,</span><br><span class="line">                port = 3306,</span><br><span class="line">                database = &quot;test&quot;,</span><br><span class="line">                user = &quot;monty&quot;,</span><br><span class="line">                password = &quot;mypass&quot;</span><br><span class="line">              &#125;</span><br><span class="line">    local res, err, errno, sqlstate =</span><br><span class="line">            db:query(&quot;select * from cats order by id asc&quot;)</span><br><span class="line">    db:set_keepalive(0, 100)</span><br><span class="line">    ngx.say(&quot;mysql done: &quot;, cjson.encode(res))</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">local function query_memcached()</span><br><span class="line">    local memc = memcached:new()</span><br><span class="line">    memc:connect(&quot;127.0.0.1&quot;, 11211)</span><br><span class="line">    local res, err = memc:get(&quot;some_key&quot;)</span><br><span class="line">    ngx.say(&quot;memcached done: &quot;, res)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">local function query_http()</span><br><span class="line">    local res = ngx.location.capture(&quot;/my-http-proxy&quot;)</span><br><span class="line">    ngx.say(&quot;http done: &quot;, res.body)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">ngx.thread.spawn(query_mysql)      -- create thread 1</span><br><span class="line">ngx.thread.spawn(query_memcached)  -- create thread 2</span><br><span class="line">ngx.thread.spawn(query_http)       -- create thread 3</span><br></pre></td></tr></table></figure><p>This API was first enabled in the <code>v0.7.0</code> release.</p><h2><span id="ngxthreadwait">ngx.thread.wait</span></h2><p><strong>syntax:</strong> <em>ok, res1, res2, … = ngx.thread.wait(thread1, thread2, …)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p><p>Waits on one or more child “light threads” and returns the results of the first “light thread” that terminates (either successfully or with an error).</p><p>The arguments <code>thread1</code>, <code>thread2</code>, and etc are the Lua thread objects returned by earlier calls of [ngx.thread.spawn]</p><p>The return values have exactly the same meaning as [coroutine.resume]</p><p>Only the direct “parent coroutine” can wait on its child “light thread”, otherwise a Lua exception will be raised.</p><p>The following example demonstrates the use of <code>ngx.thread.wait</code> and [ngx.location.capture]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">local capture = ngx.location.capture</span><br><span class="line">local spawn = ngx.thread.spawn</span><br><span class="line">local wait = ngx.thread.wait</span><br><span class="line">local say = ngx.say</span><br><span class="line"></span><br><span class="line">local function fetch(uri)</span><br><span class="line">    return capture(uri)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">local threads = &#123;</span><br><span class="line">    spawn(fetch, &quot;/foo&quot;),</span><br><span class="line">    spawn(fetch, &quot;/bar&quot;),</span><br><span class="line">    spawn(fetch, &quot;/baz&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for i = 1, #threads do</span><br><span class="line">    local ok, res = wait(threads[i])</span><br><span class="line">    if not ok then</span><br><span class="line">        say(i, &quot;: failed to run: &quot;, res)</span><br><span class="line">    else</span><br><span class="line">        say(i, &quot;: status: &quot;, res.status)</span><br><span class="line">        say(i, &quot;: body: &quot;, res.body)</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>Here it essentially implements the “wait all” model.</p><p>And below is an example demonstrating the “wait any” model:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">function f()</span><br><span class="line">    ngx.sleep(0.2)</span><br><span class="line">    ngx.say(&quot;f: hello&quot;)</span><br><span class="line">    return &quot;f done&quot;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">function g()</span><br><span class="line">    ngx.sleep(0.1)</span><br><span class="line">    ngx.say(&quot;g: hello&quot;)</span><br><span class="line">    return &quot;g done&quot;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">local tf, err = ngx.thread.spawn(f)</span><br><span class="line">if not tf then</span><br><span class="line">    ngx.say(&quot;failed to spawn thread f: &quot;, err)</span><br><span class="line">    return</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">ngx.say(&quot;f thread created: &quot;, coroutine.status(tf))</span><br><span class="line"></span><br><span class="line">local tg, err = ngx.thread.spawn(g)</span><br><span class="line">if not tg then</span><br><span class="line">    ngx.say(&quot;failed to spawn thread g: &quot;, err)</span><br><span class="line">    return</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">ngx.say(&quot;g thread created: &quot;, coroutine.status(tg))</span><br><span class="line"></span><br><span class="line">ok, res = ngx.thread.wait(tf, tg)</span><br><span class="line">if not ok then</span><br><span class="line">    ngx.say(&quot;failed to wait: &quot;, res)</span><br><span class="line">    return</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">ngx.say(&quot;res: &quot;, res)</span><br><span class="line"></span><br><span class="line">-- stop the &quot;world&quot;, aborting other running threads</span><br><span class="line">ngx.exit(ngx.OK)</span><br></pre></td></tr></table></figure><p>And it will generate the following output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f thread created: running</span><br><span class="line">g thread created: running</span><br><span class="line">g: hello</span><br><span class="line">res: g done</span><br></pre></td></tr></table></figure><p>This API was first enabled in the <code>v0.7.0</code> release.</p><h2><span id="ngxthreadkill">ngx.thread.kill</span></h2><p><strong>syntax:</strong> <em>ok, err = ngx.thread.kill(thread)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.**</p><p>Kills a running “light thread” created by [ngx.thread.spawn]</p><p>According to the current implementation, only the parent coroutine (or “light thread”) can kill a thread. Also, a running “light thread” with pending NGINX subrequests (initiated by [ngx.location.capture]</p><p>This API was first enabled in the <code>v0.9.9</code> release.</p><h2><span id="ngxon_abort">ngx.on_abort</span></h2><p><strong>syntax:</strong> <em>ok, err = ngx.on_abort(callback)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*</p><p>Registers a user Lua function as the callback which gets called automatically when the client closes the (downstream) connection prematurely.</p><p>Returns <code>1</code> if the callback is registered successfully or returns <code>nil</code> and a string describing the error otherwise.</p><p>All the [Nginx API for Lua]</p><p>The callback function can decide what to do with the client abortion event all by itself. For example, it can simply ignore the event by doing nothing and the current Lua request handler will continue executing without interruptions. And the callback function can also decide to terminate everything by calling [ngx.exit]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">local function my_cleanup()</span><br><span class="line">    -- custom cleanup work goes here, like cancelling a pending DB transaction</span><br><span class="line"></span><br><span class="line">    -- now abort all the &quot;light threads&quot; running in the current request handler</span><br><span class="line">    ngx.exit(499)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">local ok, err = ngx.on_abort(my_cleanup)</span><br><span class="line">if not ok then</span><br><span class="line">    ngx.log(ngx.ERR, &quot;failed to register the on_abort callback: &quot;, err)</span><br><span class="line">    ngx.exit(500)</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>When [lua_check_client_abort]</p><p>According to the current implementation, this function can only be called once in a single request handler; subsequent calls will return the error message “duplicate call”.</p><p>This API was first introduced in the <code>v0.7.4</code> release.</p><p>See also [lua_check_client_abort]</p><h2><span id="ngxtimerat">ngx.timer.at</span></h2><p><strong>syntax:</strong> <em>hdl, err = ngx.timer.at(delay, callback, user_arg1, user_arg2, …)</em></p><p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Creates an Nginx timer with a user callback function as well as optional user arguments.</p><p>The first argument, <code>delay</code>, specifies the delay for the timer, in seconds. One can specify fractional seconds like <code>0.001</code> to mean 1 millisecond here. <code>0</code> delay can also be specified, in which case the timer will immediately expire when the current handler yields execution.</p><p>The second argument, <code>callback</code>, can be any Lua function, which will be invoked later in a background “light thread” after the delay specified. The user callback will be called automatically by the Nginx core with the arguments <code>premature</code>, <code>user_arg1</code>, <code>user_arg2</code>, and etc, where the <code>premature</code> argument takes a boolean value indicating whether it is a premature timer expiration or not, and <code>user_arg1</code>, <code>user_arg2</code>, and etc, are those (extra) user arguments specified when calling <code>ngx.timer.at</code>as the remaining arguments.</p><p>Premature timer expiration happens when the Nginx worker process is trying to shut down, as in an Nginx configuration reload triggered by the <code>HUP</code> signal or in an Nginx server shutdown. When the Nginx worker is trying to shut down, one can no longer call <code>ngx.timer.at</code> to create new timers with nonzero delays and in that case <code>ngx.timer.at</code> will return a “conditional false” value and a string describing the error, that is, “process exiting”.</p><p>Starting from the <code>v0.9.3</code> release, it is allowed to create zero-delay timers even when the Nginx worker process starts shutting down.</p><p>When a timer expires, the user Lua code in the timer callback is running in a “light thread” detached completely from the original request creating the timer. So objects with the same lifetime as the request creating them, like [cosockets]</p><p>Here is a simple example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    ...</span><br><span class="line">    log_by_lua_block &#123;</span><br><span class="line">        local function push_data(premature, uri, args, status)</span><br><span class="line">            -- push the data uri, args, and status to the remote</span><br><span class="line">            -- via ngx.socket.tcp or ngx.socket.udp</span><br><span class="line">            -- (one may want to buffer the data in Lua a bit to</span><br><span class="line">            -- save I/O operations)</span><br><span class="line">        end</span><br><span class="line">        local ok, err = ngx.timer.at(0, push_data,</span><br><span class="line">                                     ngx.var.uri, ngx.var.args, ngx.header.status)</span><br><span class="line">        if not ok then</span><br><span class="line">            ngx.log(ngx.ERR, &quot;failed to create timer: &quot;, err)</span><br><span class="line">            return</span><br><span class="line">        end</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>One can also create infinite re-occurring timers, for instance, a timer getting triggered every <code>5</code> seconds, by calling <code>ngx.timer.at</code> recursively in the timer callback function. Here is such an example,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">local delay = 5</span><br><span class="line">local handler</span><br><span class="line">handler = function (premature)</span><br><span class="line">    -- do some routine job in Lua just like a cron job</span><br><span class="line">    if premature then</span><br><span class="line">        return</span><br><span class="line">    end</span><br><span class="line">    local ok, err = ngx.timer.at(delay, handler)</span><br><span class="line">    if not ok then</span><br><span class="line">        ngx.log(ngx.ERR, &quot;failed to create the timer: &quot;, err)</span><br><span class="line">        return</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">local ok, err = ngx.timer.at(delay, handler)</span><br><span class="line">if not ok then</span><br><span class="line">    ngx.log(ngx.ERR, &quot;failed to create the timer: &quot;, err)</span><br><span class="line">    return</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>It is recommended, however, to use the [ngx.timer.every]</p><p>Because timer callbacks run in the background and their running time will not add to any client request’s response time, they can easily accumulate in the server and exhaust system resources due to either Lua programming mistakes or just too much client traffic. To prevent extreme consequences like crashing the Nginx server, there are built-in limitations on both the number of “pending timers” and the number of “running timers” in an Nginx worker process. The “pending timers” here mean timers that have not yet been expired and “running timers” are those whose user callbacks are currently running.</p><p>The maximal number of pending timers allowed in an Nginx worker is controlled by the [lua_max_pending_timers]</p><p>According to the current implementation, each “running timer” will take one (fake) connection record from the global connection record list configured by the standard <a href="http://nginx.org/en/docs/ngx_core_module.html#worker_connections" target="_blank" rel="noopener">worker_connections</a> directive in <code>nginx.conf</code>. So ensure that the<a href="http://nginx.org/en/docs/ngx_core_module.html#worker_connections" target="_blank" rel="noopener">worker_connections</a> directive is set to a large enough value that takes into account both the real connections and fake connections required by timer callbacks (as limited by the [lua_max_running_timers]</p><p>A lot of the Lua APIs for Nginx are enabled in the context of the timer callbacks, like stream/datagram cosockets ([ngx.socket.tcp]</p><p>You can pass most of the standard Lua values (nils, booleans, numbers, strings, tables, closures, file handles, and etc) into the timer callback, either explicitly as user arguments or implicitly as upvalues for the callback closure. There are several exceptions, however: you <em>cannot</em> pass any thread objects returned by [coroutine.create]</p><p>This API was first introduced in the <code>v0.8.0</code> release.</p><h2><span id="ngxtimerevery">ngx.timer.every</span></h2><p><strong>syntax:</strong> <em>hdl, err = ngx.timer.every(delay, callback, user_arg1, user_arg2, …)</em></p><p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Similar to the [ngx.timer.at]</p><ol><li><code>delay</code> <em>cannot</em> be zero,</li><li>timer will be created every <code>delay</code> seconds until the current Nginx worker process starts exiting.</li></ol><p>When success, returns a “conditional true” value (but not a <code>true</code>). Otherwise, returns a “conditional false” value and a string describing the error.</p><p>This API also respect the [lua_max_pending_timers]</p><p>This API was first introduced in the <code>v0.10.9</code> release.</p><h2><span id="ngxtimerrunning_count">ngx.timer.running_count</span></h2><p><strong>syntax:</strong> <em>count = ngx.timer.running_count()</em></p><p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Returns the number of timers currently running.</p><p>This directive was first introduced in the <code>v0.9.20</code> release.</p><h2><span id="ngxtimerpending_count">ngx.timer.pending_count</span></h2><p><strong>syntax:</strong> <em>count = ngx.timer.pending_count()</em></p><p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Returns the number of pending timers.</p><p>This directive was first introduced in the <code>v0.9.20</code> release.</p><h2><span id="ngxconfigsubsystem">ngx.config.subsystem</span></h2><p><strong>syntax:</strong> <em>subsystem = ngx.config.subsystem</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_by_lua*, init_worker_by_lua*</p><p>This string field indicates the current NGINX subsystem the current Lua environment is based on. For this module, this field always takes the string value <code>&quot;http&quot;</code>. For [ngx_stream_lua_module]</p><p>This field was first introduced in the <code>0.10.1</code>.</p><h2><span id="ngxconfigdebug">ngx.config.debug</span></h2><p><strong>syntax:</strong> <em>debug = ngx.config.debug</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_by_lua*, init_worker_by_lua*</p><p>This boolean field indicates whether the current Nginx is a debug build, i.e., being built by the <code>./configure</code> option <code>--with-debug</code>.</p><p>This field was first introduced in the <code>0.8.7</code>.</p><h2><span id="ngxconfigprefix">ngx.config.prefix</span></h2><p><strong>syntax:</strong> <em>prefix = ngx.config.prefix()</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_by_lua*, init_worker_by_lua*</p><p>Returns the Nginx server “prefix” path, as determined by the <code>-p</code> command-line option when running the nginx executable, or the path specified by the <code>--prefix</code> command-line option when building Nginx with the <code>./configure</code> script.</p><p>This function was first introduced in the <code>0.9.2</code>.</p><h2><span id="ngxconfignginx_version">ngx.config.nginx_version</span></h2><p><strong>syntax:</strong> <em>ver = ngx.config.nginx_version</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_by_lua*, init_worker_by_lua*</p><p>This field take an integral value indicating the version number of the current Nginx core being used. For example, the version number <code>1.4.3</code> results in the Lua number 1004003.</p><p>This API was first introduced in the <code>0.9.3</code> release.</p><h2><span id="ngxconfignginx_configure">ngx.config.nginx_configure</span></h2><p><strong>syntax:</strong> <em>str = ngx.config.nginx_configure()</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_by_lua*</p><p>This function returns a string for the NGINX <code>./configure</code> command’s arguments string.</p><p>This API was first introduced in the <code>0.9.5</code> release.</p><h2><span id="ngxconfigngx_lua_version">ngx.config.ngx_lua_version</span></h2><p><strong>syntax:</strong> <em>ver = ngx.config.ngx_lua_version</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_by_lua*</p><p>This field take an integral value indicating the version number of the current <code>ngx_lua</code> module being used. For example, the version number <code>0.9.3</code> results in the Lua number 9003.</p><p>This API was first introduced in the <code>0.9.3</code> release.</p><h2><span id="ngxworkerexiting">ngx.worker.exiting</span></h2><p><strong>syntax:</strong> <em>exiting = ngx.worker.exiting()</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_by_lua*, init_worker_by_lua*</p><p>This function returns a boolean value indicating whether the current Nginx worker process already starts exiting. Nginx worker process exiting happens on Nginx server quit or configuration reload (aka HUP reload).</p><p>This API was first introduced in the <code>0.9.3</code> release.</p><h2><span id="ngxworkerpid">ngx.worker.pid</span></h2><p><strong>syntax:</strong> <em>pid = ngx.worker.pid()</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_by_lua*, init_worker_by_lua*</p><p>This function returns a Lua number for the process ID (PID) of the current Nginx worker process. This API is more efficient than <code>ngx.var.pid</code> and can be used in contexts where the [ngx.var.VARIABLE]</p><p>This API was first introduced in the <code>0.9.5</code> release.</p><h2><span id="ngxworkercount">ngx.worker.count</span></h2><p><strong>syntax:</strong> <em>count = ngx.worker.count()</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_by_lua*, init_worker_by_lua*</p><p>Returns the total number of the Nginx worker processes (i.e., the value configured by the <a href="http://nginx.org/en/docs/ngx_core_module.html#worker_processes" target="_blank" rel="noopener">worker_processes</a> directive in <code>nginx.conf</code>).</p><p>This API was first introduced in the <code>0.9.20</code> release.</p><h2><span id="ngxworkerid">ngx.worker.id</span></h2><p><strong>syntax:</strong> <em>count = ngx.worker.id()</em></p><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_worker_by_lua*</p><p>Returns the ordinal number of the current Nginx worker processes (starting from number 0).</p><p>So if the total number of workers is <code>N</code>, then this method may return a number between 0 and <code>N - 1</code> (inclusive).</p><p>This function returns meaningful values only for NGINX 1.9.1+. With earlier versions of NGINX, it always returns <code>nil</code>.</p><p>See also [ngx.worker.count]</p><p>This API was first introduced in the <code>0.9.20</code> release.</p><h2><span id="ngxsemaphore">ngx.semaphore</span></h2><p><strong>syntax:</strong> <em>local semaphore = require “ngx.semaphore”</em></p><p>This is a Lua module that implements a classic-style semaphore API for efficient synchronizations among different “light threads”. Sharing the same semaphore among different “light threads” created in different (request) contexts are also supported as long as the “light threads” reside in the same NGINX worker process and the [lua_code_cache]</p><p>This Lua module does not ship with this ngx_lua module itself rather it is shipped with the [lua-resty-core]</p><p>Please refer to the [documentation]</p><p>This feature requires at least ngx_lua <code>v0.10.0</code>.</p><h2><span id="ngxbalancer">ngx.balancer</span></h2><p><strong>syntax:</strong> <em>local balancer = require “ngx.balancer”</em></p><p>This is a Lua module that provides a Lua API to allow defining completely dynamic load balancers in pure Lua.</p><p>This Lua module does not ship with this ngx_lua module itself rather it is shipped with the [lua-resty-core]</p><p>Please refer to the [documentation]</p><p>This feature requires at least ngx_lua <code>v0.10.0</code>.</p><h2><span id="ngxssl">ngx.ssl</span></h2><p><strong>syntax:</strong> <em>local ssl = require “ngx.ssl”</em></p><p>This Lua module provides API functions to control the SSL handshake process in contexts like [ssl_certificate_by_lua*]</p><p>This Lua module does not ship with this ngx_lua module itself rather it is shipped with the [lua-resty-core]</p><p>Please refer to the [documentation]</p><p>This feature requires at least ngx_lua <code>v0.10.0</code>.</p><h2><span id="ngxocsp">ngx.ocsp</span></h2><p><strong>syntax:</strong> <em>local ocsp = require “ngx.ocsp”</em></p><p>This Lua module provides API to perform OCSP queries, OCSP response validations, and OCSP stapling planting.</p><p>Usually, this module is used together with the [ngx.ssl]</p><p>This Lua module does not ship with this ngx_lua module itself rather it is shipped with the [lua-resty-core]</p><p>Please refer to the [documentation]</p><p>This feature requires at least ngx_lua <code>v0.10.0</code>.</p><h2><span id="ndkset_vardirective">ndk.set_var.DIRECTIVE</span></h2><p><strong>syntax:</strong> <em>res = ndk.set_var.DIRECTIVE_NAME</em></p><p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>This mechanism allows calling other nginx C modules’ directives that are implemented by [Nginx Devel Kit]</p><p>For example, the following <a href="http://github.com/openresty/set-misc-nginx-module" target="_blank" rel="noopener">set-misc-nginx-module</a> directives can be invoked this way:</p><ul><li><a href="http://github.com/openresty/set-misc-nginx-module#set_quote_sql_str" target="_blank" rel="noopener">set_quote_sql_str</a></li><li><a href="http://github.com/openresty/set-misc-nginx-module#set_quote_pgsql_str" target="_blank" rel="noopener">set_quote_pgsql_str</a></li><li><a href="http://github.com/openresty/set-misc-nginx-module#set_quote_json_str" target="_blank" rel="noopener">set_quote_json_str</a></li><li><a href="http://github.com/openresty/set-misc-nginx-module#set_unescape_uri" target="_blank" rel="noopener">set_unescape_uri</a></li><li><a href="http://github.com/openresty/set-misc-nginx-module#set_escape_uri" target="_blank" rel="noopener">set_escape_uri</a></li><li><a href="http://github.com/openresty/set-misc-nginx-module#set_encode_base32" target="_blank" rel="noopener">set_encode_base32</a></li><li><a href="http://github.com/openresty/set-misc-nginx-module#set_decode_base32" target="_blank" rel="noopener">set_decode_base32</a></li><li><a href="http://github.com/openresty/set-misc-nginx-module#set_encode_base64" target="_blank" rel="noopener">set_encode_base64</a></li><li><a href="http://github.com/openresty/set-misc-nginx-module#set_decode_base64" target="_blank" rel="noopener">set_decode_base64</a></li><li><a href="http://github.com/openresty/set-misc-nginx-module#set_encode_base64" target="_blank" rel="noopener">set_encode_hex</a></li><li><a href="http://github.com/openresty/set-misc-nginx-module#set_decode_base64" target="_blank" rel="noopener">set_decode_hex</a></li><li><a href="http://github.com/openresty/set-misc-nginx-module#set_encode_base64" target="_blank" rel="noopener">set_sha1</a></li><li><a href="http://github.com/openresty/set-misc-nginx-module#set_decode_base64" target="_blank" rel="noopener">set_md5</a></li></ul><p>For instance,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local res = ndk.set_var.set_escape_uri(&apos;a/b&apos;);</span><br><span class="line">-- now res == &apos;a%2fb&apos;</span><br></pre></td></tr></table></figure><p>Similarly, the following directives provided by <a href="http://github.com/openresty/encrypted-session-nginx-module" target="_blank" rel="noopener">encrypted-session-nginx-module</a> can be invoked from within Lua too:</p><ul><li><a href="http://github.com/openresty/encrypted-session-nginx-module#set_encrypt_session" target="_blank" rel="noopener">set_encrypt_session</a></li><li><a href="http://github.com/openresty/encrypted-session-nginx-module#set_decrypt_session" target="_blank" rel="noopener">set_decrypt_session</a></li></ul><p>This feature requires the [ngx_devel_kit]</p><h2><span id="coroutinecreate">coroutine.create</span></h2><p><strong>syntax:</strong> <em>co = coroutine.create(f)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, init_by_lua*, ngx.timer.*, header_filter_by_lua*, body_filter_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Creates a user Lua coroutines with a Lua function, and returns a coroutine object.</p><p>Similar to the standard Lua <a href="http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.create" target="_blank" rel="noopener">coroutine.create</a> API, but works in the context of the Lua coroutines created by ngx_lua.</p><p>This API was first usable in the context of [init_by_lua*]</p><p>This API was first introduced in the <code>v0.6.0</code> release.</p><h2><span id="coroutineresume">coroutine.resume</span></h2><p><strong>syntax:</strong> <em>ok, … = coroutine.resume(co, …)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, init_by_lua*, ngx.timer.*, header_filter_by_lua*, body_filter_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Resumes the executation of a user Lua coroutine object previously yielded or just created.</p><p>Similar to the standard Lua <a href="http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.resume" target="_blank" rel="noopener">coroutine.resume</a> API, but works in the context of the Lua coroutines created by ngx_lua.</p><p>This API was first usable in the context of [init_by_lua*]</p><p>This API was first introduced in the <code>v0.6.0</code> release.</p><h2><span id="coroutineyield">coroutine.yield</span></h2><p><strong>syntax:</strong> <em>… = coroutine.yield(…)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, init_by_lua*, ngx.timer.*, header_filter_by_lua*, body_filter_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Yields the execution of the current user Lua coroutine.</p><p>Similar to the standard Lua <a href="http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.yield" target="_blank" rel="noopener">coroutine.yield</a> API, but works in the context of the Lua coroutines created by ngx_lua.</p><p>This API was first usable in the context of [init_by_lua*]</p><p>This API was first introduced in the <code>v0.6.0</code> release.</p><h2><span id="coroutinewrap">coroutine.wrap</span></h2><p><strong>syntax:</strong> <em>co = coroutine.wrap(f)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, init_by_lua*, ngx.timer.*, header_filter_by_lua*, body_filter_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Similar to the standard Lua <a href="http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.wrap" target="_blank" rel="noopener">coroutine.wrap</a> API, but works in the context of the Lua coroutines created by ngx_lua.</p><p>This API was first usable in the context of [init_by_lua*]</p><p>This API was first introduced in the <code>v0.6.0</code> release.</p><h2><span id="coroutinerunning">coroutine.running</span></h2><p><strong>syntax:</strong> <em>co = coroutine.running()</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, init_by_lua*, ngx.timer.*, header_filter_by_lua*, body_filter_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Identical to the standard Lua <a href="http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.running" target="_blank" rel="noopener">coroutine.running</a> API.</p><p>This API was first usable in the context of [init_by_lua*]</p><p>This API was first enabled in the <code>v0.6.0</code> release.</p><h2><span id="coroutinestatus">coroutine.status</span></h2><p><strong>syntax:</strong> <em>status = coroutine.status(co)</em></p><p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, init_by_lua*, ngx.timer.*, header_filter_by_lua*, body_filter_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p><p>Identical to the standard Lua <a href="http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.status" target="_blank" rel="noopener">coroutine.status</a> API.</p><p>This API was first usable in the context of [init_by_lua*]</p><p>This API was first enabled in the <code>v0.6.0</code> release.</p><p>##</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#nginx-api-for-lua&quot;&gt;Nginx API for Lua&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#introduction&quot;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx+Lua=OpenResty</title>
    <link href="http://yoursite.com/2018/02/28/Nginx-Lua-OpenResty/"/>
    <id>http://yoursite.com/2018/02/28/Nginx-Lua-OpenResty/</id>
    <published>2018-02-28T08:23:27.000Z</published>
    <updated>2019-03-01T06:26:01.525Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="openresty">openresty</span></h1><h2><span id="应用场景">应用场景</span></h2><p>理论上可以使用ngx_lua开发各种复杂的web应用，不过lua是一种脚本/动态语言，不适合业务逻辑比较重的场景，适合小巧的应用场景，代码行数保持在几十行到几千行。目前见到的一些应用场景有：</p><ul><li>web应用：进行一些业务逻辑的处理，模板渲染，一般流程：mysql/redis/http获取数据-&gt;业务处理-&gt;产生JSON/XML/模板渲染内容，比如京东的列表页/商品详情页；</li><li>接入网关：实现如数据校验前置、缓存前置、数据过滤、API请求聚合、AB测试、灰度发布、降级、监控等功能，比如京东的交易大Nginx节点、无线网关、实时价格、动态服务；</li><li>Web防火墙：可以进行IP/URL/UserAgent/Referer黑名单、限流功能；</li><li>缓存服务器：可以对响应内容进行缓存，减少到后端的请求，从而提高性能；</li><li>其他：如静态资源服务器、消息推送服务、缩略图裁剪等</li></ul><h2><span id="location">location</span></h2><h3><span id="内部调用">内部调用</span></h3><p>对数据库、内部公共函数的统一接口，可以把它们放到统一的location中。</p><p>为了保护这些内部接口，都会把这些接口设置为internal。这么做的好处是可以让这个内部接口相对独立，不受外界干扰。</p><p><em>ngx.say()是怎么调用的？</em></p><p><em>这是个API，供lua调用。那这个api的定义和实现都在哪里呢？</em></p><p>示例代码：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">location = /sum &#123;</span><br><span class="line">    # 只允许内部调用</span><br><span class="line">    internal;</span><br><span class="line"></span><br><span class="line">    # 这里做了一个求和运算只是一个例子，可以在这里完成一些数据库、</span><br><span class="line">    # 缓存服务器的操作，达到基础模块和业务逻辑分离目的</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        <span class="keyword">local</span> args = ngx.req.get_uri_args()</span><br><span class="line">        # ngx.say 打印到response body并换行</span><br><span class="line">        ngx.say(<span class="built_in">tonumber</span>(args.a) + <span class="built_in">tonumber</span>(args.b))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location = /app/test &#123;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        <span class="keyword">local</span> res = ngx.location.capture(</span><br><span class="line">                        <span class="string">"/sum"</span>, &#123;args=&#123;a=<span class="number">3</span>, b=<span class="number">8</span>&#125;&#125;</span><br><span class="line">                        )</span><br><span class="line">        ngx.say(<span class="string">"status:"</span>, res.<span class="built_in">status</span>, <span class="string">" response:"</span>, res.body)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[root@geek work]# curl localhost/app/test</span><br><span class="line"><span class="built_in">status</span>:<span class="number">200</span>response:<span class="number">11</span></span><br></pre></td></tr></table></figure><p>并行请求的效果，示例如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">location = /sum &#123;</span><br><span class="line">    internal;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        ngx.sleep(<span class="number">0.1</span>)</span><br><span class="line">        <span class="keyword">local</span> args = ngx.req.get_uri_args()</span><br><span class="line">        ngx.<span class="built_in">print</span>(<span class="built_in">tonumber</span>(args.a) + <span class="built_in">tonumber</span>(args.b))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location = /subduction &#123;</span><br><span class="line">    internal;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        ngx.sleep(<span class="number">0.1</span>)</span><br><span class="line">        <span class="keyword">local</span> args = ngx.req.get_uri_args()</span><br><span class="line">        ngx.<span class="built_in">print</span>(<span class="built_in">tonumber</span>(args.a) - <span class="built_in">tonumber</span>(args.b))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location = /app/test_parallels &#123;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        <span class="keyword">local</span> start_time = ngx.now()</span><br><span class="line">        <span class="keyword">local</span> res1, res2 = ngx.location.capture_multi( &#123;</span><br><span class="line">                        &#123;<span class="string">"/sum"</span>, &#123;args=&#123;a=<span class="number">3</span>, b=<span class="number">8</span>&#125;&#125;&#125;,</span><br><span class="line">                        &#123;<span class="string">"/subduction"</span>, &#123;args=&#123;a=<span class="number">3</span>, b=<span class="number">8</span>&#125;&#125;&#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">        ngx.say(<span class="string">"status:"</span>, res1.<span class="built_in">status</span>, <span class="string">" response:"</span>, res1.body)</span><br><span class="line">        ngx.say(<span class="string">"status:"</span>, res2.<span class="built_in">status</span>, <span class="string">" response:"</span>, res2.body)</span><br><span class="line">        ngx.say(<span class="string">"time used:"</span>, ngx.now() - start_time)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location = /app/test_queue &#123;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        <span class="keyword">local</span> start_time = ngx.now()</span><br><span class="line">        <span class="keyword">local</span> res1 = ngx.location.capture_multi( &#123;</span><br><span class="line">                        &#123;<span class="string">"/sum"</span>, &#123;args=&#123;a=<span class="number">3</span>, b=<span class="number">8</span>&#125;&#125;&#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">        <span class="keyword">local</span> res2 = ngx.location.capture_multi( &#123;</span><br><span class="line">                        &#123;<span class="string">"/subduction"</span>, &#123;args=&#123;a=<span class="number">3</span>, b=<span class="number">8</span>&#125;&#125;&#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">        ngx.say(<span class="string">"status:"</span>, res1.<span class="built_in">status</span>, <span class="string">" response:"</span>, res1.body)</span><br><span class="line">        ngx.say(<span class="string">"status:"</span>, res2.<span class="built_in">status</span>, <span class="string">" response:"</span>, res2.body)</span><br><span class="line">        ngx.say(<span class="string">"time used:"</span>, ngx.now() - start_time)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 测试结果</span><br><span class="line">➜  ~ curl <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>/app/test_parallels</span><br><span class="line"><span class="built_in">status</span>:<span class="number">200</span> response:<span class="number">11</span></span><br><span class="line"><span class="built_in">status</span>:<span class="number">200</span> response:<span class="number">-5</span></span><br><span class="line"><span class="built_in">time</span> used:<span class="number">0.10099983215332</span></span><br><span class="line">➜  ~ curl <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>/app/test_queue</span><br><span class="line"><span class="built_in">status</span>:<span class="number">200</span> response:<span class="number">11</span></span><br><span class="line"><span class="built_in">status</span>:<span class="number">200</span> response:<span class="number">-5</span></span><br><span class="line"><span class="built_in">time</span> used:<span class="number">0.20199990272522</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;openresty&quot;&gt;openresty&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span id=&quot;应用场景&quot;&gt;应用场景&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;理论上可以使用ngx_lua开发各种复杂的web应用，不过lua是一种脚本/动态语言，不适合业务逻辑比较重的场
      
    
    </summary>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
</feed>
