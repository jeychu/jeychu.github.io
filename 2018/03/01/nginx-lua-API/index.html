

<!DOCTYPE html>
<html lang xmlns:v-bind="http://www.w3.org/1999/xhtml">

<head><meta name="generator" content="Hexo 3.8.0">
    <title>nginx-lua-API - javfa&#39;s blog</title>
<meta charset="utf-8">
<meta name="X-UA-Compatible" content="IE=edge">
<meta name="author" content="Javfa">
<meta name="description" content="

Nginx API for Lua
Introduction
ngx.arg
ngx.var.VARIABLE...">
<meta name="keywords" content>

    <meta charset="utf-8">
    <meta name="X-UA-Compatible" content="IE=edge">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <meta content="telephone=no" name="format-detection">
    <meta name="renderer" content="webkit">
    <meta name="theme-color" content="#ffffff">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.1.3/dist/css/bootstrap.min.css" integrity="sha256-eSi1q2PG6J7g7ib17yAaWMcrr5GrtohYChqibrV7PBE=" crossorigin="anonymous">
<link rel="stylesheet" href="/css/journal.css?10845045">
<script src="/js/loadCSS.js"></script>
<script>
    loadCSS("https://fonts.googleapis.com/css?family=Lora|Montserrat|Fira+Mono|Material+Icons");
    (function (d) {
        var config = {
                kitId: 'dwg1tuc',
                scriptTimeout: 3000,
                async: true
            },
            h = d.documentElement, t = setTimeout(function () {
                h.className = h.className.replace(/\bwf-loading\b/g, "") + " wf-inactive";
            }, config.scriptTimeout), tk = d.createElement("script"), f = false,
            s = d.getElementsByTagName("script")[0], a;
        h.className += " wf-loading";
        tk.src = 'https://use.typekit.net/' + config.kitId + '.js';
        tk.async = true;
        tk.onload = tk.onreadystatechange = function () {
            a = this.readyState;
            if (f || a && a != "complete" && a != "loaded") return;
            f = true;
            clearTimeout(t);
            try {
                Typekit.load(config)
            } catch (e) {
            }
        };
        s.parentNode.insertBefore(tk, s)
    })(document);
</script>
<noscript>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora|Montserrat|Anonymous+Pro:400|Material+Icons">
</noscript>
</head>
<body>
<div id="top"></div>
<div id="app">
<div class="single-column-drawer-container" ref="drawer" v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }">
    <div class="drawer-content">
        <div class="drawer-menu">
            <a class="a-block drawer-menu-item false" href="http://yoursite.com">
                首页
            </a>
            <a class="a-block drawer-menu-item false" href="/archives">
                归档
            </a>

            
            

            
        </div>
    </div>
</div>
<transition name="fade">
    <div v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if="isDrawerOpen" v-on:click="toggleDrawer"></div>
</transition>
<nav ref="navBar" class="navbar sticky-top navbar-light single-column-nav-container">
    <div ref="navBackground" class="nav-background"></div>
    <div class="container container-narrow nav-content">
        <button id="nav_dropdown_btn" class="nav-dropdown-toggle" type="button" v-on:click="toggleDrawer">
            <i class="material-icons">
                menu
            </i>
        </button>
        <a ref="navTitle" class="navbar-brand" href="/">
            javfa&#39;s blog
        </a>
    </div>
</nav>
<div class="single-column-header-container" ref="pageHead" v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }">
    <a href="/">
        <div class="single-column-header-title">javfa&#39;s blog</div>
        <div class="single-column-header-subtitle"></div>
    </a>
</div>
<div ref="sideContainer" class="side-container">
    <a class="a-block nav-head false" href="/">
        <div class="nav-title">
            {博客@家發}
        </div>
        <div class="nav-subtitle">
            隻言片語<br>於此匯聚
        </div>
    </a>

    <div class="nav-link-list">
        <a class="a-block no-tint nav-link-item false" href="/archives">
            归档
        </a>

        
        

        
    </div>

    
    <div class="nav-footer">
        Proudly published with Hexo<br>
        
        Theme <a href="https://github.com/SumiMakito/hexo-theme-journal/" target="_blank" rel="noreferrer noopener">Journal.</a> by <a href="https://mak1t0.cc/" target="_blank" rel="noreferrer noopener">Makito</a><br>
        
        &copy; 2019 <a href="http://yoursite.com">javfa&#39;s blog</a>
    </div>
</div>
<div ref="extraContainer" class="extra-container">
    <div class="pagination">
        <a id="globalBackToTop" class="pagination-action animated-visibility" href="#top" :class="{ invisible: scrollY == 0 }">
            <i class="material-icons pagination-action-icon">
                keyboard_arrow_up
            </i>
        </a>

        
    </div>
</div>

<div ref="streamContainer" class="stream-container">
    <div class="post-list-container post-list-container-shadow">
        <div class="post">
            <div class="post-head-wrapper-text-only" style="background-image: url('')">
                <div class="post-title">
                    nginx-lua-API
                    <div class="post-meta">
                        <time datetime="2018-03-01T04:17:54.000Z" itemprop="datePublished">
                            2018-03-01 12:17
                        </time>&nbsp;
                        
    
                        
                        
                        <i class="material-icons" style>label</i>
                        
                        <a href="/tags/Nginx/">Nginx</a>
                        
                        
                    </div>
                </div>
            </div>
    
            <div class="post-body-wrapper">
                <div class="post-body">
                    <!-- toc -->
<ul>
<li><a href="#nginx-api-for-lua">Nginx API for Lua</a><ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#ngxarg">ngx.arg</a></li>
<li><a href="#ngxvarvariable">ngx.var.VARIABLE</a></li>
<li><a href="#core-constants">Core constants</a></li>
<li><a href="#http-method-constants">HTTP method constants</a></li>
<li><a href="#http-status-constants">HTTP status constants</a></li>
<li><a href="#nginx-log-level-constants">Nginx log level constants</a></li>
<li><a href="#print">print</a></li>
<li><a href="#ngxctx">ngx.ctx</a></li>
<li><a href="#ngxlocationcapture">ngx.location.capture</a></li>
<li><a href="#ngxlocationcapture_multi">ngx.location.capture_multi</a></li>
<li><a href="#ngxstatus">ngx.status</a></li>
<li><a href="#ngxheaderheader">ngx.header.HEADER</a></li>
<li><a href="#ngxrespget_headers">ngx.resp.get_headers</a></li>
<li><a href="#ngxreqis_internal">ngx.req.is_internal</a></li>
<li><a href="#ngxreqstart_time">ngx.req.start_time</a></li>
<li><a href="#ngxreqhttp_version">ngx.req.http_version</a></li>
<li><a href="#ngxreqraw_header">ngx.req.raw_header</a></li>
<li><a href="#ngxreqget_method">ngx.req.get_method</a></li>
<li><a href="#ngxreqset_method">ngx.req.set_method</a></li>
<li><a href="#ngxreqset_uri">ngx.req.set_uri</a></li>
<li><a href="#ngxreqset_uri_args">ngx.req.set_uri_args</a></li>
<li><a href="#ngxreqget_uri_args">ngx.req.get_uri_args</a></li>
<li><a href="#ngxreqget_post_args">ngx.req.get_post_args</a></li>
<li><a href="#ngxreqget_headers">ngx.req.get_headers</a></li>
<li><a href="#ngxreqset_header">ngx.req.set_header</a></li>
<li><a href="#ngxreqclear_header">ngx.req.clear_header</a></li>
<li><a href="#ngxreqread_body">ngx.req.read_body</a></li>
<li><a href="#ngxreqdiscard_body">ngx.req.discard_body</a></li>
<li><a href="#ngxreqget_body_data">ngx.req.get_body_data</a></li>
<li><a href="#ngxreqget_body_file">ngx.req.get_body_file</a></li>
<li><a href="#ngxreqset_body_data">ngx.req.set_body_data</a></li>
<li><a href="#ngxreqset_body_file">ngx.req.set_body_file</a></li>
<li><a href="#ngxreqinit_body">ngx.req.init_body</a></li>
<li><a href="#ngxreqappend_body">ngx.req.append_body</a></li>
<li><a href="#ngxreqfinish_body">ngx.req.finish_body</a></li>
<li><a href="#ngxreqsocket">ngx.req.socket</a></li>
<li><a href="#ngxexec">ngx.exec</a></li>
<li><a href="#ngxredirect">ngx.redirect</a></li>
<li><a href="#ngxsend_headers">ngx.send_headers</a></li>
<li><a href="#ngxheaders_sent">ngx.headers_sent</a></li>
<li><a href="#ngxprint">ngx.print</a></li>
<li><a href="#ngxsay">ngx.say</a></li>
<li><a href="#ngxlog">ngx.log</a></li>
<li><a href="#ngxflush">ngx.flush</a></li>
<li><a href="#ngxexit">ngx.exit</a></li>
<li><a href="#ngxeof">ngx.eof</a></li>
<li><a href="#ngxsleep">ngx.sleep</a></li>
<li><a href="#ngxescape_uri">ngx.escape_uri</a></li>
<li><a href="#ngxunescape_uri">ngx.unescape_uri</a></li>
<li><a href="#ngxencode_args">ngx.encode_args</a></li>
<li><a href="#ngxdecode_args">ngx.decode_args</a></li>
<li><a href="#ngxencode_base64">ngx.encode_base64</a></li>
<li><a href="#ngxdecode_base64">ngx.decode_base64</a></li>
<li><a href="#ngxcrc32_short">ngx.crc32_short</a></li>
<li><a href="#ngxcrc32_long">ngx.crc32_long</a></li>
<li><a href="#ngxhmac_sha1">ngx.hmac_sha1</a></li>
<li><a href="#ngxmd5">ngx.md5</a></li>
<li><a href="#ngxmd5_bin">ngx.md5_bin</a></li>
<li><a href="#ngxsha1_bin">ngx.sha1_bin</a></li>
<li><a href="#ngxquote_sql_str">ngx.quote_sql_str</a></li>
<li><a href="#ngxtoday">ngx.today</a></li>
<li><a href="#ngxtime">ngx.time</a></li>
<li><a href="#ngxnow">ngx.now</a></li>
<li><a href="#ngxupdate_time">ngx.update_time</a></li>
<li><a href="#ngxlocaltime">ngx.localtime</a></li>
<li><a href="#ngxutctime">ngx.utctime</a></li>
<li><a href="#ngxcookie_time">ngx.cookie_time</a></li>
<li><a href="#ngxhttp_time">ngx.http_time</a></li>
<li><a href="#ngxparse_http_time">ngx.parse_http_time</a></li>
<li><a href="#ngxis_subrequest">ngx.is_subrequest</a></li>
<li><a href="#ngxrematch">ngx.re.match</a></li>
<li><a href="#ngxrefind">ngx.re.find</a></li>
<li><a href="#ngxregmatch">ngx.re.gmatch</a></li>
<li><a href="#ngxresub">ngx.re.sub</a></li>
<li><a href="#ngxregsub">ngx.re.gsub</a></li>
<li><a href="#ngxshareddict">ngx.shared.DICT</a></li>
<li><a href="#ngxshareddictget">ngx.shared.DICT.get</a></li>
<li><a href="#ngxshareddictget_stale">ngx.shared.DICT.get_stale</a></li>
<li><a href="#ngxshareddictset">ngx.shared.DICT.set</a></li>
<li><a href="#ngxshareddictsafe_set">ngx.shared.DICT.safe_set</a></li>
<li><a href="#ngxshareddictadd">ngx.shared.DICT.add</a></li>
<li><a href="#ngxshareddictsafe_add">ngx.shared.DICT.safe_add</a></li>
<li><a href="#ngxshareddictreplace">ngx.shared.DICT.replace</a></li>
<li><a href="#ngxshareddictdelete">ngx.shared.DICT.delete</a></li>
<li><a href="#ngxshareddictincr">ngx.shared.DICT.incr</a></li>
<li><a href="#ngxshareddictlpush">ngx.shared.DICT.lpush</a></li>
<li><a href="#ngxshareddictrpush">ngx.shared.DICT.rpush</a></li>
<li><a href="#ngxshareddictlpop">ngx.shared.DICT.lpop</a></li>
<li><a href="#ngxshareddictrpop">ngx.shared.DICT.rpop</a></li>
<li><a href="#ngxshareddictllen">ngx.shared.DICT.llen</a></li>
<li><a href="#ngxshareddictttl">ngx.shared.DICT.ttl</a></li>
<li><a href="#ngxshareddictexpire">ngx.shared.DICT.expire</a></li>
<li><a href="#ngxshareddictflush_all">ngx.shared.DICT.flush_all</a></li>
<li><a href="#ngxshareddictflush_expired">ngx.shared.DICT.flush_expired</a></li>
<li><a href="#ngxshareddictget_keys">ngx.shared.DICT.get_keys</a></li>
<li><a href="#ngxshareddictcapacity">ngx.shared.DICT.capacity</a></li>
<li><a href="#ngxshareddictfree_space">ngx.shared.DICT.free_space</a></li>
<li><a href="#ngxsocketudp">ngx.socket.udp</a></li>
<li><a href="#udpsocksetpeername">udpsock:setpeername</a></li>
<li><a href="#udpsocksend">udpsock:send</a></li>
<li><a href="#udpsockreceive">udpsock:receive</a></li>
<li><a href="#udpsockclose">udpsock:close</a></li>
<li><a href="#udpsocksettimeout">udpsock:settimeout</a></li>
<li><a href="#ngxsocketstream">ngx.socket.stream</a></li>
<li><a href="#ngxsockettcp">ngx.socket.tcp</a></li>
<li><a href="#tcpsockconnect">tcpsock:connect</a></li>
<li><a href="#tcpsocksslhandshake">tcpsock:sslhandshake</a></li>
<li><a href="#tcpsocksend">tcpsock:send</a></li>
<li><a href="#tcpsockreceive">tcpsock:receive</a></li>
<li><a href="#tcpsockreceiveany">tcpsock:receiveany</a></li>
<li><a href="#tcpsockreceiveuntil">tcpsock:receiveuntil</a></li>
<li><a href="#tcpsockclose">tcpsock:close</a></li>
<li><a href="#tcpsocksettimeout">tcpsock:settimeout</a></li>
<li><a href="#tcpsocksettimeouts">tcpsock:settimeouts</a></li>
<li><a href="#tcpsocksetoption">tcpsock:setoption</a></li>
<li><a href="#tcpsocksetkeepalive">tcpsock:setkeepalive</a></li>
<li><a href="#tcpsockgetreusedtimes">tcpsock:getreusedtimes</a></li>
<li><a href="#ngxsocketconnect">ngx.socket.connect</a></li>
<li><a href="#ngxget_phase">ngx.get_phase</a></li>
<li><a href="#ngxthreadspawn">ngx.thread.spawn</a></li>
<li><a href="#ngxthreadwait">ngx.thread.wait</a></li>
<li><a href="#ngxthreadkill">ngx.thread.kill</a></li>
<li><a href="#ngxon_abort">ngx.on_abort</a></li>
<li><a href="#ngxtimerat">ngx.timer.at</a></li>
<li><a href="#ngxtimerevery">ngx.timer.every</a></li>
<li><a href="#ngxtimerrunning_count">ngx.timer.running_count</a></li>
<li><a href="#ngxtimerpending_count">ngx.timer.pending_count</a></li>
<li><a href="#ngxconfigsubsystem">ngx.config.subsystem</a></li>
<li><a href="#ngxconfigdebug">ngx.config.debug</a></li>
<li><a href="#ngxconfigprefix">ngx.config.prefix</a></li>
<li><a href="#ngxconfignginx_version">ngx.config.nginx_version</a></li>
<li><a href="#ngxconfignginx_configure">ngx.config.nginx_configure</a></li>
<li><a href="#ngxconfigngx_lua_version">ngx.config.ngx_lua_version</a></li>
<li><a href="#ngxworkerexiting">ngx.worker.exiting</a></li>
<li><a href="#ngxworkerpid">ngx.worker.pid</a></li>
<li><a href="#ngxworkercount">ngx.worker.count</a></li>
<li><a href="#ngxworkerid">ngx.worker.id</a></li>
<li><a href="#ngxsemaphore">ngx.semaphore</a></li>
<li><a href="#ngxbalancer">ngx.balancer</a></li>
<li><a href="#ngxssl">ngx.ssl</a></li>
<li><a href="#ngxocsp">ngx.ocsp</a></li>
<li><a href="#ndkset_vardirective">ndk.set_var.DIRECTIVE</a></li>
<li><a href="#coroutinecreate">coroutine.create</a></li>
<li><a href="#coroutineresume">coroutine.resume</a></li>
<li><a href="#coroutineyield">coroutine.yield</a></li>
<li><a href="#coroutinewrap">coroutine.wrap</a></li>
<li><a href="#coroutinerunning">coroutine.running</a></li>
<li><a href="#coroutinestatus">coroutine.status</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<p>本文是GitHub上nginx-lua-module自述文档的一部分，详细列举说明了OpenResty所有的Lua API。</p>
<p>放到这里，方便查阅。</p>
<h1><span id="nginx-api-for-lua">Nginx API for Lua</span></h1><h2><span id="introduction">Introduction</span></h2><p>The various <code>*_by_lua</code>, <code>*_by_lua_block</code> and <code>*_by_lua_file</code> configuration directives serve as gateways to the Lua API within the <code>nginx.conf</code> file. The Nginx Lua API described below can only be called within the user Lua code run in the context of these configuration directives.</p>
<p>The API is exposed to Lua in the form of two standard packages <code>ngx</code> and <code>ndk</code>. These packages are in the default global scope within ngx_lua and are always available within ngx_lua directives.</p>
<p>The packages can be introduced into external Lua modules like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">local say = ngx.say</span><br><span class="line"></span><br><span class="line">local _M = &#123;&#125;</span><br><span class="line"></span><br><span class="line">function _M.foo(a)</span><br><span class="line">    say(a)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">return _M</span><br></pre></td></tr></table></figure>
<p>Use of the <a href="http://www.lua.org/manual/5.1/manual.html#pdf-package.seeall" target="_blank" rel="noopener">package.seeall</a> flag is strongly discouraged due to its various bad side-effects.</p>
<p>It is also possible to directly require the packages in external Lua modules:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local ngx = require &quot;ngx&quot;</span><br><span class="line">local ndk = require &quot;ndk&quot;</span><br></pre></td></tr></table></figure>
<p>The ability to require these packages was introduced in the <code>v0.2.1rc19</code> release.</p>
<p>Network I/O operations in user code should only be done through the Nginx Lua API calls as the Nginx event loop may be blocked and performance drop off dramatically otherwise. Disk operations with relatively small amount of data can be done using the standard Lua <code>io</code> library but huge file reading and writing should be avoided wherever possible as they may block the Nginx process significantly. Delegating all network and disk I/O operations to Nginx’s subrequests (via the [ngx.location.capture]</p>
<h2><span id="ngxarg">ngx.arg</span></h2><p><strong>syntax:</strong> <em>val = ngx.arg[index]</em></p>
<p><strong>context:</strong> set_by_lua*, body_filter_by_lua*</p>
<p>When this is used in the context of the [set_by_lua*]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value = ngx.arg[n]</span><br></pre></td></tr></table></figure>
<p>Here is an example</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">location /foo &#123;</span><br><span class="line">    set $a 32;</span><br><span class="line">    set $b 56;</span><br><span class="line"></span><br><span class="line">    set_by_lua $sum</span><br><span class="line">        &apos;return tonumber(ngx.arg[1]) + tonumber(ngx.arg[2])&apos;</span><br><span class="line">        $a $b;</span><br><span class="line"></span><br><span class="line">    echo $sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>that writes out <code>88</code>, the sum of <code>32</code> and <code>56</code>.</p>
<p>When this table is used in the context of [body_filter_by_lua*]</p>
<p>The data chunk and “eof” flag passed to the downstream Nginx output filters can also be overridden by assigning values directly to the corresponding table elements. When setting <code>nil</code> or an empty Lua string value to <code>ngx.arg[1]</code>, no data chunk will be passed to the downstream Nginx output filters at all.</p>
<h2><span id="ngxvarvariable">ngx.var.VARIABLE</span></h2><p><strong>syntax:</strong> <em>ngx.var.VAR_NAME</em></p>
<p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*</p>
<p>Read and write Nginx variable values.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value = ngx.var.some_nginx_variable_name</span><br><span class="line">ngx.var.some_nginx_variable_name = value</span><br></pre></td></tr></table></figure>
<p>Note that only already defined nginx variables can be written to. For example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location /foo &#123;</span><br><span class="line">    set $my_var &apos;&apos;; # this line is required to create $my_var at config time</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        ngx.var.my_var = 123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>That is, nginx variables cannot be created on-the-fly.</p>
<p>Some special nginx variables like <code>$args</code> and <code>$limit_rate</code> can be assigned a value, many others are not, like <code>$query_string</code>, <code>$arg_PARAMETER</code>, and <code>$http_NAME</code>.</p>
<p>Nginx regex group capturing variables <code>$1</code>, <code>$2</code>, <code>$3</code>, and etc, can be read by this interface as well, by writing <code>ngx.var[1]</code>, <code>ngx.var[2]</code>, <code>ngx.var[3]</code>, and etc.</p>
<p>Setting <code>ngx.var.Foo</code> to a <code>nil</code> value will unset the <code>$Foo</code> Nginx variable.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.var.args = nil</span><br></pre></td></tr></table></figure>
<p><strong>CAUTION</strong> When reading from an Nginx variable, Nginx will allocate memory in the per-request memory pool which is freed only at request termination. So when you need to read from an Nginx variable repeatedly in your Lua code, cache the Nginx variable value to your own Lua variable, for example,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local val = ngx.var.some_var</span><br><span class="line">--- use the val repeatedly later</span><br></pre></td></tr></table></figure>
<p>to prevent (temporary) memory leaking within the current request’s lifetime. Another way of caching the result is to use the [ngx.ctx]</p>
<p>Undefined NGINX variables are evaluated to <code>nil</code> while uninitialized (but defined) NGINX variables are evaluated to an empty Lua string.</p>
<p>This API requires a relatively expensive metamethod call and it is recommended to avoid using it on hot code paths.</p>
<h2><span id="core-constants">Core constants</span></h2><p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, *log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ngx.OK (0)</span><br><span class="line">ngx.ERROR (-1)</span><br><span class="line">ngx.AGAIN (-2)</span><br><span class="line">ngx.DONE (-4)</span><br><span class="line">ngx.DECLINED (-5)</span><br></pre></td></tr></table></figure>
<p>Note that only three of these constants are utilized by the [Nginx API for Lua]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.null</span><br></pre></td></tr></table></figure>
<p>The <code>ngx.null</code> constant is a <code>NULL</code> light userdata usually used to represent nil values in Lua tables etc and is similar to the <a href="http://www.kyne.com.au/~mark/software/lua-cjson.php" target="_blank" rel="noopener">lua-cjson</a> library’s <code>cjson.null</code> constant. This constant was first introduced in the <code>v0.5.0rc5</code> release.</p>
<p>The <code>ngx.DECLINED</code> constant was first introduced in the <code>v0.5.0rc19</code> release.</p>
<h2><span id="http-method-constants">HTTP method constants</span></h2><p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ngx.HTTP_GET</span><br><span class="line">ngx.HTTP_HEAD</span><br><span class="line">ngx.HTTP_PUT</span><br><span class="line">ngx.HTTP_POST</span><br><span class="line">ngx.HTTP_DELETE</span><br><span class="line">ngx.HTTP_OPTIONS   (added in the v0.5.0rc24 release)</span><br><span class="line">ngx.HTTP_MKCOL     (added in the v0.8.2 release)</span><br><span class="line">ngx.HTTP_COPY      (added in the v0.8.2 release)</span><br><span class="line">ngx.HTTP_MOVE      (added in the v0.8.2 release)</span><br><span class="line">ngx.HTTP_PROPFIND  (added in the v0.8.2 release)</span><br><span class="line">ngx.HTTP_PROPPATCH (added in the v0.8.2 release)</span><br><span class="line">ngx.HTTP_LOCK      (added in the v0.8.2 release)</span><br><span class="line">ngx.HTTP_UNLOCK    (added in the v0.8.2 release)</span><br><span class="line">ngx.HTTP_PATCH     (added in the v0.8.2 release)</span><br><span class="line">ngx.HTTP_TRACE     (added in the v0.8.2 release)</span><br></pre></td></tr></table></figure>
<p>These constants are usually used in [ngx.location.capture]</p>
<h2><span id="http-status-constants">HTTP status constants</span></h2><p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">value = ngx.HTTP_CONTINUE (100) (first added in the v0.9.20 release)</span><br><span class="line">value = ngx.HTTP_SWITCHING_PROTOCOLS (101) (first added in the v0.9.20 release)</span><br><span class="line">value = ngx.HTTP_OK (200)</span><br><span class="line">value = ngx.HTTP_CREATED (201)</span><br><span class="line">value = ngx.HTTP_ACCEPTED (202) (first added in the v0.9.20 release)</span><br><span class="line">value = ngx.HTTP_NO_CONTENT (204) (first added in the v0.9.20 release)</span><br><span class="line">value = ngx.HTTP_PARTIAL_CONTENT (206) (first added in the v0.9.20 release)</span><br><span class="line">value = ngx.HTTP_SPECIAL_RESPONSE (300)</span><br><span class="line">value = ngx.HTTP_MOVED_PERMANENTLY (301)</span><br><span class="line">value = ngx.HTTP_MOVED_TEMPORARILY (302)</span><br><span class="line">value = ngx.HTTP_SEE_OTHER (303)</span><br><span class="line">value = ngx.HTTP_NOT_MODIFIED (304)</span><br><span class="line">value = ngx.HTTP_TEMPORARY_REDIRECT (307) (first added in the v0.9.20 release)</span><br><span class="line">value = ngx.HTTP_PERMANENT_REDIRECT (308)</span><br><span class="line">value = ngx.HTTP_BAD_REQUEST (400)</span><br><span class="line">value = ngx.HTTP_UNAUTHORIZED (401)</span><br><span class="line">value = ngx.HTTP_PAYMENT_REQUIRED (402) (first added in the v0.9.20 release)</span><br><span class="line">value = ngx.HTTP_FORBIDDEN (403)</span><br><span class="line">value = ngx.HTTP_NOT_FOUND (404)</span><br><span class="line">value = ngx.HTTP_NOT_ALLOWED (405)</span><br><span class="line">value = ngx.HTTP_NOT_ACCEPTABLE (406) (first added in the v0.9.20 release)</span><br><span class="line">value = ngx.HTTP_REQUEST_TIMEOUT (408) (first added in the v0.9.20 release)</span><br><span class="line">value = ngx.HTTP_CONFLICT (409) (first added in the v0.9.20 release)</span><br><span class="line">value = ngx.HTTP_GONE (410)</span><br><span class="line">value = ngx.HTTP_UPGRADE_REQUIRED (426) (first added in the v0.9.20 release)</span><br><span class="line">value = ngx.HTTP_TOO_MANY_REQUESTS (429) (first added in the v0.9.20 release)</span><br><span class="line">value = ngx.HTTP_CLOSE (444) (first added in the v0.9.20 release)</span><br><span class="line">value = ngx.HTTP_ILLEGAL (451) (first added in the v0.9.20 release)</span><br><span class="line">value = ngx.HTTP_INTERNAL_SERVER_ERROR (500)</span><br><span class="line">value = ngx.HTTP_METHOD_NOT_IMPLEMENTED (501)</span><br><span class="line">value = ngx.HTTP_BAD_GATEWAY (502) (first added in the v0.9.20 release)</span><br><span class="line">value = ngx.HTTP_SERVICE_UNAVAILABLE (503)</span><br><span class="line">value = ngx.HTTP_GATEWAY_TIMEOUT (504) (first added in the v0.3.1rc38 release)</span><br><span class="line">value = ngx.HTTP_VERSION_NOT_SUPPORTED (505) (first added in the v0.9.20 release)</span><br><span class="line">value = ngx.HTTP_INSUFFICIENT_STORAGE (507) (first added in the v0.9.20 release)</span><br></pre></td></tr></table></figure>
<h2><span id="nginx-log-level-constants">Nginx log level constants</span></h2><p><strong>context:</strong> init_by_lua*, init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ngx.STDERR</span><br><span class="line">ngx.EMERG</span><br><span class="line">ngx.ALERT</span><br><span class="line">ngx.CRIT</span><br><span class="line">ngx.ERR</span><br><span class="line">ngx.WARN</span><br><span class="line">ngx.NOTICE</span><br><span class="line">ngx.INFO</span><br><span class="line">ngx.DEBUG</span><br></pre></td></tr></table></figure>
<p>These constants are usually used by the [ngx.log]</p>
<h2><span id="print">print</span></h2><p><strong>syntax:</strong> <em>print(…)</em></p>
<p><strong>context:</strong> init_by_lua*, init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p>Writes argument values into the nginx <code>error.log</code> file with the <code>ngx.NOTICE</code> log level.</p>
<p>It is equivalent to</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.log(ngx.NOTICE, ...)</span><br></pre></td></tr></table></figure>
<p>Lua <code>nil</code> arguments are accepted and result in literal <code>&quot;nil&quot;</code> strings while Lua booleans result in literal <code>&quot;true&quot;</code> or <code>&quot;false&quot;</code>strings. And the <code>ngx.null</code> constant will yield the <code>&quot;null&quot;</code> string output.</p>
<p>There is a hard coded <code>2048</code> byte limitation on error message lengths in the Nginx core. This limit includes trailing newlines and leading time stamps. If the message size exceeds this limit, Nginx will truncate the message text accordingly. This limit can be manually modified by editing the <code>NGX_MAX_ERROR_STR</code> macro definition in the <code>src/core/ngx_log.h</code> file in the Nginx source tree.</p>
<h2><span id="ngxctx">ngx.ctx</span></h2><p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*</p>
<p>This table can be used to store per-request Lua context data and has a life time identical to the current request (as with the Nginx variables).</p>
<p>Consider the following example,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">location /test &#123;</span><br><span class="line">    rewrite_by_lua_block &#123;</span><br><span class="line">        ngx.ctx.foo = 76</span><br><span class="line">    &#125;</span><br><span class="line">    access_by_lua_block &#123;</span><br><span class="line">        ngx.ctx.foo = ngx.ctx.foo + 3</span><br><span class="line">    &#125;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        ngx.say(ngx.ctx.foo)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Then <code>GET /test</code> will yield the output</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">79</span><br></pre></td></tr></table></figure>
<p>That is, the <code>ngx.ctx.foo</code> entry persists across the rewrite, access, and content phases of a request.</p>
<p>Every request, including subrequests, has its own copy of the table. For example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">location /sub &#123;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        ngx.say(&quot;sub pre: &quot;, ngx.ctx.blah)</span><br><span class="line">        ngx.ctx.blah = 32</span><br><span class="line">        ngx.say(&quot;sub post: &quot;, ngx.ctx.blah)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /main &#123;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        ngx.ctx.blah = 73</span><br><span class="line">        ngx.say(&quot;main pre: &quot;, ngx.ctx.blah)</span><br><span class="line">        local res = ngx.location.capture(&quot;/sub&quot;)</span><br><span class="line">        ngx.print(res.body)</span><br><span class="line">        ngx.say(&quot;main post: &quot;, ngx.ctx.blah)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Then <code>GET /main</code> will give the output</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main pre: 73</span><br><span class="line">sub pre: nil</span><br><span class="line">sub post: 32</span><br><span class="line">main post: 73</span><br></pre></td></tr></table></figure>
<p>Here, modification of the <code>ngx.ctx.blah</code> entry in the subrequest does not affect the one in the parent request. This is because they have two separate versions of <code>ngx.ctx.blah</code>.</p>
<p>Internal redirection will destroy the original request <code>ngx.ctx</code> data (if any) and the new request will have an empty <code>ngx.ctx</code>table. For instance,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">location /new &#123;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        ngx.say(ngx.ctx.foo)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /orig &#123;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        ngx.ctx.foo = &quot;hello&quot;</span><br><span class="line">        ngx.exec(&quot;/new&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Then <code>GET /orig</code> will give</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nil</span><br></pre></td></tr></table></figure>
<p>rather than the original <code>&quot;hello&quot;</code> value.</p>
<p>Arbitrary data values, including Lua closures and nested tables, can be inserted into this “magic” table. It also allows the registration of custom meta methods.</p>
<p>Overriding <code>ngx.ctx</code> with a new Lua table is also supported, for example,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.ctx = &#123; foo = 32, bar = 54 &#125;</span><br></pre></td></tr></table></figure>
<p>When being used in the context of [init_worker_by_lua*]</p>
<p>The <code>ngx.ctx</code> lookup requires relatively expensive metamethod calls and it is much slower than explicitly passing per-request data along by your own function arguments. So do not abuse this API for saving your own function arguments because it usually has quite some performance impact.</p>
<p>Because of the metamethod magic, never “local” the <code>ngx.ctx</code> table outside your Lua function scope on the Lua module level due to [worker-level data sharing]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-- mymodule.lua</span><br><span class="line">local _M = &#123;&#125;</span><br><span class="line"></span><br><span class="line">-- the following line is bad since ngx.ctx is a per-request</span><br><span class="line">-- data while this &lt;code&gt;ctx&lt;/code&gt; variable is on the Lua module level</span><br><span class="line">-- and thus is per-nginx-worker.</span><br><span class="line">local ctx = ngx.ctx</span><br><span class="line"></span><br><span class="line">function _M.main()</span><br><span class="line">    ctx.foo = &quot;bar&quot;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">return _M</span><br></pre></td></tr></table></figure>
<p>Use the following instead:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- mymodule.lua</span><br><span class="line">local _M = &#123;&#125;</span><br><span class="line"></span><br><span class="line">function _M.main(ctx)</span><br><span class="line">    ctx.foo = &quot;bar&quot;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">return _M</span><br></pre></td></tr></table></figure>
<p>That is, let the caller pass the <code>ctx</code> table explicitly via a function argument.</p>
<h2><span id="ngxlocationcapture">ngx.location.capture</span></h2><p><strong>syntax:</strong> <em>res = ngx.location.capture(uri, options?)</em></p>
<p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*</p>
<p>Issues a synchronous but still non-blocking <em>Nginx Subrequest</em> using <code>uri</code>.</p>
<p>Nginx’s subrequests provide a powerful way to make non-blocking internal requests to other locations configured with disk file directory or <em>any</em> other nginx C modules like <code>ngx_proxy</code>, <code>ngx_fastcgi</code>, <code>ngx_memc</code>, <code>ngx_postgres</code>, <code>ngx_drizzle</code>, and even ngx_lua itself and etc etc etc.</p>
<p>Also note that subrequests just mimic the HTTP interface but there is <em>no</em> extra HTTP/TCP traffic <em>nor</em> IPC involved. Everything works internally, efficiently, on the C level.</p>
<p>Subrequests are completely different from HTTP 301/302 redirection (via [ngx.redirect]</p>
<p>You should always read the request body (by either calling [ngx.req.read_body]</p>
<p>This API function (as well as [ngx.location.capture_multi]</p>
<p>Here is a basic example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = ngx.location.capture(uri)</span><br></pre></td></tr></table></figure>
<p>Returns a Lua table with 4 slots: <code>res.status</code>, <code>res.header</code>, <code>res.body</code>, and <code>res.truncated</code>.</p>
<p><code>res.status</code> holds the response status code for the subrequest response.</p>
<p><code>res.header</code> holds all the response headers of the subrequest and it is a normal Lua table. For multi-value response headers, the value is a Lua (array) table that holds all the values in the order that they appear. For instance, if the subrequest response headers contain the following lines:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: a=3</span><br><span class="line">Set-Cookie: foo=bar</span><br><span class="line">Set-Cookie: baz=blah</span><br></pre></td></tr></table></figure>
<p>Then <code>res.header[&quot;Set-Cookie&quot;]</code> will be evaluated to the table value <code>{&quot;a=3&quot;, &quot;foo=bar&quot;, &quot;baz=blah&quot;}</code>.</p>
<p><code>res.body</code> holds the subrequest’s response body data, which might be truncated. You always need to check the <code>res.truncated</code> boolean flag to see if <code>res.body</code> contains truncated data. The data truncation here can only be caused by those unrecoverable errors in your subrequests like the cases that the remote end aborts the connection prematurely in the middle of the response body data stream or a read timeout happens when your subrequest is receiving the response body data from the remote.</p>
<p>URI query strings can be concatenated to URI itself, for instance,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = ngx.location.capture(&apos;/foo/bar?a=3&amp;b=4&apos;)</span><br></pre></td></tr></table></figure>
<p>Named locations like <code>@foo</code> are not allowed due to a limitation in the nginx core. Use normal locations combined with the <code>internal</code> directive to prepare internal-only locations.</p>
<p>An optional option table can be fed as the second argument, which supports the options:</p>
<ul>
<li><code>method</code> specify the subrequest’s request method, which only accepts constants like <code>ngx.HTTP_POST</code>.</li>
<li><code>body</code> specify the subrequest’s request body (string value only).</li>
<li><code>args</code> specify the subrequest’s URI query arguments (both string value and Lua tables are accepted)</li>
<li><code>ctx</code> specify a Lua table to be the [ngx.ctx]</li>
<li><code>vars</code> take a Lua table which holds the values to set the specified Nginx variables in the subrequest as this option’s value. This option was first introduced in the <code>v0.3.1rc31</code> release.</li>
<li><code>copy_all_vars</code> specify whether to copy over all the Nginx variable values of the current request to the subrequest in question. modifications of the nginx variables in the subrequest will not affect the current (parent) request. This option was first introduced in the <code>v0.3.1rc31</code> release.</li>
<li><code>share_all_vars</code> specify whether to share all the Nginx variables of the subrequest with the current (parent) request. modifications of the Nginx variables in the subrequest will affect the current (parent) request. Enabling this option may lead to hard-to-debug issues due to bad side-effects and is considered bad and harmful. Only enable this option when you completely know what you are doing.</li>
<li><code>always_forward_body</code> when set to true, the current (parent) request’s request body will always be forwarded to the subrequest being created if the <code>body</code> option is not specified. The request body read by either [ngx.req.read_body()]</li>
</ul>
<p>Issuing a POST subrequest, for example, can be done as follows</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">res = ngx.location.capture(</span><br><span class="line">    &apos;/foo/bar&apos;,</span><br><span class="line">    &#123; method = ngx.HTTP_POST, body = &apos;hello, world&apos; &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>See HTTP method constants methods other than POST. The <code>method</code> option is <code>ngx.HTTP_GET</code> by default.</p>
<p>The <code>args</code> option can specify extra URI arguments, for instance,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ngx.location.capture(&apos;/foo?a=1&apos;,</span><br><span class="line">    &#123; args = &#123; b = 3, c = &apos;:&apos; &#125; &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>is equivalent to</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.location.capture(&apos;/foo?a=1&amp;b=3&amp;c=%3a&apos;)</span><br></pre></td></tr></table></figure>
<p>that is, this method will escape argument keys and values according to URI rules and concatenate them together into a complete query string. The format for the Lua table passed as the <code>args</code> argument is identical to the format used in the [ngx.encode_args]</p>
<p>The <code>args</code> option can also take plain query strings:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ngx.location.capture(&apos;/foo?a=1&apos;,</span><br><span class="line">    &#123; args = &apos;b=3&amp;c=%3a&apos; &#125; &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>This is functionally identical to the previous examples.</p>
<p>The <code>share_all_vars</code> option controls whether to share nginx variables among the current request and its subrequests. If this option is set to <code>true</code>, then the current request and associated subrequests will share the same Nginx variable scope. Hence, changes to Nginx variables made by a subrequest will affect the current request.</p>
<p>Care should be taken in using this option as variable scope sharing can have unexpected side effects. The <code>args</code>, <code>vars</code>, or <code>copy_all_vars</code> options are generally preferable instead.</p>
<p>This option is set to <code>false</code> by default</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">location /other &#123;</span><br><span class="line">    set $dog &quot;$dog world&quot;;</span><br><span class="line">    echo &quot;$uri dog: $dog&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /lua &#123;</span><br><span class="line">    set $dog &apos;hello&apos;;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        res = ngx.location.capture(&quot;/other&quot;,</span><br><span class="line">            &#123; share_all_vars = true &#125;);</span><br><span class="line"></span><br><span class="line">        ngx.print(res.body)</span><br><span class="line">        ngx.say(ngx.var.uri, &quot;: &quot;, ngx.var.dog)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Accessing location <code>/lua</code> gives</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/other dog: hello world</span><br><span class="line">/lua: hello world</span><br></pre></td></tr></table></figure>
<p>The <code>copy_all_vars</code> option provides a copy of the parent request’s Nginx variables to subrequests when such subrequests are issued. Changes made to these variables by such subrequests will not affect the parent request or any other subrequests sharing the parent request’s variables.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">location /other &#123;</span><br><span class="line">    set $dog &quot;$dog world&quot;;</span><br><span class="line">    echo &quot;$uri dog: $dog&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /lua &#123;</span><br><span class="line">    set $dog &apos;hello&apos;;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        res = ngx.location.capture(&quot;/other&quot;,</span><br><span class="line">            &#123; copy_all_vars = true &#125;);</span><br><span class="line"></span><br><span class="line">        ngx.print(res.body)</span><br><span class="line">        ngx.say(ngx.var.uri, &quot;: &quot;, ngx.var.dog)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Request <code>GET /lua</code> will give the output</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/other dog: hello world</span><br><span class="line">/lua: hello</span><br></pre></td></tr></table></figure>
<p>Note that if both <code>share_all_vars</code> and <code>copy_all_vars</code> are set to true, then <code>share_all_vars</code> takes precedence.</p>
<p>In addition to the two settings above, it is possible to specify values for variables in the subrequest using the <code>vars</code> option. These variables are set after the sharing or copying of variables has been evaluated, and provides a more efficient method of passing specific values to a subrequest over encoding them as URL arguments and unescaping them in the Nginx config file.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">location /other &#123;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        ngx.say(&quot;dog = &quot;, ngx.var.dog)</span><br><span class="line">        ngx.say(&quot;cat = &quot;, ngx.var.cat)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /lua &#123;</span><br><span class="line">    set $dog &apos;&apos;;</span><br><span class="line">    set $cat &apos;&apos;;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        res = ngx.location.capture(&quot;/other&quot;,</span><br><span class="line">            &#123; vars = &#123; dog = &quot;hello&quot;, cat = 32 &#125;&#125;);</span><br><span class="line"></span><br><span class="line">        ngx.print(res.body)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Accessing <code>/lua</code> will yield the output</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dog = hello</span><br><span class="line">cat = 32</span><br></pre></td></tr></table></figure>
<p>The <code>ctx</code> option can be used to specify a custom Lua table to serve as the [ngx.ctx]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">location /sub &#123;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        ngx.ctx.foo = &quot;bar&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">location /lua &#123;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        local ctx = &#123;&#125;</span><br><span class="line">        res = ngx.location.capture(&quot;/sub&quot;, &#123; ctx = ctx &#125;)</span><br><span class="line"></span><br><span class="line">        ngx.say(ctx.foo);</span><br><span class="line">        ngx.say(ngx.ctx.foo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Then request <code>GET /lua</code> gives</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bar</span><br><span class="line">nil</span><br></pre></td></tr></table></figure>
<p>It is also possible to use this <code>ctx</code> option to share the same [ngx.ctx]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">location /sub &#123;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        ngx.ctx.foo = &quot;bar&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">location /lua &#123;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        res = ngx.location.capture(&quot;/sub&quot;, &#123; ctx = ngx.ctx &#125;)</span><br><span class="line">        ngx.say(ngx.ctx.foo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Request <code>GET /lua</code> yields the output</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bar</span><br></pre></td></tr></table></figure>
<p>Note that subrequests issued by [ngx.location.capture]</p>
<p>When the <code>body</code> option is not specified and the <code>always_forward_body</code> option is false (the default value), the <code>POST</code> and <code>PUT</code>subrequests will inherit the request bodies of the parent request (if any).</p>
<p>There is a hard-coded upper limit on the number of concurrent subrequests possible for every main request. In older versions of Nginx, the limit was <code>50</code> concurrent subrequests and in more recent versions, Nginx <code>1.1.x</code> onwards, this was increased to <code>200</code> concurrent subrequests. When this limit is exceeded, the following error message is added to the <code>error.log</code> file:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[error] 13983#0: *1 subrequests cycle while processing &quot;/uri&quot;</span><br></pre></td></tr></table></figure>
<p>The limit can be manually modified if required by editing the definition of the <code>NGX_HTTP_MAX_SUBREQUESTS</code> macro in the <code>nginx/src/http/ngx_http_request.h</code> file in the Nginx source tree.</p>
<p>Please also refer to restrictions on capturing locations configured by [subrequest directives of other modules]</p>
<h2><span id="ngxlocationcapture_multi">ngx.location.capture_multi</span></h2><p><strong>syntax:</strong> <em>res1, res2, … = ngx.location.capture_multi({ {uri, options?}, {uri, options?}, … })</em></p>
<p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*</p>
<p>Just like [ngx.location.capture]</p>
<p>This function issues several parallel subrequests specified by the input table and returns their results in the same order. For example,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">res1, res2, res3 = ngx.location.capture_multi&#123;</span><br><span class="line">    &#123; &quot;/foo&quot;, &#123; args = &quot;a=3&amp;b=4&quot; &#125; &#125;,</span><br><span class="line">    &#123; &quot;/bar&quot; &#125;,</span><br><span class="line">    &#123; &quot;/baz&quot;, &#123; method = ngx.HTTP_POST, body = &quot;hello&quot; &#125; &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if res1.status == ngx.HTTP_OK then</span><br><span class="line">    ...</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">if res2.body == &quot;BLAH&quot; then</span><br><span class="line">    ...</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>This function will not return until all the subrequests terminate. The total latency is the longest latency of the individual subrequests rather than the sum.</p>
<p>Lua tables can be used for both requests and responses when the number of subrequests to be issued is not known in advance:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-- construct the requests table</span><br><span class="line">local reqs = &#123;&#125;</span><br><span class="line">table.insert(reqs, &#123; &quot;/mysql&quot; &#125;)</span><br><span class="line">table.insert(reqs, &#123; &quot;/postgres&quot; &#125;)</span><br><span class="line">table.insert(reqs, &#123; &quot;/redis&quot; &#125;)</span><br><span class="line">table.insert(reqs, &#123; &quot;/memcached&quot; &#125;)</span><br><span class="line"></span><br><span class="line">-- issue all the requests at once and wait until they all return</span><br><span class="line">local resps = &#123; ngx.location.capture_multi(reqs) &#125;</span><br><span class="line"></span><br><span class="line">-- loop over the responses table</span><br><span class="line">for i, resp in ipairs(resps) do</span><br><span class="line">    -- process the response table &quot;resp&quot;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>The [ngx.location.capture]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ngx.location.capture =</span><br><span class="line">    function (uri, args)</span><br><span class="line">        return ngx.location.capture_multi(&#123; &#123;uri, args&#125; &#125;)</span><br><span class="line">    end</span><br></pre></td></tr></table></figure>
<p>Please also refer to restrictions on capturing locations configured by [subrequest directives of other modules]</p>
<h2><span id="ngxstatus">ngx.status</span></h2><p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*</p>
<p>Read and write the current request’s response status. This should be called before sending out the response headers.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ngx.status = ngx.HTTP_CREATED</span><br><span class="line">status = ngx.status</span><br></pre></td></tr></table></figure>
<p>Setting <code>ngx.status</code> after the response header is sent out has no effect but leaving an error message in your nginx’s error log file:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">attempt to set ngx.status after sending out response headers</span><br></pre></td></tr></table></figure>
<h2><span id="ngxheaderheader">ngx.header.HEADER</span></h2><p><strong>syntax:</strong> <em>ngx.header.HEADER = VALUE</em></p>
<p><strong>syntax:</strong> <em>value = ngx.header.HEADER</em></p>
<p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*</p>
<p>Set, add to, or clear the current request’s <code>HEADER</code> response header that is to be sent.</p>
<p>Underscores (<code>_</code>) in the header names will be replaced by hyphens (<code>-</code>) by default. This transformation can be turned off via the [lua_transform_underscores_in_response_headers]</p>
<p>The header names are matched case-insensitively.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- equivalent to ngx.header[&quot;Content-Type&quot;] = &apos;text/plain&apos;</span><br><span class="line">ngx.header.content_type = &apos;text/plain&apos;;</span><br><span class="line"></span><br><span class="line">ngx.header[&quot;X-My-Header&quot;] = &apos;blah blah&apos;;</span><br></pre></td></tr></table></figure>
<p>Multi-value headers can be set this way:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.header[&apos;Set-Cookie&apos;] = &#123;&apos;a=32; path=/&apos;, &apos;b=4; path=/&apos;&#125;</span><br></pre></td></tr></table></figure>
<p>will yield</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: a=32; path=/</span><br><span class="line">Set-Cookie: b=4; path=/</span><br></pre></td></tr></table></figure>
<p>in the response headers.</p>
<p>Only Lua tables are accepted (Only the last element in the table will take effect for standard headers such as <code>Content-Type</code>that only accept a single value).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.header.content_type = &#123;&apos;a&apos;, &apos;b&apos;&#125;</span><br></pre></td></tr></table></figure>
<p>is equivalent to</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.header.content_type = &apos;b&apos;</span><br></pre></td></tr></table></figure>
<p>Setting a slot to <code>nil</code> effectively removes it from the response headers:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.header[&quot;X-My-Header&quot;] = nil;</span><br></pre></td></tr></table></figure>
<p>The same applies to assigning an empty table:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.header[&quot;X-My-Header&quot;] = &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>Setting <code>ngx.header.HEADER</code> after sending out response headers (either explicitly with [ngx.send_headers]</p>
<p>Reading <code>ngx.header.HEADER</code> will return the value of the response header named <code>HEADER</code>.</p>
<p>Underscores (<code>_</code>) in the header names will also be replaced by dashes (<code>-</code>) and the header names will be matched case-insensitively. If the response header is not present at all, <code>nil</code> will be returned.</p>
<p>This is particularly useful in the context of [header_filter_by_lua*]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">location /test &#123;</span><br><span class="line">    set $footer &apos;&apos;;</span><br><span class="line"></span><br><span class="line">    proxy_pass http://some-backend;</span><br><span class="line"></span><br><span class="line">    header_filter_by_lua_block &#123;</span><br><span class="line">        if ngx.header[&quot;X-My-Header&quot;] == &quot;blah&quot; then</span><br><span class="line">            ngx.var.footer = &quot;some value&quot;</span><br><span class="line">        end</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    echo_after_body $footer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>For multi-value headers, all of the values of header will be collected in order and returned as a Lua table. For example, response headers</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Foo: bar</span><br><span class="line">Foo: baz</span><br></pre></td></tr></table></figure>
<p>will result in</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;bar&quot;, &quot;baz&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>to be returned when reading <code>ngx.header.Foo</code>.</p>
<p>Note that <code>ngx.header</code> is not a normal Lua table and as such, it is not possible to iterate through it using the Lua <code>ipairs</code>function.</p>
<p>For reading <em>request</em> headers, use the [ngx.req.get_headers]</p>
<h2><span id="ngxrespget_headers">ngx.resp.get_headers</span></h2><p><strong>syntax:</strong> <em>headers, err = ngx.resp.get_headers(max_headers?, raw?)</em></p>
<p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, balancer_by_lua*</p>
<p>Returns a Lua table holding all the current response headers for the current request.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">local h, err = ngx.resp.get_headers()</span><br><span class="line"></span><br><span class="line">if err == &quot;truncated&quot; then</span><br><span class="line">    -- one can choose to ignore or reject the current response here</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">for k, v in pairs(h) do</span><br><span class="line">    ...</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>This function has the same signature as [ngx.req.get_headers]</p>
<p>Note that a maximum of 100 response headers are parsed by default (including those with the same name) and that additional response headers are silently discarded to guard against potential denial of service attacks. Since <code>v0.10.13</code>, when the limit is exceeded, it will return a second value which is the string <code>&quot;truncated&quot;</code>.</p>
<p>This API was first introduced in the <code>v0.9.5</code> release.</p>
<h2><span id="ngxreqis_internal">ngx.req.is_internal</span></h2><p><strong>syntax:</strong> <em>is_internal = ngx.req.is_internal()</em></p>
<p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*</p>
<p>Returns a boolean indicating whether the current request is an “internal request”, i.e., a request initiated from inside the current nginx server instead of from the client side.</p>
<p>Subrequests are all internal requests and so are requests after internal redirects.</p>
<p>This API was first introduced in the <code>v0.9.20</code> release.</p>
<h2><span id="ngxreqstart_time">ngx.req.start_time</span></h2><p><strong>syntax:</strong> <em>secs = ngx.req.start_time()</em></p>
<p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*</p>
<p>Returns a floating-point number representing the timestamp (including milliseconds as the decimal part) when the current request was created.</p>
<p>The following example emulates the <code>$request_time</code> variable value (provided by <a href="http://nginx.org/en/docs/http/ngx_http_log_module.html" target="_blank" rel="noopener">ngx_http_log_module</a>) in pure Lua:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">local request_time = ngx.now() - ngx.req.start_time()</span><br></pre></td></tr></table></figure>
<p>This function was first introduced in the <code>v0.7.7</code> release.</p>
<p>See also [ngx.now]</p>
<h2><span id="ngxreqhttp_version">ngx.req.http_version</span></h2><p><strong>syntax:</strong> <em>num = ngx.req.http_version()</em></p>
<p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*</p>
<p>Returns the HTTP version number for the current request as a Lua number.</p>
<p>Current possible values are 2.0, 1.0, 1.1, and 0.9. Returns <code>nil</code> for unrecognized values.</p>
<p>This method was first introduced in the <code>v0.7.17</code> release.</p>
<h2><span id="ngxreqraw_header">ngx.req.raw_header</span></h2><p><strong>syntax:</strong> <em>str = ngx.req.raw_header(no_request_line?)</em></p>
<p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*</p>
<p>Returns the original raw HTTP protocol header received by the Nginx server.</p>
<p>By default, the request line and trailing <code>CR LF</code> terminator will also be included. For example,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.print(ngx.req.raw_header())</span><br></pre></td></tr></table></figure>
<p>gives something like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /t HTTP/1.1</span><br><span class="line">Host: localhost</span><br><span class="line">Connection: close</span><br><span class="line">Foo: bar</span><br></pre></td></tr></table></figure>
<p>You can specify the optional <code>no_request_line</code> argument as a <code>true</code> value to exclude the request line from the result. For example,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.print(ngx.req.raw_header(true))</span><br></pre></td></tr></table></figure>
<p>outputs something like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Host: localhost</span><br><span class="line">Connection: close</span><br><span class="line">Foo: bar</span><br></pre></td></tr></table></figure>
<p>This method was first introduced in the <code>v0.7.17</code> release.</p>
<p>This method does not work in HTTP/2 requests yet.</p>
<h2><span id="ngxreqget_method">ngx.req.get_method</span></h2><p><strong>syntax:</strong> <em>method_name = ngx.req.get_method()</em></p>
<p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, balancer_by_lua*, log_by_lua*</p>
<p>Retrieves the current request’s request method name. Strings like <code>&quot;GET&quot;</code> and <code>&quot;POST&quot;</code> are returned instead of numerical [method constants]</p>
<p>If the current request is an Nginx subrequest, then the subrequest’s method name will be returned.</p>
<p>This method was first introduced in the <code>v0.5.6</code> release.</p>
<p>See also [ngx.req.set_method]</p>
<h2><span id="ngxreqset_method">ngx.req.set_method</span></h2><p><strong>syntax:</strong> <em>ngx.req.set_method(method_id)</em></p>
<p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*</p>
<p>Overrides the current request’s request method with the <code>method_id</code> argument. Currently only numerical [method constants]</p>
<p>If the current request is an Nginx subrequest, then the subrequest’s method will be overridden.</p>
<p>This method was first introduced in the <code>v0.5.6</code> release.</p>
<p>See also [ngx.req.get_method]</p>
<h2><span id="ngxreqset_uri">ngx.req.set_uri</span></h2><p><strong>syntax:</strong> <em>ngx.req.set_uri(uri, jump?)</em></p>
<p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*</p>
<p>Rewrite the current request’s (parsed) URI by the <code>uri</code> argument. The <code>uri</code> argument must be a Lua string and cannot be of zero length, or a Lua exception will be thrown.</p>
<p>The optional boolean <code>jump</code> argument can trigger location rematch (or location jump) as <a href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html" target="_blank" rel="noopener">ngx_http_rewrite_module</a>‘s <a href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html#rewrite" target="_blank" rel="noopener">rewrite</a>directive, that is, when <code>jump</code> is <code>true</code> (default to <code>false</code>), this function will never return and it will tell Nginx to try re-searching locations with the new URI value at the later <code>post-rewrite</code> phase and jumping to the new location.</p>
<p>Location jump will not be triggered otherwise, and only the current request’s URI will be modified, which is also the default behavior. This function will return but with no returned values when the <code>jump</code> argument is <code>false</code> or absent altogether.</p>
<p>For example, the following nginx config snippet</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rewrite ^ /foo last;</span><br></pre></td></tr></table></figure>
<p>can be coded in Lua like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.req.set_uri(&quot;/foo&quot;, true)</span><br></pre></td></tr></table></figure>
<p>Similarly, Nginx config</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rewrite ^ /foo break;</span><br></pre></td></tr></table></figure>
<p>can be coded in Lua as</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.req.set_uri(&quot;/foo&quot;, false)</span><br></pre></td></tr></table></figure>
<p>or equivalently,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.req.set_uri(&quot;/foo&quot;)</span><br></pre></td></tr></table></figure>
<p>The <code>jump</code> argument can only be set to <code>true</code> in [rewrite_by_lua*]</p>
<p>A more sophisticated example involving regex substitutions is as follows</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location /test &#123;</span><br><span class="line">    rewrite_by_lua_block &#123;</span><br><span class="line">        local uri = ngx.re.sub(ngx.var.uri, &quot;^/test/(.*)&quot;, &quot;/$1&quot;, &quot;o&quot;)</span><br><span class="line">        ngx.req.set_uri(uri)</span><br><span class="line">    &#125;</span><br><span class="line">    proxy_pass http://my_backend;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>which is functionally equivalent to</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location /test &#123;</span><br><span class="line">    rewrite ^/test/(.*) /$1 break;</span><br><span class="line">    proxy_pass http://my_backend;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note that it is not possible to use this interface to rewrite URI arguments and that [ngx.req.set_uri_args]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rewrite ^ /foo?a=3? last;</span><br></pre></td></tr></table></figure>
<p>can be coded as</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ngx.req.set_uri_args(&quot;a=3&quot;)</span><br><span class="line">ngx.req.set_uri(&quot;/foo&quot;, true)</span><br></pre></td></tr></table></figure>
<p>or</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ngx.req.set_uri_args(&#123;a = 3&#125;)</span><br><span class="line">ngx.req.set_uri(&quot;/foo&quot;, true)</span><br></pre></td></tr></table></figure>
<p>This interface was first introduced in the <code>v0.3.1rc14</code> release.</p>
<h2><span id="ngxreqset_uri_args">ngx.req.set_uri_args</span></h2><p><strong>syntax:</strong> <em>ngx.req.set_uri_args(args)</em></p>
<p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*</p>
<p>Rewrite the current request’s URI query arguments by the <code>args</code> argument. The <code>args</code> argument can be either a Lua string, as in</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.req.set_uri_args(&quot;a=3&amp;b=hello%20world&quot;)</span><br></pre></td></tr></table></figure>
<p>or a Lua table holding the query arguments’ key-value pairs, as in</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.req.set_uri_args(&#123; a = 3, b = &quot;hello world&quot; &#125;)</span><br></pre></td></tr></table></figure>
<p>where in the latter case, this method will escape argument keys and values according to the URI escaping rule.</p>
<p>Multi-value arguments are also supported:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.req.set_uri_args(&#123; a = 3, b = &#123;5, 6&#125; &#125;)</span><br></pre></td></tr></table></figure>
<p>which will result in a query string like <code>a=3&amp;b=5&amp;b=6</code>.</p>
<p>This interface was first introduced in the <code>v0.3.1rc13</code> release.</p>
<p>See also [ngx.req.set_uri]</p>
<h2><span id="ngxreqget_uri_args">ngx.req.get_uri_args</span></h2><p><strong>syntax:</strong> <em>args, err = ngx.req.get_uri_args(max_args?)</em></p>
<p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, balancer_by_lua*</p>
<p>Returns a Lua table holding all the current request URL query arguments.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">location = /test &#123;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        local args, err = ngx.req.get_uri_args()</span><br><span class="line"></span><br><span class="line">        if err == &quot;truncated&quot; then</span><br><span class="line">            -- one can choose to ignore or reject the current request here</span><br><span class="line">        end</span><br><span class="line"></span><br><span class="line">        for key, val in pairs(args) do</span><br><span class="line">            if type(val) == &quot;table&quot; then</span><br><span class="line">                ngx.say(key, &quot;: &quot;, table.concat(val, &quot;, &quot;))</span><br><span class="line">            else</span><br><span class="line">                ngx.say(key, &quot;: &quot;, val)</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Then <code>GET /test?foo=bar&amp;bar=baz&amp;bar=blah</code> will yield the response body</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo: bar</span><br><span class="line">bar: baz, blah</span><br></pre></td></tr></table></figure>
<p>Multiple occurrences of an argument key will result in a table value holding all the values for that key in order.</p>
<p>Keys and values are unescaped according to URI escaping rules. In the settings above, <code>GET /test?a%20b=1%61+2</code> will yield:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a b: 1a 2</span><br></pre></td></tr></table></figure>
<p>Arguments without the <code>=&lt;value&gt;</code> parts are treated as boolean arguments. <code>GET /test?foo&amp;bar</code> will yield:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo: true</span><br><span class="line">bar: true</span><br></pre></td></tr></table></figure>
<p>That is, they will take Lua boolean values <code>true</code>. However, they are different from arguments taking empty string values. <code>GET /test?foo=&amp;bar=</code> will give something like</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo:</span><br><span class="line">bar:</span><br></pre></td></tr></table></figure>
<p>Empty key arguments are discarded. <code>GET /test?=hello&amp;=world</code> will yield an empty output for instance.</p>
<p>Updating query arguments via the nginx variable <code>$args</code> (or <code>ngx.var.args</code> in Lua) at runtime is also supported:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ngx.var.args = &quot;a=3&amp;b=42&quot;</span><br><span class="line">local args, err = ngx.req.get_uri_args()</span><br></pre></td></tr></table></figure>
<p>Here the <code>args</code> table will always look like</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;a = 3, b = 42&#125;</span><br></pre></td></tr></table></figure>
<p>regardless of the actual request query string.</p>
<p>Note that a maximum of 100 request arguments are parsed by default (including those with the same name) and that additional request arguments are silently discarded to guard against potential denial of service attacks. Since <code>v0.10.13</code>, when the limit is exceeded, it will return a second value which is the string <code>&quot;truncated&quot;</code>.</p>
<p>However, the optional <code>max_args</code> function argument can be used to override this limit:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">local args, err = ngx.req.get_uri_args(10)</span><br><span class="line">if err == &quot;truncated&quot; then</span><br><span class="line">    -- one can choose to ignore or reject the current request here</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>This argument can be set to zero to remove the limit and to process all request arguments received:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">local args, err = ngx.req.get_uri_args(0)</span><br></pre></td></tr></table></figure>
<p>Removing the <code>max_args</code> cap is strongly discouraged.</p>
<h2><span id="ngxreqget_post_args">ngx.req.get_post_args</span></h2><p><strong>syntax:</strong> <em>args, err = ngx.req.get_post_args(max_args?)</em></p>
<p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*</p>
<p>Returns a Lua table holding all the current request POST query arguments (of the MIME type <code>application/x-www-form-urlencoded</code>). Call [ngx.req.read_body]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">location = /test &#123;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        ngx.req.read_body()</span><br><span class="line">        local args, err = ngx.req.get_post_args()</span><br><span class="line"></span><br><span class="line">        if err == &quot;truncated&quot; then</span><br><span class="line">            -- one can choose to ignore or reject the current request here</span><br><span class="line">        end</span><br><span class="line"></span><br><span class="line">        if not args then</span><br><span class="line">            ngx.say(&quot;failed to get post args: &quot;, err)</span><br><span class="line">            return</span><br><span class="line">        end</span><br><span class="line">        for key, val in pairs(args) do</span><br><span class="line">            if type(val) == &quot;table&quot; then</span><br><span class="line">                ngx.say(key, &quot;: &quot;, table.concat(val, &quot;, &quot;))</span><br><span class="line">            else</span><br><span class="line">                ngx.say(key, &quot;: &quot;, val)</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Then</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Post request with the body &apos;foo=bar&amp;bar=baz&amp;bar=blah&apos;</span><br><span class="line">$ curl --data &apos;foo=bar&amp;bar=baz&amp;bar=blah&apos; localhost/test</span><br></pre></td></tr></table></figure>
<p>will yield the response body like</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo: bar</span><br><span class="line">bar: baz, blah</span><br></pre></td></tr></table></figure>
<p>Multiple occurrences of an argument key will result in a table value holding all of the values for that key in order.</p>
<p>Keys and values will be unescaped according to URI escaping rules.</p>
<p>With the settings above,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># POST request with body &apos;a%20b=1%61+2&apos;</span><br><span class="line">$ curl -d &apos;a%20b=1%61+2&apos; localhost/test</span><br></pre></td></tr></table></figure>
<p>will yield:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a b: 1a 2</span><br></pre></td></tr></table></figure>
<p>Arguments without the <code>=&lt;value&gt;</code> parts are treated as boolean arguments. <code>POST /test</code> with the request body <code>foo&amp;bar</code> will yield:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo: true</span><br><span class="line">bar: true</span><br></pre></td></tr></table></figure>
<p>That is, they will take Lua boolean values <code>true</code>. However, they are different from arguments taking empty string values. <code>POST /test</code> with request body <code>foo=&amp;bar=</code> will return something like</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo:</span><br><span class="line">bar:</span><br></pre></td></tr></table></figure>
<p>Empty key arguments are discarded. <code>POST /test</code> with body <code>=hello&amp;=world</code> will yield empty outputs for instance.</p>
<p>Note that a maximum of 100 request arguments are parsed by default (including those with the same name) and that additional request arguments are silently discarded to guard against potential denial of service attacks. Since <code>v0.10.13</code>, when the limit is exceeded, it will return a second value which is the string <code>&quot;truncated&quot;</code>.</p>
<p>However, the optional <code>max_args</code> function argument can be used to override this limit:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">local args, err = ngx.req.get_post_args(10)</span><br><span class="line">if err == &quot;truncated&quot; then</span><br><span class="line">    -- one can choose to ignore or reject the current request here</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>This argument can be set to zero to remove the limit and to process all request arguments received:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">local args, err = ngx.req.get_post_args(0)</span><br></pre></td></tr></table></figure>
<p>Removing the <code>max_args</code> cap is strongly discouraged.</p>
<h2><span id="ngxreqget_headers">ngx.req.get_headers</span></h2><p><strong>syntax:</strong> <em>headers, err = ngx.req.get_headers(max_headers?, raw?)</em></p>
<p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*</p>
<p>Returns a Lua table holding all the current request headers.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">local h, err = ngx.req.get_headers()</span><br><span class="line"></span><br><span class="line">if err == &quot;truncated&quot; then</span><br><span class="line">    -- one can choose to ignore or reject the current request here</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">for k, v in pairs(h) do</span><br><span class="line">    ...</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>To read an individual header:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.say(&quot;Host: &quot;, ngx.req.get_headers()[&quot;Host&quot;])</span><br></pre></td></tr></table></figure>
<p>Note that the [ngx.var.HEADER]</p>
<p>For multiple instances of request headers such as:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Foo: foo</span><br><span class="line">Foo: bar</span><br><span class="line">Foo: baz</span><br></pre></td></tr></table></figure>
<p>the value of <code>ngx.req.get_headers()[&quot;Foo&quot;]</code> will be a Lua (array) table such as:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>Note that a maximum of 100 request headers are parsed by default (including those with the same name) and that additional request headers are silently discarded to guard against potential denial of service attacks. Since <code>v0.10.13</code>, when the limit is exceeded, it will return a second value which is the string <code>&quot;truncated&quot;</code>.</p>
<p>However, the optional <code>max_headers</code> function argument can be used to override this limit:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">local headers, err = ngx.req.get_headers(10)</span><br><span class="line"></span><br><span class="line">if err == &quot;truncated&quot; then</span><br><span class="line">    -- one can choose to ignore or reject the current request here</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>This argument can be set to zero to remove the limit and to process all request headers received:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">local headers, err = ngx.req.get_headers(0)</span><br></pre></td></tr></table></figure>
<p>Removing the <code>max_headers</code> cap is strongly discouraged.</p>
<p>Since the <code>0.6.9</code> release, all the header names in the Lua table returned are converted to the pure lower-case form by default, unless the <code>raw</code> argument is set to <code>true</code> (default to <code>false</code>).</p>
<p>Also, by default, an <code>__index</code> metamethod is added to the resulting Lua table and will normalize the keys to a pure lowercase form with all underscores converted to dashes in case of a lookup miss. For example, if a request header <code>My-Foo-Header</code> is present, then the following invocations will all pick up the value of this header correctly:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ngx.say(headers.my_foo_header)</span><br><span class="line">ngx.say(headers[&quot;My-Foo-Header&quot;])</span><br><span class="line">ngx.say(headers[&quot;my-foo-header&quot;])</span><br></pre></td></tr></table></figure>
<p>The <code>__index</code> metamethod will not be added when the <code>raw</code> argument is set to <code>true</code>.</p>
<h2><span id="ngxreqset_header">ngx.req.set_header</span></h2><p><strong>syntax:</strong> <em>ngx.req.set_header(header_name, header_value)</em></p>
<p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*</p>
<p>Set the current request’s request header named <code>header_name</code> to value <code>header_value</code>, overriding any existing ones.</p>
<p>By default, all the subrequests subsequently initiated by [ngx.location.capture]</p>
<p>Here is an example of setting the <code>Content-Type</code> header:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.req.set_header(&quot;Content-Type&quot;, &quot;text/css&quot;)</span><br></pre></td></tr></table></figure>
<p>The <code>header_value</code> can take an array list of values, for example,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.req.set_header(&quot;Foo&quot;, &#123;&quot;a&quot;, &quot;abc&quot;&#125;)</span><br></pre></td></tr></table></figure>
<p>will produce two new request headers:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Foo: a</span><br><span class="line">Foo: abc</span><br></pre></td></tr></table></figure>
<p>and old <code>Foo</code> headers will be overridden if there is any.</p>
<p>When the <code>header_value</code> argument is <code>nil</code>, the request header will be removed. So</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.req.set_header(&quot;X-Foo&quot;, nil)</span><br></pre></td></tr></table></figure>
<p>is equivalent to</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.req.clear_header(&quot;X-Foo&quot;)</span><br></pre></td></tr></table></figure>
<h2><span id="ngxreqclear_header">ngx.req.clear_header</span></h2><p><strong>syntax:</strong> <em>ngx.req.clear_header(header_name)</em></p>
<p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*</p>
<p>Clears the current request’s request header named <code>header_name</code>. None of the current request’s existing subrequests will be affected but subsequently initiated subrequests will inherit the change by default.</p>
<h2><span id="ngxreqread_body">ngx.req.read_body</span></h2><p><strong>syntax:</strong> <em>ngx.req.read_body()</em></p>
<p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*</p>
<p>Reads the client request body synchronously without blocking the Nginx event loop.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ngx.req.read_body()</span><br><span class="line">local args = ngx.req.get_post_args()</span><br></pre></td></tr></table></figure>
<p>If the request body is already read previously by turning on [lua_need_request_body]</p>
<p>If the request body has already been explicitly discarded, either by the [ngx.req.discard_body]</p>
<p>In case of errors, such as connection errors while reading the data, this method will throw out a Lua exception <em>or</em> terminate the current request with a 500 status code immediately.</p>
<p>The request body data read using this function can be retrieved later via [ngx.req.get_body_data]</p>
<ol>
<li>whether the current request body is already larger than the <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_buffer_size" target="_blank" rel="noopener">client_body_buffer_size</a>,</li>
<li>and whether <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_in_file_only" target="_blank" rel="noopener">client_body_in_file_only</a> has been switched on.</li>
</ol>
<p>In cases where current request may have a request body and the request body data is not required, The [ngx.req.discard_body]</p>
<p>This function was first introduced in the <code>v0.3.1rc17</code> release.</p>
<h2><span id="ngxreqdiscard_body">ngx.req.discard_body</span></h2><p><strong>syntax:</strong> <em>ngx.req.discard_body()</em></p>
<p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*</p>
<p>Explicitly discard the request body, i.e., read the data on the connection and throw it away immediately (without using the request body by any means).</p>
<p>This function is an asynchronous call and returns immediately.</p>
<p>If the request body has already been read, this function does nothing and returns immediately.</p>
<p>This function was first introduced in the <code>v0.3.1rc17</code> release.</p>
<p>See also [ngx.req.read_body]</p>
<h2><span id="ngxreqget_body_data">ngx.req.get_body_data</span></h2><p><strong>syntax:</strong> <em>data = ngx.req.get_body_data()</em></p>
<p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, log_by_lua*</p>
<p>Retrieves in-memory request body data. It returns a Lua string rather than a Lua table holding all the parsed query arguments. Use the [ngx.req.get_post_args]</p>
<p>This function returns <code>nil</code> if</p>
<ol>
<li>the request body has not been read,</li>
<li>the request body has been read into disk temporary files,</li>
<li>or the request body has zero size.</li>
</ol>
<p>If the request body has not been read yet, call [ngx.req.read_body]</p>
<p>If the request body has been read into disk files, try calling the [ngx.req.get_body_file]</p>
<p>To force in-memory request bodies, try setting <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_buffer_size" target="_blank" rel="noopener">client_body_buffer_size</a> to the same size value in <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#client_max_body_size" target="_blank" rel="noopener">client_max_body_size</a>.</p>
<p>Note that calling this function instead of using <code>ngx.var.request_body</code> or <code>ngx.var.echo_request_body</code> is more efficient because it can save one dynamic memory allocation and one data copy.</p>
<p>This function was first introduced in the <code>v0.3.1rc17</code> release.</p>
<p>See also [ngx.req.get_body_file]</p>
<h2><span id="ngxreqget_body_file">ngx.req.get_body_file</span></h2><p><strong>syntax:</strong> <em>file_name = ngx.req.get_body_file()</em></p>
<p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*</p>
<p>Retrieves the file name for the in-file request body data. Returns <code>nil</code> if the request body has not been read or has been read into memory.</p>
<p>The returned file is read only and is usually cleaned up by Nginx’s memory pool. It should not be manually modified, renamed, or removed in Lua code.</p>
<p>If the request body has not been read yet, call [ngx.req.read_body]</p>
<p>If the request body has been read into memory, try calling the [ngx.req.get_body_data]</p>
<p>To force in-file request bodies, try turning on <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_in_file_only" target="_blank" rel="noopener">client_body_in_file_only</a>.</p>
<p>This function was first introduced in the <code>v0.3.1rc17</code> release.</p>
<p>See also [ngx.req.get_body_data]</p>
<h2><span id="ngxreqset_body_data">ngx.req.set_body_data</span></h2><p><strong>syntax:</strong> <em>ngx.req.set_body_data(data)</em></p>
<p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*</p>
<p>Set the current request’s request body using the in-memory data specified by the <code>data</code> argument.</p>
<p>If the request body has not been read yet, call [ngx.req.read_body]</p>
<p>Whether the previous request body has been read into memory or buffered into a disk file, it will be freed or the disk file will be cleaned up immediately, respectively.</p>
<p>This function was first introduced in the <code>v0.3.1rc18</code> release.</p>
<p>See also [ngx.req.set_body_file]</p>
<h2><span id="ngxreqset_body_file">ngx.req.set_body_file</span></h2><p><strong>syntax:</strong> <em>ngx.req.set_body_file(file_name, auto_clean?)</em></p>
<p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*</p>
<p>Set the current request’s request body using the in-file data specified by the <code>file_name</code> argument.</p>
<p>If the request body has not been read yet, call [ngx.req.read_body]</p>
<p>If the optional <code>auto_clean</code> argument is given a <code>true</code> value, then this file will be removed at request completion or the next time this function or [ngx.req.set_body_data]</p>
<p>Please ensure that the file specified by the <code>file_name</code> argument exists and is readable by an Nginx worker process by setting its permission properly to avoid Lua exception errors.</p>
<p>Whether the previous request body has been read into memory or buffered into a disk file, it will be freed or the disk file will be cleaned up immediately, respectively.</p>
<p>This function was first introduced in the <code>v0.3.1rc18</code> release.</p>
<p>See also [ngx.req.set_body_data]</p>
<h2><span id="ngxreqinit_body">ngx.req.init_body</span></h2><p><strong>syntax:</strong> <em>ngx.req.init_body(buffer_size?)</em></p>
<p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*</p>
<p>Creates a new blank request body for the current request and inializes the buffer for later request body data writing via the [ngx.req.append_body]</p>
<p>If the <code>buffer_size</code> argument is specified, then its value will be used for the size of the memory buffer for body writing with [ngx.req.append_body]</p>
<p>When the data can no longer be hold in the memory buffer for the request body, then the data will be flushed onto a temporary file just like the standard request body reader in the Nginx core.</p>
<p>It is important to always call the [ngx.req.finish_body]</p>
<p>The usage of this function is often like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ngx.req.init_body(128 * 1024)  -- buffer is 128KB</span><br><span class="line">for chunk in next_data_chunk() do</span><br><span class="line">    ngx.req.append_body(chunk) -- each chunk can be 4KB</span><br><span class="line">end</span><br><span class="line">ngx.req.finish_body()</span><br></pre></td></tr></table></figure>
<p>This function can be used with [ngx.req.append_body]</p>
<p>This function was first introduced in the <code>v0.5.11</code> release.</p>
<h2><span id="ngxreqappend_body">ngx.req.append_body</span></h2><p><strong>syntax:</strong> <em>ngx.req.append_body(data_chunk)</em></p>
<p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*</p>
<p>Append new data chunk specified by the <code>data_chunk</code> argument onto the existing request body created by the [ngx.req.init_body]</p>
<p>When the data can no longer be hold in the memory buffer for the request body, then the data will be flushed onto a temporary file just like the standard request body reader in the Nginx core.</p>
<p>It is important to always call the [ngx.req.finish_body]</p>
<p>This function can be used with [ngx.req.init_body]</p>
<p>This function was first introduced in the <code>v0.5.11</code> release.</p>
<p>See also [ngx.req.init_body]</p>
<h2><span id="ngxreqfinish_body">ngx.req.finish_body</span></h2><p><strong>syntax:</strong> <em>ngx.req.finish_body()</em></p>
<p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*</p>
<p>Completes the construction process of the new request body created by the [ngx.req.init_body]</p>
<p>This function can be used with [ngx.req.init_body]</p>
<p>This function was first introduced in the <code>v0.5.11</code> release.</p>
<p>See also [ngx.req.init_body]</p>
<h2><span id="ngxreqsocket">ngx.req.socket</span></h2><p><strong>syntax:</strong> <em>tcpsock, err = ngx.req.socket()</em></p>
<p><strong>syntax:</strong> <em>tcpsock, err = ngx.req.socket(raw)</em></p>
<p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*</p>
<p>Returns a read-only cosocket object that wraps the downstream connection. Only [receive]</p>
<p>In case of error, <code>nil</code> will be returned as well as a string describing the error.</p>
<p>The socket object returned by this method is usually used to read the current request’s body in a streaming fashion. Do not turn on the [lua_need_request_body]</p>
<p>If any request body data has been pre-read into the Nginx core request header buffer, the resulting cosocket object will take care of this to avoid potential data loss resulting from such pre-reading. Chunked request bodies are not yet supported in this API.</p>
<p>Since the <code>v0.9.0</code> release, this function accepts an optional boolean <code>raw</code> argument. When this argument is <code>true</code>, this function returns a full-duplex cosocket object wrapping around the raw downstream connection socket, upon which you can call the [receive]</p>
<p>When the <code>raw</code> argument is <code>true</code>, it is required that no pending data from any previous [ngx.say]</p>
<p>You can use the “raw request socket” returned by <code>ngx.req.socket(true)</code> to implement fancy protocols like <a href="http://en.wikipedia.org/wiki/WebSocket" target="_blank" rel="noopener">WebSocket</a>, or just emit your own raw HTTP response header or body data. You can refer to the [lua-resty-websocket library]</p>
<p>This function was first introduced in the <code>v0.5.0rc1</code> release.</p>
<h2><span id="ngxexec">ngx.exec</span></h2><p><strong>syntax:</strong> <em>ngx.exec(uri, args?)</em></p>
<p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*</p>
<p>Does an internal redirect to <code>uri</code> with <code>args</code> and is similar to the <a href="http://github.com/openresty/echo-nginx-module#echo_exec" target="_blank" rel="noopener">echo_exec</a> directive of the <a href="http://github.com/openresty/echo-nginx-module" target="_blank" rel="noopener">echo-nginx-module</a>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ngx.exec(&apos;/some-location&apos;);</span><br><span class="line">ngx.exec(&apos;/some-location&apos;, &apos;a=3&amp;b=5&amp;c=6&apos;);</span><br><span class="line">ngx.exec(&apos;/some-location?a=3&amp;b=5&apos;, &apos;c=6&apos;);</span><br></pre></td></tr></table></figure>
<p>The optional second <code>args</code> can be used to specify extra URI query arguments, for example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.exec(&quot;/foo&quot;, &quot;a=3&amp;b=hello%20world&quot;)</span><br></pre></td></tr></table></figure>
<p>Alternatively, a Lua table can be passed for the <code>args</code> argument for ngx_lua to carry out URI escaping and string concatenation.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.exec(&quot;/foo&quot;, &#123; a = 3, b = &quot;hello world&quot; &#125;)</span><br></pre></td></tr></table></figure>
<p>The result is exactly the same as the previous example.</p>
<p>The format for the Lua table passed as the <code>args</code> argument is identical to the format used in the [ngx.encode_args]</p>
<p>Named locations are also supported but the second <code>args</code> argument will be ignored if present and the querystring for the new target is inherited from the referring location (if any).</p>
<p><code>GET /foo/file.php?a=hello</code> will return “hello” and not “goodbye” in the example below</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">location /foo &#123;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        ngx.exec(&quot;@bar&quot;, &quot;a=goodbye&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location @bar &#123;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        local args = ngx.req.get_uri_args()</span><br><span class="line">        for key, val in pairs(args) do</span><br><span class="line">            if key == &quot;a&quot; then</span><br><span class="line">                ngx.say(val)</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note that the <code>ngx.exec</code> method is different from [ngx.redirect]</p>
<p>Also note that this method call terminates the processing of the current request and that it <em>must</em> be called before [ngx.send_headers]</p>
<p>It is recommended that a coding style that combines this method call with the <code>return</code> statement, i.e., <code>return ngx.exec(...)</code>be adopted when this method call is used in contexts other than [header_filter_by_lua*]</p>
<h2><span id="ngxredirect">ngx.redirect</span></h2><p><strong>syntax:</strong> <em>ngx.redirect(uri, status?)</em></p>
<p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*</p>
<p>Issue an <code>HTTP 301</code> or <code>302</code> redirection to <code>uri</code>.</p>
<p>The optional <code>status</code> parameter specifies the HTTP status code to be used. The following status codes are supported right now:</p>
<ul>
<li><code>301</code></li>
<li><code>302</code> (default)</li>
<li><code>303</code></li>
<li><code>307</code></li>
<li><code>308</code></li>
</ul>
<p>It is <code>302</code> (<code>ngx.HTTP_MOVED_TEMPORARILY</code>) by default.</p>
<p>Here is an example assuming the current server name is <code>localhost</code> and that it is listening on port 1984:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return ngx.redirect(&quot;/foo&quot;)</span><br></pre></td></tr></table></figure>
<p>which is equivalent to</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return ngx.redirect(&quot;/foo&quot;, ngx.HTTP_MOVED_TEMPORARILY)</span><br></pre></td></tr></table></figure>
<p>Redirecting arbitrary external URLs is also supported, for example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return ngx.redirect(&quot;http://www.google.com&quot;)</span><br></pre></td></tr></table></figure>
<p>We can also use the numerical code directly as the second <code>status</code> argument:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return ngx.redirect(&quot;/foo&quot;, 301)</span><br></pre></td></tr></table></figure>
<p>This method is similar to the <a href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html#rewrite" target="_blank" rel="noopener">rewrite</a> directive with the <code>redirect</code> modifier in the standard <a href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html" target="_blank" rel="noopener">ngx_http_rewrite_module</a>, for example, this <code>nginx.conf</code> snippet</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rewrite ^ /foo? redirect;  # nginx config</span><br></pre></td></tr></table></figure>
<p>is equivalent to the following Lua code</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return ngx.redirect(&apos;/foo&apos;);  -- Lua code</span><br></pre></td></tr></table></figure>
<p>while</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rewrite ^ /foo? permanent;  # nginx config</span><br></pre></td></tr></table></figure>
<p>is equivalent to</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return ngx.redirect(&apos;/foo&apos;, ngx.HTTP_MOVED_PERMANENTLY)  -- Lua code</span><br></pre></td></tr></table></figure>
<p>URI arguments can be specified as well, for example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return ngx.redirect(&apos;/foo?a=3&amp;b=4&apos;)</span><br></pre></td></tr></table></figure>
<p>Note that this method call terminates the processing of the current request and that it <em>must</em> be called before [ngx.send_headers]</p>
<p>It is recommended that a coding style that combines this method call with the <code>return</code> statement, i.e., <code>return ngx.redirect(...)</code> be adopted when this method call is used in contexts other than [header_filter_by_lua*]</p>
<h2><span id="ngxsend_headers">ngx.send_headers</span></h2><p><strong>syntax:</strong> <em>ok, err = ngx.send_headers()</em></p>
<p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*</p>
<p>Explicitly send out the response headers.</p>
<p>Since <code>v0.8.3</code> this function returns <code>1</code> on success, or returns <code>nil</code> and a string describing the error otherwise.</p>
<p>Note that there is normally no need to manually send out response headers as ngx_lua will automatically send headers out before content is output with [ngx.say]</p>
<h2><span id="ngxheaders_sent">ngx.headers_sent</span></h2><p><strong>syntax:</strong> <em>value = ngx.headers_sent</em></p>
<p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*</p>
<p>Returns <code>true</code> if the response headers have been sent (by ngx_lua), and <code>false</code> otherwise.</p>
<p>This API was first introduced in ngx_lua v0.3.1rc6.</p>
<h2><span id="ngxprint">ngx.print</span></h2><p><strong>syntax:</strong> <em>ok, err = ngx.print(…)</em></p>
<p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*</p>
<p>Emits arguments concatenated to the HTTP client (as response body). If response headers have not been sent, this function will send headers out first and then output body data.</p>
<p>Since <code>v0.8.3</code> this function returns <code>1</code> on success, or returns <code>nil</code> and a string describing the error otherwise.</p>
<p>Lua <code>nil</code> values will output <code>&quot;nil&quot;</code> strings and Lua boolean values will output <code>&quot;true&quot;</code> and <code>&quot;false&quot;</code> literal strings respectively.</p>
<p>Nested arrays of strings are permitted and the elements in the arrays will be sent one by one:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">local table = &#123;</span><br><span class="line">    &quot;hello, &quot;,</span><br><span class="line">    &#123;&quot;world: &quot;, true, &quot; or &quot;, false,</span><br><span class="line">        &#123;&quot;: &quot;, nil&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line">ngx.print(table)</span><br></pre></td></tr></table></figure>
<p>will yield the output</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello, world: true or false: nil</span><br></pre></td></tr></table></figure>
<p>Non-array table arguments will cause a Lua exception to be thrown.</p>
<p>The <code>ngx.null</code> constant will yield the <code>&quot;null&quot;</code> string output.</p>
<p>This is an asynchronous call and will return immediately without waiting for all the data to be written into the system send buffer. To run in synchronous mode, call <code>ngx.flush(true)</code> after calling <code>ngx.print</code>. This can be particularly useful for streaming output. See [ngx.flush]</p>
<p>Please note that both <code>ngx.print</code> and [ngx.say] will always invoke the whole Nginx output body filter chain, which is an expensive operation. So be careful when calling either of these two in a tight loop; buffer the data yourself in Lua and save the calls.</p>
<h2><span id="ngxsay">ngx.say</span></h2><p><strong>syntax:</strong> <em>ok, err = ngx.say(…)</em></p>
<p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*</p>
<p>Just as [ngx.print]</p>
<h2><span id="ngxlog">ngx.log</span></h2><p><strong>syntax:</strong> <em>ngx.log(log_level, …)</em></p>
<p><strong>context:</strong> init_by_lua*, init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p>Log arguments concatenated to error.log with the given logging level.</p>
<p>Lua <code>nil</code> arguments are accepted and result in literal <code>&quot;nil&quot;</code> string while Lua booleans result in literal <code>&quot;true&quot;</code> or <code>&quot;false&quot;</code>string outputs. And the <code>ngx.null</code> constant will yield the <code>&quot;null&quot;</code> string output.</p>
<p>The <code>log_level</code> argument can take constants like <code>ngx.ERR</code> and <code>ngx.WARN</code>. Check out [Nginx log level constants]</p>
<p>There is a hard coded <code>2048</code> byte limitation on error message lengths in the Nginx core. This limit includes trailing newlines and leading time stamps. If the message size exceeds this limit, Nginx will truncate the message text accordingly. This limit can be manually modified by editing the <code>NGX_MAX_ERROR_STR</code> macro definition in the <code>src/core/ngx_log.h</code> file in the Nginx source tree.</p>
<h2><span id="ngxflush">ngx.flush</span></h2><p><strong>syntax:</strong> <em>ok, err = ngx.flush(wait?)</em></p>
<p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*</p>
<p>Flushes response output to the client.</p>
<p><code>ngx.flush</code> accepts an optional boolean <code>wait</code> argument (Default: <code>false</code>) first introduced in the <code>v0.3.1rc34</code> release. When called with the default argument, it issues an asynchronous call (Returns immediately without waiting for output data to be written into the system send buffer). Calling the function with the <code>wait</code> argument set to <code>true</code> switches to synchronous mode.</p>
<p>In synchronous mode, the function will not return until all output data has been written into the system send buffer or until the <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#send_timeout" target="_blank" rel="noopener">send_timeout</a> setting has expired. Note that using the Lua coroutine mechanism means that this function does not block the Nginx event loop even in the synchronous mode.</p>
<p>When <code>ngx.flush(true)</code> is called immediately after [ngx.print]</p>
<p>Note that <code>ngx.flush</code> is not functional when in the HTTP 1.0 output buffering mode. See [HTTP 1.0 support]</p>
<p>Since <code>v0.8.3</code> this function returns <code>1</code> on success, or returns <code>nil</code> and a string describing the error otherwise.</p>
<h2><span id="ngxexit">ngx.exit</span></h2><p><strong>syntax:</strong> <em>ngx.exit(status)</em></p>
<p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p>When <code>status &gt;= 200</code> (i.e., <code>ngx.HTTP_OK</code> and above), it will interrupt the execution of the current request and return status code to nginx.</p>
<p>When <code>status == 0</code> (i.e., <code>ngx.OK</code>), it will only quit the current phase handler (or the content handler if the [content_by_lua*]</p>
<p>The <code>status</code> argument can be <code>ngx.OK</code>, <code>ngx.ERROR</code>, <code>ngx.HTTP_NOT_FOUND</code>, <code>ngx.HTTP_MOVED_TEMPORARILY</code>, or other [HTTP status constants]</p>
<p>To return an error page with custom contents, use code snippets like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ngx.status = ngx.HTTP_GONE</span><br><span class="line">ngx.say(&quot;This is our own content&quot;)</span><br><span class="line">-- to cause quit the whole request rather than the current phase handler</span><br><span class="line">ngx.exit(ngx.HTTP_OK)</span><br></pre></td></tr></table></figure>
<p>The effect in action:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ curl -i http://localhost/test</span><br><span class="line">HTTP/1.1 410 Gone</span><br><span class="line">Server: nginx/1.0.6</span><br><span class="line">Date: Thu, 15 Sep 2011 00:51:48 GMT</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">This is our own content</span><br></pre></td></tr></table></figure>
<p>Number literals can be used directly as the argument, for instance,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.exit(501)</span><br></pre></td></tr></table></figure>
<p>Note that while this method accepts all [HTTP status constants]</p>
<p>Also note that this method call terminates the processing of the current request and that it is recommended that a coding style that combines this method call with the <code>return</code> statement, i.e., <code>return ngx.exit(...)</code> be used to reinforce the fact that the request processing is being terminated.</p>
<p>When being used in the contexts of [header_filter_by_lua*]</p>
<h2><span id="ngxeof">ngx.eof</span></h2><p><strong>syntax:</strong> <em>ok, err = ngx.eof()</em></p>
<p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*</p>
<p>Explicitly specify the end of the response output stream. In the case of HTTP 1.1 chunked encoded output, it will just trigger the Nginx core to send out the “last chunk”.</p>
<p>When you disable the HTTP 1.1 keep-alive feature for your downstream connections, you can rely on well written HTTP clients to close the connection actively for you when you call this method. This trick can be used do back-ground jobs without letting the HTTP clients to wait on the connection, as in the following example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location = /async &#123;</span><br><span class="line">    keepalive_timeout 0;</span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        ngx.say(&quot;got the task!&quot;)</span><br><span class="line">        ngx.eof()  -- well written HTTP clients will close the connection at this point</span><br><span class="line">        -- access MySQL, PostgreSQL, Redis, Memcached, and etc here...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>But if you create subrequests to access other locations configured by Nginx upstream modules, then you should configure those upstream modules to ignore client connection abortions if they are not by default. For example, by default the standard <a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html" target="_blank" rel="noopener">ngx_http_proxy_module</a> will terminate both the subrequest and the main request as soon as the client closes the connection, so it is important to turn on the <a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_ignore_client_abort" target="_blank" rel="noopener">proxy_ignore_client_abort</a> directive in your location block configured by <a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html" target="_blank" rel="noopener">ngx_http_proxy_module</a>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy_ignore_client_abort on;</span><br></pre></td></tr></table></figure>
<p>A better way to do background jobs is to use the [ngx.timer.at]</p>
<p>Since <code>v0.8.3</code> this function returns <code>1</code> on success, or returns <code>nil</code> and a string describing the error otherwise.</p>
<h2><span id="ngxsleep">ngx.sleep</span></h2><p><strong>syntax:</strong> <em>ngx.sleep(seconds)</em></p>
<p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p>
<p>Sleeps for the specified seconds without blocking. One can specify time resolution up to 0.001 seconds (i.e., one milliseconds).</p>
<p>Behind the scene, this method makes use of the Nginx timers.</p>
<p>Since the <code>0.7.20</code> release, The <code>0</code> time argument can also be specified.</p>
<p>This method was introduced in the <code>0.5.0rc30</code> release.</p>
<h2><span id="ngxescape_uri">ngx.escape_uri</span></h2><p><strong>syntax:</strong> <em>newstr = ngx.escape_uri(str)</em></p>
<p><strong>context:</strong> init_by_lua*, init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p>Escape <code>str</code> as a URI component.</p>
<h2><span id="ngxunescape_uri">ngx.unescape_uri</span></h2><p><strong>syntax:</strong> <em>newstr = ngx.unescape_uri(str)</em></p>
<p><strong>context:</strong> init_by_lua*, init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*</p>
<p>Unescape <code>str</code> as an escaped URI component.</p>
<p>For example,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.say(ngx.unescape_uri(&quot;b%20r56+7&quot;))</span><br></pre></td></tr></table></figure>
<p>gives the output</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b r56 7</span><br></pre></td></tr></table></figure>
<h2><span id="ngxencode_args">ngx.encode_args</span></h2><p><strong>syntax:</strong> <em>str = ngx.encode_args(table)</em></p>
<p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*</p>
<p>Encode the Lua table to a query args string according to the URI encoded rules.</p>
<p>For example,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.encode_args(&#123;foo = 3, [&quot;b r&quot;] = &quot;hello world&quot;&#125;)</span><br></pre></td></tr></table></figure>
<p>yields</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo=3&amp;b%20r=hello%20world</span><br></pre></td></tr></table></figure>
<p>The table keys must be Lua strings.</p>
<p>Multi-value query args are also supported. Just use a Lua table for the argument’s value, for example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.encode_args(&#123;baz = &#123;32, &quot;hello&quot;&#125;&#125;)</span><br></pre></td></tr></table></figure>
<p>gives</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">baz=32&amp;baz=hello</span><br></pre></td></tr></table></figure>
<p>If the value table is empty and the effect is equivalent to the <code>nil</code> value.</p>
<p>Boolean argument values are also supported, for instance,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.encode_args(&#123;a = true, b = 1&#125;)</span><br></pre></td></tr></table></figure>
<p>yields</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a&amp;b=1</span><br></pre></td></tr></table></figure>
<p>If the argument value is <code>false</code>, then the effect is equivalent to the <code>nil</code> value.</p>
<p>This method was first introduced in the <code>v0.3.1rc27</code> release.</p>
<h2><span id="ngxdecode_args">ngx.decode_args</span></h2><p><strong>syntax:</strong> <em>table, err = ngx.decode_args(str, max_args?)</em></p>
<p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p>Decodes a URI encoded query-string into a Lua table. This is the inverse function of [ngx.encode_args]</p>
<p>The optional <code>max_args</code> argument can be used to specify the maximum number of arguments parsed from the <code>str</code>argument. By default, a maximum of 100 request arguments are parsed (including those with the same name) and that additional URI arguments are silently discarded to guard against potential denial of service attacks. Since <code>v0.10.13</code>, when the limit is exceeded, it will return a second value which is the string <code>&quot;truncated&quot;</code>.</p>
<p>This argument can be set to zero to remove the limit and to process all request arguments received:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">local args = ngx.decode_args(str, 0)</span><br></pre></td></tr></table></figure>
<p>Removing the <code>max_args</code> cap is strongly discouraged.</p>
<p>This method was introduced in the <code>v0.5.0rc29</code>.</p>
<h2><span id="ngxencode_base64">ngx.encode_base64</span></h2><p><strong>syntax:</strong> <em>newstr = ngx.encode_base64(str, no_padding?)</em></p>
<p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p>Encodes <code>str</code> to a base64 digest.</p>
<p>Since the <code>0.9.16</code> release, an optional boolean-typed <code>no_padding</code> argument can be specified to control whether the base64 padding should be appended to the resulting digest (default to <code>false</code>, i.e., with padding enabled).</p>
<h2><span id="ngxdecode_base64">ngx.decode_base64</span></h2><p><strong>syntax:</strong> <em>newstr = ngx.decode_base64(str)</em></p>
<p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p>Decodes the <code>str</code> argument as a base64 digest to the raw form. Returns <code>nil</code> if <code>str</code> is not well formed.</p>
<h2><span id="ngxcrc32_short">ngx.crc32_short</span></h2><p><strong>syntax:</strong> <em>intval = ngx.crc32_short(str)</em></p>
<p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p>Calculates the CRC-32 (Cyclic Redundancy Code) digest for the <code>str</code> argument.</p>
<p>This method performs better on relatively short <code>str</code> inputs (i.e., less than 30 ~ 60 bytes), as compared to [ngx.crc32_long]</p>
<p>Behind the scene, it is just a thin wrapper around the <code>ngx_crc32_short</code> function defined in the Nginx core.</p>
<p>This API was first introduced in the <code>v0.3.1rc8</code> release.</p>
<h2><span id="ngxcrc32_long">ngx.crc32_long</span></h2><p><strong>syntax:</strong> <em>intval = ngx.crc32_long(str)</em></p>
<p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p>Calculates the CRC-32 (Cyclic Redundancy Code) digest for the <code>str</code> argument.</p>
<p>This method performs better on relatively long <code>str</code> inputs (i.e., longer than 30 ~ 60 bytes), as compared to [ngx.crc32_short]</p>
<p>Behind the scene, it is just a thin wrapper around the <code>ngx_crc32_long</code> function defined in the Nginx core.</p>
<p>This API was first introduced in the <code>v0.3.1rc8</code> release.</p>
<h2><span id="ngxhmac_sha1">ngx.hmac_sha1</span></h2><p><strong>syntax:</strong> <em>digest = ngx.hmac_sha1(secret_key, str)</em></p>
<p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p>Computes the <a href="http://en.wikipedia.org/wiki/HMAC" target="_blank" rel="noopener">HMAC-SHA1</a> digest of the argument <code>str</code> and turns the result using the secret key <code>&lt;secret_key&gt;</code>.</p>
<p>The raw binary form of the <code>HMAC-SHA1</code> digest will be generated, use [ngx.encode_base64]</p>
<p>For example,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">local key = &quot;thisisverysecretstuff&quot;</span><br><span class="line">local src = &quot;some string we want to sign&quot;</span><br><span class="line">local digest = ngx.hmac_sha1(key, src)</span><br><span class="line">ngx.say(ngx.encode_base64(digest))</span><br></pre></td></tr></table></figure>
<p>yields the output</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R/pvxzHC4NLtj7S+kXFg/NePTmk=</span><br></pre></td></tr></table></figure>
<p>This API requires the OpenSSL library enabled in the Nginx build (usually by passing the <code>--with-http_ssl_module</code> option to the <code>./configure</code> script).</p>
<p>This function was first introduced in the <code>v0.3.1rc29</code> release.</p>
<h2><span id="ngxmd5">ngx.md5</span></h2><p><strong>syntax:</strong> <em>digest = ngx.md5(str)</em></p>
<p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p>Returns the hexadecimal representation of the MD5 digest of the <code>str</code> argument.</p>
<p>For example,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location = /md5 &#123;</span><br><span class="line">    content_by_lua_block &#123; ngx.say(ngx.md5(&quot;hello&quot;)) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>yields the output</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5d41402abc4b2a76b9719d911017c592</span><br></pre></td></tr></table></figure>
<p>See [ngx.md5_bin]</p>
<h2><span id="ngxmd5_bin">ngx.md5_bin</span></h2><p><strong>syntax:</strong> <em>digest = ngx.md5_bin(str)</em></p>
<p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p>Returns the binary form of the MD5 digest of the <code>str</code> argument.</p>
<p>See [ngx.md5]</p>
<h2><span id="ngxsha1_bin">ngx.sha1_bin</span></h2><p><strong>syntax:</strong> <em>digest = ngx.sha1_bin(str)</em></p>
<p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p>Returns the binary form of the SHA-1 digest of the <code>str</code> argument.</p>
<p>This function requires SHA-1 support in the Nginx build. (This usually just means OpenSSL should be installed while building Nginx).</p>
<p>This function was first introduced in the <code>v0.5.0rc6</code>.</p>
<h2><span id="ngxquote_sql_str">ngx.quote_sql_str</span></h2><p><strong>syntax:</strong> <em>quoted_value = ngx.quote_sql_str(raw_value)</em></p>
<p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p>Returns a quoted SQL string literal according to the MySQL quoting rules.</p>
<h2><span id="ngxtoday">ngx.today</span></h2><p><strong>syntax:</strong> <em>str = ngx.today()</em></p>
<p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p>Returns current date (in the format <code>yyyy-mm-dd</code>) from the nginx cached time (no syscall involved unlike Lua’s date library).</p>
<p>This is the local time.</p>
<h2><span id="ngxtime">ngx.time</span></h2><p><strong>syntax:</strong> <em>secs = ngx.time()</em></p>
<p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p>Returns the elapsed seconds from the epoch for the current time stamp from the nginx cached time (no syscall involved unlike Lua’s date library).</p>
<p>Updates of the Nginx time cache can be forced by calling [ngx.update_time]</p>
<h2><span id="ngxnow">ngx.now</span></h2><p><strong>syntax:</strong> <em>secs = ngx.now()</em></p>
<p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p>Returns a floating-point number for the elapsed time in seconds (including milliseconds as the decimal part) from the epoch for the current time stamp from the nginx cached time (no syscall involved unlike Lua’s date library).</p>
<p>You can forcibly update the Nginx time cache by calling [ngx.update_time]</p>
<p>This API was first introduced in <code>v0.3.1rc32</code>.</p>
<h2><span id="ngxupdate_time">ngx.update_time</span></h2><p><strong>syntax:</strong> <em>ngx.update_time()</em></p>
<p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p>Forcibly updates the Nginx current time cache. This call involves a syscall and thus has some overhead, so do not abuse it.</p>
<p>This API was first introduced in <code>v0.3.1rc32</code>.</p>
<h2><span id="ngxlocaltime">ngx.localtime</span></h2><p><strong>syntax:</strong> <em>str = ngx.localtime()</em></p>
<p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p>Returns the current time stamp (in the format <code>yyyy-mm-dd hh:mm:ss</code>) of the nginx cached time (no syscall involved unlike Lua’s <a href="http://www.lua.org/manual/5.1/manual.html#pdf-os.date" target="_blank" rel="noopener">os.date</a> function).</p>
<p>This is the local time.</p>
<h2><span id="ngxutctime">ngx.utctime</span></h2><p><strong>syntax:</strong> <em>str = ngx.utctime()</em></p>
<p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p>Returns the current time stamp (in the format <code>yyyy-mm-dd hh:mm:ss</code>) of the nginx cached time (no syscall involved unlike Lua’s <a href="http://www.lua.org/manual/5.1/manual.html#pdf-os.date" target="_blank" rel="noopener">os.date</a> function).</p>
<p>This is the UTC time.</p>
<h2><span id="ngxcookie_time">ngx.cookie_time</span></h2><p><strong>syntax:</strong> <em>str = ngx.cookie_time(sec)</em></p>
<p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p>Returns a formatted string can be used as the cookie expiration time. The parameter <code>sec</code> is the time stamp in seconds (like those returned from [ngx.time]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ngx.say(ngx.cookie_time(1290079655))</span><br><span class="line">    -- yields &quot;Thu, 18-Nov-10 11:27:35 GMT&quot;</span><br></pre></td></tr></table></figure>
<h2><span id="ngxhttp_time">ngx.http_time</span></h2><p><strong>syntax:</strong> <em>str = ngx.http_time(sec)</em></p>
<p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p>Returns a formated string can be used as the http header time (for example, being used in <code>Last-Modified</code> header). The parameter <code>sec</code> is the time stamp in seconds (like those returned from [ngx.time]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ngx.say(ngx.http_time(1290079655))</span><br><span class="line">    -- yields &quot;Thu, 18 Nov 2010 11:27:35 GMT&quot;</span><br></pre></td></tr></table></figure>
<h2><span id="ngxparse_http_time">ngx.parse_http_time</span></h2><p><strong>syntax:</strong> <em>sec = ngx.parse_http_time(str)</em></p>
<p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p>Parse the http time string (as returned by [ngx.http_time]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">local time = ngx.parse_http_time(&quot;Thu, 18 Nov 2010 11:27:35 GMT&quot;)</span><br><span class="line">if time == nil then</span><br><span class="line">    ...</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h2><span id="ngxis_subrequest">ngx.is_subrequest</span></h2><p><strong>syntax:</strong> <em>value = ngx.is_subrequest</em></p>
<p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*</p>
<p>Returns <code>true</code> if the current request is an nginx subrequest, or <code>false</code> otherwise.</p>
<h2><span id="ngxrematch">ngx.re.match</span></h2><p><strong>syntax:</strong> <em>captures, err = ngx.re.match(subject, regex, options?, ctx?, res_table?)</em></p>
<p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p>Matches the <code>subject</code> string using the Perl compatible regular expression <code>regex</code> with the optional <code>options</code>.</p>
<p>Only the first occurrence of the match is returned, or <code>nil</code> if no match is found. In case of errors, like seeing a bad regular expression or exceeding the PCRE stack limit, <code>nil</code> and a string describing the error will be returned.</p>
<p>When a match is found, a Lua table <code>captures</code> is returned, where <code>captures[0]</code> holds the whole substring being matched, and <code>captures[1]</code> holds the first parenthesized sub-pattern’s capturing, <code>captures[2]</code> the second, and so on.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">local m, err = ngx.re.match(&quot;hello, 1234&quot;, &quot;[0-9]+&quot;)</span><br><span class="line">if m then</span><br><span class="line">    -- m[0] == &quot;1234&quot;</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line">    if err then</span><br><span class="line">        ngx.log(ngx.ERR, &quot;error: &quot;, err)</span><br><span class="line">        return</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    ngx.say(&quot;match not found&quot;)</span><br><span class="line">end</span><br><span class="line">local m, err = ngx.re.match(&quot;hello, 1234&quot;, &quot;([0-9])[0-9]+&quot;)</span><br><span class="line">-- m[0] == &quot;1234&quot;</span><br><span class="line">-- m[1] == &quot;1&quot;</span><br></pre></td></tr></table></figure>
<p>Named captures are also supported since the <code>v0.7.14</code> release and are returned in the same Lua table as key-value pairs as the numbered captures.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">local m, err = ngx.re.match(&quot;hello, 1234&quot;, &quot;([0-9][$1]?&lt;remaining&gt;[0-9]+)&quot;)</span><br><span class="line">-- m[0] == &quot;1234&quot;</span><br><span class="line">-- m[1] == &quot;1&quot;</span><br><span class="line">-- m[2] == &quot;234&quot;</span><br><span class="line">-- m[&quot;remaining&quot;] == &quot;234&quot;</span><br></pre></td></tr></table></figure>
<p>Unmatched subpatterns will have <code>false</code> values in their <code>captures</code> table fields.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">local m, err = ngx.re.match(&quot;hello, world&quot;, &quot;(world)|(hello)|(?&lt;named&gt;howdy)&quot;)</span><br><span class="line">-- m[0] == &quot;hello&quot;</span><br><span class="line">-- m[1] == false</span><br><span class="line">-- m[2] == &quot;hello&quot;</span><br><span class="line">-- m[3] == false</span><br><span class="line">-- m[&quot;named&quot;] == false</span><br></pre></td></tr></table></figure>
<p>Specify <code>options</code> to control how the match operation will be performed. The following option characters are supported:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">a             anchored mode (only match from the beginning)</span><br><span class="line"></span><br><span class="line">d             enable the DFA mode (or the longest token match semantics).</span><br><span class="line">              this requires PCRE 6.0+ or else a Lua exception will be thrown.</span><br><span class="line">              first introduced in ngx_lua v0.3.1rc30.</span><br><span class="line"></span><br><span class="line">D             enable duplicate named pattern support. This allows named</span><br><span class="line">              subpattern names to be repeated, returning the captures in</span><br><span class="line">              an array-like Lua table. for example,</span><br><span class="line">                local m = ngx.re.match(&quot;hello, world&quot;,</span><br><span class="line">                                       &quot;(?&lt;named&gt;\w+), (?&lt;named&gt;\w+)&quot;,</span><br><span class="line">                                       &quot;D&quot;)</span><br><span class="line">                -- m[&quot;named&quot;] == &#123;&quot;hello&quot;, &quot;world&quot;&#125;</span><br><span class="line">              this option was first introduced in the v0.7.14 release.</span><br><span class="line">              this option requires at least PCRE 8.12.</span><br><span class="line"></span><br><span class="line">i             case insensitive mode (similar to Perl&apos;s /i modifier)</span><br><span class="line"></span><br><span class="line">j             enable PCRE JIT compilation, this requires PCRE 8.21+ which</span><br><span class="line">              must be built with the --enable-jit option. for optimum performance,</span><br><span class="line">              this option should always be used together with the &apos;o&apos; option.</span><br><span class="line">              first introduced in ngx_lua v0.3.1rc30.</span><br><span class="line"></span><br><span class="line">J             enable the PCRE Javascript compatible mode. this option was</span><br><span class="line">              first introduced in the v0.7.14 release. this option requires</span><br><span class="line">              at least PCRE 8.12.</span><br><span class="line"></span><br><span class="line">m             multi-line mode (similar to Perl&apos;s /m modifier)</span><br><span class="line"></span><br><span class="line">o             compile-once mode (similar to Perl&apos;s /o modifier),</span><br><span class="line">              to enable the worker-process-level compiled-regex cache</span><br><span class="line"></span><br><span class="line">s             single-line mode (similar to Perl&apos;s /s modifier)</span><br><span class="line"></span><br><span class="line">u             UTF-8 mode. this requires PCRE to be built with</span><br><span class="line">              the --enable-utf8 option or else a Lua exception will be thrown.</span><br><span class="line"></span><br><span class="line">U             similar to &quot;u&quot; but disables PCRE&apos;s UTF-8 validity check on</span><br><span class="line">              the subject string. first introduced in ngx_lua v0.8.1.</span><br><span class="line"></span><br><span class="line">x             extended mode (similar to Perl&apos;s /x modifier)</span><br></pre></td></tr></table></figure>
<p>These options can be combined:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">local m, err = ngx.re.match(&quot;hello, world&quot;, &quot;HEL LO&quot;, &quot;ix&quot;)</span><br><span class="line">-- m[0] == &quot;hello&quot;</span><br><span class="line">local m, err = ngx.re.match(&quot;hello, 美好生活&quot;, &quot;HELLO, (.&#123;2&#125;)&quot;, &quot;iu&quot;)</span><br><span class="line">-- m[0] == &quot;hello, 美好&quot;</span><br><span class="line">-- m[1] == &quot;美好&quot;</span><br></pre></td></tr></table></figure>
<p>The <code>o</code> option is useful for performance tuning, because the regex pattern in question will only be compiled once, cached in the worker-process level, and shared among all requests in the current Nginx worker process. The upper limit of the regex cache can be tuned via the [lua_regex_cache_max_entries]</p>
<p>The optional fourth argument, <code>ctx</code>, can be a Lua table holding an optional <code>pos</code> field. When the <code>pos</code> field in the <code>ctx</code> table argument is specified, <code>ngx.re.match</code> will start matching from that offset (starting from 1). Regardless of the presence of the <code>pos</code> field in the <code>ctx</code> table, <code>ngx.re.match</code> will always set this <code>pos</code> field to the position <em>after</em> the substring matched by the whole pattern in case of a successful match. When match fails, the <code>ctx</code> table will be left intact.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">local ctx = &#123;&#125;</span><br><span class="line">local m, err = ngx.re.match(&quot;1234, hello&quot;, &quot;[0-9]+&quot;, &quot;&quot;, ctx)</span><br><span class="line">     -- m[0] = &quot;1234&quot;</span><br><span class="line">     -- ctx.pos == 5</span><br><span class="line">local ctx = &#123; pos = 2 &#125;</span><br><span class="line">local m, err = ngx.re.match(&quot;1234, hello&quot;, &quot;[0-9]+&quot;, &quot;&quot;, ctx)</span><br><span class="line">     -- m[0] = &quot;234&quot;</span><br><span class="line">     -- ctx.pos == 5</span><br></pre></td></tr></table></figure>
<p>The <code>ctx</code> table argument combined with the <code>a</code> regex modifier can be used to construct a lexer atop <code>ngx.re.match</code>.</p>
<p>Note that, the <code>options</code> argument is not optional when the <code>ctx</code> argument is specified and that the empty Lua string (<code>&quot;&quot;</code>) must be used as placeholder for <code>options</code> if no meaningful regex options are required.</p>
<p>This method requires the PCRE library enabled in Nginx. ([Known Issue With Special Escaping Sequences]</p>
<p>To confirm that PCRE JIT is enabled, activate the Nginx debug log by adding the <code>--with-debug</code> option to Nginx or OpenResty’s <code>./configure</code> script. Then, enable the “debug” error log level in <code>error_log</code> directive. The following message will be generated if PCRE JIT is enabled:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pcre JIT compiling result: 1</span><br></pre></td></tr></table></figure>
<p>Starting from the <code>0.9.4</code> release, this function also accepts a 5th argument, <code>res_table</code>, for letting the caller supply the Lua table used to hold all the capturing results. Starting from <code>0.9.6</code>, it is the caller’s responsibility to ensure this table is empty. This is very useful for recycling Lua tables and saving GC and table allocation overhead.</p>
<p>This feature was introduced in the <code>v0.2.1rc11</code> release.</p>
<h2><span id="ngxrefind">ngx.re.find</span></h2><p><strong>syntax:</strong> <em>from, to, err = ngx.re.find(subject, regex, options?, ctx?, nth?)</em></p>
<p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p>Similar to [ngx.re.match]</p>
<p>In case of errors (like bad regexes or any PCRE runtime errors), this API function returns two <code>nil</code> values followed by a string describing the error.</p>
<p>If no match is found, this function just returns a <code>nil</code> value.</p>
<p>Below is an example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">local s = &quot;hello, 1234&quot;</span><br><span class="line">local from, to, err = ngx.re.find(s, &quot;([0-9]+)&quot;, &quot;jo&quot;)</span><br><span class="line">if from then</span><br><span class="line">    ngx.say(&quot;from: &quot;, from)</span><br><span class="line">    ngx.say(&quot;to: &quot;, to)</span><br><span class="line">    ngx.say(&quot;matched: &quot;, string.sub(s, from, to))</span><br><span class="line">else</span><br><span class="line">    if err then</span><br><span class="line">        ngx.say(&quot;error: &quot;, err)</span><br><span class="line">        return</span><br><span class="line">    end</span><br><span class="line">    ngx.say(&quot;not matched!&quot;)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>This example produces the output</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from: 8</span><br><span class="line">to: 11</span><br><span class="line">matched: 1234</span><br></pre></td></tr></table></figure>
<p>Because this API function does not create new Lua strings nor new Lua tables, it is much faster than [ngx.re.match]</p>
<p>Since the <code>0.9.3</code> release, an optional 5th argument, <code>nth</code>, is supported to specify which (submatch) capture’s indexes to return. When <code>nth</code> is 0 (which is the default), the indexes for the whole matched substring is returned; when <code>nth</code> is 1, then the 1st submatch capture’s indexes are returned; when <code>nth</code> is 2, then the 2nd submatch capture is returned, and so on. When the specified submatch does not have a match, then two <code>nil</code> values will be returned. Below is an example for this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">local str = &quot;hello, 1234&quot;</span><br><span class="line">local from, to = ngx.re.find(str, &quot;([0-9][$1][0-9]+)&quot;, &quot;jo&quot;, nil, 2)</span><br><span class="line">if from then</span><br><span class="line">    ngx.say(&quot;matched 2nd submatch: &quot;, string.sub(str, from, to))  -- yields &quot;234&quot;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>This API function was first introduced in the <code>v0.9.2</code> release.</p>
<h2><span id="ngxregmatch">ngx.re.gmatch</span></h2><p><strong>syntax:</strong> <em>iterator, err = ngx.re.gmatch(subject, regex, options?)</em></p>
<p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p>Similar to [ngx.re.match]</p>
<p>In case of errors, like seeing an ill-formed regular expression, <code>nil</code> and a string describing the error will be returned.</p>
<p>Here is a small example to demonstrate its basic usage:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">local iterator, err = ngx.re.gmatch(&quot;hello, world!&quot;, &quot;([a-z]+)&quot;, &quot;i&quot;)</span><br><span class="line">if not iterator then</span><br><span class="line">    ngx.log(ngx.ERR, &quot;error: &quot;, err)</span><br><span class="line">    return</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">local m</span><br><span class="line">m, err = iterator()    -- m[0] == m[1] == &quot;hello&quot;</span><br><span class="line">if err then</span><br><span class="line">    ngx.log(ngx.ERR, &quot;error: &quot;, err)</span><br><span class="line">    return</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">m, err = iterator()    -- m[0] == m[1] == &quot;world&quot;</span><br><span class="line">if err then</span><br><span class="line">    ngx.log(ngx.ERR, &quot;error: &quot;, err)</span><br><span class="line">    return</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">m, err = iterator()    -- m == nil</span><br><span class="line">if err then</span><br><span class="line">    ngx.log(ngx.ERR, &quot;error: &quot;, err)</span><br><span class="line">    return</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>More often we just put it into a Lua loop:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">local it, err = ngx.re.gmatch(&quot;hello, world!&quot;, &quot;([a-z]+)&quot;, &quot;i&quot;)</span><br><span class="line">if not it then</span><br><span class="line">    ngx.log(ngx.ERR, &quot;error: &quot;, err)</span><br><span class="line">    return</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">while true do</span><br><span class="line">    local m, err = it()</span><br><span class="line">    if err then</span><br><span class="line">        ngx.log(ngx.ERR, &quot;error: &quot;, err)</span><br><span class="line">        return</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    if not m then</span><br><span class="line">        -- no match found (any more)</span><br><span class="line">        break</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    -- found a match</span><br><span class="line">    ngx.say(m[0])</span><br><span class="line">    ngx.say(m[1])</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>The optional <code>options</code> argument takes exactly the same semantics as the [ngx.re.match]</p>
<p>The current implementation requires that the iterator returned should only be used in a single request. That is, one should <em>not</em>assign it to a variable belonging to persistent namespace like a Lua package.</p>
<p>This method requires the PCRE library enabled in Nginx. ([Known Issue With Special Escaping Sequences]</p>
<p>This feature was first introduced in the <code>v0.2.1rc12</code> release.</p>
<h2><span id="ngxresub">ngx.re.sub</span></h2><p><strong>syntax:</strong> <em>newstr, n, err = ngx.re.sub(subject, regex, replace, options?)</em></p>
<p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p>Substitutes the first match of the Perl compatible regular expression <code>regex</code> on the <code>subject</code> argument string with the string or function argument <code>replace</code>. The optional <code>options</code> argument has exactly the same meaning as in [ngx.re.match]</p>
<p>This method returns the resulting new string as well as the number of successful substitutions. In case of failures, like syntax errors in the regular expressions or the <code>&lt;replace&gt;</code> string argument, it will return <code>nil</code> and a string describing the error.</p>
<p>When the <code>replace</code> is a string, then it is treated as a special template for string replacement. For example,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">local newstr, n, err = ngx.re.sub(&quot;hello, 1234&quot;, &quot;([0-9])[0-9]&quot;, &quot;[$0][$1]&quot;)</span><br><span class="line">if newstr then</span><br><span class="line">    -- newstr == &quot;hello, [12][1]34&quot;</span><br><span class="line">    -- n == 1</span><br><span class="line">else</span><br><span class="line">    ngx.log(ngx.ERR, &quot;error: &quot;, err)</span><br><span class="line">    return</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>where <code>$0</code> referring to the whole substring matched by the pattern and <code>$1</code> referring to the first parenthesized capturing substring.</p>
<p>Curly braces can also be used to disambiguate variable names from the background string literals:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">local newstr, n, err = ngx.re.sub(&quot;hello, 1234&quot;, &quot;[0-9]&quot;, &quot;$&#123;0&#125;00&quot;)</span><br><span class="line">    -- newstr == &quot;hello, 100234&quot;</span><br><span class="line">    -- n == 1</span><br></pre></td></tr></table></figure>
<p>Literal dollar sign characters (<code>$</code>) in the <code>replace</code> string argument can be escaped by another dollar sign, for instance,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">local newstr, n, err = ngx.re.sub(&quot;hello, 1234&quot;, &quot;[0-9]&quot;, &quot;$$&quot;)</span><br><span class="line">    -- newstr == &quot;hello, $234&quot;</span><br><span class="line">    -- n == 1</span><br></pre></td></tr></table></figure>
<p>Do not use backlashes to escape dollar signs; it will not work as expected.</p>
<p>When the <code>replace</code> argument is of type “function”, then it will be invoked with the “match table” as the argument to generate the replace string literal for substitution. The “match table” fed into the <code>replace</code> function is exactly the same as the return value of [ngx.re.match]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">local func = function (m)</span><br><span class="line">    return &quot;[&quot; .. m[0] .. &quot;][&quot; .. m[1] .. &quot;]&quot;</span><br><span class="line">end</span><br><span class="line">local newstr, n, err = ngx.re.sub(&quot;hello, 1234&quot;, &quot;( [0-9] ) [0-9]&quot;, func, &quot;x&quot;)</span><br><span class="line">    -- newstr == &quot;hello, [12][1]34&quot;</span><br><span class="line">    -- n == 1</span><br></pre></td></tr></table></figure>
<p>The dollar sign characters in the return value of the <code>replace</code> function argument are not special at all.</p>
<p>This method requires the PCRE library enabled in Nginx. ([Known Issue With Special Escaping Sequences]</p>
<p>This feature was first introduced in the <code>v0.2.1rc13</code> release.</p>
<h2><span id="ngxregsub">ngx.re.gsub</span></h2><p><strong>syntax:</strong> <em>newstr, n, err = ngx.re.gsub(subject, regex, replace, options?)</em></p>
<p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p>Just like [ngx.re.sub]</p>
<p>Here is some examples:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">local newstr, n, err = ngx.re.gsub(&quot;hello, world&quot;, &quot;([a-z])[a-z]+&quot;, &quot;[$0,$1]&quot;, &quot;i&quot;)</span><br><span class="line">if newstr then</span><br><span class="line">    -- newstr == &quot;[hello,h], [world,w]&quot;</span><br><span class="line">    -- n == 2</span><br><span class="line">else</span><br><span class="line">    ngx.log(ngx.ERR, &quot;error: &quot;, err)</span><br><span class="line">    return</span><br><span class="line">end</span><br><span class="line">local func = function (m)</span><br><span class="line">    return &quot;[&quot; .. m[0] .. &quot;,&quot; .. m[1] .. &quot;]&quot;</span><br><span class="line">end</span><br><span class="line">local newstr, n, err = ngx.re.gsub(&quot;hello, world&quot;, &quot;([a-z])[a-z]+&quot;, func, &quot;i&quot;)</span><br><span class="line">    -- newstr == &quot;[hello,h], [world,w]&quot;</span><br><span class="line">    -- n == 2</span><br></pre></td></tr></table></figure>
<p>This method requires the PCRE library enabled in Nginx. ([Known Issue With Special Escaping Sequences]</p>
<p>This feature was first introduced in the <code>v0.2.1rc15</code> release.</p>
<h2><span id="ngxshareddict">ngx.shared.DICT</span></h2><p><strong>syntax:</strong> <em>dict = ngx.shared.DICT</em></p>
<p><strong>syntax:</strong> <em>dict = ngx.shared[name_var]</em></p>
<p><strong>context:</strong> init_by_lua*, init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p>Fetching the shm-based Lua dictionary object for the shared memory zone named <code>DICT</code> defined by the [lua_shared_dict]</p>
<p>Shared memory zones are always shared by all the nginx worker processes in the current nginx server instance.</p>
<p>The resulting object <code>dict</code> has the following methods:</p>
<ul>
<li>[get]</li>
<li>[get_stale]</li>
<li>[set]</li>
<li>[safe_set]</li>
<li>[add]</li>
<li>[safe_add]</li>
<li>[replace]</li>
<li>[delete]</li>
<li>[incr]</li>
<li>[lpush]</li>
<li>[rpush]</li>
<li>[lpop]</li>
<li>[rpop]</li>
<li>[llen]</li>
<li>[ttl]</li>
<li>[expire]</li>
<li>[flush_all]</li>
<li>[flush_expired]</li>
<li>[get_keys]</li>
<li>[capacity]</li>
<li>[free_space]</li>
</ul>
<p>All these methods are <em>atomic</em> operations, that is, safe from concurrent accesses from multiple nginx worker processes for the same <code>lua_shared_dict</code> zone.</p>
<p>Here is an example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    lua_shared_dict dogs 10m;</span><br><span class="line">    server &#123;</span><br><span class="line">        location /set &#123;</span><br><span class="line">            content_by_lua_block &#123;</span><br><span class="line">                local dogs = ngx.shared.dogs</span><br><span class="line">                dogs:set(&quot;Jim&quot;, 8)</span><br><span class="line">                ngx.say(&quot;STORED&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        location /get &#123;</span><br><span class="line">            content_by_lua_block &#123;</span><br><span class="line">                local dogs = ngx.shared.dogs</span><br><span class="line">                ngx.say(dogs:get(&quot;Jim&quot;))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Let us test it:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ curl localhost/set</span><br><span class="line">STORED</span><br><span class="line"></span><br><span class="line">$ curl localhost/get</span><br><span class="line">8</span><br><span class="line"></span><br><span class="line">$ curl localhost/get</span><br><span class="line">8</span><br></pre></td></tr></table></figure>
<p>The number <code>8</code> will be consistently output when accessing <code>/get</code> regardless of how many Nginx workers there are because the <code>dogs</code> dictionary resides in the shared memory and visible to <em>all</em> of the worker processes.</p>
<p>The shared dictionary will retain its contents through a server config reload (either by sending the <code>HUP</code> signal to the Nginx process or by using the <code>-s reload</code> command-line option).</p>
<p>The contents in the dictionary storage will be lost, however, when the Nginx server quits.</p>
<p>This feature was first introduced in the <code>v0.3.1rc22</code> release.</p>
<h2><span id="ngxshareddictget">ngx.shared.DICT.get</span></h2><p><strong>syntax:</strong> <em>value, flags = ngx.shared.DICT:get(key)</em></p>
<p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p>Retrieving the value in the dictionary [ngx.shared.DICT]</p>
<p>In case of errors, <code>nil</code> and a string describing the error will be returned.</p>
<p>The value returned will have the original data type when they were inserted into the dictionary, for example, Lua booleans, numbers, or strings.</p>
<p>The first argument to this method must be the dictionary object itself, for example,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local cats = ngx.shared.cats</span><br><span class="line">local value, flags = cats.get(cats, &quot;Marry&quot;)</span><br></pre></td></tr></table></figure>
<p>or use Lua’s syntactic sugar for method calls:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local cats = ngx.shared.cats</span><br><span class="line">local value, flags = cats:get(&quot;Marry&quot;)</span><br></pre></td></tr></table></figure>
<p>These two forms are fundamentally equivalent.</p>
<p>If the user flags is <code>0</code> (the default), then no flags value will be returned.</p>
<p>This feature was first introduced in the <code>v0.3.1rc22</code> release.</p>
<p>See also [ngx.shared.DICT]</p>
<h2><span id="ngxshareddictget_stale">ngx.shared.DICT.get_stale</span></h2><p><strong>syntax:</strong> <em>value, flags, stale = ngx.shared.DICT:get_stale(key)</em></p>
<p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p>Similar to the [get]</p>
<p>Returns a 3rd value, <code>stale</code>, indicating whether the key has expired or not.</p>
<p>Note that the value of an expired key is not guaranteed to be available so one should never rely on the availability of expired items.</p>
<p>This method was first introduced in the <code>0.8.6</code> release.</p>
<p>See also [ngx.shared.DICT]</p>
<h2><span id="ngxshareddictset">ngx.shared.DICT.set</span></h2><p><strong>syntax:</strong> <em>success, err, forcible = ngx.shared.DICT:set(key, value, exptime?, flags?)</em></p>
<p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p>Unconditionally sets a key-value pair into the shm-based dictionary [ngx.shared.DICT]</p>
<ul>
<li><code>success</code>: boolean value to indicate whether the key-value pair is stored or not.</li>
<li><code>err</code>: textual error message, can be <code>&quot;no memory&quot;</code>.</li>
<li><code>forcible</code>: a boolean value to indicate whether other valid items have been removed forcibly when out of storage in the shared memory zone.</li>
</ul>
<p>The <code>value</code> argument inserted can be Lua booleans, numbers, strings, or <code>nil</code>. Their value type will also be stored into the dictionary and the same data type can be retrieved later via the [get]</p>
<p>The optional <code>exptime</code> argument specifies expiration time (in seconds) for the inserted key-value pair. The time resolution is <code>0.001</code> seconds. If the <code>exptime</code> takes the value <code>0</code> (which is the default), then the item will never expire.</p>
<p>The optional <code>flags</code> argument specifies a user flags value associated with the entry to be stored. It can also be retrieved later with the value. The user flags is stored as an unsigned 32-bit integer internally. Defaults to <code>0</code>. The user flags argument was first introduced in the <code>v0.5.0rc2</code> release.</p>
<p>When it fails to allocate memory for the current key-value item, then <code>set</code> will try removing existing items in the storage according to the Least-Recently Used (LRU) algorithm. Note that, LRU takes priority over expiration time here. If up to tens of existing items have been removed and the storage left is still insufficient (either due to the total capacity limit specified by [lua_shared_dict]</p>
<p>If this method succeeds in storing the current item by forcibly removing other not-yet-expired items in the dictionary via LRU, the <code>forcible</code> return value will be <code>true</code>. If it stores the item without forcibly removing other valid items, then the return value <code>forcible</code> will be <code>false</code>.</p>
<p>The first argument to this method must be the dictionary object itself, for example,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local cats = ngx.shared.cats</span><br><span class="line">local succ, err, forcible = cats.set(cats, &quot;Marry&quot;, &quot;it is a nice cat!&quot;)</span><br></pre></td></tr></table></figure>
<p>or use Lua’s syntactic sugar for method calls:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local cats = ngx.shared.cats</span><br><span class="line">local succ, err, forcible = cats:set(&quot;Marry&quot;, &quot;it is a nice cat!&quot;)</span><br></pre></td></tr></table></figure>
<p>These two forms are fundamentally equivalent.</p>
<p>This feature was first introduced in the <code>v0.3.1rc22</code> release.</p>
<p>Please note that while internally the key-value pair is set atomically, the atomicity does not go across the method call boundary.</p>
<p>See also [ngx.shared.DICT]</p>
<h2><span id="ngxshareddictsafe_set">ngx.shared.DICT.safe_set</span></h2><p><strong>syntax:</strong> <em>ok, err = ngx.shared.DICT:safe_set(key, value, exptime?, flags?)</em></p>
<p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p>Similar to the [set]</p>
<p>This feature was first introduced in the <code>v0.7.18</code> release.</p>
<p>See also [ngx.shared.DICT]</p>
<h2><span id="ngxshareddictadd">ngx.shared.DICT.add</span></h2><p><strong>syntax:</strong> <em>success, err, forcible = ngx.shared.DICT:add(key, value, exptime?, flags?)</em></p>
<p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p>Just like the [set]</p>
<p>If the <code>key</code> argument already exists in the dictionary (and not expired for sure), the <code>success</code> return value will be <code>false</code> and the <code>err</code> return value will be <code>&quot;exists&quot;</code>.</p>
<p>This feature was first introduced in the <code>v0.3.1rc22</code> release.</p>
<p>See also [ngx.shared.DICT]</p>
<h2><span id="ngxshareddictsafe_add">ngx.shared.DICT.safe_add</span></h2><p><strong>syntax:</strong> <em>ok, err = ngx.shared.DICT:safe_add(key, value, exptime?, flags?)</em></p>
<p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p>Similar to the [add]</p>
<p>This feature was first introduced in the <code>v0.7.18</code> release.</p>
<p>See also [ngx.shared.DICT]</p>
<h2><span id="ngxshareddictreplace">ngx.shared.DICT.replace</span></h2><p><strong>syntax:</strong> <em>success, err, forcible = ngx.shared.DICT:replace(key, value, exptime?, flags?)</em></p>
<p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p>Just like the [set]</p>
<p>If the <code>key</code> argument does <em>not</em> exist in the dictionary (or expired already), the <code>success</code> return value will be <code>false</code> and the <code>err</code> return value will be <code>&quot;not found&quot;</code>.</p>
<p>This feature was first introduced in the <code>v0.3.1rc22</code> release.</p>
<p>See also [ngx.shared.DICT]</p>
<h2><span id="ngxshareddictdelete">ngx.shared.DICT.delete</span></h2><p><strong>syntax:</strong> <em>ngx.shared.DICT:delete(key)</em></p>
<p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p>Unconditionally removes the key-value pair from the shm-based dictionary [ngx.shared.DICT]</p>
<p>It is equivalent to <code>ngx.shared.DICT:set(key, nil)</code>.</p>
<p>This feature was first introduced in the <code>v0.3.1rc22</code> release.</p>
<p>See also [ngx.shared.DICT]</p>
<h2><span id="ngxshareddictincr">ngx.shared.DICT.incr</span></h2><p><strong>syntax:</strong> <em>newval, err, forcible? = ngx.shared.DICT:incr(key, value, init?, init_ttl?)</em></p>
<p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p><strong>optional requirement:</strong> <code>resty.core.shdict</code> or <code>resty.core</code></p>
<p>Increments the (numerical) value for <code>key</code> in the shm-based dictionary [ngx.shared.DICT]</p>
<p>When the key does not exist or has already expired in the shared dictionary,</p>
<ol>
<li>if the <code>init</code> argument is not specified or takes the value <code>nil</code>, this method will return <code>nil</code> and the error string <code>&quot;not found&quot;</code>, or</li>
<li>if the <code>init</code> argument takes a number value, this method will create a new <code>key</code> with the value <code>init + value</code>.</li>
</ol>
<p>Like the [add]</p>
<p>The optional <code>init_ttl</code> argument specifies expiration time (in seconds) of the value when it is initialized via the <code>init</code>argument. The time resolution is <code>0.001</code> seconds. If <code>init_ttl</code> takes the value <code>0</code> (which is the default), then the item will never expire. This argument cannot be provided without providing the <code>init</code> argument as well, and has no effect if the value already exists (e.g., if it was previously inserted via [set]</p>
<p><strong>Note:</strong> Usage of the <code>init_ttl</code> argument requires the <code>resty.core.shdict</code> or <code>resty.core</code> modules from the [lua-resty-core]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">require &quot;resty.core&quot;</span><br><span class="line"></span><br><span class="line">local cats = ngx.shared.cats</span><br><span class="line">local newval, err = cats:incr(&quot;black_cats&quot;, 1, 0, 0.1)</span><br><span class="line"></span><br><span class="line">print(newval) -- 1</span><br><span class="line"></span><br><span class="line">ngx.sleep(0.2)</span><br><span class="line"></span><br><span class="line">local val, err = cats:get(&quot;black_cats&quot;)</span><br><span class="line">print(val) -- nil</span><br></pre></td></tr></table></figure>
<p>The <code>forcible</code> return value will always be <code>nil</code> when the <code>init</code> argument is not specified.</p>
<p>If this method succeeds in storing the current item by forcibly removing other not-yet-expired items in the dictionary via LRU, the <code>forcible</code> return value will be <code>true</code>. If it stores the item without forcibly removing other valid items, then the return value <code>forcible</code> will be <code>false</code>.</p>
<p>If the original value is not a valid Lua number in the dictionary, it will return <code>nil</code> and <code>&quot;not a number&quot;</code>.</p>
<p>The <code>value</code> argument and <code>init</code> argument can be any valid Lua numbers, like negative numbers or floating-point numbers.</p>
<p>This method was first introduced in the <code>v0.3.1rc22</code> release.</p>
<p>The optional <code>init</code> parameter was first added in the <code>v0.10.6</code> release.</p>
<p>The optional <code>init_ttl</code> parameter was introduced in the <code>v0.10.12rc2</code> release.</p>
<p>See also [ngx.shared.DICT]</p>
<h2><span id="ngxshareddictlpush">ngx.shared.DICT.lpush</span></h2><p><strong>syntax:</strong> <em>length, err = ngx.shared.DICT:lpush(key, value)</em></p>
<p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p>Inserts the specified (numerical or string) <code>value</code> at the head of the list named <code>key</code> in the shm-based dictionary [ngx.shared.DICT]</p>
<p>If <code>key</code> does not exist, it is created as an empty list before performing the push operation. When the <code>key</code> already takes a value that is not a list, it will return <code>nil</code> and <code>&quot;value not a list&quot;</code>.</p>
<p>It never overrides the (least recently used) unexpired items in the store when running out of storage in the shared memory zone. In this case, it will immediately return <code>nil</code> and the string “no memory”.</p>
<p>This feature was first introduced in the <code>v0.10.6</code> release.</p>
<p>See also [ngx.shared.DICT]</p>
<h2><span id="ngxshareddictrpush">ngx.shared.DICT.rpush</span></h2><p><strong>syntax:</strong> <em>length, err = ngx.shared.DICT:rpush(key, value)</em></p>
<p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p>Similar to the [lpush]</p>
<p>This feature was first introduced in the <code>v0.10.6</code> release.</p>
<p>See also [ngx.shared.DICT]</p>
<h2><span id="ngxshareddictlpop">ngx.shared.DICT.lpop</span></h2><p><strong>syntax:</strong> <em>val, err = ngx.shared.DICT:lpop(key)</em></p>
<p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p>Removes and returns the first element of the list named <code>key</code> in the shm-based dictionary [ngx.shared.DICT]</p>
<p>If <code>key</code> does not exist, it will return <code>nil</code>. When the <code>key</code> already takes a value that is not a list, it will return <code>nil</code> and <code>&quot;value not a list&quot;</code>.</p>
<p>This feature was first introduced in the <code>v0.10.6</code> release.</p>
<p>See also [ngx.shared.DICT]</p>
<h2><span id="ngxshareddictrpop">ngx.shared.DICT.rpop</span></h2><p><strong>syntax:</strong> <em>val, err = ngx.shared.DICT:rpop(key)</em></p>
<p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p>Removes and returns the last element of the list named <code>key</code> in the shm-based dictionary [ngx.shared.DICT]</p>
<p>If <code>key</code> does not exist, it will return <code>nil</code>. When the <code>key</code> already takes a value that is not a list, it will return <code>nil</code> and <code>&quot;value not a list&quot;</code>.</p>
<p>This feature was first introduced in the <code>v0.10.6</code> release.</p>
<p>See also [ngx.shared.DICT]</p>
<h2><span id="ngxshareddictllen">ngx.shared.DICT.llen</span></h2><p><strong>syntax:</strong> <em>len, err = ngx.shared.DICT:llen(key)</em></p>
<p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p>Returns the number of elements in the list named <code>key</code> in the shm-based dictionary [ngx.shared.DICT]</p>
<p>If key does not exist, it is interpreted as an empty list and 0 is returned. When the <code>key</code> already takes a value that is not a list, it will return <code>nil</code> and <code>&quot;value not a list&quot;</code>.</p>
<p>This feature was first introduced in the <code>v0.10.6</code> release.</p>
<p>See also [ngx.shared.DICT]</p>
<h2><span id="ngxshareddictttl">ngx.shared.DICT.ttl</span></h2><p><strong>syntax:</strong> <em>ttl, err = ngx.shared.DICT:ttl(key)</em></p>
<p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p><strong>requires:</strong> <code>resty.core.shdict</code> or <code>resty.core</code></p>
<p>Retrieves the remaining TTL (time-to-live in seconds) of a key-value pair in the shm-based dictionary [ngx.shared.DICT]</p>
<p>If the key does not exist (or has already expired), this method will return <code>nil</code> and the error string <code>&quot;not found&quot;</code>.</p>
<p>The TTL is originally determined by the <code>exptime</code> argument of the [set]</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">require &quot;resty.core&quot;</span><br><span class="line"></span><br><span class="line">local cats = ngx.shared.cats</span><br><span class="line">local succ, err = cats:set(&quot;Marry&quot;, &quot;a nice cat&quot;, 0.5)</span><br><span class="line"></span><br><span class="line">ngx.sleep(0.2)</span><br><span class="line"></span><br><span class="line">local ttl, err = cats:ttl(&quot;Marry&quot;)</span><br><span class="line">ngx.say(ttl) -- 0.3</span><br></pre></td></tr></table></figure>
<p>This feature was first introduced in the <code>v0.10.11</code> release.</p>
<p><strong>Note:</strong> This method requires the <code>resty.core.shdict</code> or <code>resty.core</code> modules from the [lua-resty-core]</p>
<p>See also [ngx.shared.DICT]</p>
<h2><span id="ngxshareddictexpire">ngx.shared.DICT.expire</span></h2><p><strong>syntax:</strong> <em>success, err = ngx.shared.DICT:expire(key, exptime)</em></p>
<p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p><strong>requires:</strong> <code>resty.core.shdict</code> or <code>resty.core</code></p>
<p>Updates the <code>exptime</code> (in second) of a key-value pair in the shm-based dictionary [ngx.shared.DICT]</p>
<p>If the key does not exist, this method will return <code>nil</code> and the error string <code>&quot;not found&quot;</code>.</p>
<p>The <code>exptime</code> argument has a resolution of <code>0.001</code> seconds. If <code>exptime</code> is <code>0</code>, then the item will never expire.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">require &quot;resty.core&quot;</span><br><span class="line"></span><br><span class="line">local cats = ngx.shared.cats</span><br><span class="line">local succ, err = cats:set(&quot;Marry&quot;, &quot;a nice cat&quot;, 0.1)</span><br><span class="line"></span><br><span class="line">succ, err = cats:expire(&quot;Marry&quot;, 0.5)</span><br><span class="line"></span><br><span class="line">ngx.sleep(0.2)</span><br><span class="line"></span><br><span class="line">local val, err = cats:get(&quot;Marry&quot;)</span><br><span class="line">ngx.say(val) -- &quot;a nice cat&quot;</span><br></pre></td></tr></table></figure>
<p>This feature was first introduced in the <code>v0.10.11</code> release.</p>
<p><strong>Note:</strong> This method requires the <code>resty.core.shdict</code> or <code>resty.core</code> modules from the [lua-resty-core]</p>
<p>See also [ngx.shared.DICT]</p>
<h2><span id="ngxshareddictflush_all">ngx.shared.DICT.flush_all</span></h2><p><strong>syntax:</strong> <em>ngx.shared.DICT:flush_all()</em></p>
<p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p>Flushes out all the items in the dictionary. This method does not actuall free up all the memory blocks in the dictionary but just marks all the existing items as expired.</p>
<p>This feature was first introduced in the <code>v0.5.0rc17</code> release.</p>
<p>See also [ngx.shared.DICT.flush_expired]</p>
<h2><span id="ngxshareddictflush_expired">ngx.shared.DICT.flush_expired</span></h2><p><strong>syntax:</strong> <em>flushed = ngx.shared.DICT:flush_expired(max_count?)</em></p>
<p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p>Flushes out the expired items in the dictionary, up to the maximal number specified by the optional <code>max_count</code> argument. When the <code>max_count</code> argument is given <code>0</code> or not given at all, then it means unlimited. Returns the number of items that have actually been flushed.</p>
<p>Unlike the [flush_all]</p>
<p>This feature was first introduced in the <code>v0.6.3</code> release.</p>
<p>See also [ngx.shared.DICT.flush_all]</p>
<h2><span id="ngxshareddictget_keys">ngx.shared.DICT.get_keys</span></h2><p><strong>syntax:</strong> <em>keys = ngx.shared.DICT:get_keys(max_count?)</em></p>
<p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p>Fetch a list of the keys from the dictionary, up to <code>&lt;max_count&gt;</code>.</p>
<p>By default, only the first 1024 keys (if any) are returned. When the <code>&lt;max_count&gt;</code> argument is given the value <code>0</code>, then all the keys will be returned even there is more than 1024 keys in the dictionary.</p>
<p><strong>CAUTION</strong> Avoid calling this method on dictionaries with a very large number of keys as it may lock the dictionary for significant amount of time and block Nginx worker processes trying to access the dictionary.</p>
<p>This feature was first introduced in the <code>v0.7.3</code> release.</p>
<h2><span id="ngxshareddictcapacity">ngx.shared.DICT.capacity</span></h2><p><strong>syntax:</strong> <em>capacity_bytes = ngx.shared.DICT:capacity()</em></p>
<p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p><strong>requires:</strong> <code>resty.core.shdict</code> or <code>resty.core</code></p>
<p>Retrieves the capacity in bytes for the shm-based dictionary [ngx.shared.DICT]</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">require &quot;resty.core.shdict&quot;</span><br><span class="line"></span><br><span class="line">local cats = ngx.shared.cats</span><br><span class="line">local capacity_bytes = cats:capacity()</span><br></pre></td></tr></table></figure>
<p>This feature was first introduced in the <code>v0.10.11</code> release.</p>
<p><strong>Note:</strong> This method requires the <code>resty.core.shdict</code> or <code>resty.core</code> modules from the [lua-resty-core]</p>
<p>This feature requires at least nginx core version <code>0.7.3</code>.</p>
<p>See also [ngx.shared.DICT]</p>
<h2><span id="ngxshareddictfree_space">ngx.shared.DICT.free_space</span></h2><p><strong>syntax:</strong> <em>free_page_bytes = ngx.shared.DICT:free_space()</em></p>
<p><strong>context:</strong> init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p><strong>requires:</strong> <code>resty.core.shdict</code> or <code>resty.core</code></p>
<p>Retrieves the free page size in bytes for the shm-based dictionary [ngx.shared.DICT]</p>
<p><strong>Note:</strong> The memory for ngx.shared.DICT is allocated via the nginx slab allocator which has each slot for data size ranges like ~8, 9~16, 17~32, …, 1025~2048, 2048~ bytes. And pages are assigned to a slot if there is no room in already assigned pages for the slot.</p>
<p>So even if the return value of the <code>free_space</code> method is zero, there may be room in already assigned pages, so you may successfully set a new key value pair to the shared dict without getting <code>true</code> for <code>forcible</code> or non nil <code>err</code> from the <code>ngx.shared.DICT.set</code>.</p>
<p>On the other hand, if already assigned pages for a slot are full and a new key value pair is added to the slot and there is no free page, you may get <code>true</code> for <code>forcible</code> or non nil <code>err</code> from the <code>ngx.shared.DICT.set</code> method.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">require &quot;resty.core.shdict&quot;</span><br><span class="line"></span><br><span class="line">local cats = ngx.shared.cats</span><br><span class="line">local free_page_bytes = cats:free_space()</span><br></pre></td></tr></table></figure>
<p>This feature was first introduced in the <code>v0.10.11</code> release.</p>
<p><strong>Note:</strong> This method requires the <code>resty.core.shdict</code> or <code>resty.core</code> modules from the [lua-resty-core]</p>
<p>This feature requires at least nginx core version <code>1.11.7</code>.</p>
<p>See also [ngx.shared.DICT]</p>
<h2><span id="ngxsocketudp">ngx.socket.udp</span></h2><p><strong>syntax:</strong> <em>udpsock = ngx.socket.udp()</em></p>
<p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p>
<p>Creates and returns a UDP or datagram-oriented unix domain socket object (also known as one type of the “cosocket” objects). The following methods are supported on this object:</p>
<ul>
<li>[setpeername]</li>
<li>[send]</li>
<li>[receive]</li>
<li>[close]</li>
<li>[settimeout]</li>
</ul>
<p>It is intended to be compatible with the UDP API of the <a href="http://w3.impa.br/~diego/software/luasocket/udp.html" target="_blank" rel="noopener">LuaSocket</a> library but is 100% nonblocking out of the box.</p>
<p>This feature was first introduced in the <code>v0.5.7</code> release.</p>
<p>See also [ngx.socket.tcp]</p>
<h2><span id="udpsocksetpeername">udpsock:setpeername</span></h2><p><strong>syntax:</strong> <em>ok, err = udpsock:setpeername(host, port)</em></p>
<p><strong>syntax:</strong> <em>ok, err = udpsock:setpeername(“unix:/path/to/unix-domain.socket”)</em></p>
<p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p>
<p>Attempts to connect a UDP socket object to a remote server or to a datagram unix domain socket file. Because the datagram protocol is actually connection-less, this method does not really establish a “connection”, but only just set the name of the remote peer for subsequent read/write operations.</p>
<p>Both IP addresses and domain names can be specified as the <code>host</code> argument. In case of domain names, this method will use Nginx core’s dynamic resolver to parse the domain name without blocking and it is required to configure the <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#resolver" target="_blank" rel="noopener">resolver</a>directive in the <code>nginx.conf</code> file like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resolver 8.8.8.8;  # use Google&apos;s public DNS nameserver</span><br></pre></td></tr></table></figure>
<p>If the nameserver returns multiple IP addresses for the host name, this method will pick up one randomly.</p>
<p>In case of error, the method returns <code>nil</code> followed by a string describing the error. In case of success, the method returns <code>1</code>.</p>
<p>Here is an example for connecting to a UDP (memcached) server:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">location /test &#123;</span><br><span class="line">    resolver 8.8.8.8;</span><br><span class="line"></span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        local sock = ngx.socket.udp()</span><br><span class="line">        local ok, err = sock:setpeername(&quot;my.memcached.server.domain&quot;, 11211)</span><br><span class="line">        if not ok then</span><br><span class="line">            ngx.say(&quot;failed to connect to memcached: &quot;, err)</span><br><span class="line">            return</span><br><span class="line">        end</span><br><span class="line">        ngx.say(&quot;successfully connected to memcached!&quot;)</span><br><span class="line">        sock:close()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Since the <code>v0.7.18</code> release, connecting to a datagram unix domain socket file is also possible on Linux:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">local sock = ngx.socket.udp()</span><br><span class="line">local ok, err = sock:setpeername(&quot;unix:/tmp/some-datagram-service.sock&quot;)</span><br><span class="line">if not ok then</span><br><span class="line">    ngx.say(&quot;failed to connect to the datagram unix domain socket: &quot;, err)</span><br><span class="line">    return</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>assuming the datagram service is listening on the unix domain socket file <code>/tmp/some-datagram-service.sock</code> and the client socket will use the “autobind” feature on Linux.</p>
<p>Calling this method on an already connected socket object will cause the original connection to be closed first.</p>
<p>This method was first introduced in the <code>v0.5.7</code> release.</p>
<h2><span id="udpsocksend">udpsock:send</span></h2><p><strong>syntax:</strong> <em>ok, err = udpsock:send(data)</em></p>
<p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p>
<p>Sends data on the current UDP or datagram unix domain socket object.</p>
<p>In case of success, it returns <code>1</code>. Otherwise, it returns <code>nil</code> and a string describing the error.</p>
<p>The input argument <code>data</code> can either be a Lua string or a (nested) Lua table holding string fragments. In case of table arguments, this method will copy all the string elements piece by piece to the underlying Nginx socket send buffers, which is usually optimal than doing string concatenation operations on the Lua land.</p>
<p>This feature was first introduced in the <code>v0.5.7</code> release.</p>
<h2><span id="udpsockreceive">udpsock:receive</span></h2><p><strong>syntax:</strong> <em>data, err = udpsock:receive(size?)</em></p>
<p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p>
<p>Receives data from the UDP or datagram unix domain socket object with an optional receive buffer size argument, <code>size</code>.</p>
<p>This method is a synchronous operation and is 100% nonblocking.</p>
<p>In case of success, it returns the data received; in case of error, it returns <code>nil</code> with a string describing the error.</p>
<p>If the <code>size</code> argument is specified, then this method will use this size as the receive buffer size. But when this size is greater than <code>8192</code>, then <code>8192</code> will be used instead.</p>
<p>If no argument is specified, then the maximal buffer size, <code>8192</code> is assumed.</p>
<p>Timeout for the reading operation is controlled by the [lua_socket_read_timeout]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sock:settimeout(1000)  -- one second timeout</span><br><span class="line">local data, err = sock:receive()</span><br><span class="line">if not data then</span><br><span class="line">    ngx.say(&quot;failed to read a packet: &quot;, err)</span><br><span class="line">    return</span><br><span class="line">end</span><br><span class="line">ngx.say(&quot;successfully read a packet: &quot;, data)</span><br></pre></td></tr></table></figure>
<p>It is important here to call the [settimeout]</p>
<p>This feature was first introduced in the <code>v0.5.7</code> release.</p>
<h2><span id="udpsockclose">udpsock:close</span></h2><p><strong>syntax:</strong> <em>ok, err = udpsock:close()</em></p>
<p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p>
<p>Closes the current UDP or datagram unix domain socket. It returns the <code>1</code> in case of success and returns <code>nil</code> with a string describing the error otherwise.</p>
<p>Socket objects that have not invoked this method (and associated connections) will be closed when the socket object is released by the Lua GC (Garbage Collector) or the current client HTTP request finishes processing.</p>
<p>This feature was first introduced in the <code>v0.5.7</code> release.</p>
<h2><span id="udpsocksettimeout">udpsock:settimeout</span></h2><p><strong>syntax:</strong> <em>udpsock:settimeout(time)</em></p>
<p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p>
<p>Set the timeout value in milliseconds for subsequent socket operations (like [receive]</p>
<p>Settings done by this method takes priority over those config directives, like [lua_socket_read_timeout]</p>
<p>This feature was first introduced in the <code>v0.5.7</code> release.</p>
<h2><span id="ngxsocketstream">ngx.socket.stream</span></h2><p>Just an alias to [ngx.socket.tcp]</p>
<p>This API function was first added to the <code>v0.10.1</code> release.</p>
<h2><span id="ngxsockettcp">ngx.socket.tcp</span></h2><p><strong>syntax:</strong> <em>tcpsock = ngx.socket.tcp()</em></p>
<p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p>
<p>Creates and returns a TCP or stream-oriented unix domain socket object (also known as one type of the “cosocket” objects). The following methods are supported on this object:</p>
<ul>
<li>[connect]</li>
<li>[sslhandshake]</li>
<li>[send]</li>
<li>[receive]</li>
<li>[close]</li>
<li>[settimeout]</li>
<li>[settimeouts]</li>
<li>[setoption]</li>
<li>[receiveany]</li>
<li>[receiveuntil]</li>
<li>[setkeepalive]</li>
<li>[getreusedtimes]</li>
</ul>
<p>It is intended to be compatible with the TCP API of the <a href="http://w3.impa.br/~diego/software/luasocket/tcp.html" target="_blank" rel="noopener">LuaSocket</a> library but is 100% nonblocking out of the box. Also, we introduce some new APIs to provide more functionalities.</p>
<p>The cosocket object created by this API function has exactly the same lifetime as the Lua handler creating it. So never pass the cosocket object to any other Lua handler (including ngx.timer callback functions) and never share the cosocket object between different NGINX requests.</p>
<p>For every cosocket object’s underlying connection, if you do not explicitly close it (via [close]</p>
<ul>
<li>the current request handler completes, or</li>
<li>the Lua cosocket object value gets collected by the Lua GC.</li>
</ul>
<p>Fatal errors in cosocket operations always automatically close the current connection (note that, read timeout error is the only error that is not fatal), and if you call [close]</p>
<p>Starting from the <code>0.9.9</code> release, the cosocket object here is full-duplex, that is, a reader “light thread” and a writer “light thread” can operate on a single cosocket object simultaneously (both “light threads” must belong to the same Lua handler though, see reasons above). But you cannot have two “light threads” both reading (or writing or connecting) the same cosocket, otherwise you might get an error like “socket busy reading” when calling the methods of the cosocket object.</p>
<p>This feature was first introduced in the <code>v0.5.0rc1</code> release.</p>
<p>See also [ngx.socket.udp]</p>
<h2><span id="tcpsockconnect">tcpsock:connect</span></h2><p><strong>syntax:</strong> <em>ok, err = tcpsock:connect(host, port, options_table?)</em></p>
<p><strong>syntax:</strong> <em>ok, err = tcpsock:connect(“unix:/path/to/unix-domain.socket”, options_table?)</em></p>
<p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p>
<p>Attempts to connect a TCP socket object to a remote server or to a stream unix domain socket file without blocking.</p>
<p>Before actually resolving the host name and connecting to the remote backend, this method will always look up the connection pool for matched idle connections created by previous calls of this method (or the [ngx.socket.connect]</p>
<p>Both IP addresses and domain names can be specified as the <code>host</code> argument. In case of domain names, this method will use Nginx core’s dynamic resolver to parse the domain name without blocking and it is required to configure the <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#resolver" target="_blank" rel="noopener">resolver</a>directive in the <code>nginx.conf</code> file like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resolver 8.8.8.8;  # use Google&apos;s public DNS nameserver</span><br></pre></td></tr></table></figure>
<p>If the nameserver returns multiple IP addresses for the host name, this method will pick up one randomly.</p>
<p>In case of error, the method returns <code>nil</code> followed by a string describing the error. In case of success, the method returns <code>1</code>.</p>
<p>Here is an example for connecting to a TCP server:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">location /test &#123;</span><br><span class="line">    resolver 8.8.8.8;</span><br><span class="line"></span><br><span class="line">    content_by_lua_block &#123;</span><br><span class="line">        local sock = ngx.socket.tcp()</span><br><span class="line">        local ok, err = sock:connect(&quot;www.google.com&quot;, 80)</span><br><span class="line">        if not ok then</span><br><span class="line">            ngx.say(&quot;failed to connect to google: &quot;, err)</span><br><span class="line">            return</span><br><span class="line">        end</span><br><span class="line">        ngx.say(&quot;successfully connected to google!&quot;)</span><br><span class="line">        sock:close()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Connecting to a Unix Domain Socket file is also possible:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">local sock = ngx.socket.tcp()</span><br><span class="line">local ok, err = sock:connect(&quot;unix:/tmp/memcached.sock&quot;)</span><br><span class="line">if not ok then</span><br><span class="line">    ngx.say(&quot;failed to connect to the memcached unix domain socket: &quot;, err)</span><br><span class="line">    return</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>assuming memcached (or something else) is listening on the unix domain socket file <code>/tmp/memcached.sock</code>.</p>
<p>Timeout for the connecting operation is controlled by the [lua_socket_connect_timeout]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">local sock = ngx.socket.tcp()</span><br><span class="line">sock:settimeout(1000)  -- one second timeout</span><br><span class="line">local ok, err = sock:connect(host, port)</span><br></pre></td></tr></table></figure>
<p>It is important here to call the [settimeout]</p>
<p>Calling this method on an already connected socket object will cause the original connection to be closed first.</p>
<p>An optional Lua table can be specified as the last argument to this method to specify various connect options:</p>
<ul>
<li><code>pool</code> specify a custom name for the connection pool being used. If omitted, then the connection pool name will be generated from the string template <code>&quot;&lt;host&gt;:&lt;port&gt;&quot;</code> or <code>&quot;&lt;unix-socket-path&gt;&quot;</code>.</li>
<li><code>pool_size</code> specify the size of the connection pool. If omitted and no <code>backlog</code> option was provided, no pool will be created. If omitted but <code>backlog</code> was provided, the pool will be created with a default size equal to the value of the [lua_socket_pool_size]</li>
<li><code>backlog</code> if specified, this module will limit the total number of opened connections for this pool. No more connections than <code>pool_size</code> can be opened for this pool at any time. If the connection pool is full, subsequent connect operations will be queued into a queue equal to this option’s value (the “backlog” queue). If the number of queued connect operations is equal to <code>backlog</code>, subsequent connect operations will fail and return <code>nil</code> plus the error string <code>&quot;too many waiting connect operations&quot;</code>. The queued connect operations will be resumed once the number of connections in the pool is less than <code>pool_size</code>. The queued connect operation will abort once they have been queued for more than <code>connect_timeout</code>, controlled by [settimeouts]</li>
</ul>
<p>The support for the options table argument was first introduced in the <code>v0.5.7</code> release.</p>
<p>This method was first introduced in the <code>v0.5.0rc1</code> release.</p>
<h2><span id="tcpsocksslhandshake">tcpsock:sslhandshake</span></h2><p><strong>syntax:</strong> <em>session, err = tcpsock:sslhandshake(reused_session?, server_name?, ssl_verify?, send_status_req?)</em></p>
<p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p>
<p>Does SSL/TLS handshake on the currently established connection.</p>
<p>The optional <code>reused_session</code> argument can take a former SSL session userdata returned by a previous <code>sslhandshake</code> call for exactly the same target. For short-lived connections, reusing SSL sessions can usually speed up the handshake by one order by magnitude but it is not so useful if the connection pool is enabled. This argument defaults to <code>nil</code>. If this argument takes the boolean <code>false</code> value, no SSL session userdata would return by this call and only a Lua boolean will be returned as the first return value; otherwise the current SSL session will always be returned as the first argument in case of successes.</p>
<p>The optional <code>server_name</code> argument is used to specify the server name for the new TLS extension Server Name Indication (SNI). Use of SNI can make different servers share the same IP address on the server side. Also, when SSL verification is enabled, this <code>server_name</code> argument is also used to validate the server name specified in the server certificate sent from the remote.</p>
<p>The optional <code>ssl_verify</code> argument takes a Lua boolean value to control whether to perform SSL verification. When set to <code>true</code>, the server certificate will be verified according to the CA certificates specified by the [lua_ssl_trusted_certificate]</p>
<p>The optional <code>send_status_req</code> argument takes a boolean that controls whether to send the OCSP status request in the SSL handshake request (which is for requesting OCSP stapling).</p>
<p>For connections that have already done SSL/TLS handshake, this method returns immediately.</p>
<p>This method was first introduced in the <code>v0.9.11</code> release.</p>
<h2><span id="tcpsocksend">tcpsock:send</span></h2><p><strong>syntax:</strong> <em>bytes, err = tcpsock:send(data)</em></p>
<p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p>
<p>Sends data without blocking on the current TCP or Unix Domain Socket connection.</p>
<p>This method is a synchronous operation that will not return until <em>all</em> the data has been flushed into the system socket send buffer or an error occurs.</p>
<p>In case of success, it returns the total number of bytes that have been sent. Otherwise, it returns <code>nil</code> and a string describing the error.</p>
<p>The input argument <code>data</code> can either be a Lua string or a (nested) Lua table holding string fragments. In case of table arguments, this method will copy all the string elements piece by piece to the underlying Nginx socket send buffers, which is usually optimal than doing string concatenation operations on the Lua land.</p>
<p>Timeout for the sending operation is controlled by the [lua_socket_send_timeout]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sock:settimeout(1000)  -- one second timeout</span><br><span class="line">local bytes, err = sock:send(request)</span><br></pre></td></tr></table></figure>
<p>It is important here to call the [settimeout]</p>
<p>In case of any connection errors, this method always automatically closes the current connection.</p>
<p>This feature was first introduced in the <code>v0.5.0rc1</code> release.</p>
<h2><span id="tcpsockreceive">tcpsock:receive</span></h2><p><strong>syntax:</strong> <em>data, err, partial = tcpsock:receive(size)</em></p>
<p><strong>syntax:</strong> <em>data, err, partial = tcpsock:receive(pattern?)</em></p>
<p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p>
<p>Receives data from the connected socket according to the reading pattern or size.</p>
<p>This method is a synchronous operation just like the [send]</p>
<p>In case of success, it returns the data received; in case of error, it returns <code>nil</code> with a string describing the error and the partial data received so far.</p>
<p>If a number-like argument is specified (including strings that look like numbers), then it is interpreted as a size. This method will not return until it reads exactly this size of data or an error occurs.</p>
<p>If a non-number-like string argument is specified, then it is interpreted as a “pattern”. The following patterns are supported:</p>
<ul>
<li><code>&#39;*a&#39;</code>: reads from the socket until the connection is closed. No end-of-line translation is performed;</li>
<li><code>&#39;*l&#39;</code>: reads a line of text from the socket. The line is terminated by a <code>Line Feed</code> (LF) character (ASCII 10), optionally preceded by a <code>Carriage Return</code> (CR) character (ASCII 13). The CR and LF characters are not included in the returned line. In fact, all CR characters are ignored by the pattern.</li>
</ul>
<p>If no argument is specified, then it is assumed to be the pattern <code>&#39;*l&#39;</code>, that is, the line reading pattern.</p>
<p>Timeout for the reading operation is controlled by the [lua_socket_read_timeout]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sock:settimeout(1000)  -- one second timeout</span><br><span class="line">local line, err, partial = sock:receive()</span><br><span class="line">if not line then</span><br><span class="line">    ngx.say(&quot;failed to read a line: &quot;, err)</span><br><span class="line">    return</span><br><span class="line">end</span><br><span class="line">ngx.say(&quot;successfully read a line: &quot;, line)</span><br></pre></td></tr></table></figure>
<p>It is important here to call the [settimeout]</p>
<p>Since the <code>v0.8.8</code> release, this method no longer automatically closes the current connection when the read timeout error happens. For other connection errors, this method always automatically closes the connection.</p>
<p>This feature was first introduced in the <code>v0.5.0rc1</code> release.</p>
<h2><span id="tcpsockreceiveany">tcpsock:receiveany</span></h2><p><strong>syntax:</strong> <em>data, err = tcpsock:receiveany(max)</em></p>
<p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p>
<p>Returns any data received by the connected socket, at most <code>max</code> bytes.</p>
<p>This method is a synchronous operation just like the [send]</p>
<p>In case of success, it returns the data received; in case of error, it returns <code>nil</code> with a string describing the error.</p>
<p>If the received data is more than this size, this method will return with exactly this size of data. The remaining data in the underlying receive buffer could be returned in the next reading operation.</p>
<p>Timeout for the reading operation is controlled by the [lua_socket_read_timeout]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sock:settimeouts(1000, 1000, 1000)  -- one second timeout for connect/read/write</span><br><span class="line">local data, err = sock:receiveany(10 * 1024 * 1024) -- read any data, at most 10K</span><br><span class="line">if not data then</span><br><span class="line">    ngx.say(&quot;failed to read any data: &quot;, err)</span><br><span class="line">    return</span><br><span class="line">end</span><br><span class="line">ngx.say(&quot;successfully read: &quot;, data)</span><br></pre></td></tr></table></figure>
<p>This method doesn’t automatically close the current connection when the read timeout error occurs. For other connection errors, this method always automatically closes the connection.</p>
<p>This feature was first introduced in the <code>v0.10.14</code> release.</p>
<h2><span id="tcpsockreceiveuntil">tcpsock:receiveuntil</span></h2><p><strong>syntax:</strong> <em>iterator = tcpsock:receiveuntil(pattern, options?)</em></p>
<p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p>
<p>This method returns an iterator Lua function that can be called to read the data stream until it sees the specified pattern or an error occurs.</p>
<p>Here is an example for using this method to read a data stream with the boundary sequence <code>--abcedhb</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">local reader = sock:receiveuntil(&quot;\r\n--abcedhb&quot;)</span><br><span class="line">local data, err, partial = reader()</span><br><span class="line">if not data then</span><br><span class="line">    ngx.say(&quot;failed to read the data stream: &quot;, err)</span><br><span class="line">end</span><br><span class="line">ngx.say(&quot;read the data stream: &quot;, data)</span><br></pre></td></tr></table></figure>
<p>When called without any argument, the iterator function returns the received data right <em>before</em> the specified pattern string in the incoming data stream. So for the example above, if the incoming data stream is <code>&#39;hello, world! -agentzh\r\n--abcedhb blah blah&#39;</code>, then the string <code>&#39;hello, world! -agentzh&#39;</code> will be returned.</p>
<p>In case of error, the iterator function will return <code>nil</code> along with a string describing the error and the partial data bytes that have been read so far.</p>
<p>The iterator function can be called multiple times and can be mixed safely with other cosocket method calls or other iterator function calls.</p>
<p>The iterator function behaves differently (i.e., like a real iterator) when it is called with a <code>size</code> argument. That is, it will read that <code>size</code> of data on each invocation and will return <code>nil</code> at the last invocation (either sees the boundary pattern or meets an error). For the last successful invocation of the iterator function, the <code>err</code> return value will be <code>nil</code> too. The iterator function will be reset after the last successful invocation that returns <code>nil</code> data and <code>nil</code> error. Consider the following example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">local reader = sock:receiveuntil(&quot;\r\n--abcedhb&quot;)</span><br><span class="line"></span><br><span class="line">while true do</span><br><span class="line">    local data, err, partial = reader(4)</span><br><span class="line">    if not data then</span><br><span class="line">        if err then</span><br><span class="line">            ngx.say(&quot;failed to read the data stream: &quot;, err)</span><br><span class="line">            break</span><br><span class="line">        end</span><br><span class="line"></span><br><span class="line">        ngx.say(&quot;read done&quot;)</span><br><span class="line">        break</span><br><span class="line">    end</span><br><span class="line">    ngx.say(&quot;read chunk: [&quot;, data, &quot;]&quot;)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>Then for the incoming data stream <code>&#39;hello, world! -agentzh\r\n--abcedhb blah blah&#39;</code>, we shall get the following output from the sample code above:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">read chunk: [hell]</span><br><span class="line">read chunk: [o, w]</span><br><span class="line">read chunk: [orld]</span><br><span class="line">read chunk: [! -a]</span><br><span class="line">read chunk: [gent]</span><br><span class="line">read chunk: [zh]</span><br><span class="line">read done</span><br></pre></td></tr></table></figure>
<p>Note that, the actual data returned <em>might</em> be a little longer than the size limit specified by the <code>size</code> argument when the boundary pattern has ambiguity for streaming parsing. Near the boundary of the data stream, the data string actually returned could also be shorter than the size limit.</p>
<p>Timeout for the iterator function’s reading operation is controlled by the [lua_socket_read_timeout]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">local readline = sock:receiveuntil(&quot;\r\n&quot;)</span><br><span class="line"></span><br><span class="line">sock:settimeout(1000)  -- one second timeout</span><br><span class="line">line, err, partial = readline()</span><br><span class="line">if not line then</span><br><span class="line">    ngx.say(&quot;failed to read a line: &quot;, err)</span><br><span class="line">    return</span><br><span class="line">end</span><br><span class="line">ngx.say(&quot;successfully read a line: &quot;, line)</span><br></pre></td></tr></table></figure>
<p>It is important here to call the [settimeout]</p>
<p>As from the <code>v0.5.1</code> release, this method also takes an optional <code>options</code> table argument to control the behavior. The following options are supported:</p>
<ul>
<li><code>inclusive</code></li>
</ul>
<p>The <code>inclusive</code> takes a boolean value to control whether to include the pattern string in the returned data string. Default to <code>false</code>. For example,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">local reader = tcpsock:receiveuntil(&quot;_END_&quot;, &#123; inclusive = true &#125;)</span><br><span class="line">local data = reader()</span><br><span class="line">ngx.say(data)</span><br></pre></td></tr></table></figure>
<p>Then for the input data stream <code>&quot;hello world _END_ blah blah blah&quot;</code>, then the example above will output <code>hello world _END_</code>, including the pattern string <code>_END_</code> itself.</p>
<p>Since the <code>v0.8.8</code> release, this method no longer automatically closes the current connection when the read timeout error happens. For other connection errors, this method always automatically closes the connection.</p>
<p>This method was first introduced in the <code>v0.5.0rc1</code> release.</p>
<h2><span id="tcpsockclose">tcpsock:close</span></h2><p><strong>syntax:</strong> <em>ok, err = tcpsock:close()</em></p>
<p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p>
<p>Closes the current TCP or stream unix domain socket. It returns the <code>1</code> in case of success and returns <code>nil</code> with a string describing the error otherwise.</p>
<p>Note that there is no need to call this method on socket objects that have invoked the [setkeepalive]</p>
<p>Socket objects that have not invoked this method (and associated connections) will be closed when the socket object is released by the Lua GC (Garbage Collector) or the current client HTTP request finishes processing.</p>
<p>This feature was first introduced in the <code>v0.5.0rc1</code> release.</p>
<h2><span id="tcpsocksettimeout">tcpsock:settimeout</span></h2><p><strong>syntax:</strong> <em>tcpsock:settimeout(time)</em></p>
<p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p>
<p>Set the timeout value in milliseconds for subsequent socket operations ([connect]</p>
<p>Settings done by this method takes priority over those config directives, i.e., [lua_socket_connect_timeout]</p>
<p>Note that this method does <em>not</em> affect the [lua_socket_keepalive_timeout]</p>
<p>This feature was first introduced in the <code>v0.5.0rc1</code> release.</p>
<h2><span id="tcpsocksettimeouts">tcpsock:settimeouts</span></h2><p><strong>syntax:</strong> <em>tcpsock:settimeouts(connect_timeout, send_timeout, read_timeout)</em></p>
<p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p>
<p>Sets the connect timeout thresold, send timeout threshold, and read timeout threshold, respetively, in milliseconds, for subsequent socket operations ([connect]</p>
<p>Settings done by this method takes priority over those config directives, i.e., [lua_socket_connect_timeout]</p>
<p>You are recommended to use [settimeouts]</p>
<p>Note that this method does <em>not</em> affect the [lua_socket_keepalive_timeout]</p>
<p>This feature was first introduced in the <code>v0.10.7</code> release.</p>
<h2><span id="tcpsocksetoption">tcpsock:setoption</span></h2><p><strong>syntax:</strong> <em>tcpsock:setoption(option, value?)</em></p>
<p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p>
<p>This function is added for <a href="http://w3.impa.br/~diego/software/luasocket/tcp.html" target="_blank" rel="noopener">LuaSocket</a> API compatibility and does nothing for now. Its functionality will be implemented in future.</p>
<p>This feature was first introduced in the <code>v0.5.0rc1</code> release.</p>
<h2><span id="tcpsocksetkeepalive">tcpsock:setkeepalive</span></h2><p><strong>syntax:</strong> <em>ok, err = tcpsock:setkeepalive(timeout?, size?)</em></p>
<p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p>
<p>Puts the current socket’s connection immediately into the cosocket built-in connection pool and keep it alive until other [connect]</p>
<p>The first optional argument, <code>timeout</code>, can be used to specify the maximal idle timeout (in milliseconds) for the current connection. If omitted, the default setting in the [lua_socket_keepalive_timeout]</p>
<p>The second optional argument <code>size</code> is considered deprecated since the <code>v0.10.14</code> release of this module, in favor of the<code>pool_size</code> option of the [connect]</p>
<p>In case of success, this method returns <code>1</code>; otherwise, it returns <code>nil</code> and a string describing the error.</p>
<p>When the system receive buffer for the current connection has unread data, then this method will return the “connection in dubious state” error message (as the second return value) because the previous session has unread data left behind for the next session and the connection is not safe to be reused.</p>
<p>This method also makes the current cosocket object enter the “closed” state, so there is no need to manually call the [close]</p>
<p>This feature was first introduced in the <code>v0.5.0rc1</code> release.</p>
<h2><span id="tcpsockgetreusedtimes">tcpsock:getreusedtimes</span></h2><p><strong>syntax:</strong> <em>count, err = tcpsock:getreusedtimes()</em></p>
<p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p>
<p>This method returns the (successfully) reused times for the current connection. In case of error, it returns <code>nil</code> and a string describing the error.</p>
<p>If the current connection does not come from the built-in connection pool, then this method always returns <code>0</code>, that is, the connection has never been reused (yet). If the connection comes from the connection pool, then the return value is always non-zero. So this method can also be used to determine if the current connection comes from the pool.</p>
<p>This feature was first introduced in the <code>v0.5.0rc1</code> release.</p>
<h2><span id="ngxsocketconnect">ngx.socket.connect</span></h2><p><strong>syntax:</strong> <em>tcpsock, err = ngx.socket.connect(host, port)</em></p>
<p><strong>syntax:</strong> <em>tcpsock, err = ngx.socket.connect(“unix:/path/to/unix-domain.socket”)</em></p>
<p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.**</p>
<p>This function is a shortcut for combining [ngx.socket.tcp()]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">local sock = ngx.socket.tcp()</span><br><span class="line">local ok, err = sock:connect(...)</span><br><span class="line">if not ok then</span><br><span class="line">    return nil, err</span><br><span class="line">end</span><br><span class="line">return sock</span><br></pre></td></tr></table></figure>
<p>There is no way to use the [settimeout]</p>
<p>This feature was first introduced in the <code>v0.5.0rc1</code> release.</p>
<h2><span id="ngxget_phase">ngx.get_phase</span></h2><p><strong>syntax:</strong> <em>str = ngx.get_phase()</em></p>
<p><strong>context:</strong> init_by_lua*, init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p>Retrieves the current running phase name. Possible return values are</p>
<ul>
<li><code>init</code> for the context of [init_by_lua*]</li>
<li><code>init_worker</code> for the context of [init_worker_by_lua*]</li>
<li><code>ssl_cert</code> for the context of [ssl_certificate_by_lua*]</li>
<li><code>ssl_session_fetch</code> for the context of [ssl_session_fetch_by_lua*]</li>
<li><code>ssl_session_store</code> for the context of [ssl_session_store_by_lua*]</li>
<li><code>set</code> for the context of [set_by_lua*]</li>
<li><code>rewrite</code> for the context of [rewrite_by_lua*]</li>
<li><code>balancer</code> for the context of [balancer_by_lua*]</li>
<li><code>access</code> for the context of [access_by_lua*]</li>
<li><code>content</code> for the context of [content_by_lua*]</li>
<li><code>header_filter</code> for the context of [header_filter_by_lua*]</li>
<li><code>body_filter</code> for the context of [body_filter_by_lua*]</li>
<li><code>log</code> for the context of [log_by_lua*]</li>
<li><code>timer</code> for the context of user callback functions for [ngx.timer.*]</li>
</ul>
<p>This API was first introduced in the <code>v0.5.10</code> release.</p>
<h2><span id="ngxthreadspawn">ngx.thread.spawn</span></h2><p><strong>syntax:</strong> <em>co = ngx.thread.spawn(func, arg1, arg2, …)</em></p>
<p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p>
<p>Spawns a new user “light thread” with the Lua function <code>func</code> as well as those optional arguments <code>arg1</code>, <code>arg2</code>, and etc. Returns a Lua thread (or Lua coroutine) object represents this “light thread”.</p>
<p>“Light threads” are just a special kind of Lua coroutines that are scheduled by the ngx_lua module.</p>
<p>Before <code>ngx.thread.spawn</code> returns, the <code>func</code> will be called with those optional arguments until it returns, aborts with an error, or gets yielded due to I/O operations via the [Nginx API for Lua]</p>
<p>After <code>ngx.thread.spawn</code> returns, the newly-created “light thread” will keep running asynchronously usually at various I/O events.</p>
<p>All the Lua code chunks running by [rewrite_by_lua]</p>
<p>By default, the corresponding Nginx handler (e.g., [rewrite_by_lua]</p>
<ol>
<li>both the “entry thread” and all the user “light threads” terminates,</li>
<li>a “light thread” (either the “entry thread” or a user “light thread” aborts by calling [ngx.exit]</li>
<li>the “entry thread” terminates with a Lua error.</li>
</ol>
<p>When the user “light thread” terminates with a Lua error, however, it will not abort other running “light threads” like the “entry thread” does.</p>
<p>Due to the limitation in the Nginx subrequest model, it is not allowed to abort a running Nginx subrequest in general. So it is also prohibited to abort a running “light thread” that is pending on one ore more Nginx subrequests. You must call [ngx.thread.wait]</p>
<p>The “light threads” are not scheduled in a pre-emptive way. In other words, no time-slicing is performed automatically. A “light thread” will keep running exclusively on the CPU until</p>
<ol>
<li>a (nonblocking) I/O operation cannot be completed in a single run,</li>
<li>it calls [coroutine.yield]</li>
<li>it is aborted by a Lua error or an invocation of [ngx.exit]</li>
</ol>
<p>For the first two cases, the “light thread” will usually be resumed later by the ngx_lua scheduler unless a “stop-the-world” event happens.</p>
<p>User “light threads” can create “light threads” themselves. And normal user coroutines created by [coroutine.create]</p>
<p>The “parent coroutine” can call [ngx.thread.wait]</p>
<p>You can call coroutine.status() and coroutine.yield() on the “light thread” coroutines.</p>
<p>The status of the “light thread” coroutine can be “zombie” if</p>
<ol>
<li>the current “light thread” already terminates (either successfully or with an error),</li>
<li>its parent coroutine is still alive, and</li>
<li>its parent coroutine is not waiting on it with [ngx.thread.wait]</li>
</ol>
<p>The following example demonstrates the use of coroutine.yield() in the “light thread” coroutines to do manual time-slicing:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">local yield = coroutine.yield</span><br><span class="line"></span><br><span class="line">function f()</span><br><span class="line">    local self = coroutine.running()</span><br><span class="line">    ngx.say(&quot;f 1&quot;)</span><br><span class="line">    yield(self)</span><br><span class="line">    ngx.say(&quot;f 2&quot;)</span><br><span class="line">    yield(self)</span><br><span class="line">    ngx.say(&quot;f 3&quot;)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">local self = coroutine.running()</span><br><span class="line">ngx.say(&quot;0&quot;)</span><br><span class="line">yield(self)</span><br><span class="line"></span><br><span class="line">ngx.say(&quot;1&quot;)</span><br><span class="line">ngx.thread.spawn(f)</span><br><span class="line"></span><br><span class="line">ngx.say(&quot;2&quot;)</span><br><span class="line">yield(self)</span><br><span class="line"></span><br><span class="line">ngx.say(&quot;3&quot;)</span><br><span class="line">yield(self)</span><br><span class="line"></span><br><span class="line">ngx.say(&quot;4&quot;)</span><br></pre></td></tr></table></figure>
<p>Then it will generate the output</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">f 1</span><br><span class="line">2</span><br><span class="line">f 2</span><br><span class="line">3</span><br><span class="line">f 3</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<p>“Light threads” are mostly useful for making concurrent upstream requests in a single Nginx request handler, much like a generalized version of [ngx.location.capture_multi]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">-- query mysql, memcached, and a remote http service at the same time,</span><br><span class="line">-- output the results in the order that they</span><br><span class="line">-- actually return the results.</span><br><span class="line"></span><br><span class="line">local mysql = require &quot;resty.mysql&quot;</span><br><span class="line">local memcached = require &quot;resty.memcached&quot;</span><br><span class="line"></span><br><span class="line">local function query_mysql()</span><br><span class="line">    local db = mysql:new()</span><br><span class="line">    db:connect&#123;</span><br><span class="line">                host = &quot;127.0.0.1&quot;,</span><br><span class="line">                port = 3306,</span><br><span class="line">                database = &quot;test&quot;,</span><br><span class="line">                user = &quot;monty&quot;,</span><br><span class="line">                password = &quot;mypass&quot;</span><br><span class="line">              &#125;</span><br><span class="line">    local res, err, errno, sqlstate =</span><br><span class="line">            db:query(&quot;select * from cats order by id asc&quot;)</span><br><span class="line">    db:set_keepalive(0, 100)</span><br><span class="line">    ngx.say(&quot;mysql done: &quot;, cjson.encode(res))</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">local function query_memcached()</span><br><span class="line">    local memc = memcached:new()</span><br><span class="line">    memc:connect(&quot;127.0.0.1&quot;, 11211)</span><br><span class="line">    local res, err = memc:get(&quot;some_key&quot;)</span><br><span class="line">    ngx.say(&quot;memcached done: &quot;, res)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">local function query_http()</span><br><span class="line">    local res = ngx.location.capture(&quot;/my-http-proxy&quot;)</span><br><span class="line">    ngx.say(&quot;http done: &quot;, res.body)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">ngx.thread.spawn(query_mysql)      -- create thread 1</span><br><span class="line">ngx.thread.spawn(query_memcached)  -- create thread 2</span><br><span class="line">ngx.thread.spawn(query_http)       -- create thread 3</span><br></pre></td></tr></table></figure>
<p>This API was first enabled in the <code>v0.7.0</code> release.</p>
<h2><span id="ngxthreadwait">ngx.thread.wait</span></h2><p><strong>syntax:</strong> <em>ok, res1, res2, … = ngx.thread.wait(thread1, thread2, …)</em></p>
<p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</p>
<p>Waits on one or more child “light threads” and returns the results of the first “light thread” that terminates (either successfully or with an error).</p>
<p>The arguments <code>thread1</code>, <code>thread2</code>, and etc are the Lua thread objects returned by earlier calls of [ngx.thread.spawn]</p>
<p>The return values have exactly the same meaning as [coroutine.resume]</p>
<p>Only the direct “parent coroutine” can wait on its child “light thread”, otherwise a Lua exception will be raised.</p>
<p>The following example demonstrates the use of <code>ngx.thread.wait</code> and [ngx.location.capture]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">local capture = ngx.location.capture</span><br><span class="line">local spawn = ngx.thread.spawn</span><br><span class="line">local wait = ngx.thread.wait</span><br><span class="line">local say = ngx.say</span><br><span class="line"></span><br><span class="line">local function fetch(uri)</span><br><span class="line">    return capture(uri)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">local threads = &#123;</span><br><span class="line">    spawn(fetch, &quot;/foo&quot;),</span><br><span class="line">    spawn(fetch, &quot;/bar&quot;),</span><br><span class="line">    spawn(fetch, &quot;/baz&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for i = 1, #threads do</span><br><span class="line">    local ok, res = wait(threads[i])</span><br><span class="line">    if not ok then</span><br><span class="line">        say(i, &quot;: failed to run: &quot;, res)</span><br><span class="line">    else</span><br><span class="line">        say(i, &quot;: status: &quot;, res.status)</span><br><span class="line">        say(i, &quot;: body: &quot;, res.body)</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>Here it essentially implements the “wait all” model.</p>
<p>And below is an example demonstrating the “wait any” model:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">function f()</span><br><span class="line">    ngx.sleep(0.2)</span><br><span class="line">    ngx.say(&quot;f: hello&quot;)</span><br><span class="line">    return &quot;f done&quot;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">function g()</span><br><span class="line">    ngx.sleep(0.1)</span><br><span class="line">    ngx.say(&quot;g: hello&quot;)</span><br><span class="line">    return &quot;g done&quot;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">local tf, err = ngx.thread.spawn(f)</span><br><span class="line">if not tf then</span><br><span class="line">    ngx.say(&quot;failed to spawn thread f: &quot;, err)</span><br><span class="line">    return</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">ngx.say(&quot;f thread created: &quot;, coroutine.status(tf))</span><br><span class="line"></span><br><span class="line">local tg, err = ngx.thread.spawn(g)</span><br><span class="line">if not tg then</span><br><span class="line">    ngx.say(&quot;failed to spawn thread g: &quot;, err)</span><br><span class="line">    return</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">ngx.say(&quot;g thread created: &quot;, coroutine.status(tg))</span><br><span class="line"></span><br><span class="line">ok, res = ngx.thread.wait(tf, tg)</span><br><span class="line">if not ok then</span><br><span class="line">    ngx.say(&quot;failed to wait: &quot;, res)</span><br><span class="line">    return</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">ngx.say(&quot;res: &quot;, res)</span><br><span class="line"></span><br><span class="line">-- stop the &quot;world&quot;, aborting other running threads</span><br><span class="line">ngx.exit(ngx.OK)</span><br></pre></td></tr></table></figure>
<p>And it will generate the following output:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f thread created: running</span><br><span class="line">g thread created: running</span><br><span class="line">g: hello</span><br><span class="line">res: g done</span><br></pre></td></tr></table></figure>
<p>This API was first enabled in the <code>v0.7.0</code> release.</p>
<h2><span id="ngxthreadkill">ngx.thread.kill</span></h2><p><strong>syntax:</strong> <em>ok, err = ngx.thread.kill(thread)</em></p>
<p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.**</p>
<p>Kills a running “light thread” created by [ngx.thread.spawn]</p>
<p>According to the current implementation, only the parent coroutine (or “light thread”) can kill a thread. Also, a running “light thread” with pending NGINX subrequests (initiated by [ngx.location.capture]</p>
<p>This API was first enabled in the <code>v0.9.9</code> release.</p>
<h2><span id="ngxon_abort">ngx.on_abort</span></h2><p><strong>syntax:</strong> <em>ok, err = ngx.on_abort(callback)</em></p>
<p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*</p>
<p>Registers a user Lua function as the callback which gets called automatically when the client closes the (downstream) connection prematurely.</p>
<p>Returns <code>1</code> if the callback is registered successfully or returns <code>nil</code> and a string describing the error otherwise.</p>
<p>All the [Nginx API for Lua]</p>
<p>The callback function can decide what to do with the client abortion event all by itself. For example, it can simply ignore the event by doing nothing and the current Lua request handler will continue executing without interruptions. And the callback function can also decide to terminate everything by calling [ngx.exit]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">local function my_cleanup()</span><br><span class="line">    -- custom cleanup work goes here, like cancelling a pending DB transaction</span><br><span class="line"></span><br><span class="line">    -- now abort all the &quot;light threads&quot; running in the current request handler</span><br><span class="line">    ngx.exit(499)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">local ok, err = ngx.on_abort(my_cleanup)</span><br><span class="line">if not ok then</span><br><span class="line">    ngx.log(ngx.ERR, &quot;failed to register the on_abort callback: &quot;, err)</span><br><span class="line">    ngx.exit(500)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>When [lua_check_client_abort]</p>
<p>According to the current implementation, this function can only be called once in a single request handler; subsequent calls will return the error message “duplicate call”.</p>
<p>This API was first introduced in the <code>v0.7.4</code> release.</p>
<p>See also [lua_check_client_abort]</p>
<h2><span id="ngxtimerat">ngx.timer.at</span></h2><p><strong>syntax:</strong> <em>hdl, err = ngx.timer.at(delay, callback, user_arg1, user_arg2, …)</em></p>
<p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p>Creates an Nginx timer with a user callback function as well as optional user arguments.</p>
<p>The first argument, <code>delay</code>, specifies the delay for the timer, in seconds. One can specify fractional seconds like <code>0.001</code> to mean 1 millisecond here. <code>0</code> delay can also be specified, in which case the timer will immediately expire when the current handler yields execution.</p>
<p>The second argument, <code>callback</code>, can be any Lua function, which will be invoked later in a background “light thread” after the delay specified. The user callback will be called automatically by the Nginx core with the arguments <code>premature</code>, <code>user_arg1</code>, <code>user_arg2</code>, and etc, where the <code>premature</code> argument takes a boolean value indicating whether it is a premature timer expiration or not, and <code>user_arg1</code>, <code>user_arg2</code>, and etc, are those (extra) user arguments specified when calling <code>ngx.timer.at</code>as the remaining arguments.</p>
<p>Premature timer expiration happens when the Nginx worker process is trying to shut down, as in an Nginx configuration reload triggered by the <code>HUP</code> signal or in an Nginx server shutdown. When the Nginx worker is trying to shut down, one can no longer call <code>ngx.timer.at</code> to create new timers with nonzero delays and in that case <code>ngx.timer.at</code> will return a “conditional false” value and a string describing the error, that is, “process exiting”.</p>
<p>Starting from the <code>v0.9.3</code> release, it is allowed to create zero-delay timers even when the Nginx worker process starts shutting down.</p>
<p>When a timer expires, the user Lua code in the timer callback is running in a “light thread” detached completely from the original request creating the timer. So objects with the same lifetime as the request creating them, like [cosockets]</p>
<p>Here is a simple example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    ...</span><br><span class="line">    log_by_lua_block &#123;</span><br><span class="line">        local function push_data(premature, uri, args, status)</span><br><span class="line">            -- push the data uri, args, and status to the remote</span><br><span class="line">            -- via ngx.socket.tcp or ngx.socket.udp</span><br><span class="line">            -- (one may want to buffer the data in Lua a bit to</span><br><span class="line">            -- save I/O operations)</span><br><span class="line">        end</span><br><span class="line">        local ok, err = ngx.timer.at(0, push_data,</span><br><span class="line">                                     ngx.var.uri, ngx.var.args, ngx.header.status)</span><br><span class="line">        if not ok then</span><br><span class="line">            ngx.log(ngx.ERR, &quot;failed to create timer: &quot;, err)</span><br><span class="line">            return</span><br><span class="line">        end</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>One can also create infinite re-occurring timers, for instance, a timer getting triggered every <code>5</code> seconds, by calling <code>ngx.timer.at</code> recursively in the timer callback function. Here is such an example,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">local delay = 5</span><br><span class="line">local handler</span><br><span class="line">handler = function (premature)</span><br><span class="line">    -- do some routine job in Lua just like a cron job</span><br><span class="line">    if premature then</span><br><span class="line">        return</span><br><span class="line">    end</span><br><span class="line">    local ok, err = ngx.timer.at(delay, handler)</span><br><span class="line">    if not ok then</span><br><span class="line">        ngx.log(ngx.ERR, &quot;failed to create the timer: &quot;, err)</span><br><span class="line">        return</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">local ok, err = ngx.timer.at(delay, handler)</span><br><span class="line">if not ok then</span><br><span class="line">    ngx.log(ngx.ERR, &quot;failed to create the timer: &quot;, err)</span><br><span class="line">    return</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>It is recommended, however, to use the [ngx.timer.every]</p>
<p>Because timer callbacks run in the background and their running time will not add to any client request’s response time, they can easily accumulate in the server and exhaust system resources due to either Lua programming mistakes or just too much client traffic. To prevent extreme consequences like crashing the Nginx server, there are built-in limitations on both the number of “pending timers” and the number of “running timers” in an Nginx worker process. The “pending timers” here mean timers that have not yet been expired and “running timers” are those whose user callbacks are currently running.</p>
<p>The maximal number of pending timers allowed in an Nginx worker is controlled by the [lua_max_pending_timers]</p>
<p>According to the current implementation, each “running timer” will take one (fake) connection record from the global connection record list configured by the standard <a href="http://nginx.org/en/docs/ngx_core_module.html#worker_connections" target="_blank" rel="noopener">worker_connections</a> directive in <code>nginx.conf</code>. So ensure that the<a href="http://nginx.org/en/docs/ngx_core_module.html#worker_connections" target="_blank" rel="noopener">worker_connections</a> directive is set to a large enough value that takes into account both the real connections and fake connections required by timer callbacks (as limited by the [lua_max_running_timers]</p>
<p>A lot of the Lua APIs for Nginx are enabled in the context of the timer callbacks, like stream/datagram cosockets ([ngx.socket.tcp]</p>
<p>You can pass most of the standard Lua values (nils, booleans, numbers, strings, tables, closures, file handles, and etc) into the timer callback, either explicitly as user arguments or implicitly as upvalues for the callback closure. There are several exceptions, however: you <em>cannot</em> pass any thread objects returned by [coroutine.create]</p>
<p>This API was first introduced in the <code>v0.8.0</code> release.</p>
<h2><span id="ngxtimerevery">ngx.timer.every</span></h2><p><strong>syntax:</strong> <em>hdl, err = ngx.timer.every(delay, callback, user_arg1, user_arg2, …)</em></p>
<p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p>Similar to the [ngx.timer.at]</p>
<ol>
<li><code>delay</code> <em>cannot</em> be zero,</li>
<li>timer will be created every <code>delay</code> seconds until the current Nginx worker process starts exiting.</li>
</ol>
<p>When success, returns a “conditional true” value (but not a <code>true</code>). Otherwise, returns a “conditional false” value and a string describing the error.</p>
<p>This API also respect the [lua_max_pending_timers]</p>
<p>This API was first introduced in the <code>v0.10.9</code> release.</p>
<h2><span id="ngxtimerrunning_count">ngx.timer.running_count</span></h2><p><strong>syntax:</strong> <em>count = ngx.timer.running_count()</em></p>
<p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p>Returns the number of timers currently running.</p>
<p>This directive was first introduced in the <code>v0.9.20</code> release.</p>
<h2><span id="ngxtimerpending_count">ngx.timer.pending_count</span></h2><p><strong>syntax:</strong> <em>count = ngx.timer.pending_count()</em></p>
<p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p>Returns the number of pending timers.</p>
<p>This directive was first introduced in the <code>v0.9.20</code> release.</p>
<h2><span id="ngxconfigsubsystem">ngx.config.subsystem</span></h2><p><strong>syntax:</strong> <em>subsystem = ngx.config.subsystem</em></p>
<p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_by_lua*, init_worker_by_lua*</p>
<p>This string field indicates the current NGINX subsystem the current Lua environment is based on. For this module, this field always takes the string value <code>&quot;http&quot;</code>. For [ngx_stream_lua_module]</p>
<p>This field was first introduced in the <code>0.10.1</code>.</p>
<h2><span id="ngxconfigdebug">ngx.config.debug</span></h2><p><strong>syntax:</strong> <em>debug = ngx.config.debug</em></p>
<p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_by_lua*, init_worker_by_lua*</p>
<p>This boolean field indicates whether the current Nginx is a debug build, i.e., being built by the <code>./configure</code> option <code>--with-debug</code>.</p>
<p>This field was first introduced in the <code>0.8.7</code>.</p>
<h2><span id="ngxconfigprefix">ngx.config.prefix</span></h2><p><strong>syntax:</strong> <em>prefix = ngx.config.prefix()</em></p>
<p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_by_lua*, init_worker_by_lua*</p>
<p>Returns the Nginx server “prefix” path, as determined by the <code>-p</code> command-line option when running the nginx executable, or the path specified by the <code>--prefix</code> command-line option when building Nginx with the <code>./configure</code> script.</p>
<p>This function was first introduced in the <code>0.9.2</code>.</p>
<h2><span id="ngxconfignginx_version">ngx.config.nginx_version</span></h2><p><strong>syntax:</strong> <em>ver = ngx.config.nginx_version</em></p>
<p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_by_lua*, init_worker_by_lua*</p>
<p>This field take an integral value indicating the version number of the current Nginx core being used. For example, the version number <code>1.4.3</code> results in the Lua number 1004003.</p>
<p>This API was first introduced in the <code>0.9.3</code> release.</p>
<h2><span id="ngxconfignginx_configure">ngx.config.nginx_configure</span></h2><p><strong>syntax:</strong> <em>str = ngx.config.nginx_configure()</em></p>
<p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_by_lua*</p>
<p>This function returns a string for the NGINX <code>./configure</code> command’s arguments string.</p>
<p>This API was first introduced in the <code>0.9.5</code> release.</p>
<h2><span id="ngxconfigngx_lua_version">ngx.config.ngx_lua_version</span></h2><p><strong>syntax:</strong> <em>ver = ngx.config.ngx_lua_version</em></p>
<p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_by_lua*</p>
<p>This field take an integral value indicating the version number of the current <code>ngx_lua</code> module being used. For example, the version number <code>0.9.3</code> results in the Lua number 9003.</p>
<p>This API was first introduced in the <code>0.9.3</code> release.</p>
<h2><span id="ngxworkerexiting">ngx.worker.exiting</span></h2><p><strong>syntax:</strong> <em>exiting = ngx.worker.exiting()</em></p>
<p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_by_lua*, init_worker_by_lua*</p>
<p>This function returns a boolean value indicating whether the current Nginx worker process already starts exiting. Nginx worker process exiting happens on Nginx server quit or configuration reload (aka HUP reload).</p>
<p>This API was first introduced in the <code>0.9.3</code> release.</p>
<h2><span id="ngxworkerpid">ngx.worker.pid</span></h2><p><strong>syntax:</strong> <em>pid = ngx.worker.pid()</em></p>
<p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_by_lua*, init_worker_by_lua*</p>
<p>This function returns a Lua number for the process ID (PID) of the current Nginx worker process. This API is more efficient than <code>ngx.var.pid</code> and can be used in contexts where the [ngx.var.VARIABLE]</p>
<p>This API was first introduced in the <code>0.9.5</code> release.</p>
<h2><span id="ngxworkercount">ngx.worker.count</span></h2><p><strong>syntax:</strong> <em>count = ngx.worker.count()</em></p>
<p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_by_lua*, init_worker_by_lua*</p>
<p>Returns the total number of the Nginx worker processes (i.e., the value configured by the <a href="http://nginx.org/en/docs/ngx_core_module.html#worker_processes" target="_blank" rel="noopener">worker_processes</a> directive in <code>nginx.conf</code>).</p>
<p>This API was first introduced in the <code>0.9.20</code> release.</p>
<h2><span id="ngxworkerid">ngx.worker.id</span></h2><p><strong>syntax:</strong> <em>count = ngx.worker.id()</em></p>
<p><strong>context:</strong> set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_worker_by_lua*</p>
<p>Returns the ordinal number of the current Nginx worker processes (starting from number 0).</p>
<p>So if the total number of workers is <code>N</code>, then this method may return a number between 0 and <code>N - 1</code> (inclusive).</p>
<p>This function returns meaningful values only for NGINX 1.9.1+. With earlier versions of NGINX, it always returns <code>nil</code>.</p>
<p>See also [ngx.worker.count]</p>
<p>This API was first introduced in the <code>0.9.20</code> release.</p>
<h2><span id="ngxsemaphore">ngx.semaphore</span></h2><p><strong>syntax:</strong> <em>local semaphore = require “ngx.semaphore”</em></p>
<p>This is a Lua module that implements a classic-style semaphore API for efficient synchronizations among different “light threads”. Sharing the same semaphore among different “light threads” created in different (request) contexts are also supported as long as the “light threads” reside in the same NGINX worker process and the [lua_code_cache]</p>
<p>This Lua module does not ship with this ngx_lua module itself rather it is shipped with the [lua-resty-core]</p>
<p>Please refer to the [documentation]</p>
<p>This feature requires at least ngx_lua <code>v0.10.0</code>.</p>
<h2><span id="ngxbalancer">ngx.balancer</span></h2><p><strong>syntax:</strong> <em>local balancer = require “ngx.balancer”</em></p>
<p>This is a Lua module that provides a Lua API to allow defining completely dynamic load balancers in pure Lua.</p>
<p>This Lua module does not ship with this ngx_lua module itself rather it is shipped with the [lua-resty-core]</p>
<p>Please refer to the [documentation]</p>
<p>This feature requires at least ngx_lua <code>v0.10.0</code>.</p>
<h2><span id="ngxssl">ngx.ssl</span></h2><p><strong>syntax:</strong> <em>local ssl = require “ngx.ssl”</em></p>
<p>This Lua module provides API functions to control the SSL handshake process in contexts like [ssl_certificate_by_lua*]</p>
<p>This Lua module does not ship with this ngx_lua module itself rather it is shipped with the [lua-resty-core]</p>
<p>Please refer to the [documentation]</p>
<p>This feature requires at least ngx_lua <code>v0.10.0</code>.</p>
<h2><span id="ngxocsp">ngx.ocsp</span></h2><p><strong>syntax:</strong> <em>local ocsp = require “ngx.ocsp”</em></p>
<p>This Lua module provides API to perform OCSP queries, OCSP response validations, and OCSP stapling planting.</p>
<p>Usually, this module is used together with the [ngx.ssl]</p>
<p>This Lua module does not ship with this ngx_lua module itself rather it is shipped with the [lua-resty-core]</p>
<p>Please refer to the [documentation]</p>
<p>This feature requires at least ngx_lua <code>v0.10.0</code>.</p>
<h2><span id="ndkset_vardirective">ndk.set_var.DIRECTIVE</span></h2><p><strong>syntax:</strong> <em>res = ndk.set_var.DIRECTIVE_NAME</em></p>
<p><strong>context:</strong> init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p>This mechanism allows calling other nginx C modules’ directives that are implemented by [Nginx Devel Kit]</p>
<p>For example, the following <a href="http://github.com/openresty/set-misc-nginx-module" target="_blank" rel="noopener">set-misc-nginx-module</a> directives can be invoked this way:</p>
<ul>
<li><a href="http://github.com/openresty/set-misc-nginx-module#set_quote_sql_str" target="_blank" rel="noopener">set_quote_sql_str</a></li>
<li><a href="http://github.com/openresty/set-misc-nginx-module#set_quote_pgsql_str" target="_blank" rel="noopener">set_quote_pgsql_str</a></li>
<li><a href="http://github.com/openresty/set-misc-nginx-module#set_quote_json_str" target="_blank" rel="noopener">set_quote_json_str</a></li>
<li><a href="http://github.com/openresty/set-misc-nginx-module#set_unescape_uri" target="_blank" rel="noopener">set_unescape_uri</a></li>
<li><a href="http://github.com/openresty/set-misc-nginx-module#set_escape_uri" target="_blank" rel="noopener">set_escape_uri</a></li>
<li><a href="http://github.com/openresty/set-misc-nginx-module#set_encode_base32" target="_blank" rel="noopener">set_encode_base32</a></li>
<li><a href="http://github.com/openresty/set-misc-nginx-module#set_decode_base32" target="_blank" rel="noopener">set_decode_base32</a></li>
<li><a href="http://github.com/openresty/set-misc-nginx-module#set_encode_base64" target="_blank" rel="noopener">set_encode_base64</a></li>
<li><a href="http://github.com/openresty/set-misc-nginx-module#set_decode_base64" target="_blank" rel="noopener">set_decode_base64</a></li>
<li><a href="http://github.com/openresty/set-misc-nginx-module#set_encode_base64" target="_blank" rel="noopener">set_encode_hex</a></li>
<li><a href="http://github.com/openresty/set-misc-nginx-module#set_decode_base64" target="_blank" rel="noopener">set_decode_hex</a></li>
<li><a href="http://github.com/openresty/set-misc-nginx-module#set_encode_base64" target="_blank" rel="noopener">set_sha1</a></li>
<li><a href="http://github.com/openresty/set-misc-nginx-module#set_decode_base64" target="_blank" rel="noopener">set_md5</a></li>
</ul>
<p>For instance,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local res = ndk.set_var.set_escape_uri(&apos;a/b&apos;);</span><br><span class="line">-- now res == &apos;a%2fb&apos;</span><br></pre></td></tr></table></figure>
<p>Similarly, the following directives provided by <a href="http://github.com/openresty/encrypted-session-nginx-module" target="_blank" rel="noopener">encrypted-session-nginx-module</a> can be invoked from within Lua too:</p>
<ul>
<li><a href="http://github.com/openresty/encrypted-session-nginx-module#set_encrypt_session" target="_blank" rel="noopener">set_encrypt_session</a></li>
<li><a href="http://github.com/openresty/encrypted-session-nginx-module#set_decrypt_session" target="_blank" rel="noopener">set_decrypt_session</a></li>
</ul>
<p>This feature requires the [ngx_devel_kit]</p>
<h2><span id="coroutinecreate">coroutine.create</span></h2><p><strong>syntax:</strong> <em>co = coroutine.create(f)</em></p>
<p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, init_by_lua*, ngx.timer.*, header_filter_by_lua*, body_filter_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p>Creates a user Lua coroutines with a Lua function, and returns a coroutine object.</p>
<p>Similar to the standard Lua <a href="http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.create" target="_blank" rel="noopener">coroutine.create</a> API, but works in the context of the Lua coroutines created by ngx_lua.</p>
<p>This API was first usable in the context of [init_by_lua*]</p>
<p>This API was first introduced in the <code>v0.6.0</code> release.</p>
<h2><span id="coroutineresume">coroutine.resume</span></h2><p><strong>syntax:</strong> <em>ok, … = coroutine.resume(co, …)</em></p>
<p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, init_by_lua*, ngx.timer.*, header_filter_by_lua*, body_filter_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p>Resumes the executation of a user Lua coroutine object previously yielded or just created.</p>
<p>Similar to the standard Lua <a href="http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.resume" target="_blank" rel="noopener">coroutine.resume</a> API, but works in the context of the Lua coroutines created by ngx_lua.</p>
<p>This API was first usable in the context of [init_by_lua*]</p>
<p>This API was first introduced in the <code>v0.6.0</code> release.</p>
<h2><span id="coroutineyield">coroutine.yield</span></h2><p><strong>syntax:</strong> <em>… = coroutine.yield(…)</em></p>
<p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, init_by_lua*, ngx.timer.*, header_filter_by_lua*, body_filter_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p>Yields the execution of the current user Lua coroutine.</p>
<p>Similar to the standard Lua <a href="http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.yield" target="_blank" rel="noopener">coroutine.yield</a> API, but works in the context of the Lua coroutines created by ngx_lua.</p>
<p>This API was first usable in the context of [init_by_lua*]</p>
<p>This API was first introduced in the <code>v0.6.0</code> release.</p>
<h2><span id="coroutinewrap">coroutine.wrap</span></h2><p><strong>syntax:</strong> <em>co = coroutine.wrap(f)</em></p>
<p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, init_by_lua*, ngx.timer.*, header_filter_by_lua*, body_filter_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p>Similar to the standard Lua <a href="http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.wrap" target="_blank" rel="noopener">coroutine.wrap</a> API, but works in the context of the Lua coroutines created by ngx_lua.</p>
<p>This API was first usable in the context of [init_by_lua*]</p>
<p>This API was first introduced in the <code>v0.6.0</code> release.</p>
<h2><span id="coroutinerunning">coroutine.running</span></h2><p><strong>syntax:</strong> <em>co = coroutine.running()</em></p>
<p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, init_by_lua*, ngx.timer.*, header_filter_by_lua*, body_filter_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p>Identical to the standard Lua <a href="http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.running" target="_blank" rel="noopener">coroutine.running</a> API.</p>
<p>This API was first usable in the context of [init_by_lua*]</p>
<p>This API was first enabled in the <code>v0.6.0</code> release.</p>
<h2><span id="coroutinestatus">coroutine.status</span></h2><p><strong>syntax:</strong> <em>status = coroutine.status(co)</em></p>
<p><strong>context:</strong> rewrite_by_lua*, access_by_lua*, content_by_lua*, init_by_lua*, ngx.timer.*, header_filter_by_lua*, body_filter_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</p>
<p>Identical to the standard Lua <a href="http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.status" target="_blank" rel="noopener">coroutine.status</a> API.</p>
<p>This API was first usable in the context of [init_by_lua*]</p>
<p>This API was first enabled in the <code>v0.6.0</code> release.</p>
<p>##</p>

                </div>
            </div>
    
            <nav class="post-pagination">
    
    <a class="newer-posts" href="/2018/03/01/Nginx-Lua-Directives/">
        上一篇<br>Nginx-Lua-Directives
    </a>
    
    <span class="page-number"></span>
    
    <a class="older-posts" href="/2018/02/28/Nginx-Lua-OpenResty/">
        下一篇<br>Nginx+Lua=OpenResty
    </a>
    
</nav>

    
            


        </div>
    </div>
    <div class="single-column-footer">
    Proudly published with Hexo<br>
    
    Theme <a href="https://github.com/SumiMakito/hexo-theme-journal/" target="_blank" rel="noreferrer noopener">Journal.</a> by <a href="https://mak1t0.cc/" target="_blank" rel="noreferrer noopener">Makito</a><br>
    
    &copy; 2018 <a href="http://yoursite.com">javfa&#39;s blog</a>
</div>
</div>

</div>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.14.4/dist/umd/popper.min.js" integrity="sha256-EGs9T1xMHdvM1geM8jPpoo8EZ1V1VRsmcJz8OByENLA=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.1.3/dist/js/bootstrap.min.js" integrity="sha256-VsEqElsCHSGmnmHXGQzvoWjWwoznFSZc6hs7ARLRacQ=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.min.js" integrity="sha256-FtWfRI+thWlNz2sB3SJbwKx5PgMyKIVgwHCTwa3biXc=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/smooth-scroll@14.2.1/dist/smooth-scroll.polyfills.min.js" integrity="sha256-CI4Gq5E0io1Pv0xM3qPM+NUIOhbIBvC3GiN1Y4KhXpw=" crossorigin="anonymous"></script>
<script src="/js/journal.js?90669860"></script>



</body>
</html>
