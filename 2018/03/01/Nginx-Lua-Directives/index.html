

<!DOCTYPE html>
<html lang xmlns:v-bind="http://www.w3.org/1999/xhtml">

<head><meta name="generator" content="Hexo 3.8.0">
    <title>Nginx-Lua-Directives - javfa&#39;s blog</title>
<meta charset="utf-8">
<meta name="X-UA-Compatible" content="IE=edge">
<meta name="author" content="Javfa">
<meta name="description" content="

Nginx Directives For Lua
lua_capture_error_log
lua_use_...">
<meta name="keywords" content>

    <meta charset="utf-8">
    <meta name="X-UA-Compatible" content="IE=edge">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <meta content="telephone=no" name="format-detection">
    <meta name="renderer" content="webkit">
    <meta name="theme-color" content="#ffffff">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.1.3/dist/css/bootstrap.min.css" integrity="sha256-eSi1q2PG6J7g7ib17yAaWMcrr5GrtohYChqibrV7PBE=" crossorigin="anonymous">
<link rel="stylesheet" href="/css/journal.css?87838444">
<script src="/js/loadCSS.js"></script>
<script>
    loadCSS("https://fonts.googleapis.com/css?family=Lora|Montserrat|Fira+Mono|Material+Icons");
    (function (d) {
        var config = {
                kitId: 'dwg1tuc',
                scriptTimeout: 3000,
                async: true
            },
            h = d.documentElement, t = setTimeout(function () {
                h.className = h.className.replace(/\bwf-loading\b/g, "") + " wf-inactive";
            }, config.scriptTimeout), tk = d.createElement("script"), f = false,
            s = d.getElementsByTagName("script")[0], a;
        h.className += " wf-loading";
        tk.src = 'https://use.typekit.net/' + config.kitId + '.js';
        tk.async = true;
        tk.onload = tk.onreadystatechange = function () {
            a = this.readyState;
            if (f || a && a != "complete" && a != "loaded") return;
            f = true;
            clearTimeout(t);
            try {
                Typekit.load(config)
            } catch (e) {
            }
        };
        s.parentNode.insertBefore(tk, s)
    })(document);
</script>
<noscript>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora|Montserrat|Anonymous+Pro:400|Material+Icons">
</noscript>
</head>
<body>
<div id="top"></div>
<div id="app">
<div class="single-column-drawer-container" ref="drawer" v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }">
    <div class="drawer-content">
        <div class="drawer-menu">
            <a class="a-block drawer-menu-item false" href="http://yoursite.com">
                ホーム
            </a>
            <a class="a-block drawer-menu-item false" href="/archives">
                記事一覧
            </a>

            
            

            
        </div>
    </div>
</div>
<transition name="fade">
    <div v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if="isDrawerOpen" v-on:click="toggleDrawer"></div>
</transition>
<nav ref="navBar" class="navbar sticky-top navbar-light single-column-nav-container">
    <div ref="navBackground" class="nav-background"></div>
    <div class="container container-narrow nav-content">
        <button id="nav_dropdown_btn" class="nav-dropdown-toggle" type="button" v-on:click="toggleDrawer">
            <i class="material-icons">
                menu
            </i>
        </button>
        <a ref="navTitle" class="navbar-brand" href="/">
            javfa&#39;s blog
        </a>
    </div>
</nav>
<div class="single-column-header-container" ref="pageHead" v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }">
    <a href="/">
        <div class="single-column-header-title">javfa&#39;s blog</div>
        <div class="single-column-header-subtitle"></div>
    </a>
</div>
<div ref="sideContainer" class="side-container">
    <a class="a-block nav-head false" href="/">
        <div class="nav-title">
            {博客@家發}
        </div>
        <div class="nav-subtitle">
            隻言片語<br>於此匯聚
        </div>
    </a>

    <div class="nav-link-list">
        <a class="a-block no-tint nav-link-item false" href="/archives">
            記事一覧
        </a>

        
        

        
    </div>

    
    <div class="nav-footer">
        Proudly published with Hexo<br>
        
        Theme <a href="https://github.com/SumiMakito/hexo-theme-journal/" target="_blank" rel="noreferrer noopener">Journal.</a> by <a href="https://mak1t0.cc/" target="_blank" rel="noreferrer noopener">Makito</a><br>
        
        &copy; 2019 <a href="http://yoursite.com">javfa&#39;s blog</a>
    </div>
</div>
<div ref="extraContainer" class="extra-container">
    <div class="pagination">
        <a id="globalBackToTop" class="pagination-action animated-visibility" href="#top" :class="{ invisible: scrollY == 0 }">
            <i class="material-icons pagination-action-icon">
                keyboard_arrow_up
            </i>
        </a>

        
    </div>
</div>

<div ref="streamContainer" class="stream-container">
    <div class="post-list-container post-list-container-shadow">
        <div class="post">
            <div class="post-head-wrapper-text-only" style="background-image: url('')">
                <div class="post-title">
                    Nginx-Lua-Directives
                    <div class="post-meta">
                        <time datetime="2018-03-01T04:44:13.000Z" itemprop="datePublished">
                            2018-03-01 12:44
                        </time>&nbsp;
                        
    
                        
                        
                        <i class="material-icons" style>label</i>
                        
                        <a href="/tags/Nginx/">Nginx</a>
                        
                        
                    </div>
                </div>
            </div>
    
            <div class="post-body-wrapper">
                <div class="post-body">
                    <!-- toc -->
<ul>
<li><a href="#nginx-directives-for-lua">Nginx Directives For Lua</a><ul>
<li><a href="#lua_capture_error_log">lua_capture_error_log</a></li>
<li><a href="#lua_use_default_type">lua_use_default_type</a></li>
<li><a href="#lua_malloc_trim">lua_malloc_trim</a></li>
<li><a href="#lua_code_cache">lua_code_cache</a></li>
<li><a href="#lua_regex_cache_max_entries">lua_regex_cache_max_entries</a></li>
<li><a href="#lua_regex_match_limit">lua_regex_match_limit</a></li>
<li><a href="#lua_package_path">lua_package_path</a></li>
<li><a href="#lua_package_cpath">lua_package_cpath</a></li>
<li><a href="#init_by_lua">init_by_lua</a></li>
<li><a href="#init_by_lua_block">init_by_lua_block</a></li>
<li><a href="#init_by_lua_file">init_by_lua_file</a></li>
<li><a href="#init_worker_by_lua">init_worker_by_lua</a></li>
<li><a href="#init_worker_by_lua_block">init_worker_by_lua_block</a></li>
<li><a href="#init_worker_by_lua_file">init_worker_by_lua_file</a></li>
<li><a href="#set_by_lua">set_by_lua</a></li>
<li><a href="#set_by_lua_block">set_by_lua_block</a></li>
<li><a href="#set_by_lua_file">set_by_lua_file</a></li>
<li><a href="#content_by_lua">content_by_lua</a></li>
<li><a href="#content_by_lua_block">content_by_lua_block</a></li>
<li><a href="#content_by_lua_file">content_by_lua_file</a></li>
<li><a href="#rewrite_by_lua">rewrite_by_lua</a></li>
<li><a href="#rewrite_by_lua_block">rewrite_by_lua_block</a></li>
<li><a href="#rewrite_by_lua_file">rewrite_by_lua_file</a></li>
<li><a href="#access_by_lua">access_by_lua</a></li>
<li><a href="#access_by_lua_block">access_by_lua_block</a></li>
<li><a href="#access_by_lua_file">access_by_lua_file</a></li>
<li><a href="#header_filter_by_lua">header_filter_by_lua</a></li>
<li><a href="#header_filter_by_lua_block">header_filter_by_lua_block</a></li>
<li><a href="#header_filter_by_lua_file">header_filter_by_lua_file</a></li>
<li><a href="#body_filter_by_lua">body_filter_by_lua</a></li>
<li><a href="#body_filter_by_lua_block">body_filter_by_lua_block</a></li>
<li><a href="#body_filter_by_lua_file">body_filter_by_lua_file</a></li>
<li><a href="#log_by_lua">log_by_lua</a></li>
<li><a href="#log_by_lua_block">log_by_lua_block</a></li>
<li><a href="#log_by_lua_file">log_by_lua_file</a></li>
<li><a href="#balancer_by_lua_block">balancer_by_lua_block</a></li>
<li><a href="#balancer_by_lua_file">balancer_by_lua_file</a></li>
<li><a href="#lua_need_request_body">lua_need_request_body</a></li>
<li><a href="#ssl_certificate_by_lua_block">ssl_certificate_by_lua_block</a></li>
<li><a href="#ssl_certificate_by_lua_file">ssl_certificate_by_lua_file</a></li>
<li><a href="#ssl_session_fetch_by_lua_block">ssl_session_fetch_by_lua_block</a></li>
<li><a href="#ssl_session_fetch_by_lua_file">ssl_session_fetch_by_lua_file</a></li>
<li><a href="#ssl_session_store_by_lua_block">ssl_session_store_by_lua_block</a></li>
<li><a href="#ssl_session_store_by_lua_file">ssl_session_store_by_lua_file</a></li>
<li><a href="#lua_shared_dict">lua_shared_dict</a></li>
<li><a href="#lua_socket_connect_timeout">lua_socket_connect_timeout</a></li>
<li><a href="#lua_socket_send_timeout">lua_socket_send_timeout</a></li>
<li><a href="#lua_socket_send_lowat">lua_socket_send_lowat</a></li>
<li><a href="#lua_socket_read_timeout">lua_socket_read_timeout</a></li>
<li><a href="#lua_socket_buffer_size">lua_socket_buffer_size</a></li>
<li><a href="#lua_socket_pool_size">lua_socket_pool_size</a></li>
<li><a href="#lua_socket_keepalive_timeout">lua_socket_keepalive_timeout</a></li>
<li><a href="#lua_socket_log_errors">lua_socket_log_errors</a></li>
<li><a href="#lua_ssl_ciphers">lua_ssl_ciphers</a></li>
<li><a href="#lua_ssl_crl">lua_ssl_crl</a></li>
<li><a href="#lua_ssl_protocols">lua_ssl_protocols</a></li>
<li><a href="#lua_ssl_trusted_certificate">lua_ssl_trusted_certificate</a></li>
<li><a href="#lua_ssl_verify_depth">lua_ssl_verify_depth</a></li>
<li><a href="#lua_http10_buffering">lua_http10_buffering</a></li>
<li><a href="#rewrite_by_lua_no_postpone">rewrite_by_lua_no_postpone</a></li>
<li><a href="#access_by_lua_no_postpone">access_by_lua_no_postpone</a></li>
<li><a href="#lua_transform_underscores_in_response_headers">lua_transform_underscores_in_response_headers</a></li>
<li><a href="#lua_check_client_abort">lua_check_client_abort</a></li>
<li><a href="#lua_max_pending_timers">lua_max_pending_timers</a></li>
<li><a href="#lua_max_running_timers">lua_max_running_timers</a></li>
<li><a href="#lua_sa_restart">lua_sa_restart</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h1><span id="nginx-directives-for-lua">Nginx Directives For Lua</span></h1><p>The basic building blocks of scripting Nginx with Lua are directives. Directives are used to specify when the user Lua code is run and how the result will be used. Below is a diagram showing the order in which directives are executed.</p>
<p><a href="https://cloud.githubusercontent.com/assets/2137369/15272097/77d1c09e-1a37-11e6-97ef-d9767035fc3e.png" target="_blank" rel="noopener"><img src="https://cloud.githubusercontent.com/assets/2137369/15272097/77d1c09e-1a37-11e6-97ef-d9767035fc3e.png" alt="Lua Nginx Modules Directives"></a></p>
<h2><span id="lua_capture_error_log">lua_capture_error_log</span></h2><p><strong>syntax:</strong> <em>lua_capture_error_log size</em></p>
<p><strong>default:</strong> <em>none</em></p>
<p><strong>context:</strong> <em>http</em></p>
<p>Enables a buffer of the specified <code>size</code> for capturing all the nginx error log message data (not just those produced by this module or the nginx http subsystem, but everything) without touching files or disks.</p>
<p>You can use units like <code>k</code> and <code>m</code> in the <code>size</code> value, as in</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lua_capture_error_log 100k;</span><br></pre></td></tr></table></figure>
<p>As a rule of thumb, a 4KB buffer can usually hold about 20 typical error log messages. So do the maths!</p>
<p>This buffer never grows. If it is full, new error log messages will replace the oldest ones in the buffer.</p>
<p>The size of the buffer must be bigger than the maximum length of a single error log message (which is 4K in OpenResty and 2K in stock NGINX).</p>
<p>You can read the messages in the buffer on the Lua land via the <a href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/errlog.md#get_logs" target="_blank" rel="noopener">get_logs()</a> function of the <a href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/errlog.md#readme" target="_blank" rel="noopener">ngx.errlog</a> module of the <a href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/errlog.md#readme" target="_blank" rel="noopener">lua-resty-core</a> library. This Lua API function will return the captured error log messages and also remove these already read from the global capturing buffer, making room for any new error log data. For this reason, the user should not configure this buffer to be too big if the user read the buffered error log data fast enough.</p>
<p>Note that the log level specified in the standard <a href="http://nginx.org/r/error_log" target="_blank" rel="noopener">error_log</a> directive <em>does</em> have effect on this capturing facility. It only captures log messages of a level no lower than the specified log level in the <a href="http://nginx.org/r/error_log" target="_blank" rel="noopener">error_log</a> directive. The user can still choose to set an even higher filtering log level on the fly via the Lua API function <a href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/errlog.md#set_filter_level" target="_blank" rel="noopener">errlog.set_filter_level</a>. So it is more flexible than the static <a href="http://nginx.org/r/error_log" target="_blank" rel="noopener">error_log</a>directive.</p>
<p>It is worth noting that there is no way to capture the debugging logs without building OpenResty or NGINX with the <code>./configure</code> option <code>--with-debug</code>. And enabling debugging logs is strongly discouraged in production builds due to high overhead.</p>
<p>This directive was first introduced in the <code>v0.10.9</code> release.</p>
<h2><span id="lua_use_default_type">lua_use_default_type</span></h2><p><strong>syntax:</strong> <em>lua_use_default_type on | off</em></p>
<p><strong>default:</strong> <em>lua_use_default_type on</em></p>
<p><strong>context:</strong> <em>http, server, location, location if</em></p>
<p>Specifies whether to use the MIME type specified by the <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#default_type" target="_blank" rel="noopener">default_type</a> directive for the default value of the <code>Content-Type</code>response header. Deactivate this directive if a default <code>Content-Type</code> response header for Lua request handlers is not desired.</p>
<p>This directive is turned on by default.</p>
<p>This directive was first introduced in the <code>v0.9.1</code> release.</p>
<h2><span id="lua_malloc_trim">lua_malloc_trim</span></h2><p><strong>syntax:</strong> <em>lua_malloc_trim <request-count></request-count></em></p>
<p><strong>default:</strong> <em>lua_malloc_trim 1000</em></p>
<p><strong>context:</strong> <em>http</em></p>
<p>Asks the underlying <code>libc</code> runtime library to release its cached free memory back to the operating system every <code>N</code> requests processed by the NGINX core. By default, <code>N</code> is 1000. You can configure the request count by using your own numbers. Smaller numbers mean more frequent releases, which may introduce higher CPU time consumption and smaller memory footprint while larger numbers usually lead to less CPU time overhead and relatively larger memory footprint. Just tune the number for your own use cases.</p>
<p>Configuring the argument to <code>0</code> essentially turns off the periodical memory trimming altogether.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lua_malloc_trim 0;  # turn off trimming completely</span><br></pre></td></tr></table></figure>
<p>The current implementation uses an NGINX log phase handler to do the request counting. So the appearance of the<a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#log_subrequest" target="_blank" rel="noopener">log_subrequest on</a> directives in <code>nginx.conf</code> may make the counting faster when subrequests are involved. By default, only “main requests” count.</p>
<p>Note that this directive does <em>not</em> affect the memory allocated by LuaJIT’s own allocator based on the <code>mmap</code> system call.</p>
<p>This directive was first introduced in the <code>v0.10.7</code> release.</p>
<h2><span id="lua_code_cache">lua_code_cache</span></h2><p><strong>syntax:</strong> <em>lua_code_cache on | off</em></p>
<p><strong>default:</strong> <em>lua_code_cache on</em></p>
<p><strong>context:</strong> <em>http, server, location, location if</em></p>
<p>Enables or disables the Lua code cache for Lua code in <code>*_by_lua_file</code> directives (like <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#set_by_lua_file" target="_blank" rel="noopener">set_by_lua_file</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#content_by_lua_file" target="_blank" rel="noopener">content_by_lua_file</a>) and Lua modules.</p>
<p>When turning off, every request served by ngx_lua will run in a separate Lua VM instance, starting from the <code>0.9.3</code> release. So the Lua files referenced in <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#set_by_lua_file" target="_blank" rel="noopener">set_by_lua_file</a>, <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#content_by_lua_file" target="_blank" rel="noopener">content_by_lua_file</a>, <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#access_by_lua_file" target="_blank" rel="noopener">access_by_lua_file</a>, and etc will not be cached and all Lua modules used will be loaded from scratch. With this in place, developers can adopt an edit-and-refresh approach.</p>
<p>Please note however, that Lua code written inlined within nginx.conf such as those specified by <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#set_by_lua" target="_blank" rel="noopener">set_by_lua</a>, <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#content_by_lua" target="_blank" rel="noopener">content_by_lua</a>,<a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#access_by_lua" target="_blank" rel="noopener">access_by_lua</a>, and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#rewrite_by_lua" target="_blank" rel="noopener">rewrite_by_lua</a> will not be updated when you edit the inlined Lua code in your <code>nginx.conf</code> file because only the Nginx config file parser can correctly parse the <code>nginx.conf</code> file and the only way is to reload the config file by sending a <code>HUP</code> signal or just to restart Nginx.</p>
<p>Even when the code cache is enabled, Lua files which are loaded by <code>dofile</code> or <code>loadfile</code> in *_by_lua_file cannot be cached (unless you cache the results yourself). Usually you can either use the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#init_by_lua" target="_blank" rel="noopener">init_by_lua</a> or <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#init-by_lua_file" target="_blank" rel="noopener">init_by_lua_file</a> directives to load all such files or just make these Lua files true Lua modules and load them via <code>require</code>.</p>
<p>The ngx_lua module does not support the <code>stat</code> mode available with the Apache <code>mod_lua</code> module (yet).</p>
<p>Disabling the Lua code cache is strongly discouraged for production use and should only be used during development as it has a significant negative impact on overall performance. For example, the performance of a “hello world” Lua example can drop by an order of magnitude after disabling the Lua code cache.</p>
<h2><span id="lua_regex_cache_max_entries">lua_regex_cache_max_entries</span></h2><p><strong>syntax:</strong> <em>lua_regex_cache_max_entries <num></num></em></p>
<p><strong>default:</strong> <em>lua_regex_cache_max_entries 1024</em></p>
<p><strong>context:</strong> <em>http</em></p>
<p>Specifies the maximum number of entries allowed in the worker process level compiled regex cache.</p>
<p>The regular expressions used in <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxrematch" target="_blank" rel="noopener">ngx.re.match</a>, <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxregmatch" target="_blank" rel="noopener">ngx.re.gmatch</a>, <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxresub" target="_blank" rel="noopener">ngx.re.sub</a>, and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxregsub" target="_blank" rel="noopener">ngx.re.gsub</a> will be cached within this cache if the regex option <code>o</code> (i.e., compile-once flag) is specified.</p>
<p>The default number of entries allowed is 1024 and when this limit is reached, new regular expressions will not be cached (as if the <code>o</code> option was not specified) and there will be one, and only one, warning in the <code>error.log</code> file:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2011/08/27 23:18:26 [warn] 31997#0: *1 lua exceeding regex cache max entries (1024), ...</span><br></pre></td></tr></table></figure>
<p>If you are using the <code>ngx.re.*</code> implementation of <a href="https://github.com/openresty/lua-resty-core" target="_blank" rel="noopener">lua-resty-core</a> by loading the <code>resty.core.regex</code> module (or just the <code>resty.core</code> module), then an LRU cache is used for the regex cache being used here.</p>
<p>Do not activate the <code>o</code> option for regular expressions (and/or <code>replace</code> string arguments for <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxresub" target="_blank" rel="noopener">ngx.re.sub</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxregsub" target="_blank" rel="noopener">ngx.re.gsub</a>) that are generated <em>on the fly</em> and give rise to infinite variations to avoid hitting the specified limit.</p>
<h2><span id="lua_regex_match_limit">lua_regex_match_limit</span></h2><p><strong>syntax:</strong> <em>lua_regex_match_limit <num></num></em></p>
<p><strong>default:</strong> <em>lua_regex_match_limit 0</em></p>
<p><strong>context:</strong> <em>http</em></p>
<p>Specifies the “match limit” used by the PCRE library when executing the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxrematch" target="_blank" rel="noopener">ngx.re API</a>. To quote the PCRE manpage, “the limit … has the effect of limiting the amount of backtracking that can take place.”</p>
<p>When the limit is hit, the error string “pcre_exec() failed: -8” will be returned by the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxrematch" target="_blank" rel="noopener">ngx.re API</a> functions on the Lua land.</p>
<p>When setting the limit to 0, the default “match limit” when compiling the PCRE library is used. And this is the default value of this directive.</p>
<p>This directive was first introduced in the <code>v0.8.5</code> release.</p>
<h2><span id="lua_package_path">lua_package_path</span></h2><p><strong>syntax:</strong> <em>lua_package_path <lua-style-path-str></lua-style-path-str></em></p>
<p><strong>default:</strong> <em>The content of LUA_PATH environment variable or Lua’s compiled-in defaults.</em></p>
<p><strong>context:</strong> <em>http</em></p>
<p>Sets the Lua module search path used by scripts specified by <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#set_by_lua" target="_blank" rel="noopener">set_by_lua</a>, <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#content_by_lua" target="_blank" rel="noopener">content_by_lua</a> and others. The path string is in standard Lua path form, and <code>;;</code> can be used to stand for the original search paths.</p>
<p>As from the <code>v0.5.0rc29</code> release, the special notation <code>$prefix</code> or <code>${prefix}</code> can be used in the search path string to indicate the path of the <code>server prefix</code> usually determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p>
<h2><span id="lua_package_cpath">lua_package_cpath</span></h2><p><strong>syntax:</strong> <em>lua_package_cpath <lua-style-cpath-str></lua-style-cpath-str></em></p>
<p><strong>default:</strong> <em>The content of LUA_CPATH environment variable or Lua’s compiled-in defaults.</em></p>
<p><strong>context:</strong> <em>http</em></p>
<p>Sets the Lua C-module search path used by scripts specified by <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#set_by_lua" target="_blank" rel="noopener">set_by_lua</a>, <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#content_by_lua" target="_blank" rel="noopener">content_by_lua</a> and others. The cpath string is in standard Lua cpath form, and <code>;;</code> can be used to stand for the original cpath.</p>
<p>As from the <code>v0.5.0rc29</code> release, the special notation <code>$prefix</code> or <code>${prefix}</code> can be used in the search path string to indicate the path of the <code>server prefix</code> usually determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p>
<h2><span id="init_by_lua">init_by_lua</span></h2><p><strong>syntax:</strong> <em>init_by_lua <lua-script-str></lua-script-str></em></p>
<p><strong>context:</strong> <em>http</em></p>
<p><strong>phase:</strong> <em>loading-config</em></p>
<p><strong>NOTE</strong> Use of this directive is <em>discouraged</em> following the <code>v0.9.17</code> release. Use the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#init_by_lua_block" target="_blank" rel="noopener">init_by_lua_block</a> directive instead.</p>
<p>Runs the Lua code specified by the argument <code>&lt;lua-script-str&gt;</code> on the global Lua VM level when the Nginx master process (if any) is loading the Nginx config file.</p>
<p>When Nginx receives the <code>HUP</code> signal and starts reloading the config file, the Lua VM will also be re-created and <code>init_by_lua</code>will run again on the new Lua VM. In case that the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lua_code_cache" target="_blank" rel="noopener">lua_code_cache</a> directive is turned off (default on), the <code>init_by_lua</code>handler will run upon every request because in this special mode a standalone Lua VM is always created for each request.</p>
<p>Usually you can pre-load Lua modules at server start-up by means of this hook and take advantage of modern operating systems’ copy-on-write (COW) optimization. Here is an example for pre-loading Lua modules:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># this runs before forking out nginx worker processes:</span><br><span class="line">init_by_lua_block &#123; require &quot;cjson&quot; &#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    location = /api &#123;</span><br><span class="line">        content_by_lua_block &#123;</span><br><span class="line">            -- the following require() will just  return</span><br><span class="line">            -- the alrady loaded module from package.loaded:</span><br><span class="line">            ngx.say(require &quot;cjson&quot;.encode&#123;dog = 5, cat = 6&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>You can also initialize the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lua_shared_dict" target="_blank" rel="noopener">lua_shared_dict</a> shm storage at this phase. Here is an example for this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">lua_shared_dict dogs 1m;</span><br><span class="line"></span><br><span class="line">init_by_lua_block &#123;</span><br><span class="line">    local dogs = ngx.shared.dogs;</span><br><span class="line">    dogs:set(&quot;Tom&quot;, 56)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    location = /api &#123;</span><br><span class="line">        content_by_lua_block &#123;</span><br><span class="line">            local dogs = ngx.shared.dogs;</span><br><span class="line">            ngx.say(dogs:get(&quot;Tom&quot;))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>But note that, the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lua_shared_dict" target="_blank" rel="noopener">lua_shared_dict</a>‘s shm storage will not be cleared through a config reload (via the <code>HUP</code> signal, for example). So if you do <em>not</em> want to re-initialize the shm storage in your <code>init_by_lua</code> code in this case, then you just need to set a custom flag in the shm storage and always check the flag in your <code>init_by_lua</code> code.</p>
<p>Because the Lua code in this context runs before Nginx forks its worker processes (if any), data or code loaded here will enjoy the <a href="http://en.wikipedia.org/wiki/Copy-on-write" target="_blank" rel="noopener">Copy-on-write (COW)</a> feature provided by many operating systems among all the worker processes, thus saving a lot of memory.</p>
<p>Do <em>not</em> initialize your own Lua global variables in this context because use of Lua global variables have performance penalties and can lead to global namespace pollution (see the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lua-variable-scope" target="_blank" rel="noopener">Lua Variable Scope</a> section for more details). The recommended way is to use proper <a href="http://www.lua.org/manual/5.1/manual.html#5.3" target="_blank" rel="noopener">Lua module</a> files (but do not use the standard Lua function <a href="http://www.lua.org/manual/5.1/manual.html#pdf-module" target="_blank" rel="noopener">module()</a> to define Lua modules because it pollutes the global namespace as well) and call <a href="http://www.lua.org/manual/5.1/manual.html#pdf-require" target="_blank" rel="noopener">require()</a> to load your own module files in <code>init_by_lua</code> or other contexts (<a href="http://www.lua.org/manual/5.1/manual.html#pdf-require" target="_blank" rel="noopener">require()</a>does cache the loaded Lua modules in the global <code>package.loaded</code> table in the Lua registry so your modules will only loaded once for the whole Lua VM instance).</p>
<p>Only a small set of the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#nginx-api-for-lua" target="_blank" rel="noopener">Nginx API for Lua</a> is supported in this context:</p>
<ul>
<li>Logging APIs: <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxlog" target="_blank" rel="noopener">ngx.log</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#print" target="_blank" rel="noopener">print</a>,</li>
<li>Shared Dictionary API: <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxshareddict" target="_blank" rel="noopener">ngx.shared.DICT</a>.</li>
</ul>
<p>More Nginx APIs for Lua may be supported in this context upon future user requests.</p>
<p>Basically you can safely use Lua libraries that do blocking I/O in this very context because blocking the master process during server start-up is completely okay. Even the Nginx core does blocking I/O (at least on resolving upstream’s host names) at the configure-loading phase.</p>
<p>You should be very careful about potential security vulnerabilities in your Lua code registered in this context because the Nginx master process is often run under the <code>root</code> account.</p>
<p>This directive was first introduced in the <code>v0.5.5</code> release.</p>
<h2><span id="init_by_lua_block">init_by_lua_block</span></h2><p><strong>syntax:</strong> <em>init_by_lua_block { lua-script }</em></p>
<p><strong>context:</strong> <em>http</em></p>
<p><strong>phase:</strong> <em>loading-config</em></p>
<p>Similar to the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#init_by_lua" target="_blank" rel="noopener">init_by_lua</a> directive except that this directive inlines the Lua source directly inside a pair of curly braces (<code>{}</code>) instead of in an NGINX string literal (which requires special character escaping).</p>
<p>For instance,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">init_by_lua_block &#123;</span><br><span class="line">    print(&quot;I need no extra escaping here, for example: \r\nblah&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This directive was first introduced in the <code>v0.9.17</code> release.</p>
<h2><span id="init_by_lua_file">init_by_lua_file</span></h2><p><strong>syntax:</strong> <em>init_by_lua_file <path-to-lua-script-file></path-to-lua-script-file></em></p>
<p><strong>context:</strong> <em>http</em></p>
<p><strong>phase:</strong> <em>loading-config</em></p>
<p>Equivalent to <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#init_by_lua" target="_blank" rel="noopener">init_by_lua</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code or <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lualuajit-bytecode-support" target="_blank" rel="noopener">Lua/LuaJIT bytecode</a> to be executed.</p>
<p>When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p>
<p>This directive was first introduced in the <code>v0.5.5</code> release.</p>
<h2><span id="init_worker_by_lua">init_worker_by_lua</span></h2><p><strong>syntax:</strong> <em>init_worker_by_lua <lua-script-str></lua-script-str></em></p>
<p><strong>context:</strong> <em>http</em></p>
<p><strong>phase:</strong> <em>starting-worker</em></p>
<p><strong>NOTE</strong> Use of this directive is <em>discouraged</em> following the <code>v0.9.17</code> release. Use the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#init_worker_by_lua_block" target="_blank" rel="noopener">init_worker_by_lua_block</a> directive instead.</p>
<p>Runs the specified Lua code upon every Nginx worker process’s startup when the master process is enabled. When the master process is disabled, this hook will just run after <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#init_by_lua" target="_blank" rel="noopener">init_by_lua*</a>.</p>
<p>This hook is often used to create per-worker reoccurring timers (via the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxtimerat" target="_blank" rel="noopener">ngx.timer.at</a> Lua API), either for backend health-check or other timed routine work. Below is an example,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">init_worker_by_lua &apos;</span><br><span class="line">    local delay = 3  -- in seconds</span><br><span class="line">    local new_timer = ngx.timer.at</span><br><span class="line">    local log = ngx.log</span><br><span class="line">    local ERR = ngx.ERR</span><br><span class="line">    local check</span><br><span class="line"></span><br><span class="line">    check = function(premature)</span><br><span class="line">        if not premature then</span><br><span class="line">            -- do the health check or other routine work</span><br><span class="line">            local ok, err = new_timer(delay, check)</span><br><span class="line">            if not ok then</span><br><span class="line">                log(ERR, &quot;failed to create timer: &quot;, err)</span><br><span class="line">                return</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    local hdl, err = new_timer(delay, check)</span><br><span class="line">    if not hdl then</span><br><span class="line">        log(ERR, &quot;failed to create timer: &quot;, err)</span><br><span class="line">        return</span><br><span class="line">    end</span><br><span class="line">&apos;;</span><br></pre></td></tr></table></figure>
<p>This directive was first introduced in the <code>v0.9.5</code> release.</p>
<p>This hook no longer runs in the cache manager and cache loader processes since the <code>v0.10.12</code> release.</p>
<h2><span id="init_worker_by_lua_block">init_worker_by_lua_block</span></h2><p><strong>syntax:</strong> <em>init_worker_by_lua_block { lua-script }</em></p>
<p><strong>context:</strong> <em>http</em></p>
<p><strong>phase:</strong> <em>starting-worker</em></p>
<p>Similar to the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#init_worker_by_lua" target="_blank" rel="noopener">init_worker_by_lua</a> directive except that this directive inlines the Lua source directly inside a pair of curly braces (<code>{}</code>) instead of in an NGINX string literal (which requires special character escaping).</p>
<p>For instance,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">init_worker_by_lua_block &#123;</span><br><span class="line">    print(&quot;I need no extra escaping here, for example: \r\nblah&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This directive was first introduced in the <code>v0.9.17</code> release.</p>
<p>This hook no longer runs in the cache manager and cache loader processes since the <code>v0.10.12</code> release.</p>
<h2><span id="init_worker_by_lua_file">init_worker_by_lua_file</span></h2><p><strong>syntax:</strong> <em>init_worker_by_lua_file <lua-file-path></lua-file-path></em></p>
<p><strong>context:</strong> <em>http</em></p>
<p><strong>phase:</strong> <em>starting-worker</em></p>
<p>Similar to <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#init_worker_by_lua" target="_blank" rel="noopener">init_worker_by_lua</a>, but accepts the file path to a Lua source file or Lua bytecode file.</p>
<p>This directive was first introduced in the <code>v0.9.5</code> release.</p>
<p>This hook no longer runs in the cache manager and cache loader processes since the <code>v0.10.12</code> release.</p>
<h2><span id="set_by_lua">set_by_lua</span></h2><p><strong>syntax:</strong> <em>set_by_lua $res <lua-script-str> [$arg1 $arg2 …]</lua-script-str></em></p>
<p><strong>context:</strong> <em>server, server if, location, location if</em></p>
<p><strong>phase:</strong> <em>rewrite</em></p>
<p><strong>NOTE</strong> Use of this directive is <em>discouraged</em> following the <code>v0.9.17</code> release. Use the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#set_by_lua_block" target="_blank" rel="noopener">set_by_lua_block</a> directive instead.</p>
<p>Executes code specified in <code>&lt;lua-script-str&gt;</code> with optional input arguments <code>$arg1 $arg2 ...</code>, and returns string output to <code>$res</code>. The code in <code>&lt;lua-script-str&gt;</code> can make <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#nginx-api-for-lua" target="_blank" rel="noopener">API calls</a> and can retrieve input arguments from the <code>ngx.arg</code> table (index starts from <code>1</code> and increases sequentially).</p>
<p>This directive is designed to execute short, fast running code blocks as the Nginx event loop is blocked during code execution. Time consuming code sequences should therefore be avoided.</p>
<p>This directive is implemented by injecting custom commands into the standard <a href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html" target="_blank" rel="noopener">ngx_http_rewrite_module</a>‘s command list. Because <a href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html" target="_blank" rel="noopener">ngx_http_rewrite_module</a> does not support nonblocking I/O in its commands, Lua APIs requiring yielding the current Lua “light thread” cannot work in this directive.</p>
<p>At least the following API functions are currently disabled within the context of <code>set_by_lua</code>:</p>
<ul>
<li>Output API functions (e.g., <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsay" target="_blank" rel="noopener">ngx.say</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsend_headers" target="_blank" rel="noopener">ngx.send_headers</a>)</li>
<li>Control API functions (e.g., <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxexit" target="_blank" rel="noopener">ngx.exit</a>)</li>
<li>Subrequest API functions (e.g., <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxlocationcapture" target="_blank" rel="noopener">ngx.location.capture</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxlocationcapture_multi" target="_blank" rel="noopener">ngx.location.capture_multi</a>)</li>
<li>Cosocket API functions (e.g., <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsockettcp" target="_blank" rel="noopener">ngx.socket.tcp</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxreqsocket" target="_blank" rel="noopener">ngx.req.socket</a>).</li>
<li>Sleeping API function <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsleep" target="_blank" rel="noopener">ngx.sleep</a>.</li>
</ul>
<p>In addition, note that this directive can only write out a value to a single Nginx variable at a time. However, a workaround is possible using the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxvarvariable" target="_blank" rel="noopener">ngx.var.VARIABLE</a> interface.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">location /foo &#123;</span><br><span class="line">    set $diff &apos;&apos;; # we have to predefine the $diff variable here</span><br><span class="line"></span><br><span class="line">    set_by_lua $sum &apos;</span><br><span class="line">        local a = 32</span><br><span class="line">        local b = 56</span><br><span class="line"></span><br><span class="line">        ngx.var.diff = a - b;  -- write to $diff directly</span><br><span class="line">        return a + b;          -- return the $sum value normally</span><br><span class="line">    &apos;;</span><br><span class="line"></span><br><span class="line">    echo &quot;sum = $sum, diff = $diff&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This directive can be freely mixed with all directives of the <a href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html" target="_blank" rel="noopener">ngx_http_rewrite_module</a>, <a href="http://github.com/openresty/set-misc-nginx-module" target="_blank" rel="noopener">set-misc-nginx-module</a>, and <a href="http://github.com/openresty/array-var-nginx-module" target="_blank" rel="noopener">array-var-nginx-module</a> modules. All of these directives will run in the same order as they appear in the config file.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set $foo 32;</span><br><span class="line">set_by_lua $bar &apos;return tonumber(ngx.var.foo) + 1&apos;;</span><br><span class="line">set $baz &quot;bar: $bar&quot;;  # $baz == &quot;bar: 33&quot;</span><br></pre></td></tr></table></figure>
<p>As from the <code>v0.5.0rc29</code> release, Nginx variable interpolation is disabled in the <code>&lt;lua-script-str&gt;</code> argument of this directive and therefore, the dollar sign character (<code>$</code>) can be used directly.</p>
<p>This directive requires the <a href="https://github.com/simplresty/ngx_devel_kit" target="_blank" rel="noopener">ngx_devel_kit</a> module.</p>
<h2><span id="set_by_lua_block">set_by_lua_block</span></h2><p><strong>syntax:</strong> <em>set_by_lua_block $res { lua-script }</em></p>
<p><strong>context:</strong> <em>server, server if, location, location if</em></p>
<p><strong>phase:</strong> <em>rewrite</em></p>
<p>Similar to the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#set_by_lua" target="_blank" rel="noopener">set_by_lua</a> directive except that</p>
<ol>
<li>this directive inlines the Lua source directly inside a pair of curly braces (<code>{}</code>) instead of in an NGINX string literal (which requires special character escaping), and</li>
<li>this directive does not support extra arguments after the Lua script as in <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#set_by_lua" target="_blank" rel="noopener">set_by_lua</a>.</li>
</ol>
<p>For example,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set_by_lua_block $res &#123; return 32 + math.cos(32) &#125;</span><br><span class="line"># $res now has the value &quot;32.834223360507&quot; or alike.</span><br></pre></td></tr></table></figure>
<p>No special escaping is required in the Lua code block.</p>
<p>This directive was first introduced in the <code>v0.9.17</code> release.</p>
<h2><span id="set_by_lua_file">set_by_lua_file</span></h2><p><strong>syntax:</strong> <em>set_by_lua_file $res <path-to-lua-script-file> [$arg1 $arg2 …]</path-to-lua-script-file></em></p>
<p><strong>context:</strong> <em>server, server if, location, location if</em></p>
<p><strong>phase:</strong> <em>rewrite</em></p>
<p>Equivalent to <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#set_by_lua" target="_blank" rel="noopener">set_by_lua</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or, as from the <code>v0.5.0rc32</code> release, the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lualuajit-bytecode-support" target="_blank" rel="noopener">Lua/LuaJIT bytecode</a> to be executed.</p>
<p>Nginx variable interpolation is supported in the <code>&lt;path-to-lua-script-file&gt;</code> argument string of this directive. But special care must be taken for injection attacks.</p>
<p>When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p>
<p>When the Lua code cache is turned on (by default), the user code is loaded once at the first request and cached and the Nginx config must be reloaded each time the Lua source file is modified. The Lua code cache can be temporarily disabled during development by switching <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lua_code_cache" target="_blank" rel="noopener">lua_code_cache</a> <code>off</code> in <code>nginx.conf</code> to avoid reloading Nginx.</p>
<p>This directive requires the <a href="https://github.com/simplresty/ngx_devel_kit" target="_blank" rel="noopener">ngx_devel_kit</a> module.</p>
<h2><span id="content_by_lua">content_by_lua</span></h2><p><strong>syntax:</strong> <em>content_by_lua <lua-script-str></lua-script-str></em></p>
<p><strong>context:</strong> <em>location, location if</em></p>
<p><strong>phase:</strong> <em>content</em></p>
<p><strong>NOTE</strong> Use of this directive is <em>discouraged</em> following the <code>v0.9.17</code> release. Use the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#content_by_lua_block" target="_blank" rel="noopener">content_by_lua_block</a> directive instead.</p>
<p>Acts as a “content handler” and executes Lua code string specified in <code>&lt;lua-script-str&gt;</code> for every request. The Lua code may make <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#nginx-api-for-lua" target="_blank" rel="noopener">API calls</a> and is executed as a new spawned coroutine in an independent global environment (i.e. a sandbox).</p>
<p>Do not use this directive and other content handler directives in the same location. For example, this directive and the <a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_pass" target="_blank" rel="noopener">proxy_pass</a> directive should not be used in the same location.</p>
<h2><span id="content_by_lua_block">content_by_lua_block</span></h2><p><strong>syntax:</strong> <em>content_by_lua_block { lua-script }</em></p>
<p><strong>context:</strong> <em>location, location if</em></p>
<p><strong>phase:</strong> <em>content</em></p>
<p>Similar to the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#content_by_lua" target="_blank" rel="noopener">content_by_lua</a> directive except that this directive inlines the Lua source directly inside a pair of curly braces (<code>{}</code>) instead of in an NGINX string literal (which requires special character escaping).</p>
<p>For instance,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">content_by_lua_block &#123;</span><br><span class="line">    ngx.say(&quot;I need no extra escaping here, for example: \r\nblah&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This directive was first introduced in the <code>v0.9.17</code> release.</p>
<h2><span id="content_by_lua_file">content_by_lua_file</span></h2><p><strong>syntax:</strong> <em>content_by_lua_file <path-to-lua-script-file></path-to-lua-script-file></em></p>
<p><strong>context:</strong> <em>location, location if</em></p>
<p><strong>phase:</strong> <em>content</em></p>
<p>Equivalent to <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#content_by_lua" target="_blank" rel="noopener">content_by_lua</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or, as from the <code>v0.5.0rc32</code> release, the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lualuajit-bytecode-support" target="_blank" rel="noopener">Lua/LuaJIT bytecode</a> to be executed.</p>
<p>Nginx variables can be used in the <code>&lt;path-to-lua-script-file&gt;</code> string to provide flexibility. This however carries some risks and is not ordinarily recommended.</p>
<p>When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p>
<p>When the Lua code cache is turned on (by default), the user code is loaded once at the first request and cached and the Nginx config must be reloaded each time the Lua source file is modified. The Lua code cache can be temporarily disabled during development by switching <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lua_code_cache" target="_blank" rel="noopener">lua_code_cache</a> <code>off</code> in <code>nginx.conf</code> to avoid reloading Nginx.</p>
<p>Nginx variables are supported in the file path for dynamic dispatch, for example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># CAUTION: contents in nginx var must be carefully filtered,</span><br><span class="line"># otherwise there&apos;ll be great security risk!</span><br><span class="line">location ~ ^/app/([-_a-zA-Z0-9/]+) &#123;</span><br><span class="line">    set $path $1;</span><br><span class="line">    content_by_lua_file /path/to/lua/app/root/$path.lua;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>But be very careful about malicious user inputs and always carefully validate or filter out the user-supplied path components.</p>
<h2><span id="rewrite_by_lua">rewrite_by_lua</span></h2><p><strong>syntax:</strong> <em>rewrite_by_lua <lua-script-str></lua-script-str></em></p>
<p><strong>context:</strong> <em>http, server, location, location if</em></p>
<p><strong>phase:</strong> <em>rewrite tail</em></p>
<p><strong>NOTE</strong> Use of this directive is <em>discouraged</em> following the <code>v0.9.17</code> release. Use the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#rewrite_by_lua_block" target="_blank" rel="noopener">rewrite_by_lua_block</a> directive instead.</p>
<p>Acts as a rewrite phase handler and executes Lua code string specified in <code>&lt;lua-script-str&gt;</code> for every request. The Lua code may make <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#nginx-api-for-lua" target="_blank" rel="noopener">API calls</a> and is executed as a new spawned coroutine in an independent global environment (i.e. a sandbox).</p>
<p>Note that this handler always runs <em>after</em> the standard <a href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html" target="_blank" rel="noopener">ngx_http_rewrite_module</a>. So the following will work as expected:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location /foo &#123;</span><br><span class="line">    set $a 12; # create and initialize $a</span><br><span class="line">    set $b &quot;&quot;; # create and initialize $b</span><br><span class="line">    rewrite_by_lua &apos;ngx.var.b = tonumber(ngx.var.a) + 1&apos;;</span><br><span class="line">    echo &quot;res = $b&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>because <code>set $a 12</code> and <code>set $b &quot;&quot;</code> run <em>before</em> <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#rewrite_by_lua" target="_blank" rel="noopener">rewrite_by_lua</a>.</p>
<p>On the other hand, the following will not work as expected:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">?  location /foo &#123;</span><br><span class="line">?      set $a 12; # create and initialize $a</span><br><span class="line">?      set $b &apos;&apos;; # create and initialize $b</span><br><span class="line">?      rewrite_by_lua &apos;ngx.var.b = tonumber(ngx.var.a) + 1&apos;;</span><br><span class="line">?      if ($b = &apos;13&apos;) &#123;</span><br><span class="line">?         rewrite ^ /bar redirect;</span><br><span class="line">?         break;</span><br><span class="line">?      &#125;</span><br><span class="line">?</span><br><span class="line">?      echo &quot;res = $b&quot;;</span><br><span class="line">?  &#125;</span><br></pre></td></tr></table></figure>
<p>because <code>if</code> runs <em>before</em> <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#rewrite_by_lua" target="_blank" rel="noopener">rewrite_by_lua</a> even if it is placed after <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#rewrite_by_lua" target="_blank" rel="noopener">rewrite_by_lua</a> in the config.</p>
<p>The right way of doing this is as follows:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">location /foo &#123;</span><br><span class="line">    set $a 12; # create and initialize $a</span><br><span class="line">    set $b &apos;&apos;; # create and initialize $b</span><br><span class="line">    rewrite_by_lua &apos;</span><br><span class="line">        ngx.var.b = tonumber(ngx.var.a) + 1</span><br><span class="line">        if tonumber(ngx.var.b) == 13 then</span><br><span class="line">            return ngx.redirect(&quot;/bar&quot;);</span><br><span class="line">        end</span><br><span class="line">    &apos;;</span><br><span class="line"></span><br><span class="line">    echo &quot;res = $b&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note that the <a href="http://www.grid.net.ru/nginx/eval.en.html" target="_blank" rel="noopener">ngx_eval</a> module can be approximated by using <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#rewrite_by_lua" target="_blank" rel="noopener">rewrite_by_lua</a>. For example,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    eval $res &#123;</span><br><span class="line">        proxy_pass http://foo.com/check-spam;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if ($res = &apos;spam&apos;) &#123;</span><br><span class="line">        rewrite ^ /terms-of-use.html redirect;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fastcgi_pass ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>can be implemented in ngx_lua as:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">location = /check-spam &#123;</span><br><span class="line">    internal;</span><br><span class="line">    proxy_pass http://foo.com/check-spam;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">    rewrite_by_lua &apos;</span><br><span class="line">        local res = ngx.location.capture(&quot;/check-spam&quot;)</span><br><span class="line">        if res.body == &quot;spam&quot; then</span><br><span class="line">            return ngx.redirect(&quot;/terms-of-use.html&quot;)</span><br><span class="line">        end</span><br><span class="line">    &apos;;</span><br><span class="line"></span><br><span class="line">    fastcgi_pass ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Just as any other rewrite phase handlers, <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#rewrite_by_lua" target="_blank" rel="noopener">rewrite_by_lua</a> also runs in subrequests.</p>
<p>Note that when calling <code>ngx.exit(ngx.OK)</code> within a <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#rewrite_by_lua" target="_blank" rel="noopener">rewrite_by_lua</a> handler, the nginx request processing control flow will still continue to the content handler. To terminate the current request from within a <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#rewrite_by_lua" target="_blank" rel="noopener">rewrite_by_lua</a> handler, calling <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxexit" target="_blank" rel="noopener">ngx.exit</a> with status &gt;= 200 (<code>ngx.HTTP_OK</code>) and status &lt; 300 (<code>ngx.HTTP_SPECIAL_RESPONSE</code>) for successful quits and <code>ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)</code> (or its friends) for failures.</p>
<p>If the <a href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html" target="_blank" rel="noopener">ngx_http_rewrite_module</a>‘s <a href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html#rewrite" target="_blank" rel="noopener">rewrite</a> directive is used to change the URI and initiate location re-lookups (internal redirections), then any <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#rewrite_by_lua" target="_blank" rel="noopener">rewrite_by_lua</a> or <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#rewrite_by_lua_file" target="_blank" rel="noopener">rewrite_by_lua_file</a> code sequences within the current location will not be executed. For example,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location /foo &#123;</span><br><span class="line">    rewrite ^ /bar;</span><br><span class="line">    rewrite_by_lua &apos;ngx.exit(503)&apos;;</span><br><span class="line">&#125;</span><br><span class="line">location /bar &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Here the Lua code <code>ngx.exit(503)</code> will never run. This will be the case if <code>rewrite ^ /bar last</code> is used as this will similarly initiate an internal redirection. If the <code>break</code> modifier is used instead, there will be no internal redirection and the <code>rewrite_by_lua</code> code will be executed.</p>
<p>The <code>rewrite_by_lua</code> code will always run at the end of the <code>rewrite</code> request-processing phase unless <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#rewrite_by_lua_no_postpone" target="_blank" rel="noopener">rewrite_by_lua_no_postpone</a> is turned on.</p>
<h2><span id="rewrite_by_lua_block">rewrite_by_lua_block</span></h2><p><strong>syntax:</strong> <em>rewrite_by_lua_block { lua-script }</em></p>
<p><strong>context:</strong> <em>http, server, location, location if</em></p>
<p><strong>phase:</strong> <em>rewrite tail</em></p>
<p>Similar to the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#rewrite_by_lua" target="_blank" rel="noopener">rewrite_by_lua</a> directive except that this directive inlines the Lua source directly inside a pair of curly braces (<code>{}</code>) instead of in an NGINX string literal (which requires special character escaping).</p>
<p>For instance,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rewrite_by_lua_block &#123;</span><br><span class="line">    do_something(&quot;hello, world!\nhiya\n&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This directive was first introduced in the <code>v0.9.17</code> release.</p>
<h2><span id="rewrite_by_lua_file">rewrite_by_lua_file</span></h2><p><strong>syntax:</strong> <em>rewrite_by_lua_file <path-to-lua-script-file></path-to-lua-script-file></em></p>
<p><strong>context:</strong> <em>http, server, location, location if</em></p>
<p><strong>phase:</strong> <em>rewrite tail</em></p>
<p>Equivalent to <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#rewrite_by_lua" target="_blank" rel="noopener">rewrite_by_lua</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or, as from the <code>v0.5.0rc32</code> release, the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lualuajit-bytecode-support" target="_blank" rel="noopener">Lua/LuaJIT bytecode</a> to be executed.</p>
<p>Nginx variables can be used in the <code>&lt;path-to-lua-script-file&gt;</code> string to provide flexibility. This however carries some risks and is not ordinarily recommended.</p>
<p>When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p>
<p>When the Lua code cache is turned on (by default), the user code is loaded once at the first request and cached and the Nginx config must be reloaded each time the Lua source file is modified. The Lua code cache can be temporarily disabled during development by switching <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lua_code_cache" target="_blank" rel="noopener">lua_code_cache</a> <code>off</code> in <code>nginx.conf</code> to avoid reloading Nginx.</p>
<p>The <code>rewrite_by_lua_file</code> code will always run at the end of the <code>rewrite</code> request-processing phase unless <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#rewrite_by_lua_no_postpone" target="_blank" rel="noopener">rewrite_by_lua_no_postpone</a> is turned on.</p>
<p>Nginx variables are supported in the file path for dynamic dispatch just as in <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#content_by_lua_file" target="_blank" rel="noopener">content_by_lua_file</a>.</p>
<h2><span id="access_by_lua">access_by_lua</span></h2><p><strong>syntax:</strong> <em>access_by_lua <lua-script-str></lua-script-str></em></p>
<p><strong>context:</strong> <em>http, server, location, location if</em></p>
<p><strong>phase:</strong> <em>access tail</em></p>
<p><strong>NOTE</strong> Use of this directive is <em>discouraged</em> following the <code>v0.9.17</code> release. Use the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#access_by_lua_block" target="_blank" rel="noopener">access_by_lua_block</a> directive instead.</p>
<p>Acts as an access phase handler and executes Lua code string specified in <code>&lt;lua-script-str&gt;</code> for every request. The Lua code may make <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#nginx-api-for-lua" target="_blank" rel="noopener">API calls</a> and is executed as a new spawned coroutine in an independent global environment (i.e. a sandbox).</p>
<p>Note that this handler always runs <em>after</em> the standard <a href="http://nginx.org/en/docs/http/ngx_http_access_module.html" target="_blank" rel="noopener">ngx_http_access_module</a>. So the following will work as expected:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    deny    192.168.1.1;</span><br><span class="line">    allow   192.168.1.0/24;</span><br><span class="line">    allow   10.1.1.0/16;</span><br><span class="line">    deny    all;</span><br><span class="line"></span><br><span class="line">    access_by_lua &apos;</span><br><span class="line">        local res = ngx.location.capture(&quot;/mysql&quot;, &#123; ... &#125;)</span><br><span class="line">        ...</span><br><span class="line">    &apos;;</span><br><span class="line"></span><br><span class="line">    # proxy_pass/fastcgi_pass/...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>That is, if a client IP address is in the blacklist, it will be denied before the MySQL query for more complex authentication is executed by <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#access_by_lua" target="_blank" rel="noopener">access_by_lua</a>.</p>
<p>Note that the <a href="http://mdounin.ru/hg/ngx_http_auth_request_module/" target="_blank" rel="noopener">ngx_auth_request</a> module can be approximated by using <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#access_by_lua" target="_blank" rel="noopener">access_by_lua</a>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    auth_request /auth;</span><br><span class="line"></span><br><span class="line">    # proxy_pass/fastcgi_pass/postgres_pass/...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>can be implemented in ngx_lua as:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    access_by_lua &apos;</span><br><span class="line">        local res = ngx.location.capture(&quot;/auth&quot;)</span><br><span class="line"></span><br><span class="line">        if res.status == ngx.HTTP_OK then</span><br><span class="line">            return</span><br><span class="line">        end</span><br><span class="line"></span><br><span class="line">        if res.status == ngx.HTTP_FORBIDDEN then</span><br><span class="line">            ngx.exit(res.status)</span><br><span class="line">        end</span><br><span class="line"></span><br><span class="line">        ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)</span><br><span class="line">    &apos;;</span><br><span class="line"></span><br><span class="line">    # proxy_pass/fastcgi_pass/postgres_pass/...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>As with other access phase handlers, <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#access_by_lua" target="_blank" rel="noopener">access_by_lua</a> will <em>not</em> run in subrequests.</p>
<p>Note that when calling <code>ngx.exit(ngx.OK)</code> within a <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#access_by_lua" target="_blank" rel="noopener">access_by_lua</a> handler, the nginx request processing control flow will still continue to the content handler. To terminate the current request from within a <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#access_by_lua" target="_blank" rel="noopener">access_by_lua</a> handler, calling <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxexit" target="_blank" rel="noopener">ngx.exit</a> with status &gt;= 200 (<code>ngx.HTTP_OK</code>) and status &lt; 300 (<code>ngx.HTTP_SPECIAL_RESPONSE</code>) for successful quits and <code>ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)</code> (or its friends) for failures.</p>
<p>Starting from the <code>v0.9.20</code> release, you can use the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#access_by_lua_no_postpone" target="_blank" rel="noopener">access_by_lua_no_postpone</a> directive to control when to run this handler inside the “access” request-processing phase of NGINX.</p>
<h2><span id="access_by_lua_block">access_by_lua_block</span></h2><p><strong>syntax:</strong> <em>access_by_lua_block { lua-script }</em></p>
<p><strong>context:</strong> <em>http, server, location, location if</em></p>
<p><strong>phase:</strong> <em>access tail</em></p>
<p>Similar to the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#access_by_lua" target="_blank" rel="noopener">access_by_lua</a> directive except that this directive inlines the Lua source directly inside a pair of curly braces (<code>{}</code>) instead of in an NGINX string literal (which requires special character escaping).</p>
<p>For instance,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">access_by_lua_block &#123;</span><br><span class="line">    do_something(&quot;hello, world!\nhiya\n&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This directive was first introduced in the <code>v0.9.17</code> release.</p>
<h2><span id="access_by_lua_file">access_by_lua_file</span></h2><p><strong>syntax:</strong> <em>access_by_lua_file <path-to-lua-script-file></path-to-lua-script-file></em></p>
<p><strong>context:</strong> <em>http, server, location, location if</em></p>
<p><strong>phase:</strong> <em>access tail</em></p>
<p>Equivalent to <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#access_by_lua" target="_blank" rel="noopener">access_by_lua</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or, as from the <code>v0.5.0rc32</code> release, the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lualuajit-bytecode-support" target="_blank" rel="noopener">Lua/LuaJIT bytecode</a> to be executed.</p>
<p>Nginx variables can be used in the <code>&lt;path-to-lua-script-file&gt;</code> string to provide flexibility. This however carries some risks and is not ordinarily recommended.</p>
<p>When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p>
<p>When the Lua code cache is turned on (by default), the user code is loaded once at the first request and cached and the Nginx config must be reloaded each time the Lua source file is modified. The Lua code cache can be temporarily disabled during development by switching <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lua_code_cache" target="_blank" rel="noopener">lua_code_cache</a> <code>off</code> in <code>nginx.conf</code> to avoid repeatedly reloading Nginx.</p>
<p>Nginx variables are supported in the file path for dynamic dispatch just as in <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#content_by_lua_file" target="_blank" rel="noopener">content_by_lua_file</a>.</p>
<h2><span id="header_filter_by_lua">header_filter_by_lua</span></h2><p><strong>syntax:</strong> <em>header_filter_by_lua <lua-script-str></lua-script-str></em></p>
<p><strong>context:</strong> <em>http, server, location, location if</em></p>
<p><strong>phase:</strong> <em>output-header-filter</em></p>
<p><strong>NOTE</strong> Use of this directive is <em>discouraged</em> following the <code>v0.9.17</code> release. Use the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#header_filter_by_lua_block" target="_blank" rel="noopener">header_filter_by_lua_block</a> directive instead.</p>
<p>Uses Lua code specified in <code>&lt;lua-script-str&gt;</code> to define an output header filter.</p>
<p>Note that the following API functions are currently disabled within this context:</p>
<ul>
<li>Output API functions (e.g., <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsay" target="_blank" rel="noopener">ngx.say</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsend_headers" target="_blank" rel="noopener">ngx.send_headers</a>)</li>
<li>Control API functions (e.g., <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxredirect" target="_blank" rel="noopener">ngx.redirect</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxexec" target="_blank" rel="noopener">ngx.exec</a>)</li>
<li>Subrequest API functions (e.g., <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxlocationcapture" target="_blank" rel="noopener">ngx.location.capture</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxlocationcapture_multi" target="_blank" rel="noopener">ngx.location.capture_multi</a>)</li>
<li>Cosocket API functions (e.g., <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsockettcp" target="_blank" rel="noopener">ngx.socket.tcp</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxreqsocket" target="_blank" rel="noopener">ngx.req.socket</a>).</li>
</ul>
<p>Here is an example of overriding a response header (or adding one if absent) in our Lua header filter:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    proxy_pass http://mybackend;</span><br><span class="line">    header_filter_by_lua &apos;ngx.header.Foo = &quot;blah&quot;&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This directive was first introduced in the <code>v0.2.1rc20</code> release.</p>
<h2><span id="header_filter_by_lua_block">header_filter_by_lua_block</span></h2><p><strong>syntax:</strong> <em>header_filter_by_lua_block { lua-script }</em></p>
<p><strong>context:</strong> <em>http, server, location, location if</em></p>
<p><strong>phase:</strong> <em>output-header-filter</em></p>
<p>Similar to the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#header_filter_by_lua" target="_blank" rel="noopener">header_filter_by_lua</a> directive except that this directive inlines the Lua source directly inside a pair of curly braces (<code>{}</code>) instead of in an NGINX string literal (which requires special character escaping).</p>
<p>For instance,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">header_filter_by_lua_block &#123;</span><br><span class="line">    ngx.header[&quot;content-length&quot;] = nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This directive was first introduced in the <code>v0.9.17</code> release.</p>
<h2><span id="header_filter_by_lua_file">header_filter_by_lua_file</span></h2><p><strong>syntax:</strong> <em>header_filter_by_lua_file <path-to-lua-script-file></path-to-lua-script-file></em></p>
<p><strong>context:</strong> <em>http, server, location, location if</em></p>
<p><strong>phase:</strong> <em>output-header-filter</em></p>
<p>Equivalent to <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#header_filter_by_lua" target="_blank" rel="noopener">header_filter_by_lua</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or as from the <code>v0.5.0rc32</code> release, the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lualuajit-bytecode-support" target="_blank" rel="noopener">Lua/LuaJIT bytecode</a> to be executed.</p>
<p>When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p>
<p>This directive was first introduced in the <code>v0.2.1rc20</code> release.</p>
<h2><span id="body_filter_by_lua">body_filter_by_lua</span></h2><p><strong>syntax:</strong> <em>body_filter_by_lua <lua-script-str></lua-script-str></em></p>
<p><strong>context:</strong> <em>http, server, location, location if</em></p>
<p><strong>phase:</strong> <em>output-body-filter</em></p>
<p><strong>NOTE</strong> Use of this directive is <em>discouraged</em> following the <code>v0.9.17</code> release. Use the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#body_filter_by_lua_block" target="_blank" rel="noopener">body_filter_by_lua_block</a> directive instead.</p>
<p>Uses Lua code specified in <code>&lt;lua-script-str&gt;</code> to define an output body filter.</p>
<p>The input data chunk is passed via <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxarg" target="_blank" rel="noopener">ngx.arg</a>[1] (as a Lua string value) and the “eof” flag indicating the end of the response body data stream is passed via <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxarg" target="_blank" rel="noopener">ngx.arg</a>[2] (as a Lua boolean value).</p>
<p>Behind the scene, the “eof” flag is just the <code>last_buf</code> (for main requests) or <code>last_in_chain</code> (for subrequests) flag of the Nginx chain link buffers. (Before the <code>v0.7.14</code> release, the “eof” flag does not work at all in subrequests.)</p>
<p>The output data stream can be aborted immediately by running the following Lua statement:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return ngx.ERROR</span><br></pre></td></tr></table></figure>
<p>This will truncate the response body and usually result in incomplete and also invalid responses.</p>
<p>The Lua code can pass its own modified version of the input data chunk to the downstream Nginx output body filters by overriding <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxarg" target="_blank" rel="noopener">ngx.arg</a>[1] with a Lua string or a Lua table of strings. For example, to transform all the lowercase letters in the response body, we can just write:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    proxy_pass http://mybackend;</span><br><span class="line">    body_filter_by_lua &apos;ngx.arg[1] = string.upper(ngx.arg[1])&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>When setting <code>nil</code> or an empty Lua string value to <code>ngx.arg[1]</code>, no data chunk will be passed to the downstream Nginx output filters at all.</p>
<p>Likewise, new “eof” flag can also be specified by setting a boolean value to <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxarg" target="_blank" rel="noopener">ngx.arg</a>[2]. For example,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">location /t &#123;</span><br><span class="line">    echo hello world;</span><br><span class="line">    echo hiya globe;</span><br><span class="line"></span><br><span class="line">    body_filter_by_lua &apos;</span><br><span class="line">        local chunk = ngx.arg[1]</span><br><span class="line">        if string.match(chunk, &quot;hello&quot;) then</span><br><span class="line">            ngx.arg[2] = true  -- new eof</span><br><span class="line">            return</span><br><span class="line">        end</span><br><span class="line"></span><br><span class="line">        -- just throw away any remaining chunk data</span><br><span class="line">        ngx.arg[1] = nil</span><br><span class="line">    &apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Then <code>GET /t</code> will just return the output</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br></pre></td></tr></table></figure>
<p>That is, when the body filter sees a chunk containing the word “hello”, then it will set the “eof” flag to true immediately, resulting in truncated but still valid responses.</p>
<p>When the Lua code may change the length of the response body, then it is required to always clear out the <code>Content-Length</code>response header (if any) in a header filter to enforce streaming output, as in</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location /foo &#123;</span><br><span class="line">    # fastcgi_pass/proxy_pass/...</span><br><span class="line"></span><br><span class="line">    header_filter_by_lua_block &#123; ngx.header.content_length = nil &#125;</span><br><span class="line">    body_filter_by_lua &apos;ngx.arg[1] = string.len(ngx.arg[1]) .. &quot;\\n&quot;&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note that the following API functions are currently disabled within this context due to the limitations in NGINX output filter’s current implementation:</p>
<ul>
<li>Output API functions (e.g., <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsay" target="_blank" rel="noopener">ngx.say</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsend_headers" target="_blank" rel="noopener">ngx.send_headers</a>)</li>
<li>Control API functions (e.g., <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxexit" target="_blank" rel="noopener">ngx.exit</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxexec" target="_blank" rel="noopener">ngx.exec</a>)</li>
<li>Subrequest API functions (e.g., <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxlocationcapture" target="_blank" rel="noopener">ngx.location.capture</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxlocationcapture_multi" target="_blank" rel="noopener">ngx.location.capture_multi</a>)</li>
<li>Cosocket API functions (e.g., <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsockettcp" target="_blank" rel="noopener">ngx.socket.tcp</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxreqsocket" target="_blank" rel="noopener">ngx.req.socket</a>).</li>
</ul>
<p>Nginx output filters may be called multiple times for a single request because response body may be delivered in chunks. Thus, the Lua code specified by in this directive may also run multiple times in the lifetime of a single HTTP request.</p>
<p>This directive was first introduced in the <code>v0.5.0rc32</code> release.</p>
<h2><span id="body_filter_by_lua_block">body_filter_by_lua_block</span></h2><p><strong>syntax:</strong> <em>body_filter_by_lua_block { lua-script-str }</em></p>
<p><strong>context:</strong> <em>http, server, location, location if</em></p>
<p><strong>phase:</strong> <em>output-body-filter</em></p>
<p>Similar to the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#body_filter_by_lua" target="_blank" rel="noopener">body_filter_by_lua</a> directive except that this directive inlines the Lua source directly inside a pair of curly braces (<code>{}</code>) instead of in an NGINX string literal (which requires special character escaping).</p>
<p>For instance,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">body_filter_by_lua_block &#123;</span><br><span class="line">    local data, eof = ngx.arg[1], ngx.arg[2]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This directive was first introduced in the <code>v0.9.17</code> release.</p>
<h2><span id="body_filter_by_lua_file">body_filter_by_lua_file</span></h2><p><strong>syntax:</strong> <em>body_filter_by_lua_file <path-to-lua-script-file></path-to-lua-script-file></em></p>
<p><strong>context:</strong> <em>http, server, location, location if</em></p>
<p><strong>phase:</strong> <em>output-body-filter</em></p>
<p>Equivalent to <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#body_filter_by_lua" target="_blank" rel="noopener">body_filter_by_lua</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or, as from the <code>v0.5.0rc32</code> release, the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lualuajit-bytecode-support" target="_blank" rel="noopener">Lua/LuaJIT bytecode</a> to be executed.</p>
<p>When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p>
<p>This directive was first introduced in the <code>v0.5.0rc32</code> release.</p>
<h2><span id="log_by_lua">log_by_lua</span></h2><p><strong>syntax:</strong> <em>log_by_lua <lua-script-str></lua-script-str></em></p>
<p><strong>context:</strong> <em>http, server, location, location if</em></p>
<p><strong>phase:</strong> <em>log</em></p>
<p><strong>NOTE</strong> Use of this directive is <em>discouraged</em> following the <code>v0.9.17</code> release. Use the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#log_by_lua_block" target="_blank" rel="noopener">log_by_lua_block</a> directive instead.</p>
<p>Runs the Lua source code inlined as the <code>&lt;lua-script-str&gt;</code> at the <code>log</code> request processing phase. This does not replace the current access logs, but runs before.</p>
<p>Note that the following API functions are currently disabled within this context:</p>
<ul>
<li>Output API functions (e.g., <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsay" target="_blank" rel="noopener">ngx.say</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsend_headers" target="_blank" rel="noopener">ngx.send_headers</a>)</li>
<li>Control API functions (e.g., <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxexit" target="_blank" rel="noopener">ngx.exit</a>)</li>
<li>Subrequest API functions (e.g., <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxlocationcapture" target="_blank" rel="noopener">ngx.location.capture</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxlocationcapture_multi" target="_blank" rel="noopener">ngx.location.capture_multi</a>)</li>
<li>Cosocket API functions (e.g., <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsockettcp" target="_blank" rel="noopener">ngx.socket.tcp</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxreqsocket" target="_blank" rel="noopener">ngx.req.socket</a>).</li>
</ul>
<p>Here is an example of gathering average data for <a href="http://nginx.org/en/docs/http/ngx_http_upstream_module.html#var_upstream_response_time" target="_blank" rel="noopener">$upstream_response_time</a>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">lua_shared_dict log_dict 5M;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://mybackend;</span><br><span class="line"></span><br><span class="line">        log_by_lua &apos;</span><br><span class="line">            local log_dict = ngx.shared.log_dict</span><br><span class="line">            local upstream_time = tonumber(ngx.var.upstream_response_time)</span><br><span class="line"></span><br><span class="line">            local sum = log_dict:get(&quot;upstream_time-sum&quot;) or 0</span><br><span class="line">            sum = sum + upstream_time</span><br><span class="line">            log_dict:set(&quot;upstream_time-sum&quot;, sum)</span><br><span class="line"></span><br><span class="line">            local newval, err = log_dict:incr(&quot;upstream_time-nb&quot;, 1)</span><br><span class="line">            if not newval and err == &quot;not found&quot; then</span><br><span class="line">                log_dict:add(&quot;upstream_time-nb&quot;, 0)</span><br><span class="line">                log_dict:incr(&quot;upstream_time-nb&quot;, 1)</span><br><span class="line">            end</span><br><span class="line">        &apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location = /status &#123;</span><br><span class="line">        content_by_lua_block &#123;</span><br><span class="line">            local log_dict = ngx.shared.log_dict</span><br><span class="line">            local sum = log_dict:get(&quot;upstream_time-sum&quot;)</span><br><span class="line">            local nb = log_dict:get(&quot;upstream_time-nb&quot;)</span><br><span class="line"></span><br><span class="line">            if nb and sum then</span><br><span class="line">                ngx.say(&quot;average upstream response time: &quot;, sum / nb,</span><br><span class="line">                        &quot; (&quot;, nb, &quot; reqs)&quot;)</span><br><span class="line">            else</span><br><span class="line">                ngx.say(&quot;no data yet&quot;)</span><br><span class="line">            end</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This directive was first introduced in the <code>v0.5.0rc31</code> release.</p>
<h2><span id="log_by_lua_block">log_by_lua_block</span></h2><p><strong>syntax:</strong> <em>log_by_lua_block { lua-script }</em></p>
<p><strong>context:</strong> <em>http, server, location, location if</em></p>
<p><strong>phase:</strong> <em>log</em></p>
<p>Similar to the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#log_by_lua" target="_blank" rel="noopener">log_by_lua</a> directive except that this directive inlines the Lua source directly inside a pair of curly braces (<code>{}</code>) instead of in an NGINX string literal (which requires special character escaping).</p>
<p>For instance,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">log_by_lua_block &#123;</span><br><span class="line">    print(&quot;I need no extra escaping here, for example: \r\nblah&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This directive was first introduced in the <code>v0.9.17</code> release.</p>
<h2><span id="log_by_lua_file">log_by_lua_file</span></h2><p><strong>syntax:</strong> <em>log_by_lua_file <path-to-lua-script-file></path-to-lua-script-file></em></p>
<p><strong>context:</strong> <em>http, server, location, location if</em></p>
<p><strong>phase:</strong> <em>log</em></p>
<p>Equivalent to <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#log_by_lua" target="_blank" rel="noopener">log_by_lua</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or, as from the <code>v0.5.0rc32</code> release, the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lualuajit-bytecode-support" target="_blank" rel="noopener">Lua/LuaJIT bytecode</a> to be executed.</p>
<p>When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p>
<p>This directive was first introduced in the <code>v0.5.0rc31</code> release.</p>
<h2><span id="balancer_by_lua_block">balancer_by_lua_block</span></h2><p><strong>syntax:</strong> <em>balancer_by_lua_block { lua-script }</em></p>
<p><strong>context:</strong> <em>upstream</em></p>
<p><strong>phase:</strong> <em>content</em></p>
<p>This directive runs Lua code as an upstream balancer for any upstream entities defined by the <code>upstream {}</code> configuration block.</p>
<p>For instance,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">upstream foo &#123;</span><br><span class="line">    server 127.0.0.1;</span><br><span class="line">    balancer_by_lua_block &#123;</span><br><span class="line">        -- use Lua to do something interesting here</span><br><span class="line">        -- as a dynamic balancer</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://foo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The resulting Lua load balancer can work with any existing nginx upstream modules like <a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html" target="_blank" rel="noopener">ngx_proxy</a> and <a href="http://nginx.org/en/docs/http/ngx_http_fastcgi_module.html" target="_blank" rel="noopener">ngx_fastcgi</a>.</p>
<p>Also, the Lua load balancer can work with the standard upstream connection pool mechanism, i.e., the standard <a href="http://nginx.org/en/docs/http/ngx_http_upstream_module.html#keepalive" target="_blank" rel="noopener">keepalive</a>directive. Just ensure that the <a href="http://nginx.org/en/docs/http/ngx_http_upstream_module.html#keepalive" target="_blank" rel="noopener">keepalive</a> directive is used <em>after</em> this <code>balancer_by_lua_block</code> directive in a single <code>upstream {}</code>configuration block.</p>
<p>The Lua load balancer can totally ignore the list of servers defined in the <code>upstream {}</code> block and select peer from a completely dynamic server list (even changing per request) via the <a href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/balancer.md" target="_blank" rel="noopener">ngx.balancer</a> module from the <a href="https://github.com/openresty/lua-resty-core" target="_blank" rel="noopener">lua-resty-core</a> library.</p>
<p>The Lua code handler registered by this directive might get called more than once in a single downstream request when the nginx upstream mechanism retries the request on conditions specified by directives like the <a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_next_upstream" target="_blank" rel="noopener">proxy_next_upstream</a> directive.</p>
<p>This Lua code execution context does not support yielding, so Lua APIs that may yield (like cosockets and “light threads”) are disabled in this context. One can usually work around this limitation by doing such operations in an earlier phase handler (like<a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#access_by_lua" target="_blank" rel="noopener">access_by_lua*</a>) and passing along the result into this context via the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxctx" target="_blank" rel="noopener">ngx.ctx</a> table.</p>
<p>This directive was first introduced in the <code>v0.10.0</code> release.</p>
<h2><span id="balancer_by_lua_file">balancer_by_lua_file</span></h2><p><strong>syntax:</strong> <em>balancer_by_lua_file <path-to-lua-script-file></path-to-lua-script-file></em></p>
<p><strong>context:</strong> <em>upstream</em></p>
<p><strong>phase:</strong> <em>content</em></p>
<p>Equivalent to <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#balancer_by_lua_block" target="_blank" rel="noopener">balancer_by_lua_block</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or, as from the <code>v0.5.0rc32</code> release, the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lualuajit-bytecode-support" target="_blank" rel="noopener">Lua/LuaJIT bytecode</a> to be executed.</p>
<p>When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p>
<p>This directive was first introduced in the <code>v0.10.0</code> release.</p>
<h2><span id="lua_need_request_body">lua_need_request_body</span></h2><p><strong>syntax:</strong> <em>lua_need_request_body &lt;on|off&gt;</em></p>
<p><strong>default:</strong> <em>off</em></p>
<p><strong>context:</strong> <em>http, server, location, location if</em></p>
<p><strong>phase:</strong> <em>depends on usage</em></p>
<p>Determines whether to force the request body data to be read before running rewrite/access/access_by_lua* or not. The Nginx core does not read the client request body by default and if request body data is required, then this directive should be turned <code>on</code> or the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxreqread_body" target="_blank" rel="noopener">ngx.req.read_body</a> function should be called within the Lua code.</p>
<p>To read the request body data within the <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#var_request_body" target="_blank" rel="noopener">$request_body</a> variable, <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_buffer_size" target="_blank" rel="noopener">client_body_buffer_size</a> must have the same value as <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#client_max_body_size" target="_blank" rel="noopener">client_max_body_size</a>. Because when the content length exceeds <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_buffer_size" target="_blank" rel="noopener">client_body_buffer_size</a> but less than <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#client_max_body_size" target="_blank" rel="noopener">client_max_body_size</a>, Nginx will buffer the data into a temporary file on the disk, which will lead to empty value in the <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#var_request_body" target="_blank" rel="noopener">$request_body</a> variable.</p>
<p>If the current location includes <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#rewrite_by_lua" target="_blank" rel="noopener">rewrite_by_lua*</a> directives, then the request body will be read just before the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#rewrite_by_lua" target="_blank" rel="noopener">rewrite_by_lua*</a>code is run (and also at the <code>rewrite</code> phase). Similarly, if only <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#content_by_lua" target="_blank" rel="noopener">content_by_lua</a> is specified, the request body will not be read until the content handler’s Lua code is about to run (i.e., the request body will be read during the content phase).</p>
<p>It is recommended however, to use the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxreqread_body" target="_blank" rel="noopener">ngx.req.read_body</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxreqdiscard_body" target="_blank" rel="noopener">ngx.req.discard_body</a> functions for finer control over the request body reading process instead.</p>
<p>This also applies to <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#access_by_lua" target="_blank" rel="noopener">access_by_lua*</a>.</p>
<h2><span id="ssl_certificate_by_lua_block">ssl_certificate_by_lua_block</span></h2><p><strong>syntax:</strong> <em>ssl_certificate_by_lua_block { lua-script }</em></p>
<p><strong>context:</strong> <em>server</em></p>
<p><strong>phase:</strong> <em>right-before-SSL-handshake</em></p>
<p>This directive runs user Lua code when NGINX is about to start the SSL handshake for the downstream SSL (https) connections.</p>
<p>It is particularly useful for setting the SSL certificate chain and the corresponding private key on a per-request basis. It is also useful to load such handshake configurations nonblockingly from the remote (for example, with the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsockettcp" target="_blank" rel="noopener">cosocket</a> API). And one can also do per-request OCSP stapling handling in pure Lua here as well.</p>
<p>Another typical use case is to do SSL handshake traffic control nonblockingly in this context, with the help of the <a href="https://github.com/openresty/lua-resty-limit-traffic" target="_blank" rel="noopener">lua-resty-limit-traffic#readme</a> library, for example.</p>
<p>One can also do interesting things with the SSL handshake requests from the client side, like rejecting old SSL clients using the SSLv3 protocol or even below selectively.</p>
<p>The <a href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl.md" target="_blank" rel="noopener">ngx.ssl</a> and <a href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ocsp.md" target="_blank" rel="noopener">ngx.ocsp</a> Lua modules provided by the <a href="https://github.com/openresty/lua-resty-core/#readme" target="_blank" rel="noopener">lua-resty-core</a> library are particularly useful in this context. You can use the Lua API offered by these two Lua modules to manipulate the SSL certificate chain and private key for the current SSL connection being initiated.</p>
<p>This Lua handler does not run at all, however, when NGINX/OpenSSL successfully resumes the SSL session via SSL session IDs or TLS session tickets for the current SSL connection. In other words, this Lua handler only runs when NGINX has to initiate a full SSL handshake.</p>
<p>Below is a trivial example using the <a href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl.md" target="_blank" rel="noopener">ngx.ssl</a> module at the same time:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name   test.com;</span><br><span class="line"></span><br><span class="line">    ssl_certificate_by_lua_block &#123;</span><br><span class="line">        print(&quot;About to initiate a new SSL handshake!&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>See more complicated examples in the <a href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl.md" target="_blank" rel="noopener">ngx.ssl</a> and <a href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ocsp.md" target="_blank" rel="noopener">ngx.ocsp</a> Lua modules’ official documentation.</p>
<p>Uncaught Lua exceptions in the user Lua code immediately abort the current SSL session, so does the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxexit" target="_blank" rel="noopener">ngx.exit</a> call with an error code like <code>ngx.ERROR</code>.</p>
<p>This Lua code execution context <em>does</em> support yielding, so Lua APIs that may yield (like cosockets, sleeping, and “light threads”) are enabled in this context.</p>
<p>Note, however, you still need to configure the <a href="http://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_certificate" target="_blank" rel="noopener">ssl_certificate</a> and <a href="http://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_certificate_key" target="_blank" rel="noopener">ssl_certificate_key</a> directives even though you will not use this static certificate and private key at all. This is because the NGINX core requires their appearance otherwise you are seeing the following error while starting NGINX:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx: [emerg] no ssl configured for the server</span><br></pre></td></tr></table></figure>
<p>This directive currently requires the following NGINX core patch to work correctly:</p>
<p><a href="http://mailman.nginx.org/pipermail/nginx-devel/2016-January/007748.html" target="_blank" rel="noopener">http://mailman.nginx.org/pipermail/nginx-devel/2016-January/007748.html</a></p>
<p>The bundled version of the NGINX core in OpenResty 1.9.7.2 (or above) already has this patch applied.</p>
<p>Furthermore, one needs at least OpenSSL 1.0.2e for this directive to work.</p>
<p>This directive was first introduced in the <code>v0.10.0</code> release.</p>
<h2><span id="ssl_certificate_by_lua_file">ssl_certificate_by_lua_file</span></h2><p><strong>syntax:</strong> <em>ssl_certificate_by_lua_file <path-to-lua-script-file></path-to-lua-script-file></em></p>
<p><strong>context:</strong> <em>server</em></p>
<p><strong>phase:</strong> <em>right-before-SSL-handshake</em></p>
<p>Equivalent to <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ssl_certificate_by_lua_block" target="_blank" rel="noopener">ssl_certificate_by_lua_block</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or, as from the <code>v0.5.0rc32</code> release, the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lualuajit-bytecode-support" target="_blank" rel="noopener">Lua/LuaJIT bytecode</a> to be executed.</p>
<p>When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p>
<p>This directive was first introduced in the <code>v0.10.0</code> release.</p>
<h2><span id="ssl_session_fetch_by_lua_block">ssl_session_fetch_by_lua_block</span></h2><p><strong>syntax:</strong> <em>ssl_session_fetch_by_lua_block { lua-script }</em></p>
<p><strong>context:</strong> <em>http</em></p>
<p><strong>phase:</strong> <em>right-before-SSL-handshake</em></p>
<p>This directive runs Lua code to look up and load the SSL session (if any) according to the session ID provided by the current SSL handshake request for the downstream.</p>
<p>The Lua API for obtaining the current session ID and loading a cached SSL session data is provided in the <a href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl/session.md" target="_blank" rel="noopener">ngx.ssl.session</a> Lua module shipped with the <a href="https://github.com/openresty/lua-resty-core#readme" target="_blank" rel="noopener">lua-resty-core</a> library.</p>
<p>Lua APIs that may yield, like <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsleep" target="_blank" rel="noopener">ngx.sleep</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsockettcp" target="_blank" rel="noopener">cosockets</a>, are enabled in this context.</p>
<p>This hook, together with the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ssl_session_store_by_lua_block" target="_blank" rel="noopener">ssl_session_store_by_lua*</a> hook, can be used to implement distributed caching mechanisms in pure Lua (based on the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsockettcp" target="_blank" rel="noopener">cosocket</a> API, for example). If a cached SSL session is found and loaded into the current SSL connection context, SSL session resumption can then get immediately initiated and bypass the full SSL handshake process which is very expensive in terms of CPU time.</p>
<p>Please note that TLS session tickets are very different and it is the clients’ responsibility to cache the SSL session state when session tickets are used. SSL session resumptions based on TLS session tickets would happen automatically without going through this hook (nor the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ssl_session_store_by_lua_block" target="_blank" rel="noopener">ssl_session_store_by_lua*</a> hook). This hook is mainly for older or less capable SSL clients that can only do SSL sessions by session IDs.</p>
<p>When <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ssl_certificate_by_lua_block" target="_blank" rel="noopener">ssl_certificate_by_lua*</a> is specified at the same time, this hook usually runs before <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ssl_certificate_by_lua_block" target="_blank" rel="noopener">ssl_certificate_by_lua*</a>. When the SSL session is found and successfully loaded for the current SSL connection, SSL session resumption will happen and thus bypass the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ssl_certificate_by_lua_block" target="_blank" rel="noopener">ssl_certificate_by_lua*</a> hook completely. In this case, NGINX also bypasses the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ssl_session_store_by_lua_block" target="_blank" rel="noopener">ssl_session_store_by_lua*</a> hook, for obvious reasons.</p>
<p>To easily test this hook locally with a modern web browser, you can temporarily put the following line in your https server block to disable the TLS session ticket support:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssl_session_tickets off;</span><br></pre></td></tr></table></figure>
<p>But do not forget to comment this line out before publishing your site to the world.</p>
<p>If you are using the <a href="http://openresty.org/en/linux-packages.html" target="_blank" rel="noopener">official pre-built packages</a> for <a href="https://openresty.org/" target="_blank" rel="noopener">OpenResty</a> 1.11.2.1 or later, then everything should work out of the box.</p>
<p>If you are using OpenSSL libraries not provided by <a href="https://openresty.org/" target="_blank" rel="noopener">OpenResty</a>, then you need to apply the following patch for OpenSSL 1.0.2h or later:</p>
<p><a href="https://github.com/openresty/openresty/blob/master/patches/openssl-1.0.2h-sess_set_get_cb_yield.patch" target="_blank" rel="noopener">https://github.com/openresty/openresty/blob/master/patches/openssl-1.0.2h-sess_set_get_cb_yield.patch</a></p>
<p>If you are not using the NGINX core shipped with <a href="https://openresty.org/" target="_blank" rel="noopener">OpenResty</a> 1.11.2.1 or later, then you need to apply the following patch to the standard NGINX core 1.11.2 or later:</p>
<p><a href="http://openresty.org/download/nginx-1.11.2-nonblocking_ssl_handshake_hooks.patch" target="_blank" rel="noopener">http://openresty.org/download/nginx-1.11.2-nonblocking_ssl_handshake_hooks.patch</a></p>
<p>This directive was first introduced in the <code>v0.10.6</code> release.</p>
<p>Note that: this directive is only allowed to used in <strong>http context</strong> from the <code>v0.10.7</code> release (because SSL session resumption happens before server name dispatch).</p>
<h2><span id="ssl_session_fetch_by_lua_file">ssl_session_fetch_by_lua_file</span></h2><p><strong>syntax:</strong> <em>ssl_session_fetch_by_lua_file <path-to-lua-script-file></path-to-lua-script-file></em></p>
<p><strong>context:</strong> <em>http</em></p>
<p><strong>phase:</strong> <em>right-before-SSL-handshake</em></p>
<p>Equivalent to <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ssl_session_fetch_by_lua_block" target="_blank" rel="noopener">ssl_session_fetch_by_lua_block</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or rather, the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lualuajit-bytecode-support" target="_blank" rel="noopener">Lua/LuaJIT bytecode</a> to be executed.</p>
<p>When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p>
<p>This directive was first introduced in the <code>v0.10.6</code> release.</p>
<p>Note that: this directive is only allowed to used in <strong>http context</strong> from the <code>v0.10.7</code> release (because SSL session resumption happens before server name dispatch).</p>
<h2><span id="ssl_session_store_by_lua_block">ssl_session_store_by_lua_block</span></h2><p><strong>syntax:</strong> <em>ssl_session_store_by_lua_block { lua-script }</em></p>
<p><strong>context:</strong> <em>http</em></p>
<p><strong>phase:</strong> <em>right-after-SSL-handshake</em></p>
<p>This directive runs Lua code to fetch and save the SSL session (if any) according to the session ID provided by the current SSL handshake request for the downstream. The saved or cached SSL session data can be used for future SSL connections to resume SSL sessions without going through the full SSL handshake process (which is very expensive in terms of CPU time).</p>
<p>Lua APIs that may yield, like <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsleep" target="_blank" rel="noopener">ngx.sleep</a> and <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsockettcp" target="_blank" rel="noopener">cosockets</a>, are <em>disabled</em> in this context. You can still, however, use the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxtimerat" target="_blank" rel="noopener">ngx.timer.at</a>API to create 0-delay timers to save the SSL session data asynchronously to external services (like <code>redis</code> or <code>memcached</code>).</p>
<p>The Lua API for obtaining the current session ID and the associated session state data is provided in the <a href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl/session.md#readme" target="_blank" rel="noopener">ngx.ssl.session</a> Lua module shipped with the <a href="https://github.com/openresty/lua-resty-core#readme" target="_blank" rel="noopener">lua-resty-core</a> library.</p>
<p>To easily test this hook locally with a modern web browser, you can temporarily put the following line in your https server block to disable the TLS session ticket support:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssl_session_tickets off;</span><br></pre></td></tr></table></figure>
<p>But do not forget to comment this line out before publishing your site to the world.</p>
<p>This directive was first introduced in the <code>v0.10.6</code> release.</p>
<p>Note that: this directive is only allowed to used in <strong>http context</strong> from the <code>v0.10.7</code> release (because SSL session resumption happens before server name dispatch).</p>
<h2><span id="ssl_session_store_by_lua_file">ssl_session_store_by_lua_file</span></h2><p><strong>syntax:</strong> <em>ssl_session_store_by_lua_file <path-to-lua-script-file></path-to-lua-script-file></em></p>
<p><strong>context:</strong> <em>http</em></p>
<p><strong>phase:</strong> <em>right-after-SSL-handshake</em></p>
<p>Equivalent to <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ssl_session_store_by_lua_block" target="_blank" rel="noopener">ssl_session_store_by_lua_block</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or rather, the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lualuajit-bytecode-support" target="_blank" rel="noopener">Lua/LuaJIT bytecode</a> to be executed.</p>
<p>When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p>
<p>This directive was first introduced in the <code>v0.10.6</code> release.</p>
<p>Note that: this directive is only allowed to used in <strong>http context</strong> from the <code>v0.10.7</code> release (because SSL session resumption happens before server name dispatch).</p>
<h2><span id="lua_shared_dict">lua_shared_dict</span></h2><p><strong>syntax:</strong> <em>lua_shared_dict <name> <size></size></name></em></p>
<p><strong>default:</strong> <em>no</em></p>
<p><strong>context:</strong> <em>http</em></p>
<p><strong>phase:</strong> <em>depends on usage</em></p>
<p>Declares a shared memory zone, <code>&lt;name&gt;</code>, to serve as storage for the shm based Lua dictionary <code>ngx.shared.&lt;name&gt;</code>.</p>
<p>Shared memory zones are always shared by all the nginx worker processes in the current nginx server instance.</p>
<p>The <code>&lt;size&gt;</code> argument accepts size units such as <code>k</code> and <code>m</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    lua_shared_dict dogs 10m;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The hard-coded minimum size is 8KB while the practical minimum size depends on actual user data set (some people start with 12KB).</p>
<p>See <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxshareddict" target="_blank" rel="noopener">ngx.shared.DICT</a> for details.</p>
<p>This directive was first introduced in the <code>v0.3.1rc22</code> release.</p>
<h2><span id="lua_socket_connect_timeout">lua_socket_connect_timeout</span></h2><p><strong>syntax:</strong> <em>lua_socket_connect_timeout <time></time></em></p>
<p><strong>default:</strong> <em>lua_socket_connect_timeout 60s</em></p>
<p><strong>context:</strong> <em>http, server, location</em></p>
<p>This directive controls the default timeout value used in TCP/unix-domain socket object’s <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#tcpsockconnect" target="_blank" rel="noopener">connect</a> method and can be overridden by the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#tcpsocksettimeout" target="_blank" rel="noopener">settimeout</a> or <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#tcpsocksettimeouts" target="_blank" rel="noopener">settimeouts</a> methods.</p>
<p>The <code>&lt;time&gt;</code> argument can be an integer, with an optional time unit, like <code>s</code> (second), <code>ms</code> (millisecond), <code>m</code> (minute). The default time unit is <code>s</code>, i.e., “second”. The default setting is <code>60s</code>.</p>
<p>This directive was first introduced in the <code>v0.5.0rc1</code> release.</p>
<h2><span id="lua_socket_send_timeout">lua_socket_send_timeout</span></h2><p><strong>syntax:</strong> <em>lua_socket_send_timeout <time></time></em></p>
<p><strong>default:</strong> <em>lua_socket_send_timeout 60s</em></p>
<p><strong>context:</strong> <em>http, server, location</em></p>
<p>Controls the default timeout value used in TCP/unix-domain socket object’s <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#tcpsocksend" target="_blank" rel="noopener">send</a> method and can be overridden by the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#tcpsocksettimeout" target="_blank" rel="noopener">settimeout</a> or <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#tcpsocksettimeouts" target="_blank" rel="noopener">settimeouts</a> methods.</p>
<p>The <code>&lt;time&gt;</code> argument can be an integer, with an optional time unit, like <code>s</code> (second), <code>ms</code> (millisecond), <code>m</code> (minute). The default time unit is <code>s</code>, i.e., “second”. The default setting is <code>60s</code>.</p>
<p>This directive was first introduced in the <code>v0.5.0rc1</code> release.</p>
<h2><span id="lua_socket_send_lowat">lua_socket_send_lowat</span></h2><p><strong>syntax:</strong> <em>lua_socket_send_lowat <size></size></em></p>
<p><strong>default:</strong> <em>lua_socket_send_lowat 0</em></p>
<p><strong>context:</strong> <em>http, server, location</em></p>
<p>Controls the <code>lowat</code> (low water) value for the cosocket send buffer.</p>
<h2><span id="lua_socket_read_timeout">lua_socket_read_timeout</span></h2><p><strong>syntax:</strong> <em>lua_socket_read_timeout <time></time></em></p>
<p><strong>default:</strong> <em>lua_socket_read_timeout 60s</em></p>
<p><strong>context:</strong> <em>http, server, location</em></p>
<p><strong>phase:</strong> <em>depends on usage</em></p>
<p>This directive controls the default timeout value used in TCP/unix-domain socket object’s <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#tcpsockreceive" target="_blank" rel="noopener">receive</a> method and iterator functions returned by the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#tcpsockreceiveuntil" target="_blank" rel="noopener">receiveuntil</a> method. This setting can be overridden by the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#tcpsocksettimeout" target="_blank" rel="noopener">settimeout</a> or <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#tcpsocksettimeouts" target="_blank" rel="noopener">settimeouts</a> methods.</p>
<p>The <code>&lt;time&gt;</code> argument can be an integer, with an optional time unit, like <code>s</code> (second), <code>ms</code> (millisecond), <code>m</code> (minute). The default time unit is <code>s</code>, i.e., “second”. The default setting is <code>60s</code>.</p>
<p>This directive was first introduced in the <code>v0.5.0rc1</code> release.</p>
<h2><span id="lua_socket_buffer_size">lua_socket_buffer_size</span></h2><p><strong>syntax:</strong> <em>lua_socket_buffer_size <size></size></em></p>
<p><strong>default:</strong> <em>lua_socket_buffer_size 4k/8k</em></p>
<p><strong>context:</strong> <em>http, server, location</em></p>
<p>Specifies the buffer size used by cosocket reading operations.</p>
<p>This buffer does not have to be that big to hold everything at the same time because cosocket supports 100% non-buffered reading and parsing. So even <code>1</code> byte buffer size should still work everywhere but the performance could be terrible.</p>
<p>This directive was first introduced in the <code>v0.5.0rc1</code> release.</p>
<h2><span id="lua_socket_pool_size">lua_socket_pool_size</span></h2><p><strong>syntax:</strong> <em>lua_socket_pool_size <size></size></em></p>
<p><strong>default:</strong> <em>lua_socket_pool_size 30</em></p>
<p><strong>context:</strong> <em>http, server, location</em></p>
<p>Specifies the size limit (in terms of connection count) for every cosocket connection pool associated with every remote server (i.e., identified by either the host-port pair or the unix domain socket file path).</p>
<p>Default to 30 connections for every pool.</p>
<p>When the connection pool exceeds the available size limit, the least recently used (idle) connection already in the pool will be closed to make room for the current connection.</p>
<p>Note that the cosocket connection pool is per nginx worker process rather than per nginx server instance, so size limit specified here also applies to every single nginx worker process.</p>
<p>This directive was first introduced in the <code>v0.5.0rc1</code> release.</p>
<h2><span id="lua_socket_keepalive_timeout">lua_socket_keepalive_timeout</span></h2><p><strong>syntax:</strong> <em>lua_socket_keepalive_timeout <time></time></em></p>
<p><strong>default:</strong> <em>lua_socket_keepalive_timeout 60s</em></p>
<p><strong>context:</strong> <em>http, server, location</em></p>
<p>This directive controls the default maximal idle time of the connections in the cosocket built-in connection pool. When this timeout reaches, idle connections will be closed and removed from the pool. This setting can be overridden by cosocket objects’ <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#tcpsocksetkeepalive" target="_blank" rel="noopener">setkeepalive</a> method.</p>
<p>The <code>&lt;time&gt;</code> argument can be an integer, with an optional time unit, like <code>s</code> (second), <code>ms</code> (millisecond), <code>m</code> (minute). The default time unit is <code>s</code>, i.e., “second”. The default setting is <code>60s</code>.</p>
<p>This directive was first introduced in the <code>v0.5.0rc1</code> release.</p>
<h2><span id="lua_socket_log_errors">lua_socket_log_errors</span></h2><p><strong>syntax:</strong> <em>lua_socket_log_errors on|off</em></p>
<p><strong>default:</strong> <em>lua_socket_log_errors on</em></p>
<p><strong>context:</strong> <em>http, server, location</em></p>
<p>This directive can be used to toggle error logging when a failure occurs for the TCP or UDP cosockets. If you are already doing proper error handling and logging in your Lua code, then it is recommended to turn this directive off to prevent data flushing in your nginx error log files (which is usually rather expensive).</p>
<p>This directive was first introduced in the <code>v0.5.13</code> release.</p>
<h2><span id="lua_ssl_ciphers">lua_ssl_ciphers</span></h2><p><strong>syntax:</strong> <em>lua_ssl_ciphers <ciphers></ciphers></em></p>
<p><strong>default:</strong> <em>lua_ssl_ciphers DEFAULT</em></p>
<p><strong>context:</strong> <em>http, server, location</em></p>
<p>Specifies the enabled ciphers for requests to a SSL/TLS server in the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#tcpsocksslhandshake" target="_blank" rel="noopener">tcpsock:sslhandshake</a> method. The ciphers are specified in the format understood by the OpenSSL library.</p>
<p>The full list can be viewed using the “openssl ciphers” command.</p>
<p>This directive was first introduced in the <code>v0.9.11</code> release.</p>
<h2><span id="lua_ssl_crl">lua_ssl_crl</span></h2><p><strong>syntax:</strong> <em>lua_ssl_crl <file></file></em></p>
<p><strong>default:</strong> <em>no</em></p>
<p><strong>context:</strong> <em>http, server, location</em></p>
<p>Specifies a file with revoked certificates (CRL) in the PEM format used to verify the certificate of the SSL/TLS server in the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#tcpsocksslhandshake" target="_blank" rel="noopener">tcpsock:sslhandshake</a> method.</p>
<p>This directive was first introduced in the <code>v0.9.11</code> release.</p>
<h2><span id="lua_ssl_protocols">lua_ssl_protocols</span></h2><p><strong>syntax:</strong> <em>lua_ssl_protocols [SSLv2] [SSLv3] [TLSv1] [TLSv1.1] [TLSv1.2] [TLSv1.3]</em></p>
<p><strong>default:</strong> <em>lua_ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2</em></p>
<p><strong>context:</strong> <em>http, server, location</em></p>
<p>Enables the specified protocols for requests to a SSL/TLS server in the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#tcpsocksslhandshake" target="_blank" rel="noopener">tcpsock:sslhandshake</a> method.</p>
<p>The support for the <code>TLSv1.3</code> parameter requires version <code>v0.10.12</code> <em>and</em> OpenSSL 1.1.1.</p>
<p>This directive was first introduced in the <code>v0.9.11</code> release.</p>
<h2><span id="lua_ssl_trusted_certificate">lua_ssl_trusted_certificate</span></h2><p><strong>syntax:</strong> <em>lua_ssl_trusted_certificate <file></file></em></p>
<p><strong>default:</strong> <em>no</em></p>
<p><strong>context:</strong> <em>http, server, location</em></p>
<p>Specifies a file path with trusted CA certificates in the PEM format used to verify the certificate of the SSL/TLS server in the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#tcpsocksslhandshake" target="_blank" rel="noopener">tcpsock:sslhandshake</a> method.</p>
<p>This directive was first introduced in the <code>v0.9.11</code> release.</p>
<p>See also <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lua_ssl_verify_depth" target="_blank" rel="noopener">lua_ssl_verify_depth</a>.</p>
<h2><span id="lua_ssl_verify_depth">lua_ssl_verify_depth</span></h2><p><strong>syntax:</strong> <em>lua_ssl_verify_depth <number></number></em></p>
<p><strong>default:</strong> <em>lua_ssl_verify_depth 1</em></p>
<p><strong>context:</strong> <em>http, server, location</em></p>
<p>Sets the verification depth in the server certificates chain.</p>
<p>This directive was first introduced in the <code>v0.9.11</code> release.</p>
<p>See also <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#lua_ssl_trusted_certificate" target="_blank" rel="noopener">lua_ssl_trusted_certificate</a>.</p>
<h2><span id="lua_http10_buffering">lua_http10_buffering</span></h2><p><strong>syntax:</strong> <em>lua_http10_buffering on|off</em></p>
<p><strong>default:</strong> <em>lua_http10_buffering on</em></p>
<p><strong>context:</strong> <em>http, server, location, location-if</em></p>
<p>Enables or disables automatic response buffering for HTTP 1.0 (or older) requests. This buffering mechanism is mainly used for HTTP 1.0 keep-alive which relies on a proper <code>Content-Length</code> response header.</p>
<p>If the Lua code explicitly sets a <code>Content-Length</code> response header before sending the headers (either explicitly via <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsend_headers" target="_blank" rel="noopener">ngx.send_headers</a> or implicitly via the first <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxsay" target="_blank" rel="noopener">ngx.say</a> or <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxprint" target="_blank" rel="noopener">ngx.print</a> call), then the HTTP 1.0 response buffering will be disabled even when this directive is turned on.</p>
<p>To output very large response data in a streaming fashion (via the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxflush" target="_blank" rel="noopener">ngx.flush</a> call, for example), this directive MUST be turned off to minimize memory usage.</p>
<p>This directive is turned <code>on</code> by default.</p>
<p>This directive was first introduced in the <code>v0.5.0rc19</code> release.</p>
<h2><span id="rewrite_by_lua_no_postpone">rewrite_by_lua_no_postpone</span></h2><p><strong>syntax:</strong> <em>rewrite_by_lua_no_postpone on|off</em></p>
<p><strong>default:</strong> <em>rewrite_by_lua_no_postpone off</em></p>
<p><strong>context:</strong> <em>http</em></p>
<p>Controls whether or not to disable postponing <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#rewrite_by_lua" target="_blank" rel="noopener">rewrite_by_lua*</a> directives to run at the end of the <code>rewrite</code> request-processing phase. By default, this directive is turned off and the Lua code is postponed to run at the end of the <code>rewrite</code> phase.</p>
<p>This directive was first introduced in the <code>v0.5.0rc29</code> release.</p>
<h2><span id="access_by_lua_no_postpone">access_by_lua_no_postpone</span></h2><p><strong>syntax:</strong> <em>access_by_lua_no_postpone on|off</em></p>
<p><strong>default:</strong> <em>access_by_lua_no_postpone off</em></p>
<p><strong>context:</strong> <em>http</em></p>
<p>Controls whether or not to disable postponing <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#access_by_lua" target="_blank" rel="noopener">access_by_lua*</a> directives to run at the end of the <code>access</code> request-processing phase. By default, this directive is turned off and the Lua code is postponed to run at the end of the <code>access</code> phase.</p>
<p>This directive was first introduced in the <code>v0.9.20</code> release.</p>
<h2><span id="lua_transform_underscores_in_response_headers">lua_transform_underscores_in_response_headers</span></h2><p><strong>syntax:</strong> <em>lua_transform_underscores_in_response_headers on|off</em></p>
<p><strong>default:</strong> <em>lua_transform_underscores_in_response_headers on</em></p>
<p><strong>context:</strong> <em>http, server, location, location-if</em></p>
<p>Controls whether to transform underscores (<code>_</code>) in the response header names specified in the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxheaderheader" target="_blank" rel="noopener">ngx.header.HEADER</a> API to hypens (<code>-</code>).</p>
<p>This directive was first introduced in the <code>v0.5.0rc32</code> release.</p>
<h2><span id="lua_check_client_abort">lua_check_client_abort</span></h2><p><strong>syntax:</strong> <em>lua_check_client_abort on|off</em></p>
<p><strong>default:</strong> <em>lua_check_client_abort off</em></p>
<p><strong>context:</strong> <em>http, server, location, location-if</em></p>
<p>This directive controls whether to check for premature client connection abortion.</p>
<p>When this directive is on, the ngx_lua module will monitor the premature connection close event on the downstream connections and when there is such an event, it will call the user Lua function callback (registered by <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxon_abort" target="_blank" rel="noopener">ngx.on_abort</a>) or just stop and clean up all the Lua “light threads” running in the current request’s request handler when there is no user callback function registered.</p>
<p>According to the current implementation, however, if the client closes the connection before the Lua code finishes reading the request body data via <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxreqsocket" target="_blank" rel="noopener">ngx.req.socket</a>, then ngx_lua will neither stop all the running “light threads” nor call the user callback (if <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxon_abort" target="_blank" rel="noopener">ngx.on_abort</a> has been called). Instead, the reading operation on <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxreqsocket" target="_blank" rel="noopener">ngx.req.socket</a> will just return the error message “client aborted” as the second return value (the first return value is surely <code>nil</code>).</p>
<p>When TCP keepalive is disabled, it is relying on the client side to close the socket gracefully (by sending a <code>FIN</code> packet or something like that). For (soft) real-time web applications, it is highly recommended to configure the <a href="http://tldp.org/HOWTO/TCP-Keepalive-HOWTO/overview.html" target="_blank" rel="noopener">TCP keepalive</a> support in your system’s TCP stack implementation in order to detect “half-open” TCP connections in time.</p>
<p>For example, on Linux, you can configure the standard <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#listen" target="_blank" rel="noopener">listen</a> directive in your <code>nginx.conf</code> file like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listen 80 so_keepalive=2s:2s:8;</span><br></pre></td></tr></table></figure>
<p>On FreeBSD, you can only tune the system-wide configuration for TCP keepalive, for example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># sysctl net.inet.tcp.keepintvl=2000</span><br><span class="line"># sysctl net.inet.tcp.keepidle=2000</span><br></pre></td></tr></table></figure>
<p>This directive was first introduced in the <code>v0.7.4</code> release.</p>
<p>See also <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxon_abort" target="_blank" rel="noopener">ngx.on_abort</a>.</p>
<h2><span id="lua_max_pending_timers">lua_max_pending_timers</span></h2><p><strong>syntax:</strong> <em>lua_max_pending_timers <count></count></em></p>
<p><strong>default:</strong> <em>lua_max_pending_timers 1024</em></p>
<p><strong>context:</strong> <em>http</em></p>
<p>Controls the maximum number of pending timers allowed.</p>
<p>Pending timers are those timers that have not expired yet.</p>
<p>When exceeding this limit, the <a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown#ngxtimerat" target="_blank" rel="noopener">ngx.timer.at</a> call will immediately return <code>nil</code> and the error string “too many pending timers”.</p>
<p>This directive was first introduced in the <code>v0.8.0</code> release.</p>
<h2><span id="lua_max_running_timers">lua_max_running_timers</span></h2><p><strong>syntax:</strong> <em>lua_max_running_timers <count></count></em></p>
<p><strong>default:</strong> <em>lua_max_running_timers 256</em></p>
<p><strong>context:</strong> <em>http</em></p>
<p>Controls the maximum number of “running timers” allowed.</p>
<p>Running timers are those timers whose user callback functions are still running.</p>
<p>When exceeding this limit, Nginx will stop running the callbacks of newly expired timers and log an error message “N lua_max_running_timers are not enough” where “N” is the current value of this directive.</p>
<p>This directive was first introduced in the <code>v0.8.0</code> release.</p>
<h2><span id="lua_sa_restart">lua_sa_restart</span></h2><p><strong>syntax:</strong> <em>lua_sa_restart on|off</em></p>
<p><strong>default:</strong> <em>lua_sa_restart on</em></p>
<p><strong>context:</strong> <em>http</em></p>
<p>When enabled, this module will set the <code>SA_RESTART</code> flag on nginx workers signal dispositions.</p>
<p>This allows Lua I/O primitives to not be interrupted by nginx’s handling of various signals.</p>
<p>This directive was first introduced in the <code>v0.10.14</code> release</p>

                </div>
            </div>
    
            <nav class="post-pagination">
    
    <a class="newer-posts" href="/2018/03/02/nginx动态流控/">
        前の記事<br>Nginx和OpenResty的动态流控
    </a>
    
    <span class="page-number"></span>
    
    <a class="older-posts" href="/2018/03/01/nginx-lua-API/">
        次の記事<br>nginx-lua-API
    </a>
    
</nav>

    
            


        </div>
    </div>
    <div class="single-column-footer">
    Proudly published with Hexo<br>
    
    Theme <a href="https://github.com/SumiMakito/hexo-theme-journal/" target="_blank" rel="noreferrer noopener">Journal.</a> by <a href="https://mak1t0.cc/" target="_blank" rel="noreferrer noopener">Makito</a><br>
    
    &copy; 2018 <a href="http://yoursite.com">javfa&#39;s blog</a>
</div>
</div>

</div>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.14.4/dist/umd/popper.min.js" integrity="sha256-EGs9T1xMHdvM1geM8jPpoo8EZ1V1VRsmcJz8OByENLA=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.1.3/dist/js/bootstrap.min.js" integrity="sha256-VsEqElsCHSGmnmHXGQzvoWjWwoznFSZc6hs7ARLRacQ=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.min.js" integrity="sha256-FtWfRI+thWlNz2sB3SJbwKx5PgMyKIVgwHCTwa3biXc=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/smooth-scroll@14.2.1/dist/smooth-scroll.polyfills.min.js" integrity="sha256-CI4Gq5E0io1Pv0xM3qPM+NUIOhbIBvC3GiN1Y4KhXpw=" crossorigin="anonymous"></script>
<script src="/js/journal.js?97431037"></script>



</body>
</html>
