

<!DOCTYPE html>
<html lang xmlns:v-bind="http://www.w3.org/1999/xhtml">

<head><meta name="generator" content="Hexo 3.8.0">
    <title>运维体系管理 - javfa&#39;s blog</title>
<meta charset="utf-8">
<meta name="X-UA-Compatible" content="IE=edge">
<meta name="author" content="Javfa">
<meta name="description" content="

微服务架构时代，运维体系建设要以应用为核心。
应用的起源
应用模型及关系模型的建立


标准化体系建设
为什么...">
<meta name="keywords" content>

    <meta charset="utf-8">
    <meta name="X-UA-Compatible" content="IE=edge">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <meta content="telephone=no" name="format-detection">
    <meta name="renderer" content="webkit">
    <meta name="theme-color" content="#ffffff">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.1.3/dist/css/bootstrap.min.css" integrity="sha256-eSi1q2PG6J7g7ib17yAaWMcrr5GrtohYChqibrV7PBE=" crossorigin="anonymous">
<link rel="stylesheet" href="/css/journal.css?68898111">
<script src="/js/loadCSS.js"></script>
<script>
    loadCSS("https://fonts.googleapis.com/css?family=Lora|Montserrat|Fira+Mono|Material+Icons");
    (function (d) {
        var config = {
                kitId: 'dwg1tuc',
                scriptTimeout: 3000,
                async: true
            },
            h = d.documentElement, t = setTimeout(function () {
                h.className = h.className.replace(/\bwf-loading\b/g, "") + " wf-inactive";
            }, config.scriptTimeout), tk = d.createElement("script"), f = false,
            s = d.getElementsByTagName("script")[0], a;
        h.className += " wf-loading";
        tk.src = 'https://use.typekit.net/' + config.kitId + '.js';
        tk.async = true;
        tk.onload = tk.onreadystatechange = function () {
            a = this.readyState;
            if (f || a && a != "complete" && a != "loaded") return;
            f = true;
            clearTimeout(t);
            try {
                Typekit.load(config)
            } catch (e) {
            }
        };
        s.parentNode.insertBefore(tk, s)
    })(document);
</script>
<noscript>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora|Montserrat|Anonymous+Pro:400|Material+Icons">
</noscript>
</head>
<body>
<div id="top"></div>
<div id="app">
<div class="single-column-drawer-container" ref="drawer" v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }">
    <div class="drawer-content">
        <div class="drawer-menu">
            <a class="a-block drawer-menu-item false" href="http://yoursite.com">
                首页
            </a>
            <a class="a-block drawer-menu-item false" href="/archives">
                归档
            </a>

            
            

            
        </div>
    </div>
</div>
<transition name="fade">
    <div v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if="isDrawerOpen" v-on:click="toggleDrawer"></div>
</transition>
<nav ref="navBar" class="navbar sticky-top navbar-light single-column-nav-container">
    <div ref="navBackground" class="nav-background"></div>
    <div class="container container-narrow nav-content">
        <button id="nav_dropdown_btn" class="nav-dropdown-toggle" type="button" v-on:click="toggleDrawer">
            <i class="material-icons">
                menu
            </i>
        </button>
        <a ref="navTitle" class="navbar-brand" href="/">
            javfa&#39;s blog
        </a>
    </div>
</nav>
<div class="single-column-header-container" ref="pageHead" v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }">
    <a href="/">
        <div class="single-column-header-title">javfa&#39;s blog</div>
        <div class="single-column-header-subtitle"></div>
    </a>
</div>
<div ref="sideContainer" class="side-container">
    <a class="a-block nav-head false" href="/">
        <div class="nav-title">
            {博客@家發}
        </div>
        <div class="nav-subtitle">
            隻言片語<br>於此匯聚
        </div>
    </a>

    <div class="nav-link-list">
        <a class="a-block no-tint nav-link-item false" href="/archives">
            归档
        </a>

        
        

        
    </div>

    
    <div class="nav-footer">
        Proudly published with Hexo<br>
        
        Theme <a href="https://github.com/SumiMakito/hexo-theme-journal/" target="_blank" rel="noreferrer noopener">Journal.</a> by <a href="https://mak1t0.cc/" target="_blank" rel="noreferrer noopener">Makito</a><br>
        
        &copy; 2019 <a href="http://yoursite.com">javfa&#39;s blog</a>
    </div>
</div>
<div ref="extraContainer" class="extra-container">
    <div class="pagination">
        <a id="globalBackToTop" class="pagination-action animated-visibility" href="#top" :class="{ invisible: scrollY == 0 }">
            <i class="material-icons pagination-action-icon">
                keyboard_arrow_up
            </i>
        </a>

        
    </div>
</div>

<div ref="streamContainer" class="stream-container">
    <div class="post-list-container post-list-container-shadow">
        <div class="post">
            <div class="post-head-wrapper-text-only" style="background-image: url('')">
                <div class="post-title">
                    运维体系管理
                    <div class="post-meta">
                        <time datetime="2018-02-21T12:51:23.000Z" itemprop="datePublished">
                            2018-02-21 20:51
                        </time>&nbsp;
                        
    
                        
                        
                        <i class="material-icons" style>label</i>
                        
                        <a href="/tags/运维/">运维</a>
                        
                        
                    </div>
                </div>
            </div>
    
            <div class="post-body-wrapper">
                <div class="post-body">
                    <!-- toc -->
<ul>
<li><a href="#微服务架构时代运维体系建设要以应用为核心">微服务架构时代，运维体系建设要以应用为核心。</a><ul>
<li><a href="#应用的起源">应用的起源</a></li>
<li><a href="#应用模型及关系模型的建立">应用模型及关系模型的建立</a></li>
</ul>
</li>
<li><a href="#标准化体系建设">标准化体系建设</a><ul>
<li><a href="#为什么要做标准化">为什么要做标准化？</a></li>
<li><a href="#基础设施层面的标准化">基础设施层面的标准化</a></li>
<li><a href="#应用层面的标准化">应用层面的标准化</a></li>
<li><a href="#基础架构的标准化">基础架构的标准化</a><ul>
<li><a href="#常见的分布式基础架构组件">常见的分布式基础架构组件</a></li>
<li><a href="#基础架构组件的选型问题">基础架构组件的选型问题</a></li>
<li><a href="#其中运维的职责">其中运维的职责</a></li>
</ul>
</li>
<li><a href="#基础架构的服务化">基础架构的服务化</a><ul>
<li><a href="#为什么要做基础架构的服务化">为什么要做基础架构的服务化</a></li>
<li><a href="#运维的职责">运维的职责</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#如何从生命周期的视角看待应用运维体系建设">如何从生命周期的视角看待应用运维体系建设</a><ul>
<li><a href="#应用的生命周期分析">应用的生命周期分析</a></li>
</ul>
</li>
<li><a href="#cmdb">CMDB</a><ul>
<li><a href="#cmdb缘起">CMDB缘起</a></li>
<li><a href="#传统运维思路下的cmdb">传统运维思路下的CMDB</a></li>
<li><a href="#互联网运维体系下的cmdb">互联网运维体系下的CMDB</a></li>
</ul>
</li>
<li><a href="#如何在cmdb中落地应用的概念">如何在CMDB中落地应用的概念？</a><ul>
<li><a href="#如何有效组织和管理应用">如何有效组织和管理应用</a></li>
<li><a href="#应用的集群服务分组建设">应用的集群服务分组建设</a></li>
<li><a href="#cmdb在基础服务体系中的核心位置">CMDB在基础服务体系中的核心位置</a></li>
</ul>
</li>
<li><a href="#持续交付">持续交付</a><ul>
<li><a href="#什么是持续交付">什么是持续交付？</a></li>
<li><a href="#持续交付的关键点">持续交付的关键点</a></li>
<li><a href="#配置管理">配置管理</a><ul>
<li><a href="#版本控制">版本控制</a></li>
<li><a href="#依赖管理">依赖管理</a></li>
<li><a href="#软件配置">软件配置</a></li>
</ul>
</li>
<li><a href="#多环境建设">多环境建设</a></li>
<li><a href="#线上环境建设">线上环境建设</a></li>
<li><a href="#持续交付中的流水线模式">持续交付中的流水线模式</a></li>
</ul>
</li>
<li><a href="#混合云">混合云</a><ul>
<li><a href="#关于混合云">关于混合云</a></li>
</ul>
</li>
<li><a href="#面向应用层的云架构解决方案">面向应用层的云架构解决方案</a></li>
<li><a href="#cdn和云存储-云生态">CDN和云存储 云生态</a></li>
<li><a href="#页面静态化架构和二级cdn建设">页面静态化架构和二级CDN建设</a></li>
<li><a href="#弹性伸缩">弹性伸缩</a><ul>
<li><a href="#弹性伸缩的主体是谁">弹性伸缩的主体是谁？</a></li>
</ul>
</li>
<li><a href="#稳定性保障">稳定性保障</a></li>
<li><a href="#容量规划">容量规划</a></li>
<li><a href="#限流降级">限流降级</a></li>
<li><a href="#开关预案">开关预案</a></li>
<li><a href="#全链路跟踪">全链路跟踪</a></li>
<li><a href="#故障">故障</a></li>
<li><a href="#安全">安全</a></li>
</ul>
<!-- tocstop -->
<h1><span id="微服务架构时代运维体系建设要以应用为核心">微服务架构时代，运维体系建设要以应用为核心。</span></h1><blockquote>
<p>在微服务的架构模式下，我们的运维视角一定转到应用这个核心概念上来，一切要以应用的角度分析和看待问题。</p>
</blockquote>
<h2><span id="应用的起源">应用的起源</span></h2><p>微服务架构一般都是从单体架构或分层架构演进而来。软件架构服务化的过程，就是我们根据业务模型进行细化的过程，在这个过程中切分出一个个具备不同职责的业务逻辑模块，然后每个微服务模块都会提供相应业务逻辑的服务化接口。</p>
<p>解释简单点，就一个字，拆！从一个单体工程，拆分出N个独立模块。这些模块都可以独立部署和运行，并提供对应的业务能力。拆分后的模块数量与业务体量和复杂度相关，少则几个、十几个，多则几十、几百个，所以为了统一概念，我们通常称这些模块为应用。</p>
<p>为了确保每个应用的唯一性，我们给每个应用定义一个唯一的标识符，这个唯一标识符我们称之为应用名。</p>
<p>这个定义为应用的概念，将成为我们微服务架构管理的核心概念。</p>
<h2><span id="应用模型及关系模型的建立">应用模型及关系模型的建立</span></h2><p>上面我们定义出来的一个个应用，都是从业务角度入手进行拆分细化出来的业务逻辑单元。它虽然可以独立部署和运行，但是每一个应用都只具备相对单一的业务职能。如果要完成整体的业务流程和目标，就需要和周边其它的服务化应用交互。同时，这个过程中还需要依赖各种与业务无直接关系、相对独立的基础设施和组件，比如机器资源、域名、DB、缓存、消息队列等等</p>
<p>所以，除了应用这个实体之外，还会存在其他各类基础组件实体。同时。在应用运行过程中，还需要不断地与他们产生和建立各种各样复杂的关联关系，这也为我们后续的运维带来很多困难。</p>
<p>我们要做的就是应用模型以及各种关系模型的梳理和建立，因为只有模型和关系梳理清楚了，才能为我们后面一系列的运维自动化、持续交付以及稳定性保障打下一个良好基础。</p>
<ol>
<li><p>应用业务模型</p>
<p>应用业务模型，也就是每个应用对外提供的业务服务能力，并以API的方式暴露给外部。<br>这个业务模型通常都是业务架构师在进行业务需求分析和拆解时进行设计，更多的时聚焦在业务逻辑上，所以从运维的角度，我们一般不会关注太多。</p>
</li>
<li><p>应用管理模型</p>
<p>应用管理模型，也就是应用自身的各种属性，如应用名、应用功能信息、责任人、Git地址、部署结构（代码路径、日志路径以及各类配置文件路径等）、启停方式、健康检测方式等待。这其中，应用名时应用的唯一标识，我们用AppName来表示。</p>
</li>
<li><p>应用运行时所依赖的基础设施和组件</p>
<ul>
<li>资源层面：应用运行所必需的资源载体有物理机、虚拟机或容器等，如果对外提供HTTP服务，及需要VIP和DNS域名服务；</li>
<li>基础组件：这一部分其实就是我们所说的中间件体系，不如应用运行过程中必然要存储和访问数据，这就需要有数据库和数据库中间件；想要更快访问数据，同时减轻DB的访问压力，就需要缓存；应用之间如果需要数据交互或同步，就需要消息队列；如果进行文件存储和访问，就需要存储系统等等。</li>
</ul>
<p>从这里我们可以挖掘出一条规律，那就是这些基础设施和组件都是为上层的一个个业务应用所服务的。也正是因为业务和应用上的需求，才开启了它们各自的生命周期。如果脱离了这些业务应用，它们之间并没有单纯存在的意义。所以，从始至终基础设施和组件都跟应用这个概念保持着紧密的联系。</p>
<p>理清了这个思路，我们再去梳理它们之间的关系就会顺畅很多，分为两步：</p>
<ul>
<li>第一步，建立各个基础设施和组件的数据模型，同时识别出它们的唯一标识。这个套路跟应用管理模型的梳理类似，以典型的缓存为例，每当我们申请一个缓存空间时，通常会以NameSpace来标识唯一命名，同时这个缓存空间会有空间容量和Paritition分区等信息。</li>
<li>第二步，识别出基础设施及组件可以与应用名AppName建立关联关系的属性，或者在基础组件的数据模型中增加所属应用这样的字段。</li>
</ul>
</li>
</ol>
<blockquote>
<p>微服务架构模式下的运维思路一定要转变，一定要将视角转换到应用这个维度，从一开始就要统一规划，从一开始就要将架构、开发和运维的工作拉通了去看，这一点是与传统运维的思路完全不同的。<strong>规划以应用为核心的运维管理体系</strong></p>
</blockquote>
<h1><span id="标准化体系建设">标准化体系建设</span></h1><p>标准化工作是运维过程中最基础、最重要的，但也是最容易忽视的一个环节。</p>
<p><strong>标准先行</strong></p>
<p>我们运维工作的开展常常不知从何下手，或者上来就冲着工具和自动化去了，却始终不得章法，工具做了一堆，效率却并没有提升。其实绝大多数情况下，问题和原因就是标准化这个基础工作没做扎实。</p>
<p>为何标准化这个事情如此重要呢？</p>
<h2><span id="为什么要做标准化">为什么要做标准化？</span></h2><p><strong>标准化的过程实际上就是对运维对象的识别和建模的过程</strong>。形成统一的对象模型后，各方在统一的认识下展开有效协作，然后针对不同的运维对象，再抽取出它们所对应的运维场景，接下来才是运维场景的自动化实现。</p>
<p>这有点像我们学的面向对象编程的思想，其实我们就是需要遵循这样一个思路，我们面对的就是一个个实体和逻辑运维对象。</p>
<p>在标准化的过程中，先识别出各个运维对象，然后我们日常做的所有运维工作，都应该是针对这些对象的运维。如果运维操作脱离了对象，那就没有任何意义。同样，没有理清对象，运维自然不得章法。</p>
<p>比如我们说扩容，那就要先确定这里到底是服务器的扩容，还是应用的扩容，还是其他对象的扩容。你会发现，对象不同，扩容这个场景所实施的动作是完全不一样的。</p>
<p>Nginx自动扩容，怎么做？</p>
<p>如果把服务器的扩容套用到应用的扩容上去，必然会导致流程错乱。同时对于对象理解上的不一致，也会徒增无谓的沟通成本，造成效率低下。自然地，这种情况下的运维自动化不但不能提升效率，还会越自动越混乱。</p>
<p><strong>标准先行</strong>，于纷繁复杂中抽象出标准规范的东西，是我们后续一系列自动化和稳定性保障的基础。</p>
<p>标准化的套路：</p>
<ul>
<li>第一步，识别对象；</li>
<li>第二步，识别对象属性；</li>
<li>第三步，识别对象关系；</li>
<li>第四步，识别对象场景。</li>
</ul>
<p>按照这个思路，来分析从基础设施层面和应用层面应该识别出哪些运维对象。</p>
<h2><span id="基础设施层面的标准化">基础设施层面的标准化</span></h2><ul>
<li>第一步，识别实体对象，主要有服务器、网络、IDC、机柜、存储、配件等。</li>
<li>第二步，识别对象的属性，比如服务器就会有SN序列号、IP地址、厂商、硬件配置（如CPU、内存、硬盘、网卡、PCIE、BIOS）、维保信息等；网络设备如交换机也会有厂商、型号、带宽等信息。</li>
<li>第三步，识别对象之间的关系，比如服务器所在的机柜，虚拟机所在的宿主机、机柜所在的IDC等简单关系；复杂一点就会有核心交换机、汇聚交换机、接入交换机以及机柜和服务器之间的级联关系等，这些相对复杂一些，也就是我们常说的网络拓扑关系。</li>
</ul>
<p>把以上信息梳理清楚，通过ER建模工具进行数据建模，再将以上的信息固化到DB中，一个资源层面的信息管理平台就基本成型了。</p>
<p>但是，信息固化不是目的，也没有价值，只有信息动态流转起来才有价值。接下来，我们需要做的事情，就是识别出针对运维对象所实施的日常运维操作有哪些，也就是识别出运维场景是什么。</p>
<ul>
<li>第四步，还是以服务器为例，针对服务器的日常操作有采购、入库、安装、配置、上线、下线、维修等等。另外，可能还会有可视化和查询的场景，如拓扑关系的可视化和动态展示，交换机和服务器之间的级联关系、状态（正常or故障）的展示等，这样可以很直观地关注到资源节点的状态。</li>
</ul>
<p>完成了这些工作，接下来才是对上述场景的自动化开发。所以，在真正执行去做工具和自动化平台之前，其实是需要做好大量的基础准备工作的。</p>
<h2><span id="应用层面的标准化">应用层面的标准化</span></h2><ul>
<li>第一步，识别对象。<br>这个识别的过程是在做微服务架构设计和拆分的时候就确定下来的。所以严格地讲，它不应该是运维阶段才被识别出来的，而是在之前设计阶段就被识别和确认下来，然后延申到运维这里才对。</li>
<li><p>第二步，识别对象属性<br>一个应用是业务的抽象逻辑，所以会有业务和运维两个维度的属性。业务属性在业务架构时确定，这主要是需要业务架构师去识别的，但是它的运维属性就应该由运维来识别了。</p>
<p>一个应用应该具备哪些基本的运维属性呢？</p>
<ul>
<li><strong>应用的元数据属性</strong>，也就是简单直接地描述一个应用的信息，如应用名、应用Owner、所属业务、是否核心链路应用以及应用功能说明等，这里关键是应用名；</li>
<li><strong>应用代码属性</strong>，主要是编程语言及版本（决定了后续的构建方式），GitLab地址；</li>
<li><strong>应用部署模式</strong>，涉及到基础软件包，如语言包Java、C++、Go等；容器如Tomcat、JBoss等；</li>
<li><strong>应用目录信息</strong>，如运维脚本目录、日志目录、应用包目录、临时目录等；</li>
<li><strong>应用运行脚本</strong>，如启停脚本、健康检测脚本；</li>
<li><strong>应用运行时的参数配置</strong>，如运行端口、Java的JVM参数GC方式、新生代、老生代、永生代的堆内存大小配置等。</li>
</ul>
</li>
<li><p>第三步，识别对象关系</p>
<ul>
<li>第一类是应用与基础设施的关系，包括应用与资源、应用与VIP、应用与DNS等等的关系；</li>
<li>第二类是平行层面的应用与应用之间的关系，这里再细分下去就是应用服务或API与其他应用服务和API的依赖关系。全链路就是这样的工具平台，是用来处理应用间关系管理的。</li>
<li>第三类是应用与各类基础组件之间的关系，比如应用与缓存、应用与消息、应用与DB等等之间的关系。</li>
</ul>
</li>
<li><p>第四步，识别应用的运维场景。<br>应用创建、持续集成、持续发布、扩容、缩容、监控等；再复杂点的比如容量评估、压测、限流降级等。</p>
</li>
</ul>
<h2><span id="基础架构的标准化">基础架构的标准化</span></h2><h3><span id="常见的分布式基础架构组件">常见的分布式基础架构组件</span></h3><ul>
<li>分布式服务化框架，业界开源产品比如Dubbo、Spring Cloud这样的框架；</li>
<li>分布式缓存及框架，业界如Redid、Memcached，框架如Codis和Redis Cluster；</li>
<li>数据库及分布式数据库框架，这两者密不可分，数据库如Mysql、MariaDB等，中间件如淘宝TDDL、Sharding-JDBC等。当前非常火热的TiDB，就直接实现了分布式数据库的功能，不再额外选择中间件框架；</li>
<li>分布式的消息中间件，业界如Kafka、RbbitMQ、Active MQ以及RocketMQ等；</li>
<li>前端接入层部分，如四层负载LVS、七层负载Nginx或Apache，再比如硬件负载F5等</li>
</ul>
<h3><span id="基础架构组件的选型问题">基础架构组件的选型问题</span></h3><p>关于基础架构组件，业界可供我们选择的解决方案和产品非常多，选择多了反而不知道从何入手了。这么多的开源产品到底该选哪一个呢？</p>
<p>按正常的思路，一定是先组织选型调研，然后进行方案验证和对比，最后确认统一的解决方案。</p>
<p>要对基础架构由统一的规划和建设。原则上，每种基础组件只允许一种选型，至少就能满足90%甚至更多的应用场景。</p>
<p>比如数据库就只允许使用MySQL，然后版本统一，同时配套的中间件也必须统一，其他的关系型数据库没有特殊情况坚决不允许使用，如果遇到特殊情况具体分析。</p>
<h3><span id="其中运维的职责">其中运维的职责</span></h3><p>参与制定基础架构标准，并强势约束。</p>
<p>在这里运维作为线上稳定的Owner，发挥约束作用有可能会比业务架构师的角色更为有效。另外，由于历史原因或者其他种种因素造成的已有架构标准不统一的问题，是需要开发和运维共同合作去改造的。这里面如何保持良好的协作，制定统一的线路图也是非常重要的。所以这里强制约束是一方面，同时也要提供工具化的手段来支持开发的改造。</p>
<h2><span id="基础架构的服务化">基础架构的服务化</span></h2><h3><span id="为什么要做基础架构的服务化">为什么要做基础架构的服务化</span></h3><p>对基础架构组件做了统一标准之后，下一步要做的就是服务化。因为这些组件都只提供了简单的维护功能，还有很多都是命令行层面的维护，这时我们要做的就是把这些组件提供的维护API进行封装，以提供更加便捷的运维能力。</p>
<p>这里以Redis缓存为例：</p>
<ul>
<li>创建和容量申请；</li>
<li>容量的扩容和缩容，新增分片的服务发现以及访问路由配置；</li>
<li>运行指标监控，如QPS、TPS、存储数据数量等等；</li>
<li>主备切换能力等等。</li>
</ul>
<p>以上这些，假设都只是依赖Redis提供的原生能力来做，基本是不可维护的。所以必须要基于这些原生能力进行封装，结合运维场景，讲能力服务化，这样就大大提升了使用方的便利性。</p>
<p>同时，我们也可以看到，这个服务化的过程其实就是PaaS化的过程。换言之，如果我们能把基础架构组件服务化完成，我们的Paas平台就基本成型了。</p>
<h3><span id="运维的职责">运维的职责</span></h3><p><strong>基础架构的服务化平台开发，目标是平台自助化，让开发依赖平台的能力自助完成对基础组件的需求，而不是依赖运维的人</strong>。这个事情是驱动运维转型和改进的动力，也是运维能够深入了解架构组件细节的有效途径。</p>
<h1><span id="如何从生命周期的视角看待应用运维体系建设">如何从生命周期的视角看待应用运维体系建设</span></h1><h2><span id="应用的生命周期分析">应用的生命周期分析</span></h2><p>在一个场景下有多个对象时，就一定要找到那个核心的运维对象，这个核心对象的生命周期就会涵盖其他附属运维对象的子生命周期。在整个运维体系中，或者说软件运行阶段的核心对象，就是应用。</p>
<p>以应用为本。对应用的生命周期阶段进行分解，大致分为五个部分：</p>
<ol>
<li><p>应用的创建阶段</p>
<p>这个阶段最重要的工作，是确认应用的基础信息和与基础服务的关系，要同时固化下来，从应用创建之初，就讲应用与各类基础服务的生命周期进行挂钩。<br>对于同一类的应用，只需要做一次标准化即可，后续完全可以形成模板固化到工具平台上。<br>同时，另外一个很重要的工作，就是要开启与应用相关的各类基础服务的生命周期。比如这个应用需要用到缓存、消息队列和DB等，也可能需要DNS服务、VIP配置等，这些就要从应用创建这个动作延申出去，启动这些关联基础服务的创建。</p>
</li>
<li><p>应用的研发阶段</p>
<p>主要是业务逻辑实现和验证的阶段。针对业务逻辑层面的场景就是开发代码和质量保证，但是这个过程中就会涉及的代码的提交合并、编译打包以及在不同环境下的发布部署过程。同时，开发和测试在不同的环境下进行各种类型的测试，比如单元测试、集成测试以及系统测试等等，这整个过程就是我们常说的持续集成。</p>
<p>所以，这个阶段，我们要做的最重要的一个事情，就是为研发团队打造完善的持续集成体系和工具链支持。</p>
</li>
<li><p>应用的上线阶段</p>
<p>这是个过渡阶段，从应用创建过渡到线上运行。创建阶段，应用的基础信息和基础服务都已经到位，接下来就是申请到应用运行的服务器资源，然后将应用软件包发布上线运行，这个动作在下面的运行阶段也会持续迭代。</p>
</li>
<li><p>应用的运行阶段</p>
<p>这是应用生命周期中最重要、最核心的阶段。<br>从运维角度来看，应用在线上运行起来之后就已经变成一个线上运行的进程，那这个进程形态的应用应该有什么样的属性呢？</p>
<p>这个时候需要应用线上运行的各种指标的输出。这个阶段，应用最重要的属性就是应用本身以及相关联的基础服务的各项运行指标。</p>
<p>这里，我们需要制定每个运维对象的SLI、SLO和SLA，同时要建设能够对这些指标进行监控和报警的监控体系。</p>
<p>从业务角度看，应用是线上业务逻辑的执行载体，但是我们的业务需求是在不断变化和迭代的，所以就需要不断地去迭代更新我们的线上应用，这里仍然会依赖到上述应用研发阶段的持续集成过程，并最终与线上发布形成持续交付这样一个闭环体系。</p>
<p>从运行阶段应用的关系看，除了它跟基础服务之间相对固化的关系外，应用跟应用、以及应用包含的服务之间的调用关系也非常重要，而且这个关系可能随时都在变化。这个时候，我们应用之间依赖管理和链路跟踪的场景就出现了。</p>
<p>同时，应用线上运行还会面临外部业务量的各种异常变化，以及应用自身所依赖的基础实施、基础服务以及应用服务的各种异常状况。</p>
</li>
<li><p>应用的销毁阶段</p>
<p>如果应用的业务职责不存在了，应用就可以下线销毁了。但是，这里不仅仅是应用自身要销毁，围绕着某个应用所产生出来的基础设施、基础服务以及关联关系都要一并清理，否则将会给系统中造成许多无源的资源浪费。</p>
</li>
</ol>
<p>结合之前所讲的标准化内容，我们就找到了做运维架构的切入点，套路也就有了，总结一下就是：</p>
<p><strong>从生命周期入手，划分阶段，提炼属性，理清关系，固化基础信息，实现运维场景。</strong></p>
<p>在思考问题和设计解决方案的时候，一定要从实际出发、从问题出发、从基础出发，理清自己的需求和痛点，然后再去寻求解决方案。</p>
<p>借鉴业界思路，千万不要一上来就去套用别人的解决方案。因为别人的思路和解决方案往往是建立在一个非常稳固的基础之上的，而这些基础，往往因为太基础而一带而过，甚至是略去不讲的。一旦忽略了这一点，再优秀的解决方案也是无源之水、无本之木，是实现不了的。</p>
<h1><span id="cmdb">CMDB</span></h1><p>当我们识别出运维对象和对象之间的关系，并形成了统一的标准之后，接下来要做的事情就是将这些标准固化，固化到某个信息管理平台中，也就是我们常说的配置管理，也就是CMDB（Configuration Management DataBase）。</p>
<h2><span id="cmdb缘起">CMDB缘起</span></h2><p>CMDB并不是一个新概念，它源于ITIL（Information Technology Infrastructure Library）。而ITIL这套理论体系在80年代末就已经成型，并在当时和后来的企业IT建设中作为服务管理的指导理论得到广泛推广和实施。</p>
<h2><span id="传统运维思路下的cmdb">传统运维思路下的CMDB</span></h2><p>按照ITIL的定义：</p>
<blockquote>
<p>CMDB，配置管理数据库，是与IT系统所有组件相关的信息库，它包含IT基础架构配置项的详细信息。</p>
</blockquote>
<p>这是一个很宽泛的概念描述，实际上并不具备可落地的指导意义。</p>
<p>同时，CMDB是与每个企业具体的IT软硬件环境、组织架构和流程强相关的，这就决定了CMDB一定是高度定制化的体系。虽然我们都知道它不仅仅是一个存储信息的数据库那么简单，但是它的具体形态是什么样子的，并没有统一的标准。</p>
<p>从传统IT运维的角度来看，运维的核心对象是资源层面，所谓的基础架构也就是网络设备和硬件设备这个层面；各种关联和拓扑关系，基本也是从服务器的视角去看。所以更多地，我们是把CMDB建设成为一个以设备为中心的信息管理平台。</p>
<p>这也是当前绝大多数公司在建设运维平台时最优先的切入点，因为这些运维对象都是实体存在的，是最容易被识别的和管理的；像应用和分布式中间件这种抽象的逻辑对象反而是不容易被识别的。</p>
<p>这种形态，如果是在软件架构变化不大的情况下，比如单体或分层架构，以服务器为中心去建设是没有问题的。因为无论设备数量也好，还是申请回收这些变更也好，都是很有限的，也就是整个IT基础设施的形态变化不大。</p>
<p>在早期，并没有太多人提及CMDB，也没有人提出把它作为核心部件去建设，在当时，CMDB这个概念并不具备实践意义，管理的方式方法也就停留在原始的Excel表格中。</p>
<p>高大上的ITIL体系更多的是被当作流程规范来落地的，真正体现在技术方案和技术产品上的落地并不多。</p>
<h2><span id="互联网运维体系下的cmdb">互联网运维体系下的CMDB</span></h2><p>进入互联网时代，随着互联网运维力量的崛起，CMDB这个概念也真正得到了落地实践，从理论概念的方法论阶段过渡到了具备具体技术方案的可实施阶段，而且得到了业界的持续分享和传播。</p>
<p>不过，值得注意的是，“此CMDB”已经非“彼CMDB”。传统运维阶段，我们更多是以设备为核心进行管理，都是到了互联网技术阶段，这个核心就变了，变成了应用这个核心对象。</p>
<p>至于原因，主要还是互联网技术的快速发展，大大推进了微服务技术架构的落地和实践，这种场景下，应用各维度的管理复杂度、应用的复杂度就逐渐体现出来了，所以我们的很多运维场景就开始围绕着应用来开展。</p>
<p>与此同时，云计算技术也在蓬勃发展，逐步屏蔽了IDC、网络设备以及硬件服务器这样的底层基础设施的复杂度，有公有云或私有云厂商来专注聚焦这些问题，让我们的运维不必再花过多的精力在这些基础设施上面；同时，单纯以硬件为核心的CMDB形态也被逐步弱化。</p>
<p>所以，此时的CMDB，仍然可以叫做配置管理数据库，但是这个配置管理的外延已经发生了很大的变化。之前所指的简单的硬件资源配置管理，只能算是狭义的理解；从广义上讲，当前的应用以及以应用为核心的分布式服务化框架、缓存、消息、DB、接入层等基础组件，都应该纳入这个配置管理的范畴。</p>
<p>所以在这个时期，我们提到的运维自动化，远不是自动化的服务器安装部署交付或网络自动化配置这种单一场景，而是出现了持续交付、DevOps、SRE等更适合这个时代的对运维职责的定义和新的方法论。</p>
<h1><span id="如何在cmdb中落地应用的概念">如何在CMDB中落地应用的概念？</span></h1><h2><span id="如何有效组织和管理应用">如何有效组织和管理应用</span></h2><p>微服务架构下会有很多应用产生出来，少则十几、几十个，多则上百甚至上千个。这时我们面临的第一个问题就是如何有效地组织和管理这些应用，而不是让它们在各处散乱，命名方式和层次结构可能还不统一。</p>
<p>用”服务树”，有效组织和管理应用的方式，就是把它组织成一个树形的层次结构。</p>
<p>基于业务维度的拆分，对应产生了我们的应用拆分原则。比如对于电商公司，大的维度会有电商、支付、广告、流量和搜索等业务领域；进一步，电商业务领域里最典型的会有用户、会员、商品、交易、商家、店铺以及物流等；这里面还可以再进一步细分，比如商品会有详情、SKU、SPU、库存、评价、标签等。</p>
<p>讲到这里，我们在看一下技术团队的组织架构，基本上是对应着整个业务技术架构的拆分的。<strong>也就是业务架构决定了技术架构</strong>，<strong>而技术架构又决定了一个研发团队的组织架构</strong>，这个组织架构中不同的团队单元分别承担着对应业务的需求开发和实现职责。</p>
<p>上面这个组织架构建设的逻辑和思路，也是我们在组建团队和职责划分时可以参考的。</p>
<p>这样一个逻辑讲下来，我们的应用管理思路其实也就明晰了：产品线-业务团队-应用。</p>
<p>对于应用名定义，要设定规范。</p>
<p>到了软件运维阶段，运维工作是否可以高效地组织开展，很大程度上，在前面的业务架构拆分阶段就决定了。也就是业务架构拆分得是否合理、职责是否明晰，决定了后续团队组织架构是否合理、团队职责是否明晰。如果这点没做好，到了运维阶段必然就是混乱的。</p>
<h2><span id="应用的集群服务分组建设">应用的集群服务分组建设</span></h2><p>为什么会有集群服务分组呢？我们来看这么几个需求场景。</p>
<ul>
<li><p>场景一：多环境问题</p>
<p>我们常见的环境会有开发联调环境、集成测试环境、预发环境、线上环境等等。</p>
</li>
<li><p>场景二：多IDC问题</p>
<p>对于大型互联网业务，会做业务单元化，或者有海外业务拓展需求的场景，我们会在多个IDC机房部署应用，应用代码是相同的，但是配置可能会不同。</p>
</li>
<li><p>场景三：多服务分组问题</p>
<p>这个场景就跟具体业务场景相关了。举个例子，比如商品中心IC这样一个核心应用，对外会有商品详情、交易下单、订单、购物车、评价、广告、秒杀活动、会场活动、商家、店铺等一系列应用依赖它，但是这些依赖它的应用优先级是不一样的。</p>
<ul>
<li>核心应用和非核心应用：比如交易支付链路上的应用属于核心应用，任何时候都必须要优先保障，但是对于评价、商家和店铺这些应用优先级就低一些。发过来理解就是一个应用出现故障，是不是会影响业务收入，如果影响就属于核心应用，如果不是或者影响非常小，那就属于非核心应用。所以IC这个应用下面，就会有IC的交易分组，IC的广告分组、IC的电商分组，这些分组就会相对固定和静态。</li>
<li>场景因素决定：这个对于电商就会比较典型，比如大促时的秒杀场景，对于参加秒杀活动的商品，瞬时的访问量就会非常大，而不参加活动的商品就不会有这么大的访问量。所以这时为了隔离较大的流量，就需要有多个不同的秒杀IC分组，从资源层面进行隔离；同时上层秒杀活动的应用在配置中心配置依赖时，就要配置到对应的秒杀IC集群分组上，这样即使秒杀IC出现问题，也不会影响正常的商品IC访问。所以根据场景，不同阶段就会有IC的大促秒杀分组，这种类型的分组就需要根据实际的业务场景来决定，是个动态调整的过程，需要开发和运维一起来讨论和验证。</li>
</ul>
</li>
</ul>
<h2><span id="cmdb在基础服务体系中的核心位置">CMDB在基础服务体系中的核心位置</span></h2><p>以应用为核心，CMDB中会保存“应用-分组-资源”的对应关系，这个关系对于周边系统来说都是需要的，举例如下：</p>
<ol>
<li><p>监控系统</p>
<p>我们需要以上的对应关系，监控到每个应用、每个集群以及每台机器上的关键信息。</p>
</li>
<li><p>发布系统</p>
<p>我们需要讲每个应用对应的代码进行编译打包，然后发布到对应集群的主机上，也需要这个对应关系。</p>
</li>
<li><p>服务化框架</p>
<p>需要依赖应用和集群分组两个信息，其中主要是对应用名和集群分组名的依赖，对于服务化框架来说，更多的是通过其配置管理中心注册的应用名，来实现应用的服务和API管理，这里要做到与CMDB统一。同样，像LVS和Nginx这样的四七层负载，以及ZK这样的开源分布式配置管理，凡是涉及服务注册、服务发现以及服务上下线的基础服务，都是类似思路。</p>
</li>
<li><p>基础服务中</p>
<p>如分布式DB、分布式缓存和消息等，就需要应用的应用名，以及应用与资源IP的对应关系，或者集群分组与IP的对应关系。</p>
<ul>
<li>应用名，是因为要建立应用与分布式服务实例之间的关系。如应用与缓存NamSpace的对应关系，应用与消息Topic的对应关系等，以便于这些基础服务的生命周期管理和自动化开发。</li>
<li>应用与资源的对应关系，是因为有些核心资源是要做ACL访问控制的。比如对于用户、交易或支付这样非常敏感的数据，它们对应的数据库就不允许随意连接，而应该是仅限于授权过的应用访问。这时就要针对应用对应的IP地址进行白名单配置。一方面，可以通过分布式DB中间件进行配置；另一方面，也可以通过在DB层面进行设置，比如MySQL就可以直接配置白名单策略；同时也可以在机器的iptables上配置，至于如何配置就看具体需求了，但是无论怎样，应用与资源的对应关系是非常重要的。</li>
</ul>
</li>
<li><p>稳定性保障平台，或者叫访问治理平台</p>
<p>针对系统的稳定性，我们会在应用中做很多的降级限流和开关预案策略，这些都是跟应用直接关联的。而且按照我们前面介绍的，不同的集群分组，策略可能会有不同，所以又会跟集群分组相关。同时，这些策略最终下发到具体服务器上运行的应用实例上，所以这里就会需要应用、集群分组以及对应的资源关系。</p>
</li>
</ol>
<h1><span id="持续交付">持续交付</span></h1><p>前面，我们介绍了非常基础的运维建设环节。如果我们想要这些运维基础建设发挥更大的作用和价值，就需要针对运维场景进行场景化设计和自动化，让效率和稳定性真正提升上来。</p>
<p>基础的事情做好之后，我们就要进入效率提升的运维场景自动化阶段了。</p>
<p>这一阶段，首先要把持续交付做好。</p>
<p>为什么要先做持续交付？如果说我们完成了一些运维职责范围内的自动化工具，提升的是运维效率的话，那么，<strong>做持续交付就是提升整个研发体系效率的关键</strong>。</p>
<p>做持续交付的价值表现在哪里？</p>
<p>持续交付覆盖了应用的整个生命周期，涉及产品、开发、测试、运维以及项目管理等相关方面。从生命周期出发，自然就会牵出整个自动化的全貌，就会有从全局着眼的规划设计，这时无论是在开发还是运维过程中存在的问题，都会完完整整地暴露出来。那么，应该以什么样的主线开展？各方应该如何配合？应该以怎样的优先级明确任务？这些问题就都清楚了。同时，也避免了各个环节只把注意力放在各自职责范围内的事情上，而忽略了整体的配合。所以，做好持续交付，对于整个研发体系意义重大。</p>
<p>我们面临的实际场景是怎样的呢？</p>
<p>我们知道，随着业务复杂度的升高，不管是分层架构，还是微服务架构，都会带来一个最明显的变化，那就是应用数量增多，有时甚至多达几十个、几百个。不同的应用就有不同的代码、依赖和配置，为了协同多应用之间的在线发布，我们还要做到服务能够平滑地进行上下线切换。同时，为了最大限度地降低发布风险，我们还需要继续多环境下的验证，以及上线后的灰度策略等等。</p>
<p>应对这一切，如果只是手工维护，或者利用简单的脚本进行维护，都不能保证正常运作。这个时候，我们必须有一系列的流程、机制和工具链来支持和保障。</p>
<h2><span id="什么是持续交付">什么是持续交付？</span></h2><p><strong>持续交付代表着从业务需求开始到交付上线之后的端到端的过程</strong>。（业务/产品、开发、测试、运维的协作）</p>
<h2><span id="持续交付的关键点">持续交付的关键点</span></h2><ol>
<li><p>配置管理</p>
<p>这一部分会利用到我们前面讲过的标准化和CMDB打下的基础，同时还会有更大的外延，比如环境配置、代码配置以及依赖管理等等。</p>
<p>配置管理是非常关键的基础工作。有一点值得注意，那就是标准化是一个持续的过程。我们不太可能在一开始就把所有运维对象、属性和关系全部考虑清楚，面面俱到是不太现实的，所以，一定要具备标准化的意识，在开展运维工作的过程中，持续不断地用这个思路去标准化新出现的对象。先标准，再固化，如何自动化。</p>
</li>
<li><p>需求拆解</p>
<p>需求拆解这个工作跟业务需求部门和业务开发有更直接的关系。在这里，运维需要做的是，明确需求拆解的粒度和我们最终发布上线的粒度相匹配。</p>
</li>
<li><p>提交管理</p>
<p>需求拆解完成后，就进入到开发阶段，开发完成后向代码库中提交代码，这个过程中代码分支的合并策略选择就是提交管理。</p>
</li>
<li><p>构建打包</p>
<p>这一部分是指将提交的代码编译成可发布的软件包。</p>
</li>
<li><p>自动化测试</p>
<p>自动化测试包括功能测试和非功能性测试。对于运维来说，会更注重非功能方面的特性。</p>
</li>
<li><p>部署发布</p>
<p>这一部分是指发布到不同的环境，如开发环境、预发环境、线上Beta以及线上全量环境。针对不同的环境，发布策略和注意事项也会不同。</p>
</li>
</ol>
<p>配置管理、提交管理、构建和部署发布是持续交付的重中之重，是关键路径，是从开发代码开始，到发布上线的必经之路。当时，因为这个几个环节出现了问题，不能解决，运维同学经常做手工发布，这样效率就跟不上，还经常出现各种问题。后来，我们就是先从这几个环节入手，把阻塞的问题解决掉，然后在这个主流程上不断增加外围能力，让整个流程的功能更加丰富和全面。整个系统也从原来的只具备持续部署发布功能的平台，逐步演进为具有持续交付能力的平台。</p>
<p>下面详细展开说明：</p>
<h2><span id="配置管理">配置管理</span></h2><p>按照持续交付的理念，这里所说的配置管理范围会更广，主要有以下几个部分。</p>
<ul>
<li>版本控制</li>
<li>依赖配置</li>
<li>软件配置</li>
<li>环境配置</li>
</ul>
<p>讲持续交付，一上来就先讲配置管理，主要还是想强调：配置管理是基础，是关键。勿在浮沙筑高台，我们做工具平台或系统，一定要重视基础的建设。</p>
<p>同时，这里还有一个前提，就是一定要做到代码和配置的分离。不要让配置写死在代码里，需要依靠严格的规范和约束。同时，对于那些因历史原因遗留在代码中的配置，要多花时间和精力把配置剥离出来，做这项工作没有什么好的方法或经验，只能多上心，多投入些精力。</p>
<h3><span id="版本控制">版本控制</span></h3><p>版本控制的主要作用是保证团队在交付软件的过程中能够高效协作，版本控制提供了一种保障机制。</p>
<p>版本控制及其工具是必不可少的，因为这是开发团队协作最基础的工具。</p>
<h3><span id="依赖管理">依赖管理</span></h3><p>以Java为例，即使运行一个非常简单的Web应用，都会有大量的jar包依赖。如果人工去管理这些依赖，基本上是不可能的，所以就需要有依赖管理的工具。</p>
<p>对于Java来说，依赖管理工具有Ant、Maven和Gradle。</p>
<p>以Maven为例，大致用法是建立一个本地Maven源，构建时会优先从本地源中获取依赖包，本地源中没有对应的依赖时，会从公网下载，同时缓存到本地。</p>
<h3><span id="软件配置">软件配置</span></h3><ol>
<li><p>代码配置</p>
<p>代码配置是跟代码运行时的业务逻辑相关的。比如应用的服务接口、并发线程数、超时时间等这些运行时参数；还有类似于业务或技术上的开关，比如商品评论是否开放、优惠时间段设置等。</p>
</li>
<li><p>应用配置</p>
<p>应用配置就是应用这个对象的属性和关系信息。我们把应用配置放到持续交付这个场景中进行分析，对于这个配置可以细分为：</p>
<ul>
<li>应用构建时配置，比如它的编程语言、Git地址以及构建方式等；</li>
<li>应用的部署配置，源代码目录、应用日志目录、Web日志目录、临时目录、脚本目录等；</li>
<li>应用的运行配置，应用启停、服务上下线方式、健康检测方式等；</li>
<li>应用运行时与基础组件的关联关系，比如其依赖的DB、缓存、消息以及存储的IP地址、域名、端口、用户名或Token等。</li>
</ul>
</li>
</ol>
<h2><span id="多环境建设">多环境建设</span></h2><h2><span id="线上环境建设">线上环境建设</span></h2><h2><span id="持续交付中的流水线模式">持续交付中的流水线模式</span></h2><h1><span id="混合云">混合云</span></h1><h2><span id="关于混合云">关于混合云</span></h2><p>随着技术趋势的发展，这个概念的内涵和外延也在不断发生着变化。</p>
<p>从字面上理解，混合云即公有云和私有云的混合搭配。</p>
<p>但是随着公有云服务越来越丰富，我们对于公有云的应用也不再仅仅限于资源层面，二更多地体现在云服务层面。</p>
<p>以CDN为例：</p>
<p>我们使用CDN服务，其实是云服务最早被应用的典型形态。在很长时间内，我们并没有意识到这就是云服务。但是，这种使用模式，从云的特性来讲，就是混合云模式。</p>
<p>我们所经历的几个基础设施建设阶段</p>
<ul>
<li><p>第一个阶段，完全托管IDC模式。我们选择与电信运营商或者第三方ISP合作，租赁其IDC机房中的机柜。而其他主机硬件和网络设备都是我们自行采购，然后放入机房中进行托管。</p>
</li>
<li><p>第二个阶段，资源短期租赁模式。因为电商大促的例行化，以及峰值流量的激增，导致我们短时资源需求量庞大。如果再靠一次性采购模式，付出的成本巨大，且后期成本闲置，造成严重的浪费。</p>
<p>我们曾跟运营商或第三方ISP谈过一些短期租赁合作。</p>
<p>这种合作模式，确实帮助我们在资源紧张和成本优化方面，解决了很大的难题。这种模式起到的作用，很大程度上满足了我们对弹性的需求，可以称之为“人肉云”或者“人工云”。</p>
</li>
<li><p>第三个阶段，同城混合云模式。这些年运营商和ISP服务商也在做自己的公有云体系，所以随着他们服务的不断完善，后来为了能够提升交付效率，我们也会尝试使用他们的公有云业务。</p>
<p>同城混合云模式，作为运营商和ISP服务商，他们的云资源可以和我们在同一机房或同城机房。这种模式最大的优势就是可以与我们的IDC网络专线拉通，大大降低网络延时，网络质量相对稳定，同时成本也相对较低。</p>
<p>如果是跨城甚至是跨省，就会频繁发生网络抖动、丢包这些问题。对于时延敏感的服务，是完全满足不了要求的，且微服务间频繁调用产生的大流量带宽需求，成本也是巨大的。</p>
<p>所以这种情况下，虽然公有云的各项产品和服务相对完善，但是如果在对应的城市没有公有云节点，或者距离较远，又或者专线质量不高，就基本没法满足我们规模化使用的场景。</p>
<p>但也不是全部无法满足。通过公有云建设CDN和二级CDN体系，虽然没有专线，但仍然可以满足部分业务场景。</p>
</li>
<li><p>公有云体系内混合云模式。从长远角度考虑，为了能够更加全面和深入地利用好云计算的产品技术，我们整体搬迁到了腾讯云。</p>
<p>这个阶段的初期，我们使用的还是完全独立的物理机资源。这种资源使用模式与之前托管IDC模式相比，除硬件和网络外，操作系统和各项技术栈还完全是由我们自己运维。</p>
<p>之所以这样做，还是为了保证迁移过程的平稳。因为我们自身的技术体系和架构已经非常庞大，也有较高的复杂度。</p>
<p>要想在另外一套基础设施上将这套精密的体系部署、测试、运行起来，同时还要保证各项性能指标以及系统容量不出问题 ，项目难度就已经非常高了。而这样做可以很好地防止软件架构发生变化，避免各种复杂因素交织在一起导致的因为稳定性的不可控。</p>
<p>之前我看到有很多人批评，甚至是贬低这种公有云提供的独立物理机资源的模式，认为这时换汤不换药，或者认为这是技术含量太低、技术水平不足的表现。但是我认为这种理解还是太片面。</p>
<p>单纯从技术角度来讲，这种模式或许没有体现公有云的特性，但是从实际业务场景和实际客户需求来讲却是必要的。而且对于类似蘑菇街这样有着大规模业务体量和复杂技术架构的产品来说，它还满足了用户的过渡需求。</p>
<p>所以，我认为腾讯云在这一方面还是体现了“客户第一”的意识的。</p>
<p>当然，搬迁到腾讯云之后，下一阶段，我们必然会利用更多的云资源和云服务。比如无状态的web服务器或者微服务应用，在大促时完全可以利用云的弹性优势进行快速的资源扩缩容。</p>
<p>但是对于数据库或大数据这样的存储类业务，因为它们本身又是支持业务运行的核心基础设施，所以短期内我们仍然还是采用独占物理机的模式。主要是基于下面两方面进行考量：</p>
<ul>
<li><p>技术架构匹配问题。以数据库为例，我们自研了分布式数据库中间件和大量的工具，比如对分库分表的支持和数据迁移转换等待。还针对具体的业务场景和特性在数据库和操作系统层面做了大量的优化工作，包括但不限于各类参数的调优，以及部分特性定制。</p>
<p>再者，云上资源也无法规模化地满足我们对硬件的特定需求，所以我们在这种模式下，就很难一下子将云服务利用起来，而其他的分布式组件也会存在类似问题。</p>
<p>归根结底，这还是云上的技术体系和原有的业务技术体系不匹配的矛盾所导致的，需要二者花更多的时间来磨合。同时，这也决定了在未来很长一段时间内，混合云模式才是最佳实践模式。</p>
</li>
<li><p>数据安全问题。一些有政策要求或政策限制的业务，需要慎重考虑这个问题。</p>
</li>
</ul>
</li>
</ul>
<p>不管如何选择和使用，我们一定还是要以满足业务场景为出发点，脱离了这一点，单纯准求技术深度和复杂度是没有意义的。</p>
<h1><span id="面向应用层的云架构解决方案">面向应用层的云架构解决方案</span></h1><p>spring Cloud如何解决应用层的云架构问题。</p>
<p>Spring Boot可以快速开发单个微服务应用，SpringCloud则提供一系列的服务治理框架，比如服务注册、服务发现、动态路由、负载均衡以及熔断等等能力，可以将一个个独立的微服务作为一个整体，进行很好的管理和维护。</p>
<p>Spring Cloud框架中云的影子</p>
<h1><span id="cdn和云存储-云生态">CDN和云存储 云生态</span></h1><h1><span id="页面静态化架构和二级cdn建设">页面静态化架构和二级CDN建设</span></h1><h1><span id="弹性伸缩">弹性伸缩</span></h1><h2><span id="弹性伸缩的主体是谁">弹性伸缩的主体是谁？</span></h2><p>做运维和做架构的思路是相通的，我们碰到问题后，一定要找到问题的主体是什么，通过问题找主体，通过主体的特性制定问题的解决方案。</p>
<p>对于运维，一定要准确识别出日常运维过程中不同的运维对象，然后再进一步去分析这个对象所对应的运维场景是什么，进而才是针对运维场景的分解和开发。</p>
<p>弹性伸缩其实是一个运维场景，但是我们并没有定义这个场景的主体是谁。我们来假定以下几种主体：</p>
<ul>
<li><p>服务器的弹性伸缩。针对这个场景，假设业务是运行在私有云或公有云上，那我们只要能够通过云平台的API申请和释放资源，申请时初始化我们的操作系统，释放是销毁资源就可以。不过，在私有云资源下，为了能够保障弹性，我们必须自己提取采购、上架、装机、配置然后交付资源，需要大量的准备工作，公有云上就省去这些步骤，可以即拿即用。</p>
</li>
<li><p>应用的弹性伸缩。这个场景下其实是默认包含第一步的，就是我们首先必须要拿到应用运行的服务器资源才可以，这一步做到了，下面就是应用的部署、启动以及服务上线接入流量。</p>
</li>
<li><p>业务的弹性伸缩。我们可以再进一步思考，通常一个业务可能会包括多个应用，所以为了保障整个业务容量充足，这个时候扩容单个的应用是没有意义的，所以这时要做的就是扩容多个应用，但是这里面就会有一个顺序问题，先扩哪个，后扩哪个，哪些又是可以同时扩容而不会影响业务正常运行的，再进一步，业务承载的服务能力提升了，那网络带宽、缓存、DB等等这些基础设施需不需要也同时扩容呢？</p>
</li>
</ul>
<h1><span id="稳定性保障">稳定性保障</span></h1><h1><span id="容量规划">容量规划</span></h1><h1><span id="限流降级">限流降级</span></h1><h1><span id="开关预案">开关预案</span></h1><h1><span id="全链路跟踪">全链路跟踪</span></h1><h1><span id="故障">故障</span></h1><h1><span id="安全">安全</span></h1>
                </div>
            </div>
    
            <nav class="post-pagination">
    
    <a class="newer-posts" href="/2018/02/23/持续交付/">
        上一篇<br>持续交付
    </a>
    
    <span class="page-number"></span>
    
    <a class="older-posts" href="/2017/03/20/Nginx中SSL的配置/">
        下一篇<br>Nginx中SSL的配置
    </a>
    
</nav>

    
            


        </div>
    </div>
    <div class="single-column-footer">
    Proudly published with Hexo<br>
    
    Theme <a href="https://github.com/SumiMakito/hexo-theme-journal/" target="_blank" rel="noreferrer noopener">Journal.</a> by <a href="https://mak1t0.cc/" target="_blank" rel="noreferrer noopener">Makito</a><br>
    
    &copy; 2018 <a href="http://yoursite.com">javfa&#39;s blog</a>
</div>
</div>

</div>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.14.4/dist/umd/popper.min.js" integrity="sha256-EGs9T1xMHdvM1geM8jPpoo8EZ1V1VRsmcJz8OByENLA=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.1.3/dist/js/bootstrap.min.js" integrity="sha256-VsEqElsCHSGmnmHXGQzvoWjWwoznFSZc6hs7ARLRacQ=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.min.js" integrity="sha256-FtWfRI+thWlNz2sB3SJbwKx5PgMyKIVgwHCTwa3biXc=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/smooth-scroll@14.2.1/dist/smooth-scroll.polyfills.min.js" integrity="sha256-CI4Gq5E0io1Pv0xM3qPM+NUIOhbIBvC3GiN1Y4KhXpw=" crossorigin="anonymous"></script>
<script src="/js/journal.js?16381247"></script>



</body>
</html>
