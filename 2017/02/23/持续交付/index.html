

<!DOCTYPE html>
<html lang xmlns:v-bind="http://www.w3.org/1999/xhtml">

<head><meta name="generator" content="Hexo 3.8.0">
    <title>持续交付 - javfa&#39;s blog</title>
<meta charset="utf-8">
<meta name="X-UA-Compatible" content="IE=edge">
<meta name="author" content="Javfa">
<meta name="description" content="

持续交付的价值
持续交付的定义
持续集成、持续交付和持续部署的关系
持续交付的显性价值
持续交付的隐性价值
如...">
<meta name="keywords" content>

    <meta charset="utf-8">
    <meta name="X-UA-Compatible" content="IE=edge">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <meta content="telephone=no" name="format-detection">
    <meta name="renderer" content="webkit">
    <meta name="theme-color" content="#ffffff">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.1.3/dist/css/bootstrap.min.css" integrity="sha256-eSi1q2PG6J7g7ib17yAaWMcrr5GrtohYChqibrV7PBE=" crossorigin="anonymous">
<link rel="stylesheet" href="/css/journal.css?26680035">
<script src="/js/loadCSS.js"></script>
<script>
    loadCSS("https://fonts.googleapis.com/css?family=Lora|Montserrat|Fira+Mono|Material+Icons");
    (function (d) {
        var config = {
                kitId: 'dwg1tuc',
                scriptTimeout: 3000,
                async: true
            },
            h = d.documentElement, t = setTimeout(function () {
                h.className = h.className.replace(/\bwf-loading\b/g, "") + " wf-inactive";
            }, config.scriptTimeout), tk = d.createElement("script"), f = false,
            s = d.getElementsByTagName("script")[0], a;
        h.className += " wf-loading";
        tk.src = 'https://use.typekit.net/' + config.kitId + '.js';
        tk.async = true;
        tk.onload = tk.onreadystatechange = function () {
            a = this.readyState;
            if (f || a && a != "complete" && a != "loaded") return;
            f = true;
            clearTimeout(t);
            try {
                Typekit.load(config)
            } catch (e) {
            }
        };
        s.parentNode.insertBefore(tk, s)
    })(document);
</script>
<noscript>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora|Montserrat|Anonymous+Pro:400|Material+Icons">
</noscript>
</head>
<body>
<div id="top"></div>
<div id="app">
<div class="single-column-drawer-container" ref="drawer" v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }">
    <div class="drawer-content">
        <div class="drawer-menu">
            <a class="a-block drawer-menu-item false" href="http://yoursite.com">
                首页
            </a>
            <a class="a-block drawer-menu-item false" href="/archives">
                归档
            </a>

            
            

            
        </div>
    </div>
</div>
<transition name="fade">
    <div v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if="isDrawerOpen" v-on:click="toggleDrawer"></div>
</transition>
<nav ref="navBar" class="navbar sticky-top navbar-light single-column-nav-container">
    <div ref="navBackground" class="nav-background"></div>
    <div class="container container-narrow nav-content">
        <button id="nav_dropdown_btn" class="nav-dropdown-toggle" type="button" v-on:click="toggleDrawer">
            <i class="material-icons">
                menu
            </i>
        </button>
        <a ref="navTitle" class="navbar-brand" href="/">
            javfa&#39;s blog
        </a>
    </div>
</nav>
<div class="single-column-header-container" ref="pageHead" v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }">
    <a href="/">
        <div class="single-column-header-title">javfa&#39;s blog</div>
        <div class="single-column-header-subtitle"></div>
    </a>
</div>
<div ref="sideContainer" class="side-container">
    <a class="a-block nav-head false" href="/">
        <div class="nav-title">
            {博客@家發}
        </div>
        <div class="nav-subtitle">
            隻言片語<br>於此匯聚
        </div>
    </a>

    <div class="nav-link-list">
        <a class="a-block no-tint nav-link-item false" href="/archives">
            归档
        </a>

        
        

        
    </div>

    
    <div class="nav-footer">
        Proudly published with Hexo<br>
        
        Theme <a href="https://github.com/SumiMakito/hexo-theme-journal/" target="_blank" rel="noreferrer noopener">Journal.</a> by <a href="https://mak1t0.cc/" target="_blank" rel="noreferrer noopener">Makito</a><br>
        
        &copy; 2019 <a href="http://yoursite.com">javfa&#39;s blog</a>
    </div>
</div>
<div ref="extraContainer" class="extra-container">
    <div class="pagination">
        <a id="globalBackToTop" class="pagination-action animated-visibility" href="#top" :class="{ invisible: scrollY == 0 }">
            <i class="material-icons pagination-action-icon">
                keyboard_arrow_up
            </i>
        </a>

        
    </div>
</div>

<div ref="streamContainer" class="stream-container">
    <div class="post-list-container post-list-container-shadow">
        <div class="post">
            <div class="post-head-wrapper-text-only" style="background-image: url('')">
                <div class="post-title">
                    持续交付
                    <div class="post-meta">
                        <time datetime="2017-02-23T07:46:12.000Z" itemprop="datePublished">
                            2017-02-23 15:46
                        </time>&nbsp;
                        
    
                        
                        
                        <i class="material-icons" style>label</i>
                        
                        <a href="/tags/运维/">运维</a>
                        
                        
                    </div>
                </div>
            </div>
    
            <div class="post-body-wrapper">
                <div class="post-body">
                    <!-- toc -->
<ul>
<li><a href="#持续交付的价值">持续交付的价值</a><ul>
<li><a href="#持续交付的定义">持续交付的定义</a></li>
<li><a href="#持续集成-持续交付和持续部署的关系">持续集成、持续交付和持续部署的关系</a></li>
<li><a href="#持续交付的显性价值">持续交付的显性价值</a></li>
<li><a href="#持续交付的隐性价值">持续交付的隐性价值</a></li>
<li><a href="#如何评估持续交付的价值">如何评估持续交付的价值</a></li>
</ul>
</li>
<li><a href="#影响持续交付的因素">影响持续交付的因素</a><ul>
<li><a href="#组织和文化因素">组织和文化因素</a></li>
<li><a href="#代码分支策略的选择">代码分支策略的选择</a><ul>
<li><a href="#主干开发tbd">主干开发（TBD）</a></li>
<li><a href="#特性分支开发">特性分支开发</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#依赖管理">依赖管理</a></li>
<li><a href="#代码回滚">代码回滚</a><ul>
<li><a href="#什么是代码回滚">什么是代码回滚？</a></li>
<li><a href="#哪些情况下需要回滚代码">哪些情况下需要回滚代码？</a></li>
<li><a href="#哪些情况下包的回滚无需回滚代码">哪些情况下包的回滚无需回滚代码？</a></li>
<li><a href="#代码回滚必须遵循的原则">代码回滚必须遵循的原则</a></li>
<li><a href="#三种典型回滚场景及回滚策略">三种典型回滚场景及回滚策略</a></li>
</ul>
</li>
<li><a href="#测试环境">测试环境</a><ul>
<li><a href="#互联网公司测试环境的结构">互联网公司测试环境的结构</a></li>
<li><a href="#什么是好的测试环境">什么是好的测试环境？</a></li>
<li><a href="#测试环境的成本">测试环境的成本</a></li>
<li><a href="#如何调节效率和成本的矛盾">如何调节效率和成本的矛盾？</a></li>
</ul>
</li>
<li><a href="#环境自描性">环境自描性</a><ul>
<li><a href="#环境一定要标准化">环境一定要标准化</a></li>
<li><a href="#约定大于配置">约定大于配置</a></li>
<li><a href="#让环境自己能开口说话">让环境自己能开口说话</a></li>
</ul>
</li>
<li><a href="#各种配置方法">各种配置方法</a></li>
<li><a href="#分钟级搭建环境">分钟级搭建环境</a><ul>
<li><a href="#环境构建流水线">环境构建流水线</a></li>
</ul>
</li>
<li><a href="#构建提速">构建提速</a></li>
<li><a href="#发布">发布</a><ul>
<li><a href="#发布是持续交付的最后一公里">发布是持续交付的最后一公里</a></li>
<li><a href="#任何变更都需要发布">任何变更都需要发布</a></li>
<li><a href="#发布系统一定要注意用户体验">发布系统一定要注意用户体验</a></li>
<li><a href="#发布系统的核心架构和功能设计">发布系统的核心架构和功能设计</a></li>
</ul>
</li>
<li><a href="#利用监控保障发布质量">利用监控保障发布质量</a></li>
<li><a href="#代码静态检查">代码静态检查</a></li>
<li><a href="#破坏性测试">破坏性测试</a></li>
<li><a href="#自动化回归">自动化回归</a></li>
<li><a href="#平台化设计持续交付">平台化设计持续交付</a></li>
<li><a href="#持续交付中的宝贵数据">持续交付中的宝贵数据</a></li>
<li><a href="#移动app的持续交付生命周期">移动APP的持续交付生命周期</a></li>
<li><a href="#快速构建持续交付系统">快速构建持续交付系统</a><ul>
<li><a href="#需求分析">需求分析</a><ul>
<li><a href="#模拟团队介绍">模拟团队介绍</a></li>
<li><a href="#模拟系统介绍">模拟系统介绍</a></li>
</ul>
</li>
<li><a href="#gitlab解决代码管理问题">Gitlab解决代码管理问题</a></li>
<li><a href="#jenkins解决集成打包问题">Jenkins解决集成打包问题</a></li>
<li><a href="#ansible解决自动部署问题">Ansible解决自动部署问题</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h1><span id="持续交付的价值">持续交付的价值</span></h1><h2><span id="持续交付的定义">持续交付的定义</span></h2><blockquote>
<p>持续交付是软件研发人员，如何将一个好点子，以最快的速度交付给用户的方法。</p>
<p>From 《持续交付：发布可靠软件的系统方法》</p>
</blockquote>
<h2><span id="持续集成-持续交付和持续部署的关系">持续集成、持续交付和持续部署的关系</span></h2><p>我们通常会把软件研发工作拆解，拆分成不同模块或不同团队后进行编码，编码完成后，进行集成构建和测试。这个从编码到构建再到测试的反复持续的过程，就叫做“持续集成”。</p>
<p>“持续集成”一旦完成，则代表产品处于一个可交付的状态，但并不代表这是最优状态，还需要根据外部使用者的反馈逐步优化。当然这里的使用者并不一定是真正的用户，还可能是测试人员、产品人员、用户体验工程师、安全工程师、企业领导等等。</p>
<p>这个“持续集成”之后，获取外部对软件的反馈再通过“持续集成”进行优化的过程就叫做“持续交付”，它是“持续集成”的自然延续。</p>
<p>传统安装型软件，要现场调试，要用户购买等等，其难度可想而知。即使是可达度最高的互联网应用，由于生成环境的多样性、架构的复杂性、影响的广泛性（需要灰度发布）等等，就算产品已是待交付的状态，要真正达到用户可用的标准，还有大量的问题需要解决。</p>
<p>而“持续部署”就是将可交付产品，快速且安全地交付用户使用的一套方法和系统，它是“持续交付”的最后“一公里”。</p>
<h2><span id="持续交付的显性价值">持续交付的显性价值</span></h2><p>持续交付也通常以“发布流水线”的方式来解释，即研发团队从开发，到测试，再到部署，最终将产品交付给最终用户使用的过程。</p>
<p>虽然持续交付着重打造的是发布流水线的部分，但它索要达到的目标是在“最终用户”和“研发团队”之间建立紧密的反馈环：通过持续交付新的软件版本，以验证新想法和软件改动的正确性，并衡量这些改动对软件价值的影响。</p>
<p>这里所说的“软件价值”，就是收入、日活、GMV等KPI指标了。</p>
<p>通常我们在实施持续交付后，都能够做到在保证交付质量的前提下，加快交付速度，从而更快地得到市场反馈，引领产品的方向，最终达到扩大收益的目的。</p>
<p>速度为王的今天，持续交付的能力，正成为评定一家互联网公司研发能力的重要指标。</p>
<h2><span id="持续交付的隐性价值">持续交付的隐性价值</span></h2><p>无论是什么企业，无论你的职位高低，都可以或者应该尝试持续交付，它一定会让你觉得物超所值。</p>
<p>它可以实现的能力：</p>
<ul>
<li><p>解决技术选型的难题</p>
<p>技术选型最大的难点在于影响大，又难以验证（或者验证效率低下）。而造成这些困境的绝大多数原因是没有合适的测试环境，比如环境差异造成测试数据缺乏说服力，又比如缺少隔离环境造成服务冲突等等。而这正是持续交付的用武之地。</p>
<p>持续交付的实施，将全面改善企业对测试环境的关联方法，使得环境管理更合理、更自由。</p>
</li>
<li><p>让制定的标准更好落地：</p>
<p>标准、规范、流程的落地，都需要载体，而最好的载体就是平台工具。而持续交付是一整套平台工具的落地，几乎涵盖了研发的整个生命周期，是天然的、最佳的载体。</p>
<p>另外，持续交付的落地本身伴随着各类标准、规范、流程的制定和实施，可以说两者相互依存，是非常好的管理思想落地方案。</p>
</li>
<li><p>提高跨部门协作的效率</p>
<p>每一个持续交付的实施团队，都可以说是最厉害的“拆墙大队”，拆的就是各个研发协作部门间的“隔离墙”。</p>
<p>持续交付能够向各个协作部门输出统一的标准、流程和工具，提升沟通效率；并且通过大量的自动化，进一步提升各部门工作效率；还可以快速集成，把各个分散的团队，无论是横向的业务研发团队，还是纵向的技术框架团队，紧紧地联系在一起，共同进退。</p>
</li>
<li><p>从容面对故障</p>
<p>任何故障都有一个天敌，叫做：快速恢复。</p>
<p>假设，所有的故障都可以在3分钟内恢复，你是不是觉得天下无敌了。那恢复故障最快、最有效的手段又是什么呢？当然就是回滚（或者重新部署）了，而这正是持续交付所包含和着力打造的能力之一。</p>
</li>
<li><p>让知识能够传承</p>
<p>互联网公司的人才流动之频繁已经远远超过了你我的想象。人来人往，如何将知识传承下来？</p>
<p>持续交付将团队赖以生存的工作流程进行固化；</p>
<p>利用代码静态检查等工具，能够很好地传承团队多年来的代码规范，并作为检查项进行自动化校验；</p>
<p>自动化测试脚本，同样是团队经验的产物。</p>
</li>
<li><p>让团队专注于业务而非工程</p>
<p>持续交付体系也如同中间件一样，能够从日常的业务研发工作中抽象出来，其不同只在于中间件解决架构问题，而持续交付解决工程问题。</p>
<p>这样研发团队能够全力应付业务的需求，而不用总是重复奔波于一些烦人且耗时的工程问题，比如按照测试机、准备编译服务器等等。</p>
</li>
<li><p>让产品经理成为产品真正的第一个用户</p>
<p>持续交付不仅仅是可以保证每一个变化都能及时得到测试以及反馈，更多的是解决测试与实际发布时存在差异的问题。</p>
<p>产品人员将真正成为第一个用户，而不再是最后一个QA。</p>
</li>
<li><p>让产品经理能够完全知悉当前进度和质量</p>
<p>持续交付能够实时地反应当前的开发情况，从而帮助产品人员决策和调整。</p>
</li>
<li><p>产品随时能发布</p>
<p>计划永远赶不上变化，如何产品人员都希望自己的产品能够随时处于可发布状态。这样就灵活地交付已完成的功能，迎合市场或业务的需要。</p>
<p>本质上，<strong>做到代码上线和业务上线的解耦分离</strong>，这也正是交付方法论强调的一个重点。</p>
</li>
<li><p>可以让程序员进一步加强对整个软件工程的认识</p>
<p>持续交付涵盖了软件交付端到端的整个周期，其覆盖面不仅仅包括编码，还包括：设计、测试、部署、运维、运营等等。</p>
<p>研发效率的提高往往不是个人能力的提高，而是集体协同效率的提高。</p>
</li>
<li><p>提高个人的工作效率和质量</p>
<p>随着持续交付的流行，其配套的实践和工具也层出不穷。ping-pong式结对编程（A写测试，B写实现，然后B写下一个测试，A写重构和实现），让编程充满乐趣，也很好的保证了代码质量。</p>
</li>
</ul>
<h2><span id="如何评估持续交付的价值">如何评估持续交付的价值</span></h2><p>量化？</p>
<p>产品的交付速度是否变快了。但是，实际情况下影响产品交付速度的因素实在太多，持续交付又积极作用，但到底占比多少呢？难以回答。</p>
<p>各个自动化过程的速度是否变快了？如：编译速度、发布速度、回滚速度、自动化测试速度等等。这些指标确实很好地反应了持续交付的价值，但总觉得这些并不是全部，持续交付的标准化、推行的新流程、改革的环境治理结构，好像都没有体现出来。</p>
<p>如果很难量化，也可以具象化。在整个工程生命周期中有多少被开发人员诟病，或者阻碍开发人员自主处理的问题点，即‘不可持续点’：</p>
<blockquote>
<p>开发不能按需产生隔离的测试环境；</p>
<p>生成代码回滚后，要手工处理代码分支；</p>
<p>预发布流量要能自动分离，以便预发布测试。</p>
</blockquote>
<p>以消灭这些不可持续点作为目标，拆解出来的可行动点，作为关键结果，来完成绩效考评。</p>
<h1><span id="影响持续交付的因素">影响持续交付的因素</span></h1><h2><span id="组织和文化因素">组织和文化因素</span></h2><p>持续交付一定是整个组织层面的事情，是跨部门合作的产物，所以组织和文化因素，是要首先考虑的问题。</p>
<p>紧密配合</p>
<p>集思广益</p>
<p>自我驱动</p>
<p>组织的问题，还是需要通过组织变更来解决。通常我们会采用以下三种方案：</p>
<ul>
<li>成立项目管理办公室</li>
<li>独立建立工程效能部门</li>
<li>使用敏捷形式，如Scrum，打破职能部门之间的隔离墙，以产品的形式组织团队</li>
</ul>
<h2><span id="代码分支策略的选择">代码分支策略的选择</span></h2><h3><span id="主干开发tbd">主干开发（TBD）</span></h3><p>主干开发是一个源代码控制的分支模型，开发者在一个称为“trunck”的分支（Git称master）中对代码进行协作，除了发布分支外没有其他开发分支。</p>
<p>Google和Facebook都是采用“主干开发”的方式，代码一般直接提交到主干的头部，这样可以保证所有用户看到的都是同一份代码的最新版本。</p>
<p>“主干开发”确实避免了合并分支时的麻烦，因此像Google这样的公司一般就不采用分支开发，分支只用来发布。</p>
<p>大多数时候，发布分支是主干某个时点的快照。以后的改Bug和功能增强，都是提交到主干，必要时cherry-pick（选择部分变更集合并到其他分支）到发布分支。与主干长期并行的特性分支极为少见。</p>
<p>由于不采用“特性分支开发”，所有提交的代码都被集成到了主干，为了保证主干上线后的有效性，一般会使用特性切换（feature toggle）。特性切换就像一个开关可以在运行期间隐藏、启用或禁用特定功能，项目团队可以借助这种方式加速开发过程。</p>
<p>特性切换在大型项目持续交付中变得越来越重要，因为它有助于将部署从发布中解耦除了。但是，特性切换也会导致代码更为脆弱、更难测试、更难理解和维护、更难提供技术支持，而且更不安全。（From Jim Bird）</p>
<p>特性切换需要健壮的工程过程、可靠的技术设计和成熟的特性切换生命周期管理，如果不具备这三个关键的条件，使用特性切换反而会降低生产力。</p>
<p>根据上面的分析，主干开发的分支策略虽然有利于开展持续交付，但是它对开发团队的能力要求也更高。</p>
<h3><span id="特性分支开发">特性分支开发</span></h3><p>和主干开发行对的时“特性分支开发”。在这个大类里面，我们来分析Git Flow、Github Flow和Gitlab Flow：</p>
<ul>
<li><p>Git Flow</p>
</li>
<li><p>Github Flow</p>
<p>是Github所使用的一种简单流程。该流程只使用master和特性分支，并借助Github的pull request功能。</p>
<p>在Github Flow中，master分支中包含稳定的代码，它已经或即将部署到生产环境。任何开发人员都不允许把未测试或未审查的代码直接提交到master分支。对代码的任何修改，不可Bug修复、热修复、新功能开发等都在单独的分支中进行。不管是一行代码的小改动，还是需要几个星期开发的新功能，都采用同样的方式来管理。</p>
<p>当需要修改时，从master分支创建一个新的分支，所有相关的代码修改都在新分支中进行。开发人员可以自由地提交代码和提交到远程仓库。</p>
<p>当新分支中的代码全部完成之后，通过Github提交一个新的pull request。团队中的其他人员会对代码进行审查，提出相关的修改意见。由持续集成服务器（如Jenkins）对新分支进行自动化测试。当代码通过自动化测试和代码审查之后，该分支的代码被合并到master分支。再从master分支部署到生产环境。</p>
<p>Github Flow的好处在于非常简单实用，开发人员需要注意的事项非常少，很容易形成习惯。当需要修改时，只要从master分支创建新分支，完成之后通过pull request和相关的代码审查，合并回master分支就可以了。</p>
</li>
<li><p>Gitlab Flow</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>分支模型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>带生产分支</td>
<td>1. 无法控制准确的发布时间，但又要求不停集成的。<br>2. 需要创建一个production分支来放置发布的代码</td>
</tr>
<tr>
<td>带环境分支</td>
<td>1. 要求所有代码都在逐个环境中测试通过。<br>2. 需要为不同的环境建立不同的分支</td>
</tr>
<tr>
<td>带发布分支</td>
<td>1. 用于对外界发布软件的项目，同时需要维护多个发布版本<br>2. 尽可能晚地从master拉取发布分支。<br>3. Bug修复应先合并到master，然后cherry pick到release分支。</td>
</tr>
</tbody>
</table>
<h1><span id="依赖管理">依赖管理</span></h1><h1><span id="代码回滚">代码回滚</span></h1><h2><span id="什么是代码回滚">什么是代码回滚？</span></h2><ol>
<li>包回滚是指，线上运行的系统，从现在的版本回滚到以前稳定的老版本。</li>
<li>代码回滚是指，Git分支的指针（游标），从指向当前有问题的版本改为指向一个该分支历史树上没问题的版本，而这个版本可以是曾经的commit，也可以是新建的commit。</li>
</ol>
<h2><span id="哪些情况下需要回滚代码">哪些情况下需要回滚代码？</span></h2><ul>
<li>第一种情况：开发人员独立使用的分支上，如果最近产生的commit都没有价值，应该废弃掉，此时就需要把代码回滚到以前的版本。</li>
<li>第二种情况：代码集成到团队的集成分支且尚未发布，但在后续测试中发现这部分代码有问题，且一时半会儿解决不掉，为了不把问题传递给下次的集成，此时就需要把有问题的代码从集成分支中回滚掉。</li>
<li>第三种情况：代码已经发布到线上，线上包回滚后发现是新上线的代码引起的问题，且需要一段时间修复，此时又有其他功能需要上线，那么主干分支必须把代码回滚到正确版本产品包对应的commit</li>
</ul>
<h2><span id="哪些情况下包的回滚无需回滚代码">哪些情况下包的回滚无需回滚代码？</span></h2><ul>
<li>线上回滚后，查出并不是因为源代码有问题。</li>
<li>下次线上发布，就是用来修复刚才线上运行的问题。</li>
</ul>
<h2><span id="代码回滚必须遵循的原则">代码回滚必须遵循的原则</span></h2><p>集成分支上代码回滚坚决不用reset –hard的方式，原因如下：</p>
<ul>
<li>集成分支上的commit都是项目阶段性的成果，即使最近的发布不需要某些commit的功能，但仍然需要保留这些commit，以备后需。</li>
<li>开发人员会基于集成分支上的commit拉取新分支，如果集成分支采用reset的方式消除了该commit，下次开发人员把新分支合并回集成分支时，又会把被清除的commit申请合并，很可能导致不需要的功能再次被引入集成分支。</li>
</ul>
<h2><span id="三种典型回滚场景及回滚策略">三种典型回滚场景及回滚策略</span></h2><table>
<thead>
<tr>
<th>场景名称</th>
<th>特点</th>
<th>策略</th>
</tr>
</thead>
<tbody>
<tr>
<td>个人分支回滚</td>
<td>不会影响团队其他成员</td>
<td>可以用git reset –hard</td>
</tr>
<tr>
<td>集成分支上线前回滚</td>
<td>1. 会影响团队其他成员<br>2. 非线上故障，相对不紧急<br>3. 可以对单独的commit做回滚</td>
<td>1. 一定不用 git reset –hard<br>2. 可在gitlab上找到对应的Merge Request，点击revert</td>
</tr>
<tr>
<td>集成分支上线后回滚</td>
<td>1. 会影响团队其他成员<br>2. 线上故障，相对紧急<br>3. 需回滚到包对应的commit</td>
<td>1. 一定不用 git reset <br>2. 再集成分支的头上增加一个commit，该commit的内容等于包回滚后对应的commit</td>
</tr>
</tbody>
</table>
<h1><span id="测试环境">测试环境</span></h1><p>在整个持续交付生命周期中，测试环境的易用程度会直接影响软件的交付程度，但因为以下两点，它又是最被容易忽略的一环。</p>
<ol>
<li>我们总是把环境理想化，忽略了其管理的难度；</li>
<li>我们也很少设立专职的环境管理员，导致环境长期处于混乱状态。</li>
</ol>
<p>通常，我们在项目初期并不会关注测试环境的问题，然而在回顾时却发现在环境问题上浪费的时间非常惊人：硬件资源申请困难，测试环境配置繁琐，测试应用更新困难，基础设施稳定性差，服务调用异常，多项目并行造成互相干扰等等问题。</p>
<p>构建一整套好的测试环境的关键点以及具体实施方案</p>
<ol>
<li>测试环境的结构一般是怎样的？</li>
<li>什么才是好的测试环境？</li>
</ol>
<h2><span id="互联网公司测试环境的结构">互联网公司测试环境的结构</span></h2><p>当公司规模较小时，测试环境的维护相对容易。开发和测试公用一套数据库缓存等基础设施，因为应用数量不多，开发环境可以是单机的，无论是手动或半自动化的更新测试环境的应用，花费的时间都还在可接受范围内。</p>
<p>这时，公司环境的结构很简单，分为开发环境，测试环境，生产环境即可。</p>
<p>但实际上，大多数公司的研发过程及配套环境并没有这么简单，一般都会存在5套以上的大环境以及更多的子环境，每个环境的机器数量可能有数十台甚至更多。</p>
<p>为什么需要这么多套环境呢？</p>
<ul>
<li><p>纵向上看，人员的增多提高了项目的并行度，如果这时还使用一套环境的话，就会发生以下问题：</p>
<ul>
<li>开发同学在debug一个问题时，发现下游的应用突然就不可用了；</li>
<li>测试同学在跑了10多分钟测试脚本后，发现应用已经被开发更新掉了。</li>
</ul>
<p>这样的体验是让人崩溃的。</p>
</li>
<li><p>横向上看，公司的应用架构逐渐转为微服务化，完整的应用数量很容易就达到了几百甚至几千个的量级，建立一套完整的环境变得越来越复杂，往往是研发团队想要构建一套新的环境却构建不出来。</p>
</li>
</ul>
<p>所以，目前互联网公司常见的环境模型一般分为开发环境，功能测试环境，验收测试环境，预发布环境，生产环境这五套大环境。</p>
<ul>
<li><p>开发环境</p>
<p>微服务架构下，单机已经无法完整地运行业务应用，这就需要开发环境内包含一套完整的业务应用依赖以及相关的基础设施，以保证业务开发同学能在本地完成开发测试。</p>
</li>
<li><p>功能测试环境</p>
<p>在开发环境下，每个下游依赖应用都只有一个可用的stable版本。而在实际的开发过程中，由于项目的并行开发，往往会同时存在多个可依赖的版本。而每个项目组的同学在测试时，都希望测试过程中的关键依赖应用是可以被独占的，版本是固定的，不会被其他项目组干扰。</p>
<p>所以，一套独立的功能测试环境就很有必要了。<em>通常，互联网企业会通过中间件的方式分割出一块隔离区域，在功能测试环境中创建多个子环境来解决问题。</em></p>
</li>
<li><p>验收测试环境</p>
<p>验收测试环境和功能测试环境是完全隔离的。当功能测试通过后，你可以在验收测试环境进行最终的验收。</p>
<p>它除了可以用作测试之外，还可以用作产品展示。所以，除了测试和开发人员，产品经理也是验收测试环境的主要使用者。</p>
</li>
<li><p>预发布环境</p>
<p>到预发布阶段，应用已经进入了生产网络，和真实的生产应用共享同一套数据库等基础设施。预发布是正式发布前的最后一次测试，在这个环境中往往可以发现线下环境中发现不了的Bug。这个环境的运维标准等同于生产环境，一般不允许开发人员直接登陆机器。</p>
<p>根据不同的业务需求和部署策略，不同公司对预发布环境的实现也有所不同：</p>
<ul>
<li><p>一种比较常见的方式是，将金丝雀发布作为预发布，从接入真实流量的集群中挑选一台或一小组机器先进行版本更新，通过手工测试以及自动化测试和监控系统验证，降低新版本发布的风险。</p>
<blockquote>
<p>金丝雀发布：</p>
<p>17世纪，英国矿井工人发现，金丝雀对瓦斯这种气体十分敏感。空气中哪怕有极其微量的瓦斯，金丝雀也会停止歌唱；而当瓦斯含量超过一定限度时，虽然鲁钝的人类毫无察觉，金丝雀却早已毒发身亡。当时在采矿设备相对简陋的条件下，工人们每次下井都会带上一只金丝雀作为“瓦斯检测指标”，以便在危险状况下紧急撤离</p>
<p>金丝雀发布是灰度发布的一种方式。灰度发布是指在黑与白之间，能够平滑过渡的一种发布方式。让一部分用户继续用A，一部分用户开始用B，如果用户对B没有什么反对意见，那么逐步扩大范围，把所有的用户都迁移到B上面来。</p>
<p>部署步骤：</p>
<ul>
<li>准备好部署各个阶段的工件，包括：构建工件、测试脚本、配置文件和部署清单文件。</li>
<li>从负载均衡列表中移除掉“金丝雀”服务器</li>
<li>升级“金丝雀”应用（排掉原有流量并进行部署）</li>
<li>对应用进行自动化测试</li>
<li>将“金丝雀”服务器重新添加到负载均衡列表中（连通性和健康检查）</li>
<li>如果“金丝雀”在线使用测试成功，升级剩余的其他服务器，否则就回滚。</li>
</ul>
</blockquote>
</li>
<li><p>另一种做法是，独立出一组始终不接入真实流量的机器，调用在预发布环境中形成闭环。</p>
<p>相对于第一种方式，第二张方式对生产环境的影响更小，但需要额外的资源和维护成本。</p>
</li>
</ul>
</li>
<li><p>生产环境</p>
<p>生产环境是用户真实使用的环境，对安全性和稳定性的要求最高。</p>
</li>
</ul>
<h2><span id="什么是好的测试环境">什么是好的测试环境？</span></h2><p>开发环境、功能测试环境、验收测试环境、预发布环境这四种测试环境形成的原因是什么？</p>
<p>搭建测试环境的目的是保证最终交付的软件质量，但每套测试环境的用户并不完全一样：</p>
<ul>
<li>开发环境的用户是开发同学；</li>
<li>功能测试环境的主要用户是测试同学；</li>
<li>验收测试环境的用户是产品经理和测试同学；</li>
<li>预发布环境的使用者是测试同学，但受益者却是运维同学。</li>
</ul>
<p>而每种角色对于产品研发流程中的需求也是不同的：</p>
<ul>
<li>开发同学关注研发效率；</li>
<li>测试同学关注测试的可靠性；</li>
<li>产品经理更关注的是真实的用户体验和产品的完整性；</li>
<li>预发布环境的需求其实来自于运维同学，他们需要保证生产环境的稳定性，减少生产环境的变更，所以需要将预发布环境与线下环境完全隔离。</li>
</ul>
<p>当然，不论一套环境用户是测试同学还是开发同学，以下几个需求都是必须被做到的。</p>
<ul>
<li>可得性，即在开发一个新项目时，能快速获取构建一个环境需要的机器，基础设施。最好的情况是，能随时可得，随时归还。</li>
<li>快速部署，即在搭建新环境时，能以最快的速度构建出一整套完整的环境。测试环境的部署很频繁，在代码提交后，能在很短的时间内构建代码，在环境上更新，就能更早开始测试。</li>
<li>独立性，即一个环境在使用过程中，可以不受其他项目测试人员的干扰。</li>
<li>稳定性，即不会因为下游服务，基础设施的异常，造成测试中断、等待。</li>
<li>高仿真，主要分为两个方面：“测试数据真实”，即能在测试环境构建出真实的测试用例；“环境真实”，即基础服务的架构和行为与线上环境保持一致，避免因为环境不一致造成测试结果不一致。</li>
</ul>
<p>但是，毕竟各个环境的用户和使用场景不同，它们的需求也是有差别的。比如，相对于开发环境，验收测试环境对测试数据的仿真性要求会更高，而开发环境的灵活性，决定了不会过于严格的维护测试数据的真实性。</p>
<p>当一个环境可以满足其真正核心用户的需求时，就是一个好用的测试环境。</p>
<h2><span id="测试环境的成本">测试环境的成本</span></h2><ul>
<li><p>机器资源的成本</p>
<p>保证环境的独立性，是你构建更多套环境的一个主要原因。但是，一套独立的、拥有完整链路的环境成本是非常高的。</p>
<p>以阿里云的价格为例：假设一个只有100个应用的微服务架构环境，选取单应用单机2核4G内存的低配置实例方式进行部署，单实例的年价格在2000元左右，100个实例的话，一年的花费就是20万元左右。</p>
<p>而这只是最保守的计算，随着服务规模的增加，以及更多环境的需要，整体花费上涨两个数量级也是很正常的。</p>
<p>这样的问题在开发环境和集成环境的表现是最明显的。为了保证这两套环境的独立性，你必然需要有很高的环境副本数。单无论如何，你都不可能让每一个开发和测试人员都拥有一套完整环境的硬件资源。</p>
</li>
<li><p>其次是管理成本</p>
<p>管理成本，包括维护环境的可用性，配置的管理成本，和测试数据的维护成本三个维度。</p>
<ul>
<li><p>维护多套环境的第一要点是，维护环境的可用性。</p>
<p>与云时代之前相比，容器技术已经解决了很多问题。比如，服务器操作系统级别的依赖的标准化更容易了；当出现硬件故障时，迁移和恢复服务也更加方便了。</p>
<p>但是容器技术并没有解决故障定位的问题。微服务架构下集群的节点数量多，调用链复杂，你不再能确定到底是环境问题，还是程序本身的Bug，也就导致定位故障更加困难了。</p>
<p>所以，更多套环境就意味着更大的集群规模，出现故障的几率会随之增加，而解决故障也会占用更长的工作时间。</p>
</li>
<li><p>维护多套环境的另一大成本，配置管理成本</p>
<p>配置是环境管理中最核心的内容，创建一套环境时，为了保证它真正的独立可用，不仅要保证应用可以成功运行，还要保证应用在基础设施的配置是正确的。比如集成测试环境下部署了一个应用的多个平行项目，就需要有办法保证测试人员能访问到正确的应用。</p>
<p>如果是web应用，你就要考虑把应用绑定到不同的域名，这样就会增加域名管理的成本；如果是一个service应用，就要考虑到这些service不会被其他项目的、无关环境的应用调用到，同时也不会调用到其他错误的服务。</p>
<p>每多一套环境，就会多一套这样的配置，而且这些配置都需要在各类基础设施中生效。</p>
</li>
<li><p>测试数据的维护成本</p>
<p>测试数据也是环境中极为重要的一个组成部分。当并行环境的数量变多后，数据的维护同样是让人头疼的问题。</p>
<p>为了保证环境的高仿真，哪些环境公用一套数据库，以及测试数据的更新在多套环境中怎么执行等等，都需要非常高的管理成本。</p>
</li>
</ul>
</li>
<li><p>最后是流程成本</p>
<ul>
<li><p>沟通成本</p>
<p>每增加一套环境，你都需要考虑团队成员如何在新环境上沟通协作。谁在占用，何时退出这些信息，你都需要第一时间告知团队。当环境的数量变得非常多以后，做好这些事儿的难度就很大了。</p>
</li>
<li><p>测试成本</p>
<p>在开发环境、集成测试环境、验收测试环境、预发布环境、生产环境这样的结构下，核心功能的测试流程就至少会执行五次。每引入一套新的环境，测试流程都会变得更加复杂。</p>
</li>
</ul>
</li>
</ul>
<h2><span id="如何调节效率和成本的矛盾">如何调节效率和成本的矛盾？</span></h2><p>增加一套环境带来的成本竟然有那么多，但是为了提高持续交付的效率，隔离的多套环境又是必不可少的。</p>
<p>那么，应该怎样去规划和设计环境呢？</p>
<ul>
<li><p>公共与泳道</p>
<p>第一个关键点是抽象公共环境，而其中的公共服务基本都属于底层服务，相对比较稳定，这是解耦环境的重中之重。比如我们经常会将中间件、框架类服务，底层业务公共服务（账号、登陆、基本信息）部署在这套公共环境上。</p>
<p>在公共环境的基础上，可以通过泳道的方式隔离相关测试应用，利用LB和SOA中间件对路由功能的支持，在一个大的公共集成测试环境中隔离出一个个独立的功能测试环境，那么增加的机器成本就仅与被并行的项目多少有关系了。</p>
<p>具体案例：</p>
<p>比如，你有一个新的下单流程需要测试。你可以将下单web2.0和下单sevice2.0抽离出来</p>
</li>
<li><p>避免产生多套公共环境</p>
<p>用mock service模拟大多数服务</p>
</li>
<li><p>减轻配置的复杂度</p>
<ul>
<li>制定一套统一配置的解决方案</li>
<li>要让环境自己说话，有效减少配置项</li>
</ul>
</li>
</ul>
<h1><span id="环境自描性">环境自描性</span></h1><blockquote>
<p>要想把环境配置做好，就是要做到让环境自己能说话。</p>
</blockquote>
<p>环境配置可以分为:</p>
<ul>
<li><p>以环境中每台服务器为对象的运行时配置</p>
<p>以一个Java Web应用为例，需要哪些运行时配置呢？</p>
<ol>
<li>安装war包运行依赖的基础环境，比如JDK、Tomcat等</li>
<li>修改Tomcat的配置文件，关注点主要包括：应用的日志目录，日志的输出格式，war包的存放位置。Tomcat的server.xml配置包括：连接数、端口、线程池等参数</li>
<li>配置Java参数，包括JVM堆内存的最大最小方式、GC方式、参数，JMX监控开启等</li>
<li>考虑操作系统参数，比较常见的一个配置时Linux的文件句柄数，如果应用对网络环境有一些特殊要求的话，还需要调整系统的TCP参数等配置</li>
</ol>
<p>经过上面4步，一个简单的运行时环境的配置就算时完成了，可以开始运行一个程序了。</p>
<p>但我们不光要考虑单个实例初始化配置，还要考虑每次JDK、Tomcat等基础软件的版本升级引起的运行时配置的变更，而且这些变更都需要清晰的记录下来，从而保证扩容出新的服务器时能取到正确的、最新的配置。</p>
<p>另外，对于一个集群的服务器组来说，还需要强制保证它们的运行时配置是一致的。</p>
</li>
<li><p>以一个环境为整体目标的独立环境配置</p>
<p>独立环境配置的主要目的是，保证一个环境能够完整运作的同时，又保证足够的隔离性，使其成为一个内聚的整体。</p>
<p>所以，要让一个环境能够符合需求的正常运作，你需要考虑的内容包括：</p>
<ol>
<li>这个环境所依赖的数据库该如何配置，缓存服务器又该如何配置</li>
<li>如果是分布式系统，或者SOA结构的话，就需要考虑服务中心、配置中心等一系列中间件的配置问题</li>
</ol>
<p>其中，最为重要的是配置中心的配置。</p>
<p>只有先访问到正确的配置中心，才能获取到其他相关的环境配置或者应用配置信息。也就是说，如果配置中心的配置错了，那么环境就会陷入混乱状态。</p>
<ol>
<li>要考虑访问入口问题。这套环境的入口在哪里？是一个站点还是一个服务入口？如果是一个站点的话，那这个站点的访问域名就需要被特殊配置。如果这是一个内部环境的话，那么这个内部域名的DNS解析也需要被配置。如果这套环境中有多个Web应用，那么你就要考虑7层路由的配置问题了</li>
<li>还要配置环境对应的基础服务，比如监控、短信、搜索等</li>
</ol>
</li>
</ul>
<p>再如果你的环境要承载多种语言栈，各类应用依赖的基础软件也不同，环境和环境之间有各种关联设置，数据库的连接分配，环境中负载均衡的设置等等</p>
<p>虽然环境配置有这么多的待处理事项，但是环境本身也是一个非常强大的工具，本身包含非常多的信息，如果这些糟心的事情环境能和你一起来解决，那就简单了，也就是说要让环境之间来说话。怎么做到呢？</p>
<h2><span id="环境一定要标准化">环境一定要标准化</span></h2><p>解决复杂问题的办法，无非是先将其分解，再将其简单化，对环境配置这个难题来说也是同样的道理。想要解决它，首先得要想办法分解、简化它。</p>
<p>最好的简化方法，莫过于标准化了。</p>
<p>所谓标准化，就是为了在一定范围内获得最佳秩序，对实际的或潜在的问题制定共同、可重复使用的规则。</p>
<p>标准化也就是让环境学会了一门统一的语言，是自己说话的前提。</p>
<p>按照这个思路，我们首先可以实现对语言栈的使用、运行时配置模板、独立环境配置的方法等的标准化：、</p>
<ul>
<li>规定公司的主流语言栈</li>
<li>统一服务器安装镜像</li>
<li>提供默认的运行时配置模板</li>
<li>统一基础软件的版本，以及更新方式</li>
<li>在架构层面统一解决环境路由问题</li>
<li>自动化环境产生过程</li>
</ul>
<p>在实施持续交付的同时，推动形成以下几个方面的规范：</p>
<ul>
<li>代码及依赖规范</li>
<li>命名规范</li>
<li>开发规范</li>
<li>配置规范</li>
<li>部署规范</li>
<li>安全规范</li>
<li>测试规范</li>
</ul>
<p>其实，不管是持续交付还是架构改造，标准先行都是技术实施的前提条件。</p>
<h2><span id="约定大于配置">约定大于配置</span></h2><p>像代码的部署路径，每个环境的域名定义，FAT、UAT来表示环境的作用，单机单应用，所有服务端端口是8080等等</p>
<p>约定大于配置的好处是，除了简化配置工作外，还可以提高沟通效率。</p>
<p>相当于赋予了环境天生的本能，进一步加强了环境的自我描述能力。</p>
<h2><span id="让环境自己能开口说话">让环境自己能开口说话</span></h2><p>有了环境标准化，以及约定大于配置的基础，你就可以顺利地让环境自己开口说话了。</p>
<p>也就是，通过环境的自描述文件，让环境能讲清楚自己的作用、依赖，以及状态，而不是由外部配置来解释这些内容。</p>
<p>以一台服务器为例，一旦生成，除了不能控制自己的生死外，其他运行过程中的配置，都应该根据它自身的描述来决定。</p>
<p>那么，如何让服务器自己说话呢？</p>
<ul>
<li>首先，需要定义Server Spec：在这个文件中，记录了这台服务器的所有身份信息，包括：IDC、型号、归属环境、作用、所属应用、服务类型、访问路径等</li>
<li>解决配置中心寻址：中间件根据Server Spec的描述，寻找到它所在环境对应的配置中心，从而进一步获取其他配置，如数据库连接字符串、短信服务地址等</li>
<li>完成服务自发现：根据服务类型、访问路径等，还可以自动生成对应的路由配置、负载均衡配置等</li>
</ul>
<h1><span id="各种配置方法">各种配置方法</span></h1><p>配置管理：是通过技术或行政手段对软件产品及其开发过程和生命周期进行控制、规范的一系列措施。它的目标是记录软件产品的演化过程，确保软件开发者在软件生命周期的各个阶段都能得到精确的产品配置信息。</p>
<p>配置：是指独立于程序之外，但又对程序产生作用的可配变量。也就是说，同一份代码在不同的配置下，会产生不同的运行结果。</p>
<h1><span id="分钟级搭建环境">分钟级搭建环境</span></h1><h2><span id="环境构建流水线">环境构建流水线</span></h2><ol>
<li><p>虚拟机环境准备，根据环境的应用数，每个应用需要的硬件配置，准备号环境的硬件资源</p>
<ul>
<li>当物理机接到机架上以后，打开交换机端口，等待机器被发现后，调用Nova进行物理机基本的硬件配置</li>
<li>物理机环境准备完毕后，从openstack获取虚机所需的镜像、网络等信息，调用Openstack API镜像虚机部署。虚机配置的一个关键点是，如何对网络进行配置</li>
<li>虚机初始化后，需要在虚机上进行一些基础软件比如JDK，Tomcat的安装和配置。业界一般采用的方式是，通过自动化的配置管理工具来进行操作。</li>
</ul>
</li>
<li><p>应用部署流水线，在标准化的虚拟机上进行应用部署，当出现问题时如何容错。</p>
<ul>
<li><p>单应用部署标准化，这是整个环境部署的基础。对一套测试环境而言，每个应用就像是环境上的一个零件，如果单个应用无法自动发布或发布失败率很高，那么整个环境就更难以构建出来。而如何实现一个好的发布系统，提升单应用部署速度呢？</p>
</li>
<li><p>应用部署的并行度，为了提高环境的部署速度，需要尽可能得最大化应用部署的并行度。理想的情况下，环境中的所有应用都可以一次性地并行部署。</p>
<p>然而，做到一次性并行部署并不容易，需要保证：应用都是无状态的，并且可以不依赖别的应用进行启动，或者仅仅依赖于基础环境中的应用就可以启动，且可以随时通过中间件进行调用链的切换。</p>
</li>
<li><p>流水线的容错机制。对于环境构建工具，通常的做法是力求做到全面的标准化、代码化。但是因为环境的创建本身是一个非常复杂的工作流，在创建过程总会有一些异常中断整个流程。比如，某个应用启动失败了。</p>
<p>而对于这些工作流中的异常，我们该如何处理呢？</p>
<ul>
<li><p>第一种方法是，错误中断法。创建环境过程中，各种资源申请、应用部署出现问题时，我们将工作流快照下来，然后收集所有的异常信息，返回给用户。由用户判断当前的情况，等用户确认问题已经得到解决后，可以触发一次快照重试，继续被中断的流程。</p>
</li>
<li><p>第二种方法是，优先完成法。创建环境过程中发生错误时，先进行几次重试。如果重试依然发生错误的话，就忽略当前错误，先走完剩余的流程，等所有的流程都走完了，再一次性将错误返回给用户。</p>
<p>从整体速度上来看，第二种优先完成的处理方式是更优的，而且也会更少地打断用户。只是方式二需要保证的关键原则是：所有的部署脚本的操作都是幂等的，即两次操作达成的效果是一致的，并不会带来更多的问题。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>环境变更，在SOA或微服务的架构体系下，常常会因为测试的需求，将几套环境合并或拆分，创建环境时，你需要考虑如何高效地完成这些操作。</p>
<p>一般情况下，研发人员变更环境主要有以下4种场景：</p>
<ul>
<li>已经有一套新环境，当有新项目时，开发人员会挑选部分应用，组成一个独立的子环境。这里的重点是，要保证子环境和完整环境的调用是互相隔离的</li>
<li>当存在多个子环境时，可能在某个时间点需要做多个项目的集成，这时开发人员需要合并多个环境。</li>
<li>和合并的情况相反，有些情况下，开发人员需要将一个子环境种的应用切分开来，分为两个或者多个环境分别进行隔离测试。</li>
<li>已经存在一个子环境，当多个并行项目时，开发人员会克隆一套完整的子环境做测试。</li>
</ul>
</li>
</ol>
<h1><span id="构建提速">构建提速</span></h1><h1><span id="发布">发布</span></h1><h2><span id="发布是持续交付的最后一公里">发布是持续交付的最后一公里</span></h2><h2><span id="任何变更都需要发布">任何变更都需要发布</span></h2><h2><span id="发布系统一定要注意用户体验">发布系统一定要注意用户体验</span></h2><h2><span id="发布系统的核心架构和功能设计">发布系统的核心架构和功能设计</span></h2><p>作为整个持续交付体系中极为重要的一个环节，应用的发布时提升交付效率的关键。高效的发布系统架构应该时清晰的、健壮的、低耦合的，从而达到在最糟糕的情况下也能运作的目的。</p>
<h1><span id="利用监控保障发布质量">利用监控保障发布质量</span></h1><h1><span id="代码静态检查">代码静态检查</span></h1><h1><span id="破坏性测试">破坏性测试</span></h1><h1><span id="自动化回归">自动化回归</span></h1><p>对于持续交付的测试来说，自动化回归测试是不可或缺的，占了很大的测试比重。</p>
<p>进行自动化回归测试，就始终会有三个大问题：</p>
<ul>
<li>测试数据的准备和清理</li>
<li>分布式系统的依赖</li>
<li>测试用例的高度仿真</li>
</ul>
<h1><span id="平台化设计持续交付">平台化设计持续交付</span></h1><h1><span id="持续交付中的宝贵数据">持续交付中的宝贵数据</span></h1><h1><span id="移动app的持续交付生命周期">移动APP的持续交付生命周期</span></h1><h1><span id="快速构建持续交付系统">快速构建持续交付系统</span></h1><h2><span id="需求分析">需求分析</span></h2><h3><span id="模拟团队介绍">模拟团队介绍</span></h3><table>
<thead>
<tr>
<th></th>
<th>团队1</th>
<th>团队2</th>
<th>团队3</th>
</tr>
</thead>
<tbody>
<tr>
<td>职责</td>
<td>中间件服务</td>
<td>业务后台服务</td>
<td>业务客户端服务</td>
</tr>
<tr>
<td>代码管理</td>
<td>Git</td>
<td>Git</td>
<td>Git</td>
</tr>
<tr>
<td>语言平台</td>
<td>Java</td>
<td>Java</td>
<td>React Native</td>
</tr>
<tr>
<td>交付产物</td>
<td>服务/Jar</td>
<td>服务/War</td>
<td>App</td>
</tr>
</tbody>
</table>
<p>整个产品的研发，需要由着3个团队合作完成。</p>
<h3><span id="模拟系统介绍">模拟系统介绍</span></h3><h2><span id="gitlab解决代码管理问题">Gitlab解决代码管理问题</span></h2><h2><span id="jenkins解决集成打包问题">Jenkins解决集成打包问题</span></h2><h2><span id="ansible解决自动部署问题">Ansible解决自动部署问题</span></h2>
                </div>
            </div>
    
            <nav class="post-pagination">
    
    <a class="newer-posts" href="/2017/02/26/lua进阶学习/">
        上一篇<br>lua进阶学习
    </a>
    
    <span class="page-number"></span>
    
    <a class="older-posts" href="/2017/02/21/运维体系管理/">
        下一篇<br>运维体系管理
    </a>
    
</nav>

    
            


        </div>
    </div>
    <div class="single-column-footer">
    Proudly published with Hexo<br>
    
    Theme <a href="https://github.com/SumiMakito/hexo-theme-journal/" target="_blank" rel="noreferrer noopener">Journal.</a> by <a href="https://mak1t0.cc/" target="_blank" rel="noreferrer noopener">Makito</a><br>
    
    &copy; 2018 <a href="http://yoursite.com">javfa&#39;s blog</a>
</div>
</div>

</div>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.14.4/dist/umd/popper.min.js" integrity="sha256-EGs9T1xMHdvM1geM8jPpoo8EZ1V1VRsmcJz8OByENLA=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.1.3/dist/js/bootstrap.min.js" integrity="sha256-VsEqElsCHSGmnmHXGQzvoWjWwoznFSZc6hs7ARLRacQ=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.min.js" integrity="sha256-FtWfRI+thWlNz2sB3SJbwKx5PgMyKIVgwHCTwa3biXc=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/smooth-scroll@14.2.1/dist/smooth-scroll.polyfills.min.js" integrity="sha256-CI4Gq5E0io1Pv0xM3qPM+NUIOhbIBvC3GiN1Y4KhXpw=" crossorigin="anonymous"></script>
<script src="/js/journal.js?93525346"></script>



</body>
</html>
