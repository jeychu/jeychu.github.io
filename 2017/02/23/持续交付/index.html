<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>持续交付 | javfa's blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">持续交付</h1><a id="logo" href="/.">javfa's blog</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Start</i></a><a href="/archives/"><i class="fa fa-archive"> Archiv</i></a><a href="/about/"><i class="fa fa-user"> Über</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">持续交付</h1><div class="post-meta">Feb 23, 2017</div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">Inhalte</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#持续交付的价值"><span class="toc-number">1.</span> <span class="toc-text">持续交付的价值</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#持续交付的定义"><span class="toc-number">1.1.</span> <span class="toc-text">持续交付的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#持续集成、持续交付和持续部署的关系"><span class="toc-number">1.2.</span> <span class="toc-text">持续集成、持续交付和持续部署的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#持续交付的显性价值"><span class="toc-number">1.3.</span> <span class="toc-text">持续交付的显性价值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#持续交付的隐性价值"><span class="toc-number">1.4.</span> <span class="toc-text">持续交付的隐性价值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何评估持续交付的价值"><span class="toc-number">1.5.</span> <span class="toc-text">如何评估持续交付的价值</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#影响持续交付的因素"><span class="toc-number">2.</span> <span class="toc-text">影响持续交付的因素</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#组织和文化因素"><span class="toc-number">2.1.</span> <span class="toc-text">组织和文化因素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代码分支策略的选择"><span class="toc-number">2.2.</span> <span class="toc-text">代码分支策略的选择</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#主干开发（TBD）"><span class="toc-number">2.2.1.</span> <span class="toc-text">主干开发（TBD）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#特性分支开发"><span class="toc-number">2.2.2.</span> <span class="toc-text">特性分支开发</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#依赖管理"><span class="toc-number">2.3.</span> <span class="toc-text">依赖管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代码回滚"><span class="toc-number">2.4.</span> <span class="toc-text">代码回滚</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是代码回滚？"><span class="toc-number">2.4.1.</span> <span class="toc-text">什么是代码回滚？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#哪些情况下需要回滚代码？"><span class="toc-number">2.4.2.</span> <span class="toc-text">哪些情况下需要回滚代码？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#哪些情况下包的回滚无需回滚代码？"><span class="toc-number">2.4.3.</span> <span class="toc-text">哪些情况下包的回滚无需回滚代码？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码回滚必须遵循的原则"><span class="toc-number">2.4.4.</span> <span class="toc-text">代码回滚必须遵循的原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三种典型回滚场景及回滚策略"><span class="toc-number">2.4.5.</span> <span class="toc-text">三种典型回滚场景及回滚策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#测试环境"><span class="toc-number">2.5.</span> <span class="toc-text">测试环境</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#互联网公司测试环境的结构"><span class="toc-number">2.5.1.</span> <span class="toc-text">互联网公司测试环境的结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是好的测试环境？"><span class="toc-number">2.5.2.</span> <span class="toc-text">什么是好的测试环境？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#测试环境的成本"><span class="toc-number">2.5.3.</span> <span class="toc-text">测试环境的成本</span></a></li></ol></li></ol></li></ol></div></div><div class="post-content"><h1 id="持续交付的价值"><a href="#持续交付的价值" class="headerlink" title="持续交付的价值"></a>持续交付的价值</h1><h2 id="持续交付的定义"><a href="#持续交付的定义" class="headerlink" title="持续交付的定义"></a>持续交付的定义</h2><blockquote>
<p>持续交付是软件研发人员，如何将一个好点子，以最快的速度交付给用户的方法。</p>
<p>From 《持续交付：发布可靠软件的系统方法》</p>
</blockquote>
<h2 id="持续集成、持续交付和持续部署的关系"><a href="#持续集成、持续交付和持续部署的关系" class="headerlink" title="持续集成、持续交付和持续部署的关系"></a>持续集成、持续交付和持续部署的关系</h2><p>我们通常会把软件研发工作拆解，拆分成不同模块或不同团队后进行编码，编码完成后，进行集成构建和测试。这个从编码到构建再到测试的反复持续的过程，就叫做“持续集成”。</p>
<p>“持续集成”一旦完成，则代表产品处于一个可交付的状态，但并不代表这是最优状态，还需要根据外部使用者的反馈逐步优化。当然这里的使用者并不一定是真正的用户，还可能是测试人员、产品人员、用户体验工程师、安全工程师、企业领导等等。</p>
<p>这个“持续集成”之后，获取外部对软件的反馈再通过“持续集成”进行优化的过程就叫做“持续交付”，它是“持续集成”的自然延续。</p>
<p>传统安装型软件，要现场调试，要用户购买等等，其难度可想而知。即使是可达度最高的互联网应用，由于生成环境的多样性、架构的复杂性、影响的广泛性（需要灰度发布）等等，就算产品已是待交付的状态，要真正达到用户可用的标准，还有大量的问题需要解决。</p>
<p>而“持续部署”就是将可交付产品，快速且安全地交付用户使用的一套方法和系统，它是“持续交付”的最后“一公里”。</p>
<h2 id="持续交付的显性价值"><a href="#持续交付的显性价值" class="headerlink" title="持续交付的显性价值"></a>持续交付的显性价值</h2><p>持续交付也通常以“发布流水线”的方式来解释，即研发团队从开发，到测试，再到部署，最终将产品交付给最终用户使用的过程。</p>
<p>虽然持续交付着重打造的是发布流水线的部分，但它索要达到的目标是在“最终用户”和“研发团队”之间建立紧密的反馈环：通过持续交付新的软件版本，以验证新想法和软件改动的正确性，并衡量这些改动对软件价值的影响。</p>
<p>这里所说的“软件价值”，就是收入、日活、GMV等KPI指标了。</p>
<p>通常我们在实施持续交付后，都能够做到在保证交付质量的前提下，加快交付速度，从而更快地得到市场反馈，引领产品的方向，最终达到扩大收益的目的。</p>
<p>速度为王的今天，持续交付的能力，正成为评定一家互联网公司研发能力的重要指标。</p>
<h2 id="持续交付的隐性价值"><a href="#持续交付的隐性价值" class="headerlink" title="持续交付的隐性价值"></a>持续交付的隐性价值</h2><p>无论是什么企业，无论你的职位高低，都可以或者应该尝试持续交付，它一定会让你觉得物超所值。</p>
<p>它可以实现的能力：</p>
<ul>
<li><p>解决技术选型的难题</p>
<p>技术选型最大的难点在于影响大，又难以验证（或者验证效率低下）。而造成这些困境的绝大多数原因是没有合适的测试环境，比如环境差异造成测试数据缺乏说服力，又比如缺少隔离环境造成服务冲突等等。而这正是持续交付的用武之地。</p>
<p>持续交付的实施，将全面改善企业对测试环境的关联方法，使得环境管理更合理、更自由。</p>
</li>
<li><p>让制定的标准更好落地：</p>
<p>标准、规范、流程的落地，都需要载体，而最好的载体就是平台工具。而持续交付是一整套平台工具的落地，几乎涵盖了研发的整个生命周期，是天然的、最佳的载体。</p>
<p>另外，持续交付的落地本身伴随着各类标准、规范、流程的制定和实施，可以说两者相互依存，是非常好的管理思想落地方案。</p>
</li>
<li><p>提高跨部门协作的效率</p>
<p>每一个持续交付的实施团队，都可以说是最厉害的“拆墙大队”，拆的就是各个研发协作部门间的“隔离墙”。</p>
<p>持续交付能够向各个协作部门输出统一的标准、流程和工具，提升沟通效率；并且通过大量的自动化，进一步提升各部门工作效率；还可以快速集成，把各个分散的团队，无论是横向的业务研发团队，还是纵向的技术框架团队，紧紧地联系在一起，共同进退。</p>
</li>
<li><p>从容面对故障</p>
<p>任何故障都有一个天敌，叫做：快速恢复。</p>
<p>假设，所有的故障都可以在3分钟内恢复，你是不是觉得天下无敌了。那恢复故障最快、最有效的手段又是什么呢？当然就是回滚（或者重新部署）了，而这正是持续交付所包含和着力打造的能力之一。</p>
</li>
<li><p>让知识能够传承</p>
<p>互联网公司的人才流动之频繁已经远远超过了你我的想象。人来人往，如何将知识传承下来？</p>
<p>持续交付将团队赖以生存的工作流程进行固化；</p>
<p>利用代码静态检查等工具，能够很好地传承团队多年来的代码规范，并作为检查项进行自动化校验；</p>
<p>自动化测试脚本，同样是团队经验的产物。</p>
</li>
<li><p>让团队专注于业务而非工程</p>
<p>持续交付体系也如同中间件一样，能够从日常的业务研发工作中抽象出来，其不同只在于中间件解决架构问题，而持续交付解决工程问题。</p>
<p>这样研发团队能够全力应付业务的需求，而不用总是重复奔波于一些烦人且耗时的工程问题，比如按照测试机、准备编译服务器等等。</p>
</li>
<li><p>让产品经理成为产品真正的第一个用户</p>
<p>持续交付不仅仅是可以保证每一个变化都能及时得到测试以及反馈，更多的是解决测试与实际发布时存在差异的问题。</p>
<p>产品人员将真正成为第一个用户，而不再是最后一个QA。</p>
</li>
<li><p>让产品经理能够完全知悉当前进度和质量</p>
<p>持续交付能够实时地反应当前的开发情况，从而帮助产品人员决策和调整。</p>
</li>
<li><p>产品随时能发布</p>
<p>计划永远赶不上变化，如何产品人员都希望自己的产品能够随时处于可发布状态。这样就灵活地交付已完成的功能，迎合市场或业务的需要。</p>
<p>本质上，<strong>做到代码上线和业务上线的解耦分离</strong>，这也正是交付方法论强调的一个重点。</p>
</li>
<li><p>可以让程序员进一步加强对整个软件工程的认识</p>
<p>持续交付涵盖了软件交付端到端的整个周期，其覆盖面不仅仅包括编码，还包括：设计、测试、部署、运维、运营等等。</p>
<p>研发效率的提高往往不是个人能力的提高，而是集体协同效率的提高。</p>
</li>
<li><p>提高个人的工作效率和质量</p>
<p>随着持续交付的流行，其配套的实践和工具也层出不穷。ping-pong式结对编程（A写测试，B写实现，然后B写下一个测试，A写重构和实现），让编程充满乐趣，也很好的保证了代码质量。</p>
</li>
</ul>
<h2 id="如何评估持续交付的价值"><a href="#如何评估持续交付的价值" class="headerlink" title="如何评估持续交付的价值"></a>如何评估持续交付的价值</h2><p>量化？</p>
<p>产品的交付速度是否变快了。但是，实际情况下影响产品交付速度的因素实在太多，持续交付又积极作用，但到底占比多少呢？难以回答。</p>
<p>各个自动化过程的速度是否变快了？如：编译速度、发布速度、回滚速度、自动化测试速度等等。这些指标确实很好地反应了持续交付的价值，但总觉得这些并不是全部，持续交付的标准化、推行的新流程、改革的环境治理结构，好像都没有体现出来。</p>
<p>如果很难量化，也可以具象化。在整个工程生命周期中有多少被开发人员诟病，或者阻碍开发人员自主处理的问题点，即‘不可持续点’：</p>
<blockquote>
<p>开发不能按需产生隔离的测试环境；</p>
<p>生成代码回滚后，要手工处理代码分支；</p>
<p>预发布流量要能自动分离，以便预发布测试。</p>
</blockquote>
<p>以消灭这些不可持续点作为目标，拆解出来的可行动点，作为关键结果，来完成绩效考评。</p>
<h1 id="影响持续交付的因素"><a href="#影响持续交付的因素" class="headerlink" title="影响持续交付的因素"></a>影响持续交付的因素</h1><h2 id="组织和文化因素"><a href="#组织和文化因素" class="headerlink" title="组织和文化因素"></a>组织和文化因素</h2><p>持续交付一定是整个组织层面的事情，是跨部门合作的产物，所以组织和文化因素，是要首先考虑的问题。</p>
<p>紧密配合</p>
<p>集思广益</p>
<p>自我驱动</p>
<p>组织的问题，还是需要通过组织变更来解决。通常我们会采用以下三种方案：</p>
<ul>
<li>成立项目管理办公室</li>
<li>独立建立工程效能部门</li>
<li>使用敏捷形式，如Scrum，打破职能部门之间的隔离墙，以产品的形式组织团队</li>
</ul>
<h2 id="代码分支策略的选择"><a href="#代码分支策略的选择" class="headerlink" title="代码分支策略的选择"></a>代码分支策略的选择</h2><h3 id="主干开发（TBD）"><a href="#主干开发（TBD）" class="headerlink" title="主干开发（TBD）"></a>主干开发（TBD）</h3><p>主干开发是一个源代码控制的分支模型，开发者在一个称为“trunck”的分支（Git称master）中对代码进行协作，除了发布分支外没有其他开发分支。</p>
<p>Google和Facebook都是采用“主干开发”的方式，代码一般直接提交到主干的头部，这样可以保证所有用户看到的都是同一份代码的最新版本。</p>
<p>“主干开发”确实避免了合并分支时的麻烦，因此像Google这样的公司一般就不采用分支开发，分支只用来发布。</p>
<p>大多数时候，发布分支是主干某个时点的快照。以后的改Bug和功能增强，都是提交到主干，必要时cherry-pick（选择部分变更集合并到其他分支）到发布分支。与主干长期并行的特性分支极为少见。</p>
<p>由于不采用“特性分支开发”，所有提交的代码都被集成到了主干，为了保证主干上线后的有效性，一般会使用特性切换（feature toggle）。特性切换就像一个开关可以在运行期间隐藏、启用或禁用特定功能，项目团队可以借助这种方式加速开发过程。</p>
<p>特性切换在大型项目持续交付中变得越来越重要，因为它有助于将部署从发布中解耦除了。但是，特性切换也会导致代码更为脆弱、更难测试、更难理解和维护、更难提供技术支持，而且更不安全。（From Jim Bird）</p>
<p>特性切换需要健壮的工程过程、可靠的技术设计和成熟的特性切换生命周期管理，如果不具备这三个关键的条件，使用特性切换反而会降低生产力。</p>
<p>根据上面的分析，主干开发的分支策略虽然有利于开展持续交付，但是它对开发团队的能力要求也更高。</p>
<h3 id="特性分支开发"><a href="#特性分支开发" class="headerlink" title="特性分支开发"></a>特性分支开发</h3><p>和主干开发行对的时“特性分支开发”。在这个大类里面，我们来分析Git Flow、Github Flow和Gitlab Flow：</p>
<ul>
<li><p>Git Flow</p>
</li>
<li><p>Github Flow</p>
<p>是Github所使用的一种简单流程。该流程只使用master和特性分支，并借助Github的pull request功能。</p>
<p>在Github Flow中，master分支中包含稳定的代码，它已经或即将部署到生产环境。任何开发人员都不允许把未测试或未审查的代码直接提交到master分支。对代码的任何修改，不可Bug修复、热修复、新功能开发等都在单独的分支中进行。不管是一行代码的小改动，还是需要几个星期开发的新功能，都采用同样的方式来管理。</p>
<p>当需要修改时，从master分支创建一个新的分支，所有相关的代码修改都在新分支中进行。开发人员可以自由地提交代码和提交到远程仓库。</p>
<p>当新分支中的代码全部完成之后，通过Github提交一个新的pull request。团队中的其他人员会对代码进行审查，提出相关的修改意见。由持续集成服务器（如Jenkins）对新分支进行自动化测试。当代码通过自动化测试和代码审查之后，该分支的代码被合并到master分支。再从master分支部署到生产环境。</p>
<p>Github Flow的好处在于非常简单实用，开发人员需要注意的事项非常少，很容易形成习惯。当需要修改时，只要从master分支创建新分支，完成之后通过pull request和相关的代码审查，合并回master分支就可以了。</p>
</li>
<li><p>Gitlab Flow</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>分支模型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>带生产分支</td>
<td>1. 无法控制准确的发布时间，但又要求不停集成的。<br>2. 需要创建一个production分支来放置发布的代码</td>
</tr>
<tr>
<td>带环境分支</td>
<td>1. 要求所有代码都在逐个环境中测试通过。<br>2. 需要为不同的环境建立不同的分支</td>
</tr>
<tr>
<td>带发布分支</td>
<td>1. 用于对外界发布软件的项目，同时需要维护多个发布版本<br>2. 尽可能晚地从master拉取发布分支。<br>3. Bug修复应先合并到master，然后cherry pick到release分支。</td>
</tr>
</tbody>
</table>
<h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><h2 id="代码回滚"><a href="#代码回滚" class="headerlink" title="代码回滚"></a>代码回滚</h2><h3 id="什么是代码回滚？"><a href="#什么是代码回滚？" class="headerlink" title="什么是代码回滚？"></a>什么是代码回滚？</h3><ol>
<li>包回滚是指，线上运行的系统，从现在的版本回滚到以前稳定的老版本。</li>
<li>代码回滚是指，Git分支的指针（游标），从指向当前有问题的版本改为指向一个该分支历史树上没问题的版本，而这个版本可以是曾经的commit，也可以是新建的commit。</li>
</ol>
<h3 id="哪些情况下需要回滚代码？"><a href="#哪些情况下需要回滚代码？" class="headerlink" title="哪些情况下需要回滚代码？"></a>哪些情况下需要回滚代码？</h3><ul>
<li>第一种情况：开发人员独立使用的分支上，如果最近产生的commit都没有价值，应该废弃掉，此时就需要把代码回滚到以前的版本。</li>
<li>第二种情况：代码集成到团队的集成分支且尚未发布，但在后续测试中发现这部分代码有问题，且一时半会儿解决不掉，为了不把问题传递给下次的集成，此时就需要把有问题的代码从集成分支中回滚掉。</li>
<li>第三种情况：代码已经发布到线上，线上包回滚后发现是新上线的代码引起的问题，且需要一段时间修复，此时又有其他功能需要上线，那么主干分支必须把代码回滚到正确版本产品包对应的commit</li>
</ul>
<h3 id="哪些情况下包的回滚无需回滚代码？"><a href="#哪些情况下包的回滚无需回滚代码？" class="headerlink" title="哪些情况下包的回滚无需回滚代码？"></a>哪些情况下包的回滚无需回滚代码？</h3><ul>
<li>线上回滚后，查出并不是因为源代码有问题。</li>
<li>下次线上发布，就是用来修复刚才线上运行的问题。</li>
</ul>
<h3 id="代码回滚必须遵循的原则"><a href="#代码回滚必须遵循的原则" class="headerlink" title="代码回滚必须遵循的原则"></a>代码回滚必须遵循的原则</h3><p>集成分支上代码回滚坚决不用reset –hard的方式，原因如下：</p>
<ul>
<li>集成分支上的commit都是项目阶段性的成果，即使最近的发布不需要某些commit的功能，但仍然需要保留这些commit，以备后需。</li>
<li>开发人员会基于集成分支上的commit拉取新分支，如果集成分支采用reset的方式消除了该commit，下次开发人员把新分支合并回集成分支时，又会把被清除的commit申请合并，很可能导致不需要的功能再次被引入集成分支。</li>
</ul>
<h3 id="三种典型回滚场景及回滚策略"><a href="#三种典型回滚场景及回滚策略" class="headerlink" title="三种典型回滚场景及回滚策略"></a>三种典型回滚场景及回滚策略</h3><table>
<thead>
<tr>
<th>场景名称</th>
<th>特点</th>
<th>策略</th>
</tr>
</thead>
<tbody>
<tr>
<td>个人分支回滚</td>
<td>不会影响团队其他成员</td>
<td>可以用git reset –hard</td>
</tr>
<tr>
<td>集成分支上线前回滚</td>
<td>1. 会影响团队其他成员<br>2. 非线上故障，相对不紧急<br>3. 可以对单独的commit做回滚</td>
<td>1. 一定不用 git reset –hard<br>2. 可在gitlab上找到对应的Merge Request，点击revert</td>
</tr>
<tr>
<td>集成分支上线后回滚</td>
<td>1. 会影响团队其他成员<br>2. 线上故障，相对紧急<br>3. 需回滚到包对应的commit</td>
<td>1. 一定不用 git reset <br>2. 再集成分支的头上增加一个commit，该commit的内容等于包回滚后对应的commit</td>
</tr>
</tbody>
</table>
<h2 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h2><p>在整个持续交付生命周期中，测试环境的易用程度会直接影响软件的交付程度，但因为以下两点，它又是最被容易忽略的一环。</p>
<ol>
<li>我们总是把环境理想化，忽略了其管理的难度；</li>
<li>我们也很少设立专职的环境管理员，导致环境长期处于混乱状态。</li>
</ol>
<p>通常，我们在项目初期并不会关注测试环境的问题，然而在回顾时却发现在环境问题上浪费的时间非常惊人：硬件资源申请困难，测试环境配置繁琐，测试应用更新困难，基础设施稳定性差，服务调用异常，多项目并行造成互相干扰等等问题。</p>
<p>构建一整套好的测试环境的关键点以及具体实施方案</p>
<ol>
<li>测试环境的结构一般是怎样的？</li>
<li>什么才是好的测试环境？</li>
</ol>
<h3 id="互联网公司测试环境的结构"><a href="#互联网公司测试环境的结构" class="headerlink" title="互联网公司测试环境的结构"></a>互联网公司测试环境的结构</h3><p>当公司规模较小时，测试环境的维护相对容易。开发和测试公用一套数据库缓存等基础设施，因为应用数量不多，开发环境可以是单机的，无论是手动或半自动化的更新测试环境的应用，花费的时间都还在可接受范围内。</p>
<p>这时，公司环境的结构很简单，分为开发环境，测试环境，生产环境即可。</p>
<p>但实际上，大多数公司的研发过程及配套环境并没有这么简单，一般都会存在5套以上的大环境以及更多的子环境，每个环境的机器数量可能有数十台甚至更多。</p>
<p>为什么需要这么多套环境呢？</p>
<ul>
<li><p>纵向上看，人员的增多提高了项目的并行度，如果这时还使用一套环境的话，就会发生以下问题：</p>
<ul>
<li>开发同学在debug一个问题时，发现下游的应用突然就不可用了；</li>
<li>测试同学在跑了10多分钟测试脚本后，发现应用已经被开发更新掉了。</li>
</ul>
<p>这样的体验是让人崩溃的。</p>
</li>
<li><p>横向上看，公司的应用架构逐渐转为微服务化，完整的应用数量很容易就达到了几百甚至几千个的量级，建立一套完整的环境变得越来越复杂，往往是研发团队想要构建一套新的环境却构建不出来。</p>
</li>
</ul>
<p>所以，目前互联网公司常见的环境模型一般分为开发环境，功能测试环境，验收测试环境，预发布环境，生产环境这五套大环境。</p>
<ul>
<li><p>开发环境</p>
<p>微服务架构下，单机已经无法完整地运行业务应用，这就需要开发环境内包含一套完整的业务应用依赖以及相关的基础设施，以保证业务开发同学能在本地完成开发测试。</p>
</li>
<li><p>功能测试环境</p>
<p>在开发环境下，每个下游依赖应用都只有一个可用的stable版本。而在实际的开发过程中，由于项目的并行开发，往往会同时存在多个可依赖的版本。而每个项目组的同学在测试时，都希望测试过程中的关键依赖应用是可以被独占的，版本是固定的，不会被其他项目组干扰。</p>
<p>所以，一套独立的功能测试环境就很有必要了。<em>通常，互联网企业会通过中间件的方式分割出一块隔离区域，在功能测试环境中创建多个子环境来解决问题。</em></p>
</li>
<li><p>验收测试环境</p>
<p>验收测试环境和功能测试环境是完全隔离的。当功能测试通过后，你可以在验收测试环境进行最终的验收。</p>
<p>它除了可以用作测试之外，还可以用作产品展示。所以，除了测试和开发人员，产品经理也是验收测试环境的主要使用者。</p>
</li>
<li><p>预发布环境</p>
<p>到预发布阶段，应用已经进入了生产网络，和真实的生产应用共享同一套数据库等基础设施。预发布是正式发布前的最后依次测试，在这个环境中往往可以发现线下环境中发现不了的Bug。这个环境的运维标准等同于生产环境，一般不允许开发人员直接登陆机器。</p>
<p>根据不同的业务需求和部署策略，不同公司对预发布环境的实现也有所不同：</p>
<ul>
<li><p>一种比较常见的方式是，将金丝雀发布作为预发布，从接入真实流量的集群中挑选一台或一小组机器先进行版本更新，通过手工测试以及自动化测试和监控系统验证，降低新版本发布的风险。</p>
<blockquote>
<p>金丝雀发布：</p>
<p>17世纪，英国矿井工人发现，金丝雀对瓦斯这种气体十分敏感。空气中哪怕有极其微量的瓦斯，金丝雀也会停止歌唱；而当瓦斯含量超过一定限度时，虽然鲁钝的人类毫无察觉，金丝雀却早已毒发身亡。当时在采矿设备相对简陋的条件下，工人们每次下井都会带上一只金丝雀作为“瓦斯检测指标”，以便在危险状况下紧急撤离</p>
<p>金丝雀发布是灰度发布的一种方式。灰度发布是指在黑与白之间，能够平滑过渡的一种发布方式。让一部分用户继续用A，一部分用户开始用B，如果用户对B没有什么反对意见，那么逐步扩大范围，把所有的用户都迁移到B上面来。</p>
<p>部署步骤：</p>
<ul>
<li>准备好部署各个阶段的工件，包括：构建工件、测试脚本、配置文件和部署清单文件。</li>
<li>从负载均衡列表中移除掉“金丝雀”服务器</li>
<li>升级“金丝雀”应用（排掉原有流量并进行部署）</li>
<li>对应用进行自动化测试</li>
<li>将“金丝雀”服务器重新添加到负载均衡列表中（连通性和健康检查）</li>
<li>如果“金丝雀”在线使用测试成功，升级剩余的其他服务器，否则就回滚。</li>
</ul>
</blockquote>
</li>
<li><p>另一种做法是，独立出一组始终不接入真实流量的机器，调用在预发布环境中形成闭环。</p>
<p>相对于第一种方式，第二张方式对生产环境的影响更小，但需要额外的资源和维护成本。</p>
</li>
</ul>
</li>
<li><p>生产环境</p>
<p>生产环境是用户真实使用的环境，对安全性和稳定性的要求最高。</p>
</li>
</ul>
<h3 id="什么是好的测试环境？"><a href="#什么是好的测试环境？" class="headerlink" title="什么是好的测试环境？"></a>什么是好的测试环境？</h3><p>开发环境、功能测试环境、验收测试环境、预发布环境这四种测试环境形成的原因是什么？</p>
<p>搭建测试环境的目的是保证最终交付的软件质量，但每套测试环境的用户并不完全一样：</p>
<ul>
<li>开发环境的用户是开发同学；</li>
<li>功能测试环境的主要用户是测试同学；</li>
<li>验收测试环境的用户是产品经理和测试同学；</li>
<li>预发布环境的使用者是测试同学，但受益者却是运维同学。</li>
</ul>
<p>而每种角色对于产品研发流程中的需求也是不同的：</p>
<ul>
<li>开发同学关注研发效率；</li>
<li>测试同学关注测试的可靠性；</li>
<li>产品经理更关注的是真实的用户体验和产品的完整性；</li>
<li>预发布环境的需求其实来自于运维同学，他们需要保证生产环境的稳定性，减少生产环境的变更，所以需要将预发布环境与线下环境完全隔离。</li>
</ul>
<p>当然，不论一套环境用户是测试同学还是开发同学，以下几个需求都是必须被做到的。</p>
<ul>
<li>可得性，即在开发一个新项目时，能快速获取构建一个环境需要的机器，基础设施。最好的情况是，能随时可得，随时归还。</li>
<li>快速部署，即在搭建新环境时，能以最快的速度构建出一整套完整的环境。测试环境的部署很频繁，在代码提交后，能在很短的时间内构建代码，在环境上更新，就能更早开始测试。</li>
<li>独立性，即一个环境在使用过程中，可以不受其他项目测试人员的干扰。</li>
<li>稳定性，即不会因为下游服务，基础设施的异常，造成测试中断、等待。</li>
<li>高仿真，主要分为两个方面：“测试数据真实”，即能在测试环境构建出真实的测试用例；“环境真实”，即基础服务的架构和行为与线上环境保持一致，避免因为环境不一致造成测试结果不一致。</li>
</ul>
<p>但是，毕竟各个环境的用户和使用场景不同，它们的需求也是有差别的。比如，相对于开发环境，验收测试环境对测试数据的仿真性要求会更高，而开发环境的灵活性，决定了不会过于严格的维护测试数据的真实性。</p>
<p>当一个环境可以满足其真正核心用户的需求时，就是一个好用的测试环境。</p>
<h3 id="测试环境的成本"><a href="#测试环境的成本" class="headerlink" title="测试环境的成本"></a>测试环境的成本</h3><ul>
<li><p>机器资源的成本</p>
<p>保证环境的独立性，是你构建更多套环境的一个主要原因。但是，一套独立的、拥有完整链路的环境成本是非常高的。</p>
</li>
</ul>
</div><div class="tags"><a href="/tags/运维/">运维</a></div><div class="post-nav"><a class="pre" href="/2019/02/17/Nginx-modules/">Nginx modules</a><a class="next" href="/2017/02/21/运维体系管理/">运维体系管理</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Kategorien</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/Nginx/" style="font-size: 15px;">Nginx</a> <a href="/tags/Web/" style="font-size: 15px;">Web</a> <a href="/tags/运维/" style="font-size: 15px;">运维</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Letzte</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/02/21/Nginx的配置/">Nginx的配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/21/Web性能基础/">Web性能基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/20/Linux性能优化/">Linux性能优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/20/Linux-Kernel/">Linux Kernel</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/17/Nginx-modules/">Nginx modules</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/23/持续交付/">持续交付</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/21/运维体系管理/">运维体系管理</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/24/Linux内核设计/">Linux内核设计</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Blogroll</i></div><ul></ul><a href="https://www.ibm.com/developerworks/cn/topics/" title="ibm developerworks" target="_blank">ibm developerworks</a><ul></ul><a href="https://github.com/tufu9441/maupassant-hexo" title="maupassant-hexo" target="_blank">maupassant-hexo</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">javfa's blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>